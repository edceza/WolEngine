///骑战开发要点
///   baseobject.m_btGender:=montype and $3; 这里 用来改变麒麟的样式
// m_nCharStatus:=makelong(1,16); 骑战状态为1，否则为0
unit ObjBase;

interface

uses
  Windows, Classes, SysUtils, Forms, StrUtils, Math, Grobal2, Envir, IniFiles;

type
  TClientAction = (cHit, cMagHit, cRun, cWalk, cDigUp, cTurn);
  TGender = (gMan, gWoMan);
  TJob = (jWarr, jWizard, jTaos);
  TBaseObject = class
    m_sMapName: string[16];                                 //0x04
    m_sCharName: string[100];                               //0x15  //14    玩家名字
    m_sNewName: string[40];
    m_nNewLevel: INteger;
    m_nItemUnitIndex: Integer;
    m_nCurrX: Integer;                                      //0x24  人物所在座标X(4字节)
    m_nCurrY: Integer;                                      //0x28  人物所在座标Y(4字节)
    m_btDirection: Byte;                                    //0x2C  人物所在方向(1字节)
    m_btGender: Byte;                                       //0x2D  人物的性别(1字节)
    m_btHair: Byte;                                         //0x2E  人物的头发(1字节)
    m_btJob: Byte;                                          //0x2F  人物的职业(1字节)
    m_nGold: Integer;                                       //0x30  人物金币数(4字节)
    m_Abil: TAbility;                                       //0x34 -> 0x5B
    m_nCharStatus: Integer;                                 //0x5C
    m_sHomeMap: string[16];                                 //0x78  //回城地图
    m_nHomeX: Integer;                                      //0x8C  //回城座标X
    m_nHomeY: Integer;                                      //0x90  //回城座标Y

    //   m_boTakeonHorsepai        :boolean;
    m_boOnHorse: Boolean;                                   //0x95
    m_boOnBaozi: Boolean;
    m_boBaoZiAttacked: Boolean;
    m_boUsexushou: Boolean;
    m_btHorseType: Byte;
    m_btDressEffType: Byte;

    m_nPkPoint: Integer;                                    //0xAC  人物的PK值(4字节)
    m_boAllowGroup: Boolean;                                //0xB0  允许组队
    m_boAllowGuild: Boolean;                                //0xB1  允许加入行会
    m_nIncHealth: Integer;                                  //0x0B4
    m_nIncSpell: Integer;                                   //0x0B8
    m_nIncHealing: Integer;                                 //0x0BC
    m_nFightZoneDieCount: Integer; //0x0C0  //在行会占争地图中死亡次数
    m_BonusAbil: TNakedAbility;                             //0x0CA TNakedAbility
    m_CurBonusAbil: TNakedAbility;                          //0x0DE
    m_nBonusPoint: Integer;                                 //0x0F4
    m_nHungerStatus: Integer;                               //0x0F8
    m_boAllowGuildReCall: Boolean;                          //0xFC
    //      btFC               :Byte;

    m_dBodyLuck: Double;                                    //0x100
    m_nBodyLuckLevel: Integer;                              //0x108
    m_wGroupRcallTime: Word;                                //0x10C
    m_boAllowGroupReCall: Boolean;                          //0x10E
    m_QuestUnitOpen: TQuestUnit;                            //0x10F
    m_QuestUnit: TQuestUnit;                                //0x11C
    m_QuestFlag: TQuestFlag;                                //0x128 129
    m_nCharStatusEx: Integer;
    m_nBaoziStatus: Integer;
    m_dwFightExp: LongWord;                                 //0x194   //怪物经验值
    m_WAbil: TAbility;                                      //0x198
    m_AddAbil: TAddAbility;                                 //0x1C0
    m_nViewRange: Integer;                                  //0x1E4   //可视范围大小
    m_wStatusTimeArr: TStatusTime; //0x60         //人物状态属性值，一般是持续多少秒
    m_dwStatusArrTick: array[0..MAX_STATUS_ATTRIBUTE - 1] of LongWord;  //0x1E8 //人物状态持续的开始时间
    m_wStatusArrValue: array[0..8] of Word;                 //0x218     //攻击力增加
    m_dwStatusArrTimeOutTick: array[0..8] of LongWord; // :Tarry220; //0x220     多少秒
    m_wAppr: Word;                                          //0x238
    m_wAppr1: Word;                                         //0x238
    m_btRaceServer: Byte;                                   //0x23A   //角色类型
    m_btRaceImg: Byte;                                      //0x23B   //角色外形
    m_btHitPoint: Byte;                                     //0x23C   人物攻击准确度(Byte)
    m_btMagicPoint, m_btPoisonPoint: Byte;
    m_nHitPlus: integer;                                    //0x23D
    m_nHitDouble: integer;                                  //0x23E
    m_nHitpd: integer;
    m_nHitpj: integer;
    m_nHittz: integer;
    m_dwGroupRcallTick: LongWord;                           //0x240  记忆使用间隔(Dword)
    m_boRecallSuite: Boolean;                               //0x244  记忆全套
    m_nHealthRecover: ShortInt;                             //0x248
    m_nSpellRecover: ShortInt;                              //0x249
    m_btAntiPoison: Byte;                                   //0x24A  //中毒躲避
    m_nPoisonRecover: ShortInt;                             //0x24B  //中毒恢复
    m_nAntiMagic: ShortInt;                                 //0x24C  //魔法躲避
    m_nLuck: Integer;                                       //0x250  人物的幸运值Luck
    m_nPerHealth: Integer;                                  //0x254
    m_nPerHealing: Integer;                                 //0x258
    m_nPerSpell: Integer;                                   //0x25C
    m_dwIncHealthSpellTick: LongWord;                       //0x260
    m_btGreenPoisoningPoint: Byte;                          //0x264  中绿毒降HP点数
    m_nGoldMax: Integer; //0x268  人物身上最多可带金币数(Dword)
    m_btSpeedPoint: Byte;                                   //0x26C  人物敏捷度(Byte)
    m_btPermission: Byte;                                   //0x26D  人物权限等级
    m_nHitSpeed: ShortInt;                                  //0x26E  //1-18 更改数据类型
    m_btLifeAttrib: Byte;                                   //0x26F
    m_btCoolEye: Byte;                                      //0x270
    m_GroupOwner: TBaseObject;                              //0x274
    m_GroupMembers: TStringList;                            //0x278  组成员
    m_boHearWhisper: Boolean;                               //0x27C  允许私聊
    m_boBanShout: Boolean;                                  //0x27D  允许群聊
    m_boBanGuildChat: Boolean;                              //0x27E  拒绝行会聊天
    m_boAllowDeal: Boolean;                                 //0x27F  是不允许交易
    m_BlockWhisperList: TStringList;                        //0x280  禁止私聊人员列表
    m_boAllowfriend: Boolean;
    m_dwShoutMsgTick: LongWord;                             //0x284
    m_Master: TBaseObject;                                  //0x288  是否被召唤(主人)
    m_PetSellCharName: string;                              //豹子摆摊，主人下线的名字
    m_dwMasterRoyaltyTick: LongWord;                        //0x28C  怪物叛变时间
    m_dwMasterTick: LongWord;                               //0x290
    n294: Integer;                                          //0x294  杀怪计数
    m_btSlaveExpLevel: Byte;                                //0x298  宝宝等级 1-7
    m_btSlaveMakeLevel: Byte;                               //0x299  召唤等级
    m_dwghostTick: LongWord;
    m_nghosttime: Integer;
    m_bohastishen: boolean;
    m_SlaveList: TList;                                     //0x29C  下属列表
    bt2A0: Byte;                                            //0x2A0
    m_boSlaveRelax: Boolean; //0x2A0  宝宝攻击状态(休息/攻击)(Byte)
    m_btAttatckMode: Byte;                                  //0x2A1  下属攻击状态
    m_btNameColor: Byte;                                    //0x2A2  人物名字的颜色(Byte)
    m_nLight: Integer;                                      //0x2A4  亮度
    m_boGuildWarArea: Boolean;                              //0x2A8  行会占争范围
    m_Castle: TObject;                                      //0x2AC //所属城堡
    bo2B0: Boolean;                                         //0x2B0
    m_dw2B4Tick: LongWord;                                  //0x2B4
    m_boSuperMan: Boolean;                                  //0x2B8  无敌模式
    m_boReOnLine: Boolean;
    bo2B9: Boolean;                                         //0x2B9
    bo2BA: Boolean;                                         //0x2BA
    m_boAnimal: Boolean;                                    //0x2BB
    m_boNoItem: Boolean;                                    //0x2BC
    m_boFixedHideMode: Boolean;                             //0x2BD
    m_boStickMode: Boolean;                                 //0x2BE
    bo2BF: Boolean;                                         //0x2BF
    m_boNoAttackMode: Boolean;                              //0x2C0
    bo2C1: Boolean;                                         //0x2C1
    m_boSkeleton: Boolean;                                  //0x2C2
    m_nMeatQuality: Integer;                                //0x2C4
    m_nBodyLeathery: Integer;                               //0x2C8
    m_boHolySeize: Boolean;                                 //0x2CC
    m_dwHolySeizeTick: LongWord;                            //0x2D0
    m_dwHolySeizeInterval: LongWord;                        //0x2D4

    m_bolinghunqiang: Boolean;
    m_dwlinghunqiangTick: LongWord;
    m_dwlinghunqiangInterval: LongWord;

    m_boCrazyMode: Boolean;                                 //0x2D8
    m_dwCrazyModeTick: LongWord;                            //0x2DC
    m_dwCrazyModeInterval: LongWord;                        //0x2E0
    m_boShowHP: Boolean;                                    //0x2E4
    //      nC2E6                   :Integer;      //0x2E6
    m_dwShowHPTick: LongWord; //0x2E8  心灵启示检查时间(Dword)
    m_dwShowHPInterval: LongWord; //0x2EC  心灵启示有效时长(Dword)
    bo2F0: Boolean;                                         //0x2F0
    m_dwDupObjTick: LongWord;                               //0x2F4
    m_PEnvir: TEnvirnoment;                                 //0x2F8
    m_boGhost: Boolean;                                     //0x2FC
    m_dwtishenGhostTick: LongWord;                          //0x300
    m_boDeath: Boolean;                                     //0x304
    m_dwDeathTick: LongWord;                                //0x308
    m_btMonsterWeapon: Byte;                                //0x30C 怪物所拿的武器
    m_dwStruckTick: LongWord;                               //0x310
    m_boWantRefMsg: Boolean;                                //0x314
    m_boAddtoMapSuccess: Boolean;                           //0x315
    m_bo316: Boolean;                                       //0x316
    m_boDealing: Boolean;                                   //0x317    正在交易中
    m_DealLastTick: LongWord;                               //0x318 交易最后操作时间
    m_DealCreat: TBaseObject;                               //0x31C   //交易的主动方
    m_MyGuild: TOBject;                                     //0x320
    m_nGuildRankNo: Integer;                                //0x324
    m_sGuildRankName: string;                               //0x328
    m_sScriptLable: string;                                 //0x32C
    m_btAttackSkillCount: Byte;                             //0x330

    m_btAttackSkillPointCount: Byte;                        //0x334

    m_boMission: Boolean;                                   //0x338
    m_nMissionX: Integer;                                   //0x33C
    m_nMissionY: Integer;                                   //0x340
    m_boHideMode: Boolean;                                  //0x344  隐身戒指(Byte)
    m_boStoneMode: Boolean;                                 //0x345
    m_boCoolEye: Boolean; //0x346  //是否可以看到隐身人物
    m_boUserUnLockDurg: Boolean;                            //0x347  //是否用了神水
    m_boTransparent: Boolean;                               //0x348  //魔法隐身了
    m_boAdminMode: Boolean;                                 //0x349  管理模式(Byte)
    m_boAttackMode: Boolean;                                //攻击模式
    m_boObMode: Boolean;                                    //0x34A  隐身模式(Byte)
    m_boTeleport: Boolean;                                  //0x34B  传送戒指(Byte)
    m_boDearMove: Boolean;                                  //       夫妻传送(Byte)
    m_btMobSlaveLevel: Byte;
    m_boParalysis: Boolean;                                 //0x34C  麻痹戒指(Byte)
    m_boSupperParalysis: Boolean;                           //超级麻痹
    m_boMagicParalysis: Boolean;                            //远程麻痹
    m_boUnParalysis: Boolean;
    m_boRevival: Boolean;                                   //0x34D  复活戒指(Byte)
    m_boSupperRevival: Boolean;                             //0x34D  超级复活戒指(Byte)
    m_boUnRevival: Boolean;                                 //防复活
    bo34E: boolean;
    bo34F: Boolean;
    m_dwRevivalTick: LongWord; //0x350  复活戒指使用间隔计数(Dword)
    m_boFlameRing: Boolean;                                 //0x354  火焰戒指(Byte)
    m_boRecoveryRing: Boolean;                              //0x355  治愈戒指(Byte)
    m_boAngryRing: Boolean;                                 //0x356  未知戒指(Byte)
    m_boMagicShield: Boolean;                               //0x357  护身戒指(Byte)
    m_boSupperMagicShield: Boolean;                         //0x357  护身戒指(Byte)
    m_boUnMagicShield: Boolean;                             //防护身
    m_boMuscleRing: Boolean;                                //0x358  活力戒指(Byte)
    m_boFastTrain: Boolean;                                 //0x359  技巧项链(Byte)
    m_boProbeNecklace: Boolean;                             //0x35A  探测项链(Byte)
    m_boGuildMove: Boolean;                                 //行会传送
    m_boSupermanItem: Boolean;
    m_bopirit: Boolean;                                     //祈祷

    m_boDoubleAC, m_boDoubleMAC: Boolean;
    m_boNoDropItem: Boolean;
    m_boNoDropUseItem: Boolean;
    m_boExpItem: Boolean;
    m_boPowerItem: Boolean;

    m_rExpItem: Real;
    m_rPowerItem: Real;
    m_dwPKDieLostExp: LongWord; //PK 死亡掉经验，不够经验就掉等级
    m_nPKDieLostLevel: Integer;                             //PK 死亡掉等级

    m_boAbilSeeHealGauge: Boolean;                          //0x35B  //心灵启示
    m_boAbilMagBubbleDefence: Boolean;                      //0x35C  //魔法盾
    m_btMagBubbleDefenceLevel: Byte;                        //0x35D
    m_boAbilMagfyDefence: Boolean;                          //0x35C  //风影盾
    m_btMagfyDefenceLevel: Byte;                            //0x35D

    m_boAbilMagPowerDefence: Boolean;                       //金刚护体
    m_btMagPowerDefencelevel: byte;                         // 级别

    m_boAbilMagzqDefence: Boolean;                          //护身
    m_btMagzqDefencelevel: byte;                            // 级别

    m_dwSearchTime: LongWord;                               //0x360
    m_dwSearchTick: LongWord;                               //0x364
    m_dwRunTick: LongWord;                                  //0x368
    m_nRunTime: Integer;                                    //0x36C
    m_nHealthTick: Integer; //0x370    //特别指定为 此类型  此处用到 004C7CF8
    m_nSpellTick: Integer;                                  //0x374
    m_TargetCret: TBaseObject;                              //0x378
    m_dwTargetFocusTick: LongWord;                          //0x37C
    m_LastHiter: TBaseObject; //0x380  人物被对方杀害时对方指针(Dword)
    m_LastHiterTick: LongWord;                              //0x384
    m_ExpHitter: TBaseObject;                               //0x388
    m_ExpHitterTick: LongWord;                              //0x38C
    m_dwTeleportTick: LongWord; //0x390  传送戒指使用间隔(Dword)
    m_dwProbeTick: LongWord; //0x394  探测项链使用间隔(Dword)
    m_dwMapMoveTick: LongWord;                              //0x398
    m_boPKFlag: Boolean; //0x39C  人物攻击变色标志(Byte)
    m_dwPKTick: LongWord; //0x3A0  人物攻击变色时间长度(Dword)
    m_nMoXieSuite: Integer;                                 //0x3A4  魔血一套(Dword)
    m_nHongMoSuite: Integer;                                //0x3A8 虹魔一套(Dword)
    m_n3AC: Integer;                                        //0x3AC
    m_db3B0: Double;                                        //0x3B0
    m_dwPoisoningTick: LongWord; //0x3B8 中毒处理间隔时间(Dword)
    m_dwDecPkPointTick: LongWord;                           //0x3BC  减PK值时间(Dword)
    m_DecLightItemDrugTick: LongWord;                       //0x3C0
    m_dwVerifyTick: LongWord;                               //0x3C4
    m_dwCheckRoyaltyTick: LongWord;                         //0x3C8
    m_dwDecHungerPointTick: LongWord;                       //0x3CC
    m_dwHPMPTick: LongWord;                                 //0x3D0
    m_MsgList: TList;                                       //0x3D4
    m_VisibleHumanList: TList;                              //0x3D8
    m_VisibleItems: TList;                                  //0x3DC
    m_mobpicupItems: Tlist;                                 //豹子要检取的物品列表
    m_bocanaddpickupitem: boolean;
    m_VisibleEvents: TList;                                 //0x3E0
    m_SendRefMsgTick: LongWord;                             //0x3E4
    m_boInFreePKArea: Boolean;                              //0x3E8  是否在开行会战(Byte)
    LIst_3EC: TList;                                        //0x3EC
    dwTick3F0: LongWord;                                    //0x3F0
    dwTick3F4: LongWord;                                    //0x3F4
    m_dwHitTick: LongWord;                                  //0x3F8
    m_dwWalkTick: LongWord;                                 //0x3FC
    m_dwSearchEnemyTick: LongWord;                          //0x400
    m_boNameColorChanged: Boolean;                          //0x404
    m_boIsVisibleActive: Boolean; //是否在可视范围内有人物,及宝宝
    m_nProcessRunCount: ShortInt;
    m_VisibleActors: TList; //0x408  //可见范围内的人物列表
    m_ItemList: TgList;                                     //0x40C  人物背包(Dword)数量
    m_DealItemList: TList;                                  //0x410
    m_nDealGolds: Integer;                                  //0x414  交易的金币数量(Dword)
    m_boDealOK: Boolean;                                    //0x418  确认交易标志(Byte
    m_MagicList: TList;                                     //0x41C  技能表
    m_UseItems: THumanUseItems;                             //0x420  + D8 -> 4F8
    m_SayMsgList: TList;
    m_StorageItemList: TList;                               //0x4F8
    m_monStoragelist: Tlist;                                //丛林豹 包裹
    m_nWalkSpeed: Integer;                                  //0x4FC
    m_nWalkStep: Integer;                                   //0x500
    m_nWalkCount: Integer;                                  //0x504
    m_dwWalkWait: LongWord;                                 //0x508
    m_dwWalkWaitTick: LongWord;                             //0x50C
    m_boWalkWaitLocked: Boolean;                            //0x510
    m_nNextHitTime: Integer;                                //0x514
    m_MagicOneSwordSkill: pTUserMagic;                      //0x518
    m_MagicPowerHitSkill: pTUserMagic;                      //0x51C
    m_MagicPowerHitType: Integer;
    m_MagicErgumSkill: pTUserMagic;                         //0x520 刺杀剑法
    m_MagicBanwolSkill: pTUserMagic;                        //0x524 半月弯刀
    m_MagicFireSwordSkill: pTUserMagic;                     //0x528
    m_Magic44Skill: pTUserMagic;
    m_MagicCrsSkill: pTUserMagic;                           //0x528
    m_Magic40Skill: pTUserMagic;
    m_Magic42Skill: pTUserMagic;
    m_Magic43Skill: pTUserMagic;
    m_Magic41Skill: pTUserMagic;                            //0x528
    m_Magic59Skill: pTUserMagic;                            //0x528
    m_Magic60Skill: pTUserMagic;                            //0x528
    m_Magic586368skill: pTUserMagic;
    m_Magic76skill: pTUserMagic;                            //魔魂术
    m_Magic69skill: pTUserMagic;                            //兽灵术
    m_Magic88Skill: pTUserMagic;
    m_boPowerHit: Boolean;                                  //0x52C
    m_boUseThrusting: Boolean;                              //0x52D
    m_boUseHalfMoon: Boolean;                               //0x52E
    m_boFireHitSkill: Boolean;                              //0x52F
    m_nFireHitSkillType: Integer;
    m_boCrsHitkill: Boolean;                                //0x52F
    m_bo41kill: Boolean;                                    //0x52F
    m_bo43kill: Boolean;                                    //0x52F
    m_bo59kill: Boolean;                                    //0x52F
    m_bo60kill: Boolean;                                    //0x52F
    m_dwLatestFireHitTick: LongWord;                        //0x530
    m_dwDoMotaeboTick: LongWord;                            //0x534
    m_boDenyRefStatus: Boolean;                             //是否刷新在地图上信息；
    m_boAddToMaped: Boolean;                                //是否增加地图计数
    m_boDelFormMaped: Boolean;                              //是否从地图中删除计数
    m_boAutoChangeColor: Boolean;
    m_dwAutoChangeColorTick: LongWord;
    m_nAutoChangeIdx: Integer;

    m_boFixColor: Boolean;                                  //固定颜色
    m_nFixColorIdx: Integer;
    m_nFixStatus: Integer;
    m_boFastParalysis: Boolean; //快速麻痹，受攻击后麻痹立即消失

    //   xjs 添加
    m_bohorse: Boolean;                                     //是否是马  //hint
    m_bohorserelax: Boolean;
    m_boBoneFamm: boolean;
    m_boTishen: boolean;
    m_boshiling: boolean;
    m_nxiyingmon: Integer;
    m_boDog: boolean;
    byistopnpc: byte;
    m_bMaxBagitem: byte;
    m_nGameGold: Integer;                                   //元宝
    m_nDealGameGolds: Integer;                              //交易的元宝
    m_boArrow: boolean;
    nskill: integer;                                        //怪物使用的技能标号
    m_boOnSellItem: boolean;                                //正在摆摊中
    m_boBOSS: BOOLEAN;
    m_nfenghaolevel: integer;
    m_isBeFsBoss: boolean;
    m_befsBossTime: dword;
    m_befsbossStartdw: dword;
    m_hasFsBoss: boolean;

    m_boPetOnSell: Boolean;
    m_Onsellitemarr: array[0..MAXPETSELLCOUNT - 1] of TClientItem; //摆摊的物品
    m_PetSellItem: array[0..MAXPETSELLCOUNT - 1] of TUserItem;
    m_Sonsellname: string;                                  //摊位的名称
    m_nOnsellcount: integer;                                //摆摊的物品数量
    m_nflagforsell: boolean;
    m_nflagforsellcolor: integer;
    m_nFlagType: Word;
    M_monstoragelevel: integer;
    M_monstoragehuoli: integer;
    M_monsterZSD: Integer;
    M_monsterExp: Integer;
    // M_MonPetColor: Integer;
    M_monitemmake: integer;
    M_monOnHorseitemmake: integer;
    M_monYSOnHorseitemmake: integer;
    M_monSellitemmake: integer;
    //  M_PetSellItemMake:INteger;
    BaoZiInfo: array[0..4] of TBaoZiInfo;
    m_sSytleName: string[80];
    m_wPowerRate: array[0..7] of Word;                      //0x218
    m_wPowerRateTick: array[0..7] of LongWord;
    m_nmainPetId: Integer;

    m_sKILLMONNAME: string;
    m_sKILLHUMNAME: string;
    m_sKILLMONMAP: string;
    m_sKILLERNAME: string;

    m_LoveMaster: string;
    m_nDieTime: TDateTime;
    m_nDieDay: Integer;
    m_sOldName: string;
  private
    function CheckMapEnvir(X: string; Y: string; MapName: string; EnvirMode: string):
      string;
    function GetLevelExp(nLevel: Integer): LongWord;
    function InSafeArea: Boolean;
    //    procedure UpdateVisibleGay(BaseObject:TBaseObject);
    function Walk(nIdent: Integer): Boolean;
    function AddToMap(): Boolean;
    procedure UseLamp();
    procedure CheckPKStatus();
    //    procedure UpdateVisibleItem(wX,wY:Integer;MapItem:PTMapItem);
    procedure UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);
    procedure GetAccessory(Item: TUserItem; var AddAbility: TAddAbility);
    function RecalcBagWeight(): Integer;
    //    procedure RecalcHitSpeed();
    procedure AddItemSkill(nIndex: Integer);
    procedure DelItemSkill(nIndex: Integer);
    procedure DecPKPoint(nPoint: Integer);
    function GetCharColor(BaseObject: TBaseObject): Byte;
    function GetNamecolor: Byte;
    procedure SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
      lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord);
    procedure LeaveGroup();
    procedure DelMember(BaseObject: TBaseObject);
    procedure SendGroupText(sMsg: string);
    procedure HearMsg(sMsg: string);
    procedure AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir: Integer);
      virtual;
    procedure DamageSpell(nSpellPoint: Integer);
    procedure DoDamageWeapon(nWeaponDamage: Integer);
    function GetFeatureEx: Word;
  public
    constructor Create(); virtual;
    destructor Destroy; override;
    procedure UpdateVisibleGay(BaseObject: TBaseObject);
    procedure UpdateVisibleItem(wX, wY: Integer; MapItem: PTMapItem);
    procedure SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1, nParam2,
      nParam3: Integer; sMsg: string);
    procedure SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1,
      lParam2, lParam3: Integer; sMsg: string);
    procedure SendDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1,
      lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord);
    procedure SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3: Integer; sMsg:
      string);
    procedure SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word; lParam1,
      lParam2, lParam3: Integer; sMsg: string);
    procedure SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
      lParam1, lParam2, lParam3: Integer; sMsg: string);
    procedure SendAttackMsg(wIdent: Word; btDir: Byte; nX, nY, w3: Integer);
    procedure SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType);
    procedure MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus: TMonStatus);
    function IsVisibleHuman(): Boolean;
    procedure RecalcLevelAbilitys;
    function PKLevel(): Integer;
    function InSafeZone(): Boolean; overload;
    function InSafeZone(Envir: TEnvirnoment; nX, nY: Integer): Boolean; overload;
    procedure OpenHolySeizeMode(dwInterval: LongWord);
    procedure BreakHolySeizeMode;
    procedure OpenCrazyMode(nTime: Integer);
    procedure BreakCrazyMode();
    procedure HealthSpellChanged();
    function _Attack(var wHitMode: Word; AttackTarget: TBaseObject): Boolean;
    function GetHitStruckDamage(Target: TBaseObject; nDamage: integer): Integer;
    procedure HasLevelUp(nLevel: Integer);
    procedure GoldChanged();
    procedure GameGoldChanged;
    procedure RecalcHitSpeed();

    function GetGuildRelation(cert1: TBaseObject; cert2: TBaseObject): Integer;
    function IsGoodKilling(cert: TBaseObject): Boolean;
    procedure IncPkPoint(nPoint: Integer);
    procedure AddBodyLuck(dLuck: Double);
    procedure MakeWeaponUnlock();
    procedure ScatterGolds(GoldOfCreat: TBaseObject);
    function DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat, DropGoldCreat:
      TBaseObject): Boolean;
    function DropItemDown(UserItem: pTUserItem; nScatterRange: Integer; boDieDrop:
      Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
    procedure DamageHealth(nDamage: Integer; ntype: integer);
    function GetAttackPower(nBasePower, nPower: Integer; nMagicID: Integer = -1):
      Integer;
    function CharPushed(nDir, nPushCount: Integer): Integer;
    function CharPushedX(nDir, nPushCount: Integer): Integer;
    function GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var nDY:
      Integer; Envir: TEnvirnoment = nil): Boolean;
    function GetBackDir(nDir: integer): Integer;
    function GetMapBaseObjects(tEnvir: TEnvirnoment; nX, nY: Integer; nRage: Integer;
      rList: TList): Boolean;
    function MagPassThroughMagic(sx, sy, tx, ty, ndir, magpwr: integer;
      undeadattack: Boolean): integer;
    procedure KickException;
    function GetMagStruckDamage(BaseObject: TBaseObject; nDamage: Integer): Integer;
    procedure DamageBubbleDefence(nInt: Integer);
    procedure BreakOpenHealth;
    function GetCharStatus: Integer;
    procedure MakeOpenHealth;
    procedure IncHealthSpell(nHP, nMP: Integer);
    procedure ItemDamageRevivalRing;
    function CalcGetExp(nLevel: Integer; nExp: Integer): Integer;
    procedure GainSlaveExp(nLevel: Integer);
    procedure MapRandomMove(sMapName: string; nInt: Integer);
    procedure TurnTo(nDir: integer);
    procedure FeatureChanged();
    function GetFeatureToLong(): Integer;
    function GetPoseCreate(): TBaseObject;
    function GetFeature(BaseObject: TBaseObject): Integer;
    function GetDress(): Integer;
    function GetYSfenghao(nfegnhao: Integer): Integer;
    function IsGroupMember(target: TBaseObject): Boolean;
    procedure AbilCopyToWAbil();
    procedure ChangePKStatus(boWarFlag: Boolean);
    procedure StruckDamage(nDamage: integer);
    function sub_4C4CD4(sItemName: string; var nCount: Integer): pTUserItem;
    procedure StatusChanged;
    function GeTBaseObjectInfo(): string;
    procedure TrainSkill(UserMagic: pTUserMagic; nTranPoint: Integer);
    function CheckMagicLevelup(UserMagic: pTUserMagic): Boolean;
    function MagCanHitTarget(nX, nY: Integer; TargeTBaseObject: TBaseObject): Boolean;
    procedure sub_4C713C(Magic: pTUserMagic);
    function MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean;
    function Magfenghuo(nLevel, nSec: Integer): Boolean;

    procedure ApplyMeatQuality();
    function TakeBagItems(BaseObject: TBaseObject): Boolean;
    function AddItemToBag(UserItem: PTUserItem): Boolean;
    function DelBagItem(nIndex: Integer): Boolean; overload;
    function DelBagItem(nItemIndex: Integer; sItemName: string; bosendDel: Boolean =
      false): Boolean; overload;
    procedure WeightChanged();
    function IsTrainingSkill(nIndex: Integer): Boolean;
    function IsTrainingPreSkill(magicname: string): Boolean;
    function IsTraininglimitSkill(magicname: string): Boolean;

    procedure SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
    function GetQuestFalgStatus(nFlag: integer): Integer;
    procedure SetQuestUnitOpenStatus(nFlag: Integer; nValue: Integer);
    function GetQuestUnitOpenStatus(nFlag: integer): Integer;
    procedure SetQuestUnitStatus(nFlag: Integer; nValue: Integer);
    function GetQuestUnitStatus(nFlag: integer): Integer;
    function GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean;
    function GetAttackDirx(BaseObject: TBaseObject; ragen: integer; var btDir: Byte):
      Boolean;
    function TargetInSpitRange(BaseObject: TBaseObject; var btDir: Byte): Boolean;
    procedure MonsterRecalcAbilitys();
    procedure RefNameColor;
    procedure SetPKFlag(BaseObject: TBaseObject);
    procedure SetLastHiter(BaseObject: TBaseObject);
    function EnterAnotherMap(Envir: TEnvirnoment; nDMapX, nDMapY: Integer): Boolean;
    function sub_4DD704(): Boolean;
    function DefenceUp(nSec: Integer): Boolean;
    function MagDefenceUp(nSec: Integer): Boolean;
    procedure RefShowName;
    function MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob: Integer;
      dwRoyaltySec: LongWord; defaulX: Integer = 0; defaulY: Integer = 0): TBaseObject;
    function MakeSlaveghost(sMonName: string): boolean;
    function MakePetghost(Baseobject: TBaseObject): boolean;

    function MakePosion(nType, nTime, nPoint: Integer): Boolean;
    function GetFrontPosition(var nX: Integer; var nY: Integer): Boolean;
    function GetBackPosition(var nX: Integer; var nY: Integer): Boolean;
    function WalkTo(btDir: Byte; boFlag: boolean): Boolean;
    procedure SpaceMove(sMap: string; nX, nY: Integer; nInt: Integer);
    function sub_4C5370(nX, nY: Integer; nRange: Integer; var nDX, nDY: Integer):
      Boolean;
    function CheckItems(sItemName: string): pTUserItem;
    function CheckItemsByIndex(nIndex: Integer): pTUserItem;

    function GetItemsCount(sItemName: string): Integer;
    function GetItems(nMakeIndex: Integer): pTUserItem;
    function GetItemByName(sItemName: string; boDel: Boolean = false): pTUserItem;
    function MagMakeDefenceArea(nX, nY, nRange, nSec: Integer; btState: Byte): Integer;
    function sub_4C3538(): Integer;
    function IsGuildMaster(): Boolean;
    procedure LoadSayMsg();
    procedure DisappearA();
    function GetShowName(): string; virtual;
    procedure DropUseItems(BaseObject: TBaseObject); virtual;
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); virtual;
    function GetMessage(Msg: pTProcessMessage): Boolean; virtual; //FFFF
    procedure Initialize(); virtual;                        //FFFE
    procedure Disappear(); virtual;                         //FFFD
    function Operate(ProcessMsg: pTProcessMessage): Boolean; virtual; //FFFC
    procedure SearchViewRange(); virtual;                   //dynamic;
    procedure Run(); virtual;                               //dynamic;//FFFB
    procedure ProcessSayMsg(sMsg: string); virtual;         //FFFA
    procedure MakeGhost; virtual;
    procedure Die(); virtual;                               //FFF9;
    function getmainplayer(baseobject: TBaseObject): TBaseObject;
    procedure ReAlive(); virtual;                           //FFF8;
    procedure RecalcAbilitys(); virtual;                    //FFF7
    function IsProtectTarget(BaseObject: TBaseObject): Boolean; virtual; //FFF6
    function IsAttackTarget(BaseObject: TBaseObject): Boolean; virtual; //FFF5
    function IsProperTarget(BaseObject: TBaseObject): Boolean; virtual; //FFF4
    function IsProperFriend(BaseObject1: TBaseObject): Boolean; virtual; //FFF3
    procedure SetTargetCreat(BaseObject: TBaseObject); virtual; //FFF2
    procedure DelTargetCreat(); virtual;                    //FFF1
  end;
  TAnimalObject = class(TBaseObject)
    m_nNotProcessCount: Integer; //未被处理次数，用于怪物处理循环
    m_nTargetX: Integer;                                    //0x538
    m_nTargetY: Integer;                                    //0x53C
    m_boRunAwayMode: Boolean;                               //0x540
    m_dwRunAwayStart: LongWord;                             //0x544
    m_dwRunAwayTime: LongWord;                              //0x548
  private

  public
    constructor Create(); override;
    procedure SearchTarget();
    procedure sub_4C959C;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override; //FFFC
    procedure Run; override;                                //FFFB
    procedure DelTargetCreat(); override;                   //FFF1
    procedure SetTargetXY(nX, nY: Integer); virtual;        //FFF0
    procedure GotoTargetXY(); virtual;                      //0FFEF
    //   procedure runtoTargetXY(); virtual; //0FFEF
    procedure Wondering(); virtual;                         //0FFEE
    procedure Wondering1(); virtual;                        //0FFEE
    procedure Attack(TargeTBaseObject: TBaseObject; nDir: Integer); virtual; //0FFED
    procedure Attack1(TargeTBaseObject: TBaseObject; ntype: integer; nDir: Integer);
      virtual;                                                //0FFED
    procedure Struck(Hiter: TBaseObject); virtual;          //FFEC

    procedure HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower: Integer;
      nMagPower: integer; boFlag: Boolean);
    procedure tiexueHitAttackTarget(TargeTBaseObject: TBaseObject; nHitPower: Integer;
      nMagPower: integer; boFlag: Boolean; ntype: Integer);
    procedure tiexueHitwideTarget(TargeTBaseObject: TBaseObject; nHitPower: Integer;
      nMagPower: integer; boFlag: Boolean; ntype: Integer);
    procedure tiexueHitALLTarget(TargeTBaseObject: TBaseObject; nHitPower: Integer;
      nMagPower: integer; boFlag: Boolean; ntype: Integer);

  end;
  TPlayObject = class(TAnimalObject)
    m_DefMsg: TDefaultMessage;                              //0x550

    m_sOldSayMsg: string;                                   //0x560
    m_nSayMsgCount: Integer;                                //0x560
    m_dwSayMsgTick: LongWord;                               //0x568
    m_dwusehuichengTick: LongWord;
    m_boDisableSayMsg: Boolean;                             //0x56C
    m_dwDisableSayMsgTick: LongWord;                        //0x570
    m_dwCheckDupObjTick: LongWord;                          //0x574
    m_dwCheckEvilCtrl10SecDecPowerTick: LongWord;           //0x574
    dwTick578: LongWord;                                    //0x578
    dwTick57C: LongWord;                                    //0x57C
    m_boInSafeArea: Boolean;                                //0x580
    m_boInSafezone: boolean;
    n584: Integer;                                          //0x584
    n588: Integer;                                          //0x584
    m_sUserID: string[11];                                  //0x58C    登录帐号名
    m_sIPaddr: string;                                      //0x598    人物IP地址
    m_sIPLocal: string;
    m_nSocket: Integer;                                     //0x59C nSocket
    m_nGSocketIdx: Integer; //0x5A0 wGateIndex 人物连接到游戏网关SOCKET ID
    m_nGateIdx: Integer; //0x5A8 nGateIdx   人物所在网关号
    m_nSoftVersionDate: Integer;                            //0x5AC
    m_dLogonTime: TDateTime;                                //0x5B0  //登录时间
    m_dwLogonTick: LongWord;                                //0x5B8  战领沙城时间(Dword)
    m_boReadyRun: Boolean;                                  //0x5BC  //是否进入游戏完成
    m_nSessionID: Integer;                                  //0x5C0
    m_nPayMent: Integer; //0x5C4  人物当前模式(测试/付费模式)(Dword)
    m_nPayMode: Integer;                                    //0x5C8
    m_SessInfo: pTSessInfo;                                 //全局会话信息
    m_dwLoadTick: LongWord;                                 //0x5CC
    m_nServerIndex: Integer; //0x5D0  人物当前所在服务器序号
    m_boEmergencyClose: Boolean;                            //0x5D4  掉线标志
    m_boSoftClose: Boolean;                                 //0x5D5
    m_booffline: boolean;
    m_soffline: string;
    m_boKickFlag: Boolean; //0x5D6  断线标志(Byte)(@kick 命令)
    m_boReconnection: Boolean;                              //0x5D7    //重新连接标志
    //   m_bomustdels              :Boolean;
    m_boRcdSaved: Boolean;                                  //0x5D8
    m_boDeathRcdSaved: Boolean;
    m_boSwitchData: Boolean;                                //0x5D9
    m_nWriteChgDataErrCount: Integer;                       //0x5DC
    m_sSwitchMapName: string;                               //0x5E0
    m_nSwitchMapX: Integer;                                 //0x5E4
    m_nSwitchMapY: Integer;                                 //0x5E8
    m_boSwitchDataSended: Boolean;                          //0x5EC
    m_dwChgDataWritedTick: LongWord;                        //0x5F0
    m_dw5D4: LongWord;                                      //0x5F4
    n5F8: Integer;                                          //0x5F8
    n5FC: Integer;                                          //0x5FC
    m_dwHitIntervalTime: LongWord;                          //攻击间隔
    m_dwMagicHitIntervalTime: LongWord;                     //魔法间隔
    m_dwRunIntervalTime: LongWord;                          //走路间隔
    m_dwWalkIntervalTime: LongWord;                         //走路间隔
    m_dwTurnIntervalTime: LongWord;                         //换方向间隔
    m_dwActionIntervalTime: LongWord;                       //组合操作间隔
    m_dwRunLongHitIntervalTime: LongWord;                   //移动刺杀间隔
    m_dwRunHitIntervalTime: LongWord;                       //跑位攻击间隔
    m_dwWalkHitIntervalTime: LongWord;                      //走位攻击间隔
    m_dwRunMagicIntervalTime: LongWord;                     //跑位魔法间隔

    m_dwMagicAttackTick: LongWord;                          //0x600  魔法攻击时间(Dword)
    m_dwMagicAttackInterval: LongWord; //0x604  魔法攻击间隔时间(Dword)
    m_dwAttackTick: LongWord;                               //0x608  攻击时间(Dword)
    m_dwMoveTick: LongWord;                                 //0x60C  人物跑动时间(Dword)
    m_dwtuzhanMoveTick: LongWord;
    m_dwAttackCount: LongWord;                              //0x610  人物攻击计数(Dword)
    m_dwAttackCountA: LongWord;                             //0x614  人物攻击计数(Dword)
    m_dwMagicAttackCount: LongWord;                         //0x618  魔法攻击计数(Dword)
    m_dwMoveCount: LongWord;                                //0x61C  人物跑计数(Dword)
    m_dwMoveCountA: LongWord;                               //0x620  人物跑计数(Dword)
    m_nOverSpeedCount: Integer;                             //0x624  超速计数(Dword)
    m_boDieInFight3Zone: Boolean;                           //0x628
    m_Script: pTScript;                                     //0x62C
    m_NPC: TBaseObject;                                     //0x630
    m_NPC1: TBaseObject;                                    //0x630
    m_nVal: array[0..9] of Integer;                         //0x634 - 658
    m_nMval: array[0..99] of Integer;
    m_DyVal: array[0..9] of Integer;                        //0x65C - 680
    m_DySval: array[0..199] of string;
    m_sPlayDiceLabel: string;
    m_boTimeRecall: Boolean;                                //0x684
    m_dwTimeRecallTick: LongWord;                           //0x688
    m_sMoveMap: string;                                     //0x68C
    m_nMoveX: Integer;                                      //0x690
    m_nMoveY: Integer;                                      //0x694
    bo698: Boolean;                                         //0x698
    n69C: Integer;                                          //0x69C
    m_dwSaveRcdTick: LongWord;                              //0x6A0 保存人物数据时间间隔
    m_nBright: Integer;                                     //0x6A4
    m_boNewHuman: Boolean;                                  //0x6A8
    m_boSendNotice: Boolean;                                //0x6A9
    m_dwWaitLoginNoticeOKTick: LongWord;
    m_boLoginNoticeOK: Boolean;                             //0x6AA
    bo6AB: Boolean;                                         //0x6AB
    m_boExpire: Boolean;                                    //0x6AC  帐号过期
    m_dwShowLineNoticeTick: LongWord;                       //0x6B0
    m_nShowLineNoticeIdx: Integer;                          //0x6B4
    m_dwShowBannerNoticeTime: LongWord;
    //    m_dwHideBannerNoticeTime  :LongWord;
    m_nShowBannerNoticeIdx: Integer;
    m_boshowBanner: boolean;
    //m_AddUseItems             :array[9..12] of TUserItem;
    m_nSoftVersionDateEx: Integer;
    m_CanJmpScriptLableList: TStringList;
    m_CanJmpScriptLableListleft: TStringList;
    m_nScriptGotoCount: Integer;
    m_sScriptCurrLable: string;                             //用于处理 @back 脚本命令
    m_sScriptGoBackLable: string;                           //用于处理 @back 脚本命令
    m_dwTurnTick: LongWord;
    m_wOldIdent: Word;
    m_btOldDir: Byte;

    m_boFirstAction: Boolean;                               //第一个操作
    m_dwActionTick: LongWord;                               //二次操作之间间隔时间
    m_dwcheckactionTick: LongWord;
    m_haszuobicount: integer;
    m_sDearName: string[14];                                //配偶名称
    m_DearHuman: TPlayObject;
    m_boCanDearRecall: Boolean;                             //是否允许夫妻传送
    m_boCanMasterRecall: Boolean;
    m_dwDearRecallTick: LongWord;                           //夫妻传送时间
    m_dwMasterRecallTick: LongWord;
    m_sMasterName: string[14];                              //师徒名称
    sYsname: string[14];                                    //我的元神
    boPneumastorage: Boolean;
    Ysplayer: Tplayobject;
    sYsnameMaster: string[14];                              //元神的主人
    sDieMap: string[17];                                    // 16
    wDieX: word;                                            // 2
    wDieY: word;                                            //  2
    nTimeTick: array[0..9] of LongWord;
    ysmasterplayer: Tplayobject;
    nyssex: byte;
    nysjob: byte;
    wyslevel: word;
    nyssex_1: byte;
    nysjob_1: byte;
    wyslevel_1: word;
    btHasYS2: Byte;
    m_boStartshow: boolean;
    m_nYsCallcount: integer;
    m_dwYsCallTick: dword;
    m_MasterHuman: TPlayObject;
    m_MasterList: TList;                                    //徒弟列表
    m_FrientList: TGStringList;                             //TstringList;    //好友列表
    m_boMaster: Boolean;
    m_btCreditPoint: Byte;                                  //声望点
    m_btMarryCount: Byte;                                   //离婚次数
    m_btReLevel: Byte;                                      //转生等级
    m_btReColorIdx: Byte;
    m_dwReColorTick: LongWord;
    m_nKillMonExpMultiple: Integer;                         //杀怪经验倍数
    m_dwGetMsgTick: LongWord;                               //处理消息循环时间控制

    m_boSetStoragePwd: Boolean;
    m_boReConfigPwd: Boolean;
    m_boCheckOldPwd: Boolean;
    m_boUnLockPwd: Boolean;
    m_boUnLockStoragePwd: Boolean;
    m_boPasswordLocked: Boolean;                            //锁密码
    m_btPwdFailCount: Byte;
    m_boLockLogon: Boolean;                                 //是否启用锁登录功能
    m_boLockLogoned: Boolean;                               //是否打开登录锁
    m_sTempPwd: string[7];
    m_sStoragePwd: string[7];
    m_PoseBaseObject: TBaseObject;
    m_boStartMarry: Boolean;
    m_boStartMaster: Boolean;
    m_boStartUnMarry: Boolean;
    m_boStartUnMaster: Boolean;
    m_boFilterSendMsg: Boolean; //禁止发方字(发的文字只能自己看到)
    m_nKillMonExpRate: Integer; //杀怪经验倍数(此数除以 100 为真正倍数)
    m_nPowerRate: Integer; //人物攻击力倍数(此数除以 100 为真正倍数)
    m_dwKillMonExpRateTime: LongWord;
    m_dwPowerRateTime: LongWord;
    m_dwRateTick: LongWord;

    m_boCanUseItem: Boolean;                                //是否允许使用物品
    m_boCanDeal: Boolean;
    m_boCanDrop: Boolean;
    m_boCanGetBackItem: Boolean;
    m_boCanWalk: Boolean;
    m_boCanRun: Boolean;
    m_boCanHit: Boolean;
    m_boCanSpell: Boolean;
    m_boCanSendMsg: Boolean;

    m_nMemberType: Integer;                                 //会员类型
    m_nMemberLevel: Integer;                                //会员等级
    m_boSendMsgFlag: Boolean;                               //发祝福语标志
    m_boChangeItemNameFlag: Boolean;

    m_boDecGameGold: Boolean;                               //是否自动减游戏币
    m_dwDecGameGoldTime: LongWord;
    m_dwDecGameGoldTick: LongWord;
    m_nDecGameGold: Integer;                                //一次减点数

    m_boIncGameGold: Boolean;                               //是否自动加游戏币
    m_dwIncGameGoldTime: LongWord;
    m_dwIncGameGoldTick: LongWord;
    m_nIncGameGold: Integer;                                //一次减点数

    m_nGamePoint: Integer;                                  //游戏点数
    m_nGameCode: Integer;                                   //游戏积分
    m_nJpPoint: Integer;
    wGEMCOUNT: array[0..2] of Word;                         //红宝石数量
    wATTACHEPOINT: Word;                                    //武官积分
    m_YSPoint: Integer;
    M_YSfenghao: integer;
    m_dwIncGamePointTick: LongWord;

    m_nPayMentPoint: Integer;
    m_dwPayMentPointTick: LongWord;

    m_dwDecHPTick: LongWord;
    m_dwIncHPTick: LongWord;

    m_GetWhisperHuman: TPlayObject;
    m_dwClearObjTick: LongWord;
    m_wContribution: Word;                                  //贡献度
    m_sRankLevelName: string;                               //显示名称格式串
    m_boFilterAction: Boolean;
    m_boClientFlag: Boolean;
    m_nStep: Byte;
    m_nClientFlagMode: Integer;
    m_dwAutoGetExpTick: LongWord;
    m_nAutoGetExpTime: Integer;
    m_nAutoGetExpPoint: Integer;
    m_AutoGetExpEnvir: TEnvirnoment;
    m_boAutoGetExpInSafeZone: Boolean;
    m_DynamicVarList: TList;
    m_dwClientTick: LongWord;
    m_boTestSpeedMode: Boolean;                             //进入速度测试模式

    nRunCount: Integer;
    dwRunTimeCount: LongWord;
    m_dwDelayTime: LongWord;
    //hint 加
    m_nSendValue: integer;
    m_nSendstring: string;
    m_nsendtype: integer;
    m_nsendid: string;
    m_nSendIdx: Integer;

    m_bocheckboxitem: integer;
    m_nboxid: string;
    m_nboxbacktype: integer;
    m_bohasmagicfont: boolean;
    m_wmagicfont: byte;
    m_wmagicfontcolor: byte;
    m_bomagiccolorchange: boolean;
    m_nmagiccolor: integer;
    m_bohasMONSTORAGE: BOOLEAN;
    m_PetBaseObject: TBaseObject;
    m_PetSellBaseObject: TBaseObject;
    m_monStoragesize: byte;

    SWYINFO: TSWYINFO;

    M_boPetOnSell: Boolean;
    ///  for delay
    m_nnpcdelay: integer;
    m_dwnnpcdelaytick: LongWord;
    m_MapDelayTick: Longword;
    m_bonpcdelay: boolean;
    m_nnpc: integer;
    M_Snpcgots: string[20];
    m_nDelayCallCount: Integer;
    ///
    m_bohashuanying: boolean;
    m_bohashuancai: boolean;
    m_boHavebeArp: boolean;                                 //变身标志
    m_nApprNum: integer;

    m_dwLastModSytelNameTick: Dword;
    m_nArrowtime: integer;
    m_nArrowtick: LongWord;
    m_nArrowEattick: LongWord;
    //    m_boArrow:boolean;
    m_SArrownpcgoto: string[20];

    m_sofflinegoto: string[20];

    m_SarrowTimernpc: string[20];
    m_sArrowitem: string[20];
    m_sfenghao: string[50];
    //  m_nfenghaolevel:integer;
    m_dwchecksafearea: dword;
    m_dwcheckhumitem: dword;
    m_boAddhpmode: boolean;
    m_boAddYQMode: Boolean;
    m_nAddYQ: Integer;
    m_dwAddhpmodetick: dword;
    m_boAddmpmode: boolean;
    m_dwAddmpmodetick: dword;

    m_dwcheckdelaytick: dword;
    m_boCheckNewYs: boolean;
    m_sCheckYS: string;
    m_nBuyItemnum: integer;
    UsesTimeItem: pTUserItem;
    bocanhcall: boolean;
    nTaskStep: Integer;
    nTaskCount: Integer;
    nENDTASKCOUNT: Integer;
    nyuanqi: Integer;

    m_nYuJingPingIndex: Integer;
    m_nFuMoItemIndex: Integer;

    m_sFuMoItemName: string;

    m_sParam: array[0..120] of string;
    m_UpDateItem: array[0..7] of TClientItem;
    m_nSuperBoxType: Integer;
    m_wSmelBoxResult: Word;
    m_boSuperBoxResult: Boolean;
    m_sMessageLabeOK: string;
    m_sMessageLableCancel: string;
    m_BoxItem: array[0..10] of TBoxItem;
    m_BoxItemSelected: array[0..10] of Boolean;
    m_OpenBoxIndex: Integer;
    m_sBoxLable: string;
    m_sLastKillMon: string;
    m_sLastKillDate: string;
    m_sLastKillMap: string;
    m_nGiveItemIdx: Integer;

    m_nTimerA: LongWord;
    m_nTimerTick: LongWord;
    m_sTimerLable: string;
    m_MagicPOwerList: array[0..100] of Byte;
    m_btLingzhuMode: Byte;
    m_nLingzhuTime: LongWord;

    m_bouself: Boolean;
    m_sEatName: string;
    m_neatLevel: Integer;
    m_nPetRate: INteger;
    m_PetAddRate: array[0..29] of Integer;
    m_PetAddValue: array[0..29] of INteger;
    m_HackCount: Integer;
    m_nOpenBless: Integer;
    m_nZMValue: Integer;
    m_nCallEvilCount: Integer;
    m_nRecallEvilCount: Integer;
    btLXBHCount: Byte;
    nLXBHTime: Integer;
    btAdditionalAbil: array[0..14] of Byte;
    btLXBHItemCount: Byte;
    LXBHITEM: array[0..19] of TUserItem;
    btsex_1: Byte;                                          //1
    btJob_1: Byte;                                          //1
    Abil_1: TAbility;                                       //40
    Magic_1: THumMagic;
    question: Tquestion;
    DelayCallList: TList;
  private
    function ClientDropGold(nGold: Integer): Boolean;
    procedure ClientQueryUserState(PlayObject: TPlayObject; nX, nY: Integer);
    procedure ClientQueryUserSet(ProcessMsg: pTProcessMessage);
    function ClientDropItem(sItemName: string; nItemIdx: Integer): Boolean;
    function ClientPickUpItem: Boolean;

    procedure ClientOpenDoor(nX, nY: Integer);
    procedure ClientTakeOffItems(btWhere: Byte; nItemIdx: integer; sItemName: string);
    procedure ClientUseItems(nItemIdx, monid: Integer; sItemName: string);
    procedure ClientAddZM(ntype, nItemIdx: Integer);
    procedure ClientDelTask(TaskId: Integer);
    procedure ClientFlags(nItemIdx: integer; x, y: Integer; sMsg: string);
    procedure ClientBBs(nNpc: integer; sMsg: string);
    procedure ClientCHECKITEMBOXCF(ItemIDx: Integer; nCount: Integer; nType: Integer);
    function UseStdmodeFunItem(StdItem: pTStdItem): Boolean;
    function PlantTree(StdItem: pTStdItem): Boolean;
    function WaterPlantTree(StdItem: pTStdItem): Boolean;
    function FEEDMON(nValue: Integer): Boolean;             //喂豹子
    function ClientGetButchItem(BaseObject: TBaseObject; nX, nY: Integer; btDir: Byte; var
      dwDelayTime: LongWord): Boolean;
    procedure MONSTORAGE(ItemMake: Integer);
    procedure ClientChangeMagicKey(nSkillIdx, nKey: integer);
    procedure ClientClickNPC(NPC: Integer);
    procedure ClientMerchantDlgSelect(nParam1: Integer; sMsg: string);
    procedure ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserSellItem(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer; sMsg: string);
    procedure ClientQueryRepairCost(nParam1, nInt: Integer; sMsg: string);
    procedure ClientRepairItem(nParam1, nInt: Integer; sMsg: string);
    procedure ClientGemStone(RedCount, BlueCount, GreenCount, ItemCount: Integer; sMsg:
      string);
    procedure ClientGetScriptPic(sMsg: string; nParam: Integer);

    procedure ClientGropuClose();
    procedure ClientCreateGroup(sHumName: string);
    procedure ClientAddGroupMember(sHumName: string);
    procedure ClientDelGroupMember(sHumName: string);
    procedure ClientgetGroupMemberxy();
    procedure ClientDealTry(sHumName: string);
    procedure ClientAddDealItem(nItemIdx: integer; sItemName: string);
    procedure ClientDelDealItem(nItemIdx: integer; sItemName: string);
    procedure ClientCancelDeal();
    procedure ClientChangeDealGold(nGold: Integer; nType: Integer);
    procedure ClientDealEnd();
    procedure ClientStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
    procedure ClientTakeBackStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: string);

    procedure Clientgettime();
    procedure Clientgetslave();
    procedure ClientPetHuanhua(MainPetId, PetID, ItemID: Integer; nStep: Integer);
    procedure Clientmonpickup(nx, ny: Integer);
    procedure ClientSendBagPos(count: integer; sMsg: string);

    procedure ClientYsBagItem(sMsg: string);
    procedure ClientYsGoldChange(sMsg: string);

    procedure SendBagPos();
    procedure sendTaskInfo();
    procedure ClientStorageItemTomon(nItemIdx: Integer);
    procedure ClientTakeStorageItemFrommon(nItemIdx: Integer);

    procedure ClientGetMinMap();
    procedure ClientMakeDrugItem(NPC: TObject; nItemName: string);
    procedure ClientOpenGuildDlg();
    procedure ClientGuildHome();
    procedure ClientGuildMemberList(nVer: Integer);
    procedure ClientGuildAddMember(sHumName: string);
    procedure ClientGuildDelMember(sHumName: string);
    procedure ClientGuildUpdateNotice(sNotict: string);
    procedure ClientGuildUpdateRankInfo(sRankInfo: string);
    procedure ClientGuildAlly();
    procedure ClientGuildBreakAlly(sGuildName: string);
    procedure ClientAdjustBonus(nPoint: Integer; sMsg: string);
    function ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var dwDelayTime:
      LongWord): Boolean;
    function ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var
      dwDelayTime: LongWord): Boolean;

    function ClientHorseRunXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean; var
      dwDelayTime: LongWord): Boolean;
    function ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer; var dwDelayTime:
      LongWord): Boolean;
    function ClientHitXY(wIdent: Word; nX, nY, w3, nDir: Integer; boLateDelivery:
      Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime: LongWord): Boolean;
    function ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX, nTargetY: Integer;
      TargeTBaseObject: TBaseObject; boLateDelivery: Boolean; var dwDelayTime: LongWord):
      Boolean;

    function CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem): Boolean;
    function GetUserItemWeitht(nWhere: Integer): Integer;

    procedure SendDelDealItem(UserItem: pTUserItem);
    procedure SendAddDealItem(UserItem: pTUserItem);
    procedure ClientAddMagic(nMakeIndex: Integer);
    procedure ClientYuanYing(nMakeIndex: Integer);
    procedure CallLHFMMon(nMakeIndex, x, y: Integer);
    procedure ClientAddLXBH(nParam, nRecog, nSeries: Integer);
    procedure SendLXBHInfo(btSendItem: Byte = 0);
    procedure CLientAddEvil(nMakeIndex, nMakeIndex1: Integer);
    procedure CLientAddZhenmoValue(nMakeIndex, nMakeIndex1: Integer);
    procedure OpenDealDlg(BaseObject: TBaseObject);
    function EatItems(StdItem: pTStdItem): Boolean;
    function EatUseItems(nShape: integer): Boolean;
    function ReadBook(StdItem: pTStdItem): Boolean;
    function DayBright(): Byte;
    procedure BaseObjectMove(sMap, sX, sY: string);

    function RepairWeapon(): Boolean;
    function SuperRepairWeapon(): Boolean;
    function WinLottery(): Boolean;
    procedure ChangeServerMakeSlave(SalveInfo: pTSlaveInfo);
    function WeaptonMakeLuck(): Boolean;
    function PileStones(nX, nY: Integer): Boolean;
    //    function  RunTo(btDir: Byte;boFlag:boolean;nDestX,nDestY:Integer):Boolean;
    procedure ThrustingOnOff(boSwitch: Boolean);
    procedure HalfMoonOnOff(boSwitch: Boolean);
    procedure baoMoonOnOff(boSwitch: Boolean);

    procedure SkillCrsOnOff(boSwitch: Boolean);
    procedure Skill59OnOff(boSwitch: Boolean);
    procedure Skill60OnOff(boSwitch: Boolean);
    function AllowFireHitSkill(): Boolean;
    procedure MakeMine();

    function GetRangeHumanCount(): Integer;
    procedure GetStartPoint();

    procedure MobPlace(sX, sY, sMonName, sCount: string);

    procedure LogonTimcCost;
    procedure SendNotice();
    procedure SendLogon();

    procedure SendServerConfig();
    procedure SendServerStatus();

    //    procedure SendUserName(PlayObject:TPlayObject;nX,nY:Integer);
    function CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer): Boolean;
    function CretInNearhum(TargeTBaseObject: TBaseObject; nX, nY: Integer): Boolean;

    function ISsomeOneInNearXY(nX, nY: Integer): Boolean;
    procedure ClientQueryUserName(target: TBaseObject; x, y: integer);
    procedure SendUseMagic();
    procedure SendSaveItemList(nBaseObject: Integer);
    procedure SendDelItemList(ItemList: TStringList);
    procedure SendAdjustBonus();
    procedure SendChangeGuildName();
    procedure SendMapDescription();
    procedure SendGoldInfo(boSendName: Boolean);

    procedure ShowMapInfo(sMap, sX, sY: string);

    function CancelGroup(): Boolean;
    //   function  GetMagicInfo(nMagicID:Integer):pTUserMagic;
    function GetSpellPoint(UserMagic: pTUserMagic): Integer;
    function DoMotaebo(nDir: Byte; nMagicLevel: Integer; ntype: integer): Boolean;
    //    function  DoSpell(UserMagic:pTUserMagic;nTargetX,nTargetY:Integer;BaseObject:TBaseObject):boolean;
    procedure GetOldAbil(var OAbility: TOAbility);
    procedure ReadAllBook;
    function CheckItemsNeed(StdItem: pTStdItem): Boolean;
    function CheckItemBindUse(UserItem: pTUserItem): Boolean;
    function CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord): Boolean;
    procedure RecalcAdjusBonus;
    procedure CheckMarry();
    procedure CheckMaster();
    procedure CheckFriend();

    procedure CheckHorse();
    function Checkhuanying(): boolean;
    function Checkhuancai(): boolean;

    function CheckHorsepos(): integer;
    procedure RefMyStatus;
    procedure ProcessClientPassword(ProcessMsg: pTProcessMessage);
    procedure ClientMapMove(nParam, nParam2: Integer);
    function CheckDenyLogon: Boolean;
    procedure ProcessSpiritSuite;
    function HorseRunTo(btDir: Byte; boFlag: boolean): Boolean;
    function GetPetName(ItemIndex: Integer): string;
  public
    constructor Create(); override;
    destructor Destroy; override;
    procedure EvilRoyalty;
    function GetEvilId: Integer;
    procedure ClientTakeOnItems(btWhere: Byte; nItemIdx: integer; sItemName: string;
      boNpc: Boolean = false);
    procedure SendUseitems();
    procedure ClientQueryBagItems();
    function GetADDITIONALABIL(nPos: Integer): byte;
    procedure SendYuanYingInfo();

    function GetPetAddInfo(UserItem: PTUserItem; nPos: Integer): Integer;
    function GetItemInfo(UserItem: PTUserItem; nPos: Integer): Integer;
    function SetItemInfo(UserItem: PTUserItem; nPos: Integer; nvalue: Integer): Integer;
    function GetItemInfoStr(UserItem: PTUserItem; sPos: string): string;
    function SetPetAddInfo(UserItem: PTUserItem; nPos: Integer; nValue: Integer):
      Integer;
    procedure SendSocket(DefMsg: pTDefaultMessage; sMsg: string); virtual;
    procedure SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries: Word;
      sMsg: string; boencode: Boolean = false);
    procedure SearchViewRange(); override;
    procedure PKDie(PlayObject: TPlayObject);
    procedure GameTimeChanged();
    procedure RunNotice();
    procedure ClientAddMagicTOItem();
    procedure DecEvilMagic(nValue: Integer);
    procedure MoveToHome();
    function GetItemUnitIndex: Integer;
    function GetMagicInfo(nMagicID: Integer): pTUserMagic;
    function RunTo(btDir: Byte; boFlag: boolean; nDestX, nDestY: Integer): Boolean;
    function DoSpell(UserMagic: pTUserMagic; nTargetX, nTargetY: Integer; BaseObject:
      TBaseObject): boolean;
    function useDoMotaebo(UserMagic: pTUserMagic; nTargetX, nTargetY: Integer;
      BaseObject: TBaseObject): boolean;
    procedure SendQiYuanTreeItem(sPath: string);
    function ClientPickUpItemxy(nx, ny: integer): Boolean;
    function GetMyStatus(): Integer;
    function IncGold(tGold: Integer): Boolean;
    function IsEnoughBag(nCount: Integer = 1): Boolean;
    function IsAddWeightAvailable(nWeight: Integer): Boolean;
    procedure SendAddItem(UserItem: pTUserItem);
    procedure SendDelItems(UserItem: pTUserItem);
    procedure Whisper(whostr, saystr: string);
    function IsBlockWhisper(sName: string): Boolean;
    function QuestCheckItem(sItemName: string; var nCount: Integer; var nParam: Integer;
      var nDura: Integer): pTUserItem;
    procedure MakeGoBackeMap(nMapName, x, y: word);
    function CheckItemboxr(sItemName: string; param: string): boolean;
    procedure relivemon(ntype: integer);
    procedure UPGRADEPet(ntype: integer);
    procedure UPGRADEPetZS(nlevel: integer);
    procedure UPGRADEPetExp(nlevel: integer; sMethod: char);
    procedure UPGRADEPetLevel(nlevel: integer);
    procedure UPDATEMONSTONE;
    function GetPetLevel(ItemMake: Integer): TMonPetInfo;
    function QuestTakeCheckItem(CheckItem: pTUserItem): Boolean;
    function GetItemCount(sItemName: string): Integer;
    procedure TakeItem(sItemName: string; nItemCount: Integer);
    procedure GainExp(dwExp: LongWord);
    procedure GetExp(dwExp: LongWord);
    procedure WinExp(dwExp: LongWord);
    function DecGold(nGold: Integer): Boolean;
    procedure Run(); override;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    procedure RecalcAbilitys(); override;                   //FFF7
    procedure MakeSaveRcd(var HumanRcd: THumDataInfo);
    procedure DealCancel();
    procedure DealCancelA();
    function GetShowName(): string; override;
    procedure GetBackDealItems();
    procedure Disappear(); override;                        //FFFD
    procedure GoldChange(sChrName: string; nGold: Integer);
    procedure ProcessUserLineMsg(sData: string);
    procedure ModifyStylename(sData: string);
    procedure Addfriend(sData: string);
    procedure sendvalue(nParam1: integer; sData: string);
    procedure sendBOXITEM(nParam1, nParam2, nParam3: integer);
    procedure SendPaiHangbang(nParam1, nParam2, nParam3: integer);
    procedure ClientAskSell(nType: Integer);
    procedure ClientPetSellAddItem(nParam1: integer; sData: string);
    procedure ClientOpenSHOP(nParam1: integer; sData: string);
    procedure ClientFastBuy(nParam1, nIndex: integer; sItemName: string);
    procedure ClientMakeStone(nCount, nType, ntype1, npcidx: Integer; sMsg: string);
    procedure Delfriend(sData: string);
    procedure Savefriend();
    procedure ClosePetSell();
    procedure Confirmfriend(sData: string; nParam1: integer);

    procedure ClientSendSell(sData: string; nParam2: integer); //收到摆摊请求命令
    procedure ClientSendPetSell(sData: string; nParam2, nindex: integer);  //收到摆摊请求命令

    procedure ProcessSayMsg(sData: string); override;
    procedure ClearStatusTime();
    procedure UserLogon(); virtual;
    procedure RefRankInfo(nRankNo: Integer; sRankName: string);
    procedure RefUserState;
    procedure SendGroupMembers();
    procedure JoinGroup(PlayObject: TPlayObject);
    function GeTBaseObjectInfo(): string;
    function GetHitMsgCount(): Integer;
    function GetSpellMsgCount(): Integer;
    function GetWalkMsgCount(): Integer;
    function GetRunMsgCount(): Integer;
    function GetTurnMsgCount(): Integer;
    function GetSiteDownMsgCount(): Integer;
    function GetDigUpMsgCount(): Integer;
    procedure SetScriptLabel(sLabel: string);
    procedure GetScriptLabel(sMsg: string);
    procedure GetScriptLabelleft(sMsg: string);
    function LableIsCanJmp(sLabel: string; m_bocallboard: boolean): Boolean;
    function GetMyInfo(): string;
    function IsFriend(sCharName: string): Boolean;
    procedure MakeGhost; override;
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); override;
    procedure DropUseItems(BaseObject: TBaseObject); override;
    procedure RecallHuman(sHumName: string);
    procedure RecallHumanMap(sHumName, sMapName: string);
    procedure SendAddMagic(UserMagic: pTUserMagic);
    procedure SendDelMagic(UserMagic: pTUserMagic);
    procedure ReQuestGuildWar(sGuildName: string);
    procedure SendUpdateItem(UserItem: pTUserItem);
    procedure GetBagUseItems(var btDc: Byte; var btSc: Byte; var btMc: Byte; var btDura:
      Byte);

    procedure CmdEndGuild();
    procedure CmdMakeItemAndDrop(Cmd: pTGameCmd; sItemName: string; nCount: Integer);
    procedure CmdMemberFunctionEx(sCmd, sParam: string);
    procedure CmdMemberFunctionEx1(sCmd, sParam: string);
    procedure CmdSearchDear(sCmd, sParam: string);
    procedure CmdSearchMaster(sCmd, sParam: string);
    procedure CmdDearRecall(sCmd, sParam: string);
    procedure CmdMasterRecall(sCmd, sParam: string);
    procedure CmdSbkDoorControl(sCmd, sParam: string);

    procedure CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdShowUseItemInfo(Cmd: pTGameCmd; sHumanName: string);

    procedure CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
    procedure CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
    procedure CmdLockLogin(Cmd: pTGameCmd);
    procedure CmdViewDiary(sCMD: string; nFlag: Integer);
    procedure CmdUserMoveXY(sCMD, sX, sY: string);
    procedure CmdSearchHuman(sCMD, sHumanName: string);
    procedure CmdGroupRecall(sCMD: string);
    procedure CmdAllowGroupReCall(sCmd, sParam: string);

    procedure CmdGuildRecall(sCmd, sParam: string);

    procedure CmdChangeAttackMode(nMode: Integer; sParam1, sParam2, sParam3, sParam4,
      sParam5, sParam6, sParam7: string);
    procedure CmdChangeSalveStatus();

    procedure CmdChangehorseStatus();
    procedure CmdTakeOnHorse(sCmd, sParam: string);
    procedure CmdTakeOffHorse(sCmd, sParam: string);

    procedure CmdPrvMsg(sCmd: string; nPermission: Integer; sHumanName: string);
    procedure CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMapMove(Cmd: pTGameCmd; sMapName: string);

    procedure CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);

    procedure CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReLoadAdmin(sCmd: string);
    procedure CmdReloadNpc(sParam: string);
    procedure CmdReloadManage(Cmd: pTGameCmd; sParam: string);
    procedure CmdReloadRobotManage;
    procedure CmdReloadRobot;
    procedure CmdReloadMonItems();
    procedure CmdAdjustExp(Human: TPlayObject; nExp: Integer);
    procedure CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief: string);
    procedure CmdDelGuild(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdGuildWar(sCmd, sGuildName: string);
    procedure CmdChangeSabukLord(Cmd: pTGameCmd; sCastleName, sGuildName: string; boFlag:
      Boolean);
    procedure CmdForcedWallconquestWar(Cmd: pTGameCmd; sCastleName: string);
    procedure CmdOPTraining(sHumanName, sSkillName: string; nLevel: Integer);
    procedure CmdOPDeleteSkill(sHumanName, sSkillName: string);
    procedure CmdReloadGuildAll();
    procedure CmdReAlive(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string; nLevel: Integer);
    procedure CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);

    procedure CmdBackStep(sCmd: string; nType, nCount: Integer);
    procedure CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdPKpoint(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint: Integer);
    procedure CmdHunger(sCmd, sHumanName: string; nHungerPoint: Integer);
    procedure CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair: Integer);
    procedure CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel:
      Integer);
    procedure CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName: string; nLevel:
      Integer);

    procedure CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string);
    procedure CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName: string; nCount:
      Integer);
    procedure CmdClearMission(Cmd: pTGameCmd; sHumanName: string);

    procedure CmdTraining(sSkillName: string; nLevel: Integer);
    procedure CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName: string);
    procedure CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
    procedure CmdMission(Cmd: pTGameCmd; sX, sY: string);
    procedure CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount: string);
    procedure CmdMobLevel(Cmd: pTGameCmd; Param: string);
    procedure CmdMobCount(Cmd: pTGameCmd; sMapName: string);
    procedure CmdHumanCount(Cmd: pTGameCmd; sMapName: string);

    procedure CmdDisableFilter(sCmd, sParam1: string);
    procedure CmdChangeUserFull(sCmd, sUserCount: string);
    procedure CmdChangeZenFastStep(sCmd, sFastStep: string);

    procedure CmdReconnection(sCmd, sIPaddr, sPort: string);
    procedure CmdContestPoint(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdStartContest(Cmd: pTGameCmd; sParam1: string);
    procedure CmdEndContest(Cmd: pTGameCmd; sParam1: string);

    procedure CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdKill(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount: Integer);
    procedure CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);
    procedure CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
    procedure CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);

    procedure CmdFireBurn(nInt, nTime, nN: Integer);
    procedure CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint: Integer);

    procedure CmdTestanying(sCmd: string; nRange, nType, nTime, nPoint: Integer);

    procedure CmdTestStatus(sCmd: string; nType, nTime: Integer);

    procedure CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdAddGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nGold:
      Integer);
    procedure CmdGamePoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nPoint:
      Integer);
    procedure CmdCreditPoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string; nPoint:
      Integer);
    procedure CmdBigBag(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel: Integer; snewname:
      string = '');

    procedure CmdRefineWeapon(Cmd: pTGameCmd; nDC, nMC, nSC, nHit: Integer);
    procedure CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel,
      nAutoChangeColor, nFixColor: Integer);
    procedure CmdLuckPoint(sCmd: string; nPerMission: Integer; sHumanName, sCtr, sPoint:
      string);
    procedure CmdLotteryTicket(sCmd: string; nPerMission: Integer; sParam1: string);
    procedure CmdReloadGuild(sCmd: string; nPerMission: Integer; sParam1: string);
    procedure CmdReloadLineNotice(sCmd: string; nPerMission: Integer; sParam1: string);
    procedure CmdReloadAbuse(sCmd: string; nPerMission: Integer; sParam1: string);

    procedure CmdMobNpc(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3,
      sParam4: string);
    procedure CmdNpcScript(sCmd: string; nPermission: Integer; sParam1, sParam2, sParam3:
      string);
    procedure CmdDelNpc(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
    procedure CmdTing(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
    procedure CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
    procedure CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
    procedure CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);

    procedure CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string; boAll: Boolean);
    procedure CmdShutupList(Cmd: pTGameCmd; sParam1: string);
    procedure CmdShowSbkGold(Cmd: pTGameCmd; sCastleName, sCtr, sGold: string);
    procedure CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdShowHumanFlag(sCmd: string; nPermission: Integer; sHumanName, sFlag:
      string);
    procedure CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer; sHumanName, sUnit:
      string);
    procedure CmdShowHumanUnit(sCmd: string; nPermission: Integer; sHumanName, sUnit:
      string);

    procedure CmdChangeAdminMode(sCmd: string; nPermission: Integer; sParam1: string;
      boFlag: Boolean);
    procedure CmdChangeObMode(sCmd: string; nPermission: Integer; sParam1: string;
      boFlag: Boolean);
    procedure CmdChangeSuperManMode(sCmd: string; nPermission: Integer; sParam1: string;
      boFlag: Boolean);
    procedure CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
    procedure CmdChangeDearName(Cmd: pTGameCmd; sHumanName: string; sDearName: string);
    procedure CmdChangeMasterName(Cmd: pTGameCmd; sHumanName: string; sMasterName,
      sIsMaster: string);
    procedure CmdStartQuest(Cmd: pTGameCmd; sQuestName: string);
    procedure CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission: string);
    procedure CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName, sItems: string);
    procedure CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);

    procedure CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);

    procedure CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);

    procedure CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2: string);
    procedure CmdSpirtStart(sCmd: string; sParam1: string);
    procedure CmdSpirtStop(sCmd: string; sParam1: string);
    procedure CmdSetMapMode(sCmd: string; sMapName, sMapMode, sParam1, sParam2: string);
    procedure CmdShowMapMode(sCmd: string; sMapName: string);
    procedure CmdClearHumanPassword(sCmd: string; nPermission: Integer; sHumanName:
      string);

    procedure CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName: string);
    procedure CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdDisableSendMsgList(Cmd: pTGameCmd);
    procedure CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
    procedure CmdMobFireBurn(Cmd: pTGameCmd; sMap, sX, sY, sType, sTime, sPoint: string);
    procedure CmdTestSpeedMode(Cmd: pTGameCmd);

    procedure ProcessUserCmd(sParam1, sParam2, sParam3, sParam4, sParam5, sParam6,
      sParam7: string);
    procedure ClearItemEvil;
    function CheckMagic(sMagicName, sType: string; nLevel: Integer): Boolean;
    procedure messageA(nIdend: Integer; sText, sLabelOk, sLabelCancel: string);
    procedure ClientMessageA(npcidx, nIdx: Integer);
    procedure OPENMAGICBOX(nType: Integer; sParam, sLabel: string);
    procedure SETMagicBox(sParam: string);
    procedure ClientOpenMagicBox(nStep: Integer; nItemMake1, nItemMake2: Integer);
    procedure SetBlessPower(nPower: Integer);
    function FindBaseObject(TargeTBaseObject: TBaseObject): Boolean;
    procedure SendPetInfo(ItemMake: Integer; btStatu: Byte);
    procedure DelItem(UserItem: PTUserItem);
    procedure GetPetSell(ntype: Byte);
    function FindPetSell: TBaseObject;
    procedure RunNewMapEvent(x, y, nSign: Integer; sItemName: string);
    procedure MakeDropItemDown(Envir: TEnvirnoment; sItemName: string; nCount: Integer;
      x, y, nRand: Integer);
  end;

procedure AddUserLog(sMsg: string);

implementation

uses M2Share, Guild, HUtil32, EDcode, ObjNpc, IdSrvClient, ItmUnit, Event,
  ObjMon, LocalDB, Castle, Objys, EncryptUnit, svMain;

{ TBaseObject }

constructor TBaseObject.Create;                             //4B780C
begin
  FillChar(BaoZiInfo, SizeOf(TBaoZiInfo) * 4, 0);
  m_boPetOnSell := False;
  m_isBeFsBoss := False;
  m_befsbossStartdw := GetTickCount();
  m_hasFsBoss := False;
  m_sNewName := '';
  m_nNewLevel := -1;
  m_boGhost := False;
  m_dwGhostTick := 0;
  m_boDeath := False;
  m_dwDeathTick := 0;
  m_SendRefMsgTick := GetTickCount();
  m_btDirection := 4;
  m_btRaceServer := RC_ANIMAL;
  m_btRaceImg := 0;
  m_btHair := 0;
  m_btJob := 0;
  m_nGold := 0;
  m_wAppr := 0;
  bo2B9 := True;
  m_nViewRange := 5;
  m_sHomeMap := '0';

  m_btPermission := 0;
  m_nLight := 0;
  m_btNameColor := 255;
  m_nHitPlus := 0;
  m_nHitDouble := 0;
  m_dBodyLuck := 0;
  m_wGroupRcallTime := 0;
  m_dwGroupRcallTick := GetTickCount();
  m_boRecallSuite := False;

  m_boAbilSeeHealGauge := False;
  m_boPowerHit := False;
  m_boUseThrusting := False;
  m_boUseHalfMoon := False;
  m_boFireHitSkill := False;
  m_nFireHitSkillType := 0;
  m_btHitPoint := 10;
  m_btSpeedPoint := 15;
  m_nHitSpeed := 0;
  m_btLifeAttrib := 0;
  m_btAntiPoison := 0;
  m_nPoisonRecover := 0;
  m_nHealthRecover := 0;
  m_nSpellRecover := 0;
  m_nAntiMagic := 0;
  m_nLuck := 0;
  m_nIncSpell := 0;
  m_nIncHealth := 0;
  m_nIncHealing := 0;
  m_nPerHealth := 5;
  m_nPerHealing := 5;
  m_nPerSpell := 5;
  m_dwIncHealthSpellTick := GetTickCount();
  m_btGreenPoisoningPoint := 0;
  m_nFightZoneDieCount := 0;
  //  m_nGoldMax       := 5000000;
  m_nGoldMax := g_Config.nHumanMaxGold;
  m_nCharStatus := 0;
  m_nCharStatusEx := 0;
  m_nBaoziStatus := 0;
  FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);      //004B7A83
  FillChar(m_BonusAbil, SizeOf(TNakedAbility), #0);
  FillChar(m_CurBonusAbil, SizeOf(TNakedAbility), #0);

  FillChar(m_wStatusArrValue, Sizeof(m_wStatusArrValue), 0);
  FillChar(m_dwStatusArrTimeOutTick, SizeOf(m_dwStatusArrTimeOutTick), #0);
  m_boAllowGroup := False;
  m_boAllowGuild := False;

  m_btAttatckMode := 0;
  m_boInFreePKArea := False;
  m_boGuildWarArea := False;
  bo2B0 := False;
  m_boSuperMan := False;
  m_boReOnLine := False;
  m_boSkeleton := False;
  bo2BF := False;
  m_boHolySeize := False;
  m_boCrazyMode := False;
  m_bolinghunqiang := False;

  m_boShowHP := False;
  bo2F0 := False;
  m_boAnimal := False;
  m_boNoItem := False;
  m_nBodyLeathery := 50;
  m_boFixedHideMode := False;
  m_boStickMode := False;
  m_boNoAttackMode := False;
  bo2C1 := False;
  m_boPKFlag := False;
  m_nMoXieSuite := 0;
  m_nHongMoSuite := 0;
  m_db3B0 := 0;
  FillChar(m_AddAbil, SizeOf(TAddAbility), #0);
  m_MsgList := TList.Create;
  m_VisibleHumanList := TList.Create;
  LIst_3EC := TList.Create;
  m_VisibleActors := TList.Create;
  m_VisibleItems := TList.Create;
  m_mobpicupItems := TList.Create;
  m_VisibleEvents := TList.Create;
  m_ItemList := TGList.Create;
  m_DealItemList := TList.Create;
  m_boIsVisibleActive := False;
  m_nProcessRunCount := 0;
  m_nDealGolds := 0;
  m_nDealGameGolds := 0;
  m_MagicList := TList.Create;
  m_StorageItemList := TList.Create;
  m_monStoragelist := TList.Create;
  FillChar(m_UseItems, SizeOf(THumanUseItems), 0);
  m_MagicOneSwordSkill := nil;
  m_MagicPowerHitSkill := nil;
  m_MagicErgumSkill := nil;
  m_MagicBanwolSkill := nil;
  m_MagicFireSwordSkill := nil;
  m_Magic44Skill := nil;
  m_MagicCrsSkill := nil;
  m_Magic40Skill := nil;
  m_Magic42Skill := nil;
  m_Magic43Skill := nil;

  m_Magic41Skill := nil;
  m_Magic59Skill := nil;
  m_Magic88Skill := nil;
  m_Magic60Skill := nil;
  m_GroupOwner := nil;
  m_Castle := nil;
  m_Master := nil;
  n294 := 0;
  m_btSlaveExpLevel := 0;
  bt2A0 := 0;
  m_GroupMembers := TStringList.Create;
  m_boHearWhisper := True;
  m_boBanShout := True;
  m_boBanGuildChat := True;
  m_boAllowDeal := True;
  m_bohastishen := False;
  m_boAllowGroupReCall := False;
  m_BlockWhisperList := TStringList.Create;
  m_SlaveList := TList.Create;
  FillChar(m_WAbil, SizeOf(TAbility), #0);
  FillChar(m_QuestUnitOpen, SizeOf(TQuestUnit), #0);
  FillChar(m_QuestUnit, SizeOf(TQuestUnit), #0);
  m_Abil.Level := 1;
  m_Abil.AC := 0;
  m_Abil.MAC := 0;
  m_Abil.DC := MakeLong(1, 4);
  m_Abil.MC := MakeLong(1, 2);
  m_Abil.SC := MakeLong(1, 2);
  m_Abil.HP := 15;
  m_Abil.MP := 15;
  m_Abil.MaxHP := 15;
  m_Abil.MaxMP := 15;
  m_Abil.Exp := 0;
  m_Abil.MaxExp := 50;
  m_Abil.Weight := 0;
  m_Abil.MaxWeight := 100;
  m_boWantRefMsg := False;
  m_boDealing := False;
  m_DealCreat := nil;
  m_MyGuild := nil;
  m_nGuildRankNo := 0;
  m_sGuildRankName := '';
  m_sScriptLable := '';
  m_boMission := False;
  m_boHideMode := False;
  m_boStoneMode := False;
  m_boCoolEye := False;
  m_boUserUnLockDurg := False;
  m_boTransparent := False;
  m_boAdminMode := False;
  m_boAttackMode := False;
  m_boObMode := False;
  m_dwRunTick := GetTickCount + LongWord(Random(1500));
  m_nRunTime := 250;
  m_dwSearchTime := Random(2000) + 2000;
  m_dwSearchTick := GetTickCount;
  m_dwDecPkPointTick := GetTickCount;
  m_DecLightItemDrugTick := GetTickCount();
  m_dwPoisoningTick := GetTickCount;
  m_dwVerifyTick := GetTickCount();
  m_dwCheckRoyaltyTick := GetTickCount();
  m_dwDecHungerPointTick := GetTickCount();
  m_dwHPMPTick := GetTickCount();
  m_dwShoutMsgTick := 0;
  m_dwTeleportTick := 0;
  m_dwProbeTick := 0;
  m_dwMapMoveTick := GetTickCount();
  m_dwMasterTick := 0;
  m_nWalkSpeed := 1400;
  m_nNextHitTime := 2000;
  m_nWalkCount := 0;
  m_dwWalkWaitTick := GetTickCount();
  m_boWalkWaitLocked := False;
  m_nHealthTick := 0;
  m_nSpellTick := 0;
  m_TargetCret := nil;
  m_LastHiter := nil;
  m_ExpHitter := nil;
  m_SayMsgList := nil;
  m_boDenyRefStatus := False;
  m_btHorseType := 0;
  m_btDressEffType := 0;
  m_dwPKDieLostExp := 0;
  m_nPKDieLostLevel := 0;
  m_boAddToMaped := True;
  m_boAutoChangeColor := False;
  m_dwAutoChangeColorTick := GetTickCount();
  m_nAutoChangeIdx := 0;

  m_boFixColor := False;
  m_nFixColorIdx := 0;
  m_nFixStatus := -1;
  m_boFastParalysis := False;

  m_bMaxBagitem := 46;                                      //默认包裹容量为 46

  m_bohorse := false;                                       //是否是马  //hint
  m_bohorserelax := false;
  m_boBoneFamm := false;
  m_boTishen := false;
  m_boshiling := false;
  m_nxiyingmon := 0;
  m_boDog := false;
  byistopnpc := 0;
  //   m_bMaxBagitem             :byte;
  m_nGameGold := 0;                                         //元宝
  m_nDealGameGolds := 0;                                    //交易的元宝
  m_boArrow := false;
  nskill := 0;                                              //怪物使用的技能标号
  m_boOnSellItem := false;                                  //正在摆摊中
  m_boBOSS := false;
  m_nfenghaolevel := 0;

  //  m_dwLastModSytelNameTick:= GetTickCount();
end;

destructor TBaseObject.Destroy;                             //004B80C0
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
  nCheckCode                                           : Integer;
  UserItem                                             : pTUserItem;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::Destroy Code: %s %d';
begin
  nCheckCode := 0;
  try
    nCheckCode := 1;
    for i := m_MsgList.Count - 1 downto 0 do
    begin
      nCheckCode := 2;
      SendMessage := m_MsgList.Items[I];
      if SendMessage = nil then
        Continue;
      if (SendMessage.wIdent = RM_SENDDELITEMLIST) and (SendMessage.nParam1 <> 0) then
      begin
        nCheckCode := 3;
        if TStringList(SendMessage.nParam1) <> nil then
        begin
          TStringList(SendMessage.nParam1).Free;
          nCheckCode := 4;
        end;
      end;
      if (SendMessage.wIdent = RM_10401) and (SendMessage.nParam1 <> 0) then
      begin
        nCheckCode := 5;
        Dispose(pTSlaveInfo(SendMessage.nParam1));
      end;
      nCheckCode := 6;
      if (SendMessage.Buff <> nil) then
      begin
        nCheckCode := 7;
        FreeMem(SendMessage.Buff);
      end;
      Dispose(SendMessage);

      nCheckCode := 8;
    end;                                                    //004B81EE
    nCheckCode := 9;
    m_MsgList.Free;
    nCheckCode := 10;
    m_VisibleHumanList.Free;
    nCheckCode := 11;
    for i := 0 to LIst_3EC.Count - 1 do
    begin

    end;                                                    //004B8249
    LIst_3EC.Free;
    nCheckCode := 12;
    for i := m_VisibleActors.Count - 1 downto 0 do
    begin
      Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
    end;                                                    //004B8296
    nCheckCode := 13;
    m_VisibleActors.Free;
    nCheckCode := 14;
    for i := m_VisibleItems.Count - 1 downto 0 do
    begin
      Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
    end;                                                    //004B82E3
    for i := 0 to m_mobpicupItems.Count - 1 do
    begin
      Dispose(pTVisibleMapItem(m_mobpicupItems.Items[i]));
    end;                                                    //004B82E3

    m_mobpicupItems.Free;

    nCheckCode := 15;
    m_VisibleItems.Free;
    nCheckCode := 16;
    m_VisibleEvents.Free;

    nCheckCode := 19;
    for i := m_DealItemList.Count - 1 downto 0 do
    begin
      Dispose(pTUserItem(m_DealItemList.Items[i]));
    end;                                                    //004B838B
    m_DealItemList.Free;
    nCheckCode := 20;
    for i := m_MagicList.Count - 1 downto 0 do
    begin
      Dispose(pTUserMagic(m_MagicList.Items[i]));
    end;                                                    //004B83D8
    m_MagicList.Free;
    nCheckCode := 21;
    for i := m_StorageItemList.Count - 1 downto 0 do
    begin
      Dispose(pTUserItem(m_StorageItemList.Items[i]));
    end;                                                    //004B8425
    m_StorageItemList.Free;

    for i := 0 to m_monStoragelist.Count - 1 do
    begin
      Dispose(pTUserItem(m_monStoragelist.Items[i]));
    end;
    m_monStoragelist.Free;

    nCheckCode := 22;
    m_GroupMembers.Free;
    nCheckCode := 23;
    m_BlockWhisperList.Free;
    nCheckCode := 24;
    m_SlaveList.Free;
    nCheckCode := 25;
    nCheckCode := 17;
    try
      m_ItemList.lock;
      for i := m_ItemList.Count - 1 downto 0 do
      begin
        if m_ItemList.Items[i] = nil then
          continue;
        UserItem := pTUserItem(m_ItemList.Items[i]);
        Dispose(UserItem);

      end;
    finally
      m_ItemList.unlock;
    end;                                                    //004B833E
    nCheckCode := 18;
    m_ItemList.Free;
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg, [m_sCharName, nCheckCode]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;

  inherited;
end;

procedure TBaseObject.ChangePKStatus(boWarFlag: Boolean);   //004B84C8
begin
  if m_boInFreePKArea <> boWarFlag then
  begin
    m_boInFreePKArea := boWarFlag;
    m_boNameColorChanged := True;
  end;
end;

function TBaseObject.GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var
  nDY: Integer; Envir: TEnvirnoment = nil): Boolean;          //004C5238
var
  I, II, III                                           : Integer;
  nItemCount, n24, n28, n2C                            : integer;
begin
  n24 := 999;
  Result := False;
  n28 := 0;                                                 //09/10
  n2C := 0;                                                 //09/10
  if Envir = nil then
    Envir := m_PEnvir;
  if Envir = nil then
    exit;
  for I := 1 to nRange do
  begin
    for II := -I to I do
    begin
      for III := -I to I do
      begin
        nDX := nOrgX + III;
        nDY := nOrgY + II;
        if Envir.GetItemEx(nDX, nDY, nItemCount) = nil then
        begin
          if Envir.bo2C then
          begin
            Result := True;
            break;
          end;
        end
        else
        begin
          if Envir.bo2C and (n24 > nItemCount) then
          begin
            n24 := nItemCount;
            n28 := nDX;
            n2C := nDY;
          end;
        end;
      end;
      if Result then
        break;
    end;
    if Result then
      break;
  end;
  if not Result then
  begin
    if n24 < 8 then
    begin
      nDX := n28;
      nDY := n2C;
    end
    else
    begin
      nDX := nOrgX;
      nDY := nOrgY;
    end;
  end;
end;
//004C5478

function TBaseObject.DropItemDown(UserItem: pTUserItem; nScatterRange: Integer;
  boDieDrop: Boolean; ItemOfCreat, DropCreat: TBaseObject): Boolean;
var
  dx, dy, idura                                        : integer;
  MapItem, pr                                          : pTMapItem;
  StdItem                                              : pTStdItem;
  logcap                                               : string;
  sUserItemName                                        : string;

begin
  Result := FALSE;
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem <> nil then
  begin
    if StdItem.Reserved in [11, 12] then
    begin                                                   //Reserved 11,12 物品不会暴掉
      exit;
    end;

    if GetBoValue(UserItem, UserItem.wIndex, 2) then
      exit;

    if StdItem.StdMode = 40 then
    begin
      idura := UserItem.Dura;
      idura := idura - 2000;
      if idura < 0 then
        idura := 0;
      UserItem.Dura := idura;
    end;
    {  if stditem.StdMode =52 then begin     //烟花物品
         SendRefMsg(rm_21295,0,0,0,stditem.Shape,'');   //shape = 类型 1-12
         exit;
      end;
     }

    New(MapItem);
    MapItem.UserItem := UserItem^;
    MapItem.Name := FilterItemName(StdItem.Name);

    //取自定义物品名称
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
    begin
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        MapItem.Name := sUserItemName;
    end;

    MapItem.Looks := StdItem.Looks;
    if StdItem.StdMode = 45 then
    begin                                                   //林荤困, 格犁
      MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
    end;
    MapItem.AniCount := StdItem.AniCount;
    MapItem.Reserved := 0;
    MapItem.Count := 1;
    MapItem.OfBaseObject := ItemOfCreat;
    MapItem.dwCanPickUpTick := GetTickCount();
    MapItem.DropBaseObject := DropCreat;
    if DropCreat <> nil then
      MapItem.DropName := DropCreat.m_sCharName;
    GetDropPosition(m_nCurrX, m_nCurrY, nScatterRange, dx, dy);
    pr := nil;

    pr := m_PEnvir.AddToMap(dx, dy, OS_ITEMOBJECT, TObject(MapItem));
    if pr = MapItem then
    begin
      SendRefMsg(RM_ITEMSHOW, MapItem.Looks, integer(MapItem), dx, dy, MapItem.Name);
      //掉落成功触发脚本
      if m_btRaceServer = RC_PLAYOBJECT then
      begin                                                 //如果是人物掉物品
        if (g_FunctionNPC <> nil) and (Tplayobject(self).sYsnameMaster = '') then
        begin
          g_FunctionNPC.GotoLable(Tplayobject(Self), '@dropitem' +
            IntToStr(UserEngine.GetItemAnicount(UserItem.wIndex)), False);
          if Mapitem.Name = '常胜玄兵' then
            m_PEnvir.DeleteFromMap(dx, dy, OS_ITEMOBJECT, TObject(MapItem));
        end;
        TPlayObject(Self).RunNewMapEvent(m_nCurrx, m_nCurry, 1, StdItem.Name);
      end;
      /////////
      if boDieDrop then
        logcap := '15'
      else
        logcap := '7';
      if not IsCheapStuff(StdItem.StdMode) then
        //004C5716
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog(logcap + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            //UserEngine.GetStdItemName(ui.wIndex) + #9 +
            StdItem.Name + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
            '0');
      Result := TRUE;
    end
    else
    begin
      Dispose(MapItem);
    end;
  end;
end;

procedure TBaseObject.GoldChanged();                        //004C49F4
begin
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
  end;
end;

procedure TBaseObject.GameGoldChanged();                    //004C49F4
begin
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    SendUpdateMsg(Self, RM_GAMEGOLDCHANGED, 0, 0, 0, 0, '');
  end;
end;

function TPlayObject.ClientPickUpItem: Boolean;             //004C5CB0
  function IsSelf(BaseObject: TBaseObject): Boolean;
  begin
    if (BaseObject = nil) or (Self = BaseObject) then
      Result := True
    else
      Result := False;
    if (BaseObject <> nil) and (BaseObject.m_btRaceServer = RC_YSBJECT) and
      (BaseObject.m_Master = self) then
      Result := true;

  end;
  function IsOfGroup(BaseObject: TBaseObject): Boolean;
  var
    I                                                  : Integer;
    GroupMember                                        : TBaseObject;
    target                                             : TBaseObject;
    hum                                                : Tplayobject;
  begin
    Result := False;
    if BaseObject = nil then
      exit;
    if (BaseObject <> nil) and (sYsnameMaster <> '') and (sYsnameMaster =
      BaseObject.m_sCharName) then
    begin                                                   //如果元神的主人就是物品的主人
      Result := true;
      exit;
    end;
    if (BaseObject <> nil) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
      (Tplayobject(BaseObject).sYsnameMaster <> '') and (sYsname = BaseObject.m_sCharName)
      then
    begin                                                   //如果我的元神的物品
      Result := true;
      exit;
    end;

    if (m_btRaceServer = RC_PLAYOBJECT) and (Tplayobject(self).sYsnameMaster <> '') then
    begin
      // hum:=nil;
      // hum:=UserEngine.GetPlayObjectEx(sYsnameMaster);
      hum := ysmasterplayer;
      if hum <> nil then
      begin
        m_GroupOwner := hum.m_GroupOwner;
      end;
    end;
    target := BaseObject;
    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
      (Tplayobject(BaseObject).sYsnameMaster <> '') then
    begin
      //  hum:=nil;
       // hum:=UserEngine.GetPlayObjectEx(Tplayobject(BaseObject).sYsnameMaster);
      hum := ysmasterplayer;
      if hum <> nil then
      begin
        target := hum;
      end;
    end;

    if m_GroupOwner = nil then
      exit;
    for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
    begin
      GroupMember := TBaseObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if GroupMember = target then
      begin
        Result := True;
        break;
      end;
    end;
  end;
var
  UserItem                                             : PTUserItem;
  MapItem                                              : pTMapItem;
  syuseritem                                           : TUserItem;
  StdItem                                              : pTStdItem;
  PlayObject                                           : TPlayObject;
  cixu                                                 : integer;
begin
  Result := False;
  if m_boDealing then
    exit;
  MapItem := m_PEnvir.GetItem(m_nCurrX, m_nCurrY);
  if MapItem = nil then
    exit;
  m_sParam[24] := Mapitem.DropName;
  m_sParam[23] := '1';
  if MapItem.DropBaseObject <> nil then
  begin
    if TBaseObject(MapItem.DropBaseObject).m_btRaceServer = RC_PLAYOBJECT then
      m_sParam[23] := '1'
    else
      if TBaseObject(MapItem.DropBaseObject).m_btRaceServer > 50 then
        m_sParam[23] := IntToStr(TBaseObject(MapItem.DropBaseObject).m_btRaceServer)
      else
        m_sParam[23] := '10';

  end;
  if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime
    {2 * 60 * 1000} then
  begin
    MapItem.OfBaseObject := nil;
  end;
  if not IsSelf(TBaseObject(MapItem.OfBaseObject)) and not
    IsOfGroup(TBaseObject(MapItem.OfBaseObject)) then
  begin
    SysMsg(g_sCanotPickUpItem {'在一定时间以内无法捡起此物品！！！'}, c_Red, t_Hint);
    exit;
  end;

  if (sYsnameMaster <> '') and (GetBoValue(@MapItem.UserItem, MapItem.UserItem.wIndex,
    13)) then
  begin
    SysMsg('该物品元神不能捡起', c_Red, t_Hint);
    exit;
  end;
  if CompareText(MapItem.Name, sSTRING_GOLDNAME) = 0 then
  begin
    if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1
      then
    begin
      if IncGold(MapItem.Count) then
      begin
        SendRefMsg(RM_ITEMHIDE, 0, Integer(MapItem), m_nCurrX, m_nCurrY, '');
        if g_boGameLogGold then                             //004C5E8C
          AddGameDataLog('4' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(MapItem.Count) + #9 +
            '1' + #9 +
            '0');
        GoldChanged;
        Dispose(MapItem);
      end
      else
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
    end;
    exit;
  end;

  //神喻  ===========
  //  if m_PEnvir.DeleteFromMap (m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then begin

  syuseritem := MapItem.UserItem;
  StdItem := UserEngine.GetStdItem(syuseritem.wIndex);
  if (sYsnameMaster <> '') or m_boOnBaozi or m_boOnHorse then
  begin //如果是元神不能检取 shape =151  的物品
    if (StdItem <> nil) and (stditem.Shape = 151) then
      exit;
  end;

  if StdItem <> nil then
  begin
    if (stditem.Shape = 250) and (not (m_sDearName = '')) then
    begin
      SysMsg('提示:该物品[' + stditem.Name + ']无法被女性玩家或已婚玩家检取...', c_Red,
        t_Hint);
      exit;
    end;

    if (stditem.Shape = 250) and (not (m_btGender = 0)) then
    begin
      SysMsg('提示:该物品[' + stditem.Name + ']无法被女性玩家或已婚玩家检取...', c_Red,
        t_Hint);
      exit;
    end;
    if (stditem.StdMode = 49) and (stditem.Shape >= 197) and (stditem.Shape <= 200) then
    begin // (stditem.StdMode=49 )and (stditem.looks =497)
      if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1
        then
      begin

        case stditem.Shape of
          197:
            begin
              m_wStatusArrValue[8] := 197;                  //	重击
              SysMsg('来自上古的神魔赐予了你一股神奇的力量,你获得了重击的神力', c_Red,
                t_Hint);
            end;
          198:
            begin
              m_wStatusArrValue[8] := 198;                  //  秒杀
              SysMsg('来自上古的神魔赐予了你一股神奇的力量,你获得了秒杀的神力', c_Red,
                t_Hint);
            end;
          199:
            begin
              m_wStatusArrValue[8] := 199;                  //  神佑
              SysMsg('来自上古的神魔赐予了你一股神奇的力量,你获得了神佑的神力', c_Red,
                t_Hint);
              SysMsg('神魔的眷顾可能让你获得双倍的经验,进入炼狱更有可能获得三倍…',
                c_Red, t_Hint);
            end;
          200:
            begin
              m_wStatusArrValue[8] := 200;                  //  神御
              SysMsg('来自上古的神魔赐予了你一股神奇的力量,你获得了神御的神力', c_Red,
                t_Hint);
              SysMsg('被激发的神魔防御结界，将帮助你抵御怪物的攻击', c_Red, t_Hint);
            end;
        end;
        //  m_wStatusArrValue[8]:=100;
        cixu := _max(stditem.AC, 1);
        m_dwStatusArrTimeOutTick[8] := GetTickCount + cixu * 60 * 1000; //*60
        SysMsg('神力将持续' + inttostr(cixu) + '分钟…', c_Red, t_Hint);

        SendRefMsg(RM_MAGADDABILTY, 0, 0, 0, 0, '');
        SendRefMsg(RM_29, 0, 25, 100, 147, '');
        Dispose(MapItem);
        // m_PEnvir.DeleteFromMap (m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
      end; // if m_PEnvir.DeleteFromMap (m_
      exit;
    end;
  end;
  ///=======================

  if IsEnoughBag then
  begin
    if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem)) = 1
      then
    begin
      New(UserItem);
      UserItem^ := MapItem.UserItem;
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) and
        IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex)) then
      begin
        SendMsg(self, RM_ITEMHIDE, 0, integer(MapItem), m_nCurrX, m_nCurrY, '');
        AddItemToBag(UserItem);
        RunNewMapEvent(m_nCurrx, m_nCurry, 2, StdItem.Name);

        if not IsCheapStuff(StdItem.StdMode) then
          if StdItem.NeedIdentify = 1 then                  //004C60FF
            AddGameDataLog('4' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              //UserEngine.GetStdItemName(pu.wIndex) + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '1' + #9 +
              '0');
        Dispose(MapItem);
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          PlayObject := TPlayObject(self);
          PlayObject.SendAddItem(UserItem);
        end;
        ///////
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if (g_FunctionNPC <> nil) and (StdItem <> nil) then
          begin
            m_sParam[21] := IntToStr(syuseritem.MakeIndex);
            m_sParam[22] := Stditem.Name;

            g_FunctionNPC.GotoLable(tplayobject(Self), '@pickupitem' +
              IntToStr(UserEngine.GetItemAnicount(UserItem.wIndex)), False);
          end;
          sDieMap := m_PEnvir.sMapName;
          wDieX := m_nCurrX;
          wDieY := m_nCurrY;
        end;
        ////////
        Result := TRUE;
      end
      else
      begin
        Dispose(UserItem);
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT, TObject(MapItem));
      end;
    end;
  end;
end;

function TPlayObject.ClientPickUpItemxy(nx, ny: integer): Boolean; //004C5CB0
  function IsSelf(BaseObject: TBaseObject): Boolean;
  begin
    if (BaseObject = nil) or (Self = BaseObject) then
      Result := True
    else
      Result := False;
  end;
  function IsOfGroup(BaseObject: TBaseObject): Boolean;
  var
    I                                                  : Integer;
    GroupMember                                        : TBaseObject;
  begin
    Result := False;
    if m_GroupOwner = nil then
      exit;
    for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
    begin
      GroupMember := TBaseObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if GroupMember = BaseObject then
      begin
        Result := True;
        break;
      end;
    end;
  end;
var
  UserItem                                             : PTUserItem;
  MapItem                                              : pTMapItem;
  syuseritem                                           : TUserItem;
  StdItem                                              : pTStdItem;
  PlayObject                                           : TPlayObject;
begin
  Result := False;
  if m_boDealing then
    exit;
  MapItem := m_PEnvir.GetItem(nx, nY);
  if MapItem = nil then
    exit;

  if (GetTickCount - MapItem.dwCanPickUpTick) > g_Config.dwFloorItemCanPickUpTime
    {2 * 60 * 1000} then
  begin
    MapItem.OfBaseObject := nil;
  end;
  if not IsSelf(TBaseObject(MapItem.OfBaseObject)) and not
    IsOfGroup(TBaseObject(MapItem.OfBaseObject)) then
  begin
    SysMsg(g_sCanotPickUpItem {'在一定时间以内无法捡起此物品！！！'}, c_Red, t_Hint);
    exit;
  end;

  if CompareText(MapItem.Name, sSTRING_GOLDNAME) = 0 then
  begin
    if m_PEnvir.DeleteFromMap(nx, nY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then
    begin
      if IncGold(MapItem.Count) then
      begin
        SendRefMsg(RM_ITEMHIDE, 0, Integer(MapItem), nx, nY, '');
        if g_boGameLogGold then                             //004C5E8C
          AddGameDataLog('4' + #9 +
            m_sMapName + #9 +
            IntToStr(nx) + #9 +
            IntToStr(nY) + #9 +
            m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(MapItem.Count) + #9 +
            '1' + #9 +
            '0');
        GoldChanged;
        Dispose(MapItem);
      end
      else
        m_PEnvir.AddToMap(nx, nY, OS_ITEMOBJECT, TObject(MapItem));
    end;
    exit;
  end;

  StdItem := UserEngine.GetStdItem(MapItem.UserItem.wIndex);

  if (StdItem <> nil) and (stditem.Shape = 151) then
    exit;

  if IsEnoughBag then
  begin
    if m_PEnvir.DeleteFromMap(nx, nY, OS_ITEMOBJECT, TObject(MapItem)) = 1 then
    begin
      New(UserItem);
      UserItem^ := MapItem.UserItem;
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) and
        IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex)) then
      begin
        SendMsg(self, RM_ITEMHIDE, 0, integer(MapItem), nx, nY, '');
        AddItemToBag(UserItem);

        if not IsCheapStuff(StdItem.StdMode) then
          if StdItem.NeedIdentify = 1 then                  //004C60FF
            AddGameDataLog('4' + #9 +
              m_sMapName + #9 +
              IntToStr(nX) + #9 +
              IntToStr(nY) + #9 +
              m_sCharName + #9 +
              //UserEngine.GetStdItemName(pu.wIndex) + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '1' + #9 +
              '0');
        Dispose(MapItem);
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          PlayObject := TPlayObject(self);
          PlayObject.SendAddItem(UserItem);
        end;
        Result := TRUE;
      end
      else
      begin
        Dispose(UserItem);
        m_PEnvir.AddToMap(nx, nY, OS_ITEMOBJECT, TObject(MapItem));
      end;
    end;
  end;
end;

procedure TPlayObject.RunNotice;                            //004DA588
var
  Msg                                                  : TProcessMessage;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::RunNotice';
begin
  if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then
  begin
    if m_boKickFlag or m_boEmergencyClose then
      SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
    MakeGhost();
  end
  else
  begin
    try
      if not m_boSendNotice then
      begin
        SendLogon();                                        //客户端先读取地图
        SendNotice();
        m_boSendNotice := True;
        m_dwWaitLoginNoticeOKTick := GetTickCount();
      end
      else
      begin
        if GetTickCount - m_dwWaitLoginNoticeOKTick > 20 * 1000 then
        begin
          m_boEmergencyClose := True;
        end;

        while GetMessage(@Msg) do
        begin
          if msg.wIdent = CM_LOGINNOTICEOK then
          begin
            m_boLoginNoticeOK := True;
            m_dwClientTick := Msg.nParam1;
            SysMsg(IntToStr(m_dwClientTick), c_Red, t_Notice);
          end;
        end;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  end;
end;

procedure TPlayObject.WinExp(dwExp: LongWord);
var
  hum                                                  : Tplayobject;
  ysdwexp                                              : integer;
begin
  dwExp := g_Config.dwKillMonExpMultiple * dwExp;           //系统指定杀怪经验倍数
  dwExp := LongWord(m_nKillMonExpMultiple) * dwExp;         //人物指定的杀怪经验倍数

  dwExp := ROUND((m_nKillMonExpRate / 100) * dwExp);        //人物指定的杀怪经验倍数
  if m_PEnvir.m_boEXPRATE then
    dwExp := ROUND((m_PEnvir.m_nEXPRATE / 100) * dwExp);    //地图上指定杀怪经验倍数

  if m_boExpItem then
  begin                                                     //物品经验倍数
    dwExp := ROUND(m_rExpItem * dwExp);
  end;

  if (m_wStatusArrValue[8] = 199) then
  begin                                                     //神佑
    if random(10) < 3 then
    begin
      dwExp := dwExp * 2;
      SendRefMsg(RM_FUSHEN, 0, hiword(integer(self)), loword(integer(self)), 1, '');
      SysMsg('神佑成功，这次你获得了更多的经验。', c_Red, t_Hint);
    end;
  end;

  if m_Magic586368skill <> nil then
  begin
    if Random(19) < m_Magic586368skill.btLevel * 3 + 4 then
    begin
      dwExp := dwExp * 2;
      case m_btJob of
        0: SysMsg('凭着对战魂的领悟，这次你获得了更多的经验。', c_Red, t_Hint);
        1: SysMsg('凭着对魔法本质的认识，这次你获得了更多的经验。', c_Red, t_Hint);
        2: SysMsg('道的信念使你在杀戮中还保持着清醒，这次你获得了更多的经验。', c_Red,
          t_Hint);
      end;
      // SysMsg('你获得了更多的经验',c_Red,t_Hint);
      if (m_Magic586368skill.btLevel < 3) then
      begin                                                 // 战魂真悟 道心清明   法之魄
        if m_Magic586368skill.MagicInfo.TrainLevel[m_Magic586368skill.btLevel] <=
          m_Abil.Level then
        begin
          TrainSkill(m_Magic586368skill, Random(3) + 1);
          if not CheckMagicLevelup(m_Magic586368skill) then
          begin
            SendDelayMsg(self, RM_MAGIC_LVEXP, 0, m_Magic586368skill.MagicInfo.wMagicId,
              m_Magic586368skill.btLevel, m_Magic586368skill.nTranPoint, '', 1000);
          end;
        end;
      end;

    end;
  end;
  hum := nil;

  if sYsnameMaster <> '' then
  begin                                                     //表示元神获得经验，分给主人
    hum := ysmasterplayer;
    if hum <> nil then
    begin
      ysdwexp := dwExp div 3;
      GetExp(ysdwexp);                                      //元神获得 1/3
      hum.GetExp(dwExp - ysdwexp);                          //主人获得 2/3
      exit;

    end;
  end;

  hum := Ysplayer;
  if (hum = nil) or (sYsname = '') then
  begin //如果我有元神不在线，或者没有元神
    GetExp(dwExp);                                          //获得全部经验
    exit;
  end;
  if hum <> nil then
  begin                                                     //如果有元神在分经验
    ysdwexp := dwExp div 3;
    hum.GetExp(ysdwexp);
    GetExp(dwExp - ysdwexp);
    exit;
  end;

end;

procedure TPlayObject.GetExp(dwExp: LongWord);              //004BEB74
begin

  Inc(m_Abil.Exp, dwExp);
  AddBodyLuck(dwExp * 0.002);
  SendMsg(Self, RM_WINEXP, 0, dwExp, 0, 0, '');

  if m_Abil.Exp >= m_Abil.MaxExp then
  begin

    Dec(m_Abil.Exp, m_Abil.MaxExp);

    if m_Abil.Level < MAXUPLEVEL then
    begin

      Inc(m_Abil.Level);
      //  if (m_btRaceServer = RC_PLAYOBJECT ) then begin  //如果是人物升级
      if (m_PEnvir <> nil) and (m_PEnvir.m_slevelupgotolabel <> '') then
      begin                                                 //地图有被人杀死触发
        g_ManageNPC.GotoLable(TPlayObject(self), m_PEnvir.m_slevelupgotolabel, False);
      end;
      if sYsnameMaster = '' then
        SaveToPlayList(self);                               //处理人物到 TOPPLAYLIST
      //  end;

    end;

    HasLevelUp(m_Abil.Level - 1);
    AddBodyLuck(100);
    //004BECDC
    AddGameDataLog('12' + #9 +
      m_sMapName + #9 +
      IntToStr(m_Abil.Level) + #9 +
      IntToStr(m_Abil.Exp) + #9 +
      m_sCharName + #9 +
      '0' + #9 +
      '0' + #9 +
      '1' + #9 +
      '0');
    IncHealthSpell(2000, 2000);
  end;
end;

procedure TBaseObject.RecalcLevelAbilitys();                //004BF7DC
var
  nLevel, n                                            : integer;
begin

  nLevel := m_Abil.Level;
  case m_btJob of
    3:             //妖士
      begin
        //m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND((nLevel / 6 + 2.5) * nLevel));
        m_Abil.MaxHP := _MIN(High(Word), 14 + ROUND(((nLevel /
          g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel)));

        //m_Abil.MaxMP:=_MIN(High(Word),13 + ROUND((nLevel / 8)* 2.2 * nLevel));
        m_Abil.MaxMP := _MIN(High(Word), 13 + ROUND(((nLevel /
          g_Config.nLevelValueOfTaosMP) * 2.2 * nLevel)));

        m_Abil.MaxWeight := 50 + ROUND((nLevel / 4) * nLevel);
        m_Abil.MaxWearWeight := 15 + ROUND((nLevel / 50) * nLevel);
        m_Abil.MaxHandWeight := 12 + ROUND((nLevel / 42) * nLevel);

        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.MC := 0;
        m_Abil.SC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.AC := 0;

        n := ROUND(nLevel / 6);
        m_Abil.MAC := MakeLong(n div 2, n + 1);
      end;
    2:
      begin
        //m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND((nLevel / 6 + 2.5) * nLevel));
        m_Abil.MaxHP := _MIN(High(Word), 14 + ROUND(((nLevel /
          g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) * nLevel)));

        //m_Abil.MaxMP:=_MIN(High(Word),13 + ROUND((nLevel / 8)* 2.2 * nLevel));
        m_Abil.MaxMP := _MIN(High(Word), 13 + ROUND(((nLevel /
          g_Config.nLevelValueOfTaosMP) * 2.2 * nLevel)));

        m_Abil.MaxWeight := 50 + ROUND((nLevel / 4) * nLevel);
        m_Abil.MaxWearWeight := 15 + ROUND((nLevel / 50) * nLevel);
        m_Abil.MaxHandWeight := 12 + ROUND((nLevel / 42) * nLevel);

        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.MC := 0;
        m_Abil.SC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.AC := 0;

        n := ROUND(nLevel / 6);
        m_Abil.MAC := MakeLong(n div 2, n + 1);
      end;
    1:
      begin
        //m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND((nLevel / 15 + 1.8) * nLevel));
        m_Abil.MaxHP := _MIN(High(Word), 14 + ROUND(((nLevel /
          g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate) * nLevel)));

        m_Abil.MaxMP := _MIN(High(Word), 13 + ROUND((nLevel / 5 + 2) * 2.2 * nLevel));
        m_Abil.MaxWeight := 50 + ROUND((nLevel / 5) * nLevel);
        m_Abil.MaxWearWeight := 15 + ROUND((nLevel / 100) * nLevel);
        m_Abil.MaxHandWeight := 12 + ROUND((nLevel / 90) * nLevel);

        n := nLevel div 7;
        m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.MC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
        m_Abil.SC := 0;
        m_Abil.AC := 0;
        m_Abil.MAC := 0;
      end;
    0:
      begin
        //m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND((nLevel / 4.0 + 4.5 + nLevel / 20) * nLevel));
        m_Abil.MaxHP := _MIN(High(Word), 14 + ROUND(((nLevel /
          g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate + nLevel / 20) *
          nLevel)));

        m_Abil.MaxMP := _MIN(High(Word), 11 + ROUND(nLevel * 3.5));
        m_Abil.MaxWeight := 50 + ROUND((nLevel / 3) * nLevel);
        m_Abil.MaxWearWeight := 15 + ROUND((nLevel / 20) * nLevel);
        m_Abil.MaxHandWeight := 12 + ROUND((nLevel / 13) * nLevel);

        m_Abil.DC := MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div 5)));
        m_Abil.SC := 0;
        m_Abil.MC := 0;
        m_Abil.AC := MakeLong(0, (nLevel div 7));
        m_Abil.MAC := 0;
      end;
  end;
  if m_Abil.HP > m_Abil.MaxHP then
    m_Abil.HP := m_Abil.MaxHP;
  if m_Abil.MP > m_Abil.MaxMP then
    m_Abil.MP := m_Abil.MaxMP;

end;

procedure TBaseObject.HasLevelUp(nLevel: Integer);          //004BED6C
begin
  m_Abil.MaxExp := GetLevelExp(m_Abil.Level);
  RecalcLevelAbilitys();
  RecalcAbilitys();
  SendMsg(Self, RM_LEVELUP, 0, m_Abil.Exp, 0, 0, '');
  if (m_btRaceServer = RC_PLAYOBJECT) and (nLevel <> -1) and (nLevel < m_Abil.Level) then
  begin
    if g_FunctionNPC <> nil then
    begin
      g_FunctionNPC.GotoLable(TPlayObject(Self), '@升级触发', False);
    end;
  end;

{$IFDEF FOR_ABIL_POINT}
  //4/16老 何磐 利侩
  if prevlevel + 1 = Abil.Level then
  begin
    BonusPoint := BonusPoint + GetBonusPoint(Job, Abil.Level);
    SendMsg(self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
  end
  else
  begin
    if prevlevel <> Abil.Level then
    begin
      //焊呈胶 器牢飘甫 贸澜何磐 促矫 拌魂茄促.
      BonusPoint := GetLevelBonusSum(Job, Abil.Level);
      FillChar(BonusAbil, sizeof(TNakedAbility), #0);
      FillChar(CurBonusAbil, sizeof(TNakedAbility), #0);
      //if prevlevel <> 0 then begin
      RecalcLevelAbilitys; //饭骇俊 蝶弗 瓷仿摹甫 拌魂茄促.

      SendMsg(self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    end;
  end;
{$ENDIF}
end;

function TPlayObject.IncGold(tGold: Integer): Boolean;      //004BF64C
begin
  Result := False;
  //  if m_nGold + tGold <= BAGGOLD then begin
  if m_nGold + tGold <= g_Config.nHumanMaxGold then
  begin
    Inc(m_nGold, tGold);
    Result := True;
  end;
end;

procedure AddUserLog(sMsg: string);                         //004E42F8
begin
  MainOutMessage(sMsg);
end;

function TBaseObject.WalkTo(btDir: Byte; boFlag: boolean): Boolean; //004C3F64
var
  nOX, nOY, nNX, nNY, n20, n24                         : Integer;
  //Envir:TEnvirnoment;
  bo29                                                 : Boolean;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::WalkTo';
begin
  Result := False;
  if m_boHolySeize or m_bolinghunqiang then
    exit;
  try
    nOX := m_nCurrX;
    nOY := m_nCurrY;
    //    Envir:=m_PEnvir;
    m_btDirection := btDir;
    nNX := 0;
    nNY := 0;
    case btDir of
      DR_UP:
        begin
          nNX := m_nCurrX;
          nNY := m_nCurrY - 1;
        end;
      DR_UPRIGHT:
        begin
          nNX := m_nCurrX + 1;
          nNY := m_nCurrY - 1;
        end;
      DR_RIGHT:
        begin
          nNX := m_nCurrX + 1;
          nNY := m_nCurrY;
        end;
      DR_DOWNRIGHT:
        begin
          nNX := m_nCurrX + 1;
          nNY := m_nCurrY + 1;
        end;
      DR_DOWN:
        begin
          nNX := m_nCurrX;
          nNY := m_nCurrY + 1;
        end;
      DR_DOWNLEFT:
        begin
          nNX := m_nCurrX - 1;
          nNY := m_nCurrY + 1;
        end;
      DR_LEFT:
        begin
          nNX := m_nCurrX - 1;
          nNY := m_nCurrY;
        end;
      DR_UPLEFT:
        begin
          nNX := m_nCurrX - 1;
          nNY := m_nCurrY - 1;
        end;
    end;
    if (nNX >= 0) and ((m_PEnvir.m_nWidth - 1) >= nNX) and
      (nNY >= 0) and ((m_PEnvir.m_nHeight - 1) >= nNY) then
    begin
      bo29 := True;
      if bo2BA and not m_PEnvir.CanSafeWalk(nNX, nNY) then
        bo29 := False;
      if m_Master <> nil then
      begin
        m_Master.m_PEnvir.GetNextPosition(m_Master.m_nCurrX, m_Master.m_nCurrY,
          m_Master.m_btDirection, 1, n20, n24);
        if (nNX = n20) and (nNY = n24) then
          bo29 := False;
      end;
      if bo29 then
      begin
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nNX, nNY, boFlag) > 0
          then
        begin
          m_nCurrX := nNX;
          m_nCurrY := nNY;
        end;
      end;
    end;
    if (m_nCurrX <> nOX) or (m_nCurrY <> nOY) then
    begin
      if Walk(RM_WALK) then
      begin
        if m_boTransparent and m_boHideMode then
          m_wStatusTimeArr[STATE_TRANSPARENT {0x70}] := 1;
        Result := True;
      end
      else
      begin
        // m_PEnvir.DeleteFromMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
        if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) <> 1 then
          exit;
        m_nCurrX := nOX;
        m_nCurrY := nOY;
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TPlayObject.IsEnoughBag(nCount: Integer = 1): Boolean; //004C4990
begin
  Result := False;
  if m_ItemList.Count + nCOunt <= m_bMaxBagitem then        //    MAXBAGITEM
    Result := True;
end;

function TPlayObject.IsAddWeightAvailable(nWeight: Integer): Boolean; //004C4A78
begin
  Result := False;
  if (m_WAbil.Weight + nWeight) <= m_WAbil.MaxWeight then
    Result := True;
end;

procedure TPlayObject.SendAddItem(UserItem: pTUserItem);    //004D0824
var
  pStdItem                                             : pTStdItem;
  StdItem                                              : TStdItem;
  ClientItem                                           : TClientItem;

  sUserItemName                                        : string;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint, tint2                                          : integer;

begin

  begin
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then
      exit;
    StdItem := pStdItem^;
    ItemUnit.GetItemAddValue(UserItem, StdItem);
    ClientItem.S := StdItem;
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    ClientItem.DarkProperty := Useritem.DarkProp; //.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      ClientItem.S.Name := sUserItemName;
    ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
    ClientItem.MakeIndex := UserItem.MakeIndex;
    ClientItem.Dura := UserItem.Dura;
    ClientItem.DuraMax := UserItem.DuraMax;
    if StdItem.StdMode = 50 then
    begin
      ClientItem.S.Name := ClientItem.S.Name + ' #' + IntToStr(UserItem.Dura);
    end;
    if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26] then
    begin
      if UserItem.btValue[8] = 0 then
        ClientItem.S.Shape := 0
      else
        ClientItem.S.Shape := 130;
    end;
    ClientItem.S.Price := 0;
    if (ClientItem.S.StdMode = 0) and (ClientItem.s.Shape = 200) then
      ClientItem.s.AC := 0;
    m_DefMsg := MakeDefaultMsg(SM_ADDITEM, Integer(Self), 0, 0, 1);
    SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
    // if (UserItem.btValue[12] and $1)=1 then
    begin

      if UserItem.AttachMagic.MakeIndex > 0 then
      begin
        m_DefMsg := MakeDefaultMsg(207, Integer(Self), 40, 0, 1);
        SendSocket(@m_DefMsg, EncodeBuffer(@UserItem.AttachMagic.aaa,
          SizeOf(TAttachMagicRCD1)));
      end;
    end;
  end;
end;

function TBaseObject.IsGroupMember(target: TBaseObject): Boolean; //004C3908
var
  I                                                    : Integer;
  hum, hum2                                            : TPlayObject;
  targetobject                                         : TBaseObject;
begin
  Result := False;
  targetobject := target;
  if (target.m_btRaceServer = RC_PLAYOBJECT) and (Tplayobject(target).sYsnameMaster <> '')
    then
  begin
    hum2 := nil;
    // hum2:=UserEngine.GetPlayObjectEx(Tplayobject(target).sYsnameMaster);
    hum2 := Tplayobject(target).ysmasterplayer;
    if (hum2 <> nil) then
      targetobject := hum2;
  end;

  if (m_btRaceServer = RC_PLAYOBJECT) and (Tplayobject(self).sYsnameMaster <> '') then
  begin                                                     //如果是元神    不攻击组队队员
    // hum:=nil;
    // hum:=UserEngine.GetPlayObjectEx(Tplayobject(self).sYsnameMaster);
    hum := Tplayobject(self).ysmasterplayer;
    if (hum <> nil) and (hum.m_GroupOwner <> nil) then
    begin
      for I := 0 to hum.m_GroupOwner.m_GroupMembers.Count - 1 do
      begin
        if hum.m_GroupOwner.m_GroupMembers.Objects[i] = targetobject then
        begin
          Result := True;
          break;
        end;
      end;                                                  //for
    end;

    exit;
  end;
  if m_GroupOwner = nil then
    exit;

  for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
  begin
    if m_GroupOwner.m_GroupMembers.Objects[i] = targetobject then
    begin
      Result := True;
      break;
    end;
  end;                                                      //for
end;

//004D1558

procedure TPlayObject.Whisper(whostr, saystr: string);
var
  PlayObject                                           : TPlayObject;
  svidx                                                : Integer;
begin
  PlayObject := UserEngine.GeTPlayObject(whostr);
  if PlayObject <> nil then
  begin
    if (playobject.m_sCharName = m_sCharName) then
      exit;
    if not PlayObject.m_boReadyRun then
    begin
      SysMsg(whostr + g_sCanotSendmsg {'无法发送信息.'}, c_Red, t_Hint);
      exit;
    end;
    if not PlayObject.m_boHearWhisper or PlayObject.IsBlockWhisper(m_sCharName) then
    begin
      SysMsg(whostr + g_sUserDenyWhisperMsg {' 拒绝私聊！！！'}, c_Red, t_Hint);
      exit;
    end;
    if playobject.m_booffline and (playobject.m_sCharName <> m_sCharName) then
      playobject.Whisper(m_sCharName, playobject.m_soffline);
    ///
    if m_btPermission > 0 then
    begin
      PlayObject.SendMsg(PlayObject, RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor,
        g_Config.btGMWhisperMsgBColor, 0, m_sCharName + '=> ' + saystr);
      //取得私聊信息
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, 0,
          g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, m_sCharName +
          '=>' + PlayObject.m_sCharName + ' ' + saystr);

      if (PlayObject.m_GetWhisperHuman <> nil) and (not
        PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman, RM_WHISPER, 0,
          g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0, m_sCharName +
          '=>' + PlayObject.m_sCharName + ' ' + saystr);
    end
    else
    begin
      PlayObject.SendMsg(PlayObject, RM_WHISPER, 0, g_Config.btWhisperMsgFColor,
        g_Config.btWhisperMsgBColor, 0, m_sCharName + '=> ' + saystr);
      if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, 0,
          g_Config.btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, m_sCharName + '=>' +
          PlayObject.m_sCharName + ' ' + saystr);

      if (PlayObject.m_GetWhisperHuman <> nil) and (not
        PlayObject.m_GetWhisperHuman.m_boGhost) then
        PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman, RM_WHISPER, 0,
          g_Config.btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0, m_sCharName + '=>' +
          PlayObject.m_sCharName + ' ' + saystr);
    end;

  end
  else
  begin
    if UserEngine.FindOtherServerUser(whostr, svidx) then
    begin
      UserEngine.SendServerGroupMsg(SS_WHISPER, svidx, whostr + '/' + m_sCharName + '=> '
        + saystr);
    end
    else
    begin
      SysMsg(whostr + g_sUserNotOnLine {'  没有在线！！！'}, c_Red, t_Hint);
    end;
  end;
end;
//004D199C

function TPlayObject.IsBlockWhisper(sName: string): Boolean;
var
  I                                                    : Integer;
begin
  Result := False;
  for I := 0 to m_BlockWhisperList.Count - 1 do
  begin
    if CompareText(sName, m_BlockWhisperList.Strings[i]) = 0 then
    begin
      Result := True;
      break;
    end;
  end;
end;

function TBaseObject.PKLevel(): Integer;                    //004BF0A0
begin
  Result := m_nPkPoint div 100;
end;

procedure TBaseObject.HealthSpellChanged;                   //004C4A24
begin
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
  end;
  if m_boShowHP then
  begin                                                     //     //
    SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
  end;
end;

function TBaseObject.CalcGetExp(nLevel: Integer; nExp: Integer): Integer; //004BE59F
begin

  if g_Config.boHighLevelKillMonFixExp or (m_Abil.Level < (nLevel + 10)) then
  begin
    Result := nExp;
  end
  else
  begin
    Result := nExp - ROUND((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
  end;
  if Result <= 0 then
    Result := 1;
end;

procedure TBaseObject.RefNameColor();                       //004BF124
begin
  SendRefMsg(RM_CHANGENAMECOLOR, 0, 0, 0, 0, '');
end;

procedure TBaseObject.GainSlaveExp(nLevel: Integer);        //004BE8BC
  function GetUpKillCount(): Integer;                       //004BE864
  var
    tCount                                             : Integer;
  begin
    if m_btSlaveExpLevel < SLAVEMAXLEVEL - 2 then
    begin
      tCount := g_Config.MonUpLvNeedKillCount[m_btSlaveExpLevel];
    end
    else
    begin
      tCount := 0;
    end;
    //    Result:= ((m_Abil.Level shl 4) - m_Abil.Level) + 100 + tCount
    Result := ((m_Abil.Level * g_Config.nMonUpLvRate {16}) - m_Abil.Level) +
      g_Config.nMonUpLvNeedKillBase {100} + tCount
  end;
  {
  var
    nNeedCount:Integer;
  }
begin
  Inc(n294, nLevel);
  if GetUpKillCount() < n294 then
  begin
    Dec(n294, GetUpKillCount);
    if m_btSlaveExpLevel < (m_btSlaveMakeLevel * 2 + 1) then
    begin
      Inc(m_btSlaveExpLevel);
      RecalcAbilitys();
      RefShowName();
      RefNameColor();                                       //这里宝宝升级，变颜色。

    end;
  end;                                                      //004BE92F
end;

function TBaseObject.DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat,
  DropGoldCreat: TBaseObject): Boolean;                       //004C5794
var
  MapItem, MapItemA                                    : PTMapItem;
  nX, nY, DropWide                                     : Integer;
  s20                                                  : string;
begin
  DropWide := _min(g_Config.nDropItemRage, 7);
  Result := False;
  New(MapItem);
  FillChar(MapItem^, SizeOf(TMapItem), #0);
  MapItem.Name := sSTRING_GOLDNAME;
  MapItem.Count := nGold;
  MapItem.Looks := GetGoldShape(nGold);
  MapItem.OfBaseObject := GoldOfCreat;
  MapItem.dwCanPickUpTick := GetTickCount();
  MapItem.DropBaseObject := DropGoldCreat;
  if DropGoldCreat <> nil then

    MapItem.DropName := DropGoldCreat.m_sCharName;
  GetDropPosition(m_nCurrX, m_nCurrY, DropWide, nX, nY);    // 3
  MapItemA := nil;
  MapItemA := m_PEnvir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
  if MapItemA <> nil then
  begin
    if MapItemA <> MapItem then
    begin
      Dispose(MapItem);
      MapItem := MapItemA;
    end;
    SendRefMsg(RM_ITEMSHOW, MapItem.Looks, integer(MapItem), nX, nY, MapItem.Name);
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if boFalg then
        s20 := '15'
      else
        s20 := '7';
      //004C5995
      if g_boGameLogGold then
        AddGameDataLog(s20 + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          sSTRING_GOLDNAME + #9 +
          IntToStr(nGold) + #9 +
          BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
          '0');
    end;                                                    //004C599A
    Result := True;
  end
  else
    Dispose(MapItem);
end;

function TBaseObject.GetGuildRelation(cert1, cert2: TBaseObject): Integer; //004BF380
begin
  Result := 0;
  m_boGuildWarArea := False;
  if (cert1.m_MyGuild = nil) or (cert2.m_MyGuild = nil) then
    exit;
  if cert1.InSafeArea or (cert2.InSafeArea) then
    exit;
  if TGuild(cert1.m_MyGuild).GuildWarList.Count <= 0 then
    exit;
  m_boGuildWarArea := True;
  if TGuild(cert1.m_MyGuild).IsWarGuild(TGuild(cert2.m_MyGuild)) and
    TGuild(cert2.m_MyGuild).IsWarGuild(TGuild(cert1.m_MyGuild)) then
    Result := 2;

  if cert1.m_MyGuild = cert2.m_MyGuild then
    Result := 1;
  if TGuild(cert1.m_MyGuild).IsAllyGuild(TGuild(cert2.m_MyGuild)) and
    TGuild(cert2.m_MyGuild).IsAllyGuild(TGuild(cert1.m_MyGuild)) then
    Result := 3;
end;

procedure TBaseObject.IncPkPoint(nPoint: Integer);          //004BF4D4
var
  nOldPKLevel                                          : Integer;
begin
  nOldPKLevel := PKLevel;
  Inc(m_nPkPoint, nPoint);
  if PKLevel <> nOldPKLevel then
  begin
    if PKLevel <= 2 then
      RefNameColor;
  end;
end;

procedure TBaseObject.AddBodyLuck(dLuck: Double);           //004BF580
var
  n                                                    : Integer;
begin
  if (dLuck > 0) and (m_dBodyLuck < 5 * BODYLUCKUNIT) then
  begin
    m_dBodyLuck := m_dBodyLuck + dLuck;
  end;
  if (dLuck < 0) and (m_dBodyLuck > -(5 * BODYLUCKUNIT)) then
  begin
    m_dBodyLuck := m_dBodyLuck + dLuck;
  end;

  n := Trunc(m_dBodyLuck / BODYLUCKUNIT);
  if n > 5 then
    n := 5;
  if n < -10 then
    n := -10;
  m_nBodyLuckLevel := n;
end;

procedure TBaseObject.MakeWeaponUnlock;                     //004C1198
begin
  if m_UseItems[U_WEAPON].wIndex <= 0 then
    exit;
  if m_UseItems[U_WEAPON].btValue[3] > 0 then
  begin
    Dec(m_UseItems[U_WEAPON].btValue[3]);
    SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
  end
  else
  begin
    if m_UseItems[U_WEAPON].btValue[4] < 10 then
    begin
      Inc(m_UseItems[U_WEAPON].btValue[4]);
      SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  end;
end;

function TBaseObject.GetAttackPower(nBasePower, nPower: Integer; nMagicID: Integer = -1):
  Integer;
var
  PlayObject                                           : TPlayObject;
begin
  if nPower < 0 then
    nPower := 0;
  if m_nLuck > 0 then
  begin
    if Random(10 - _MIN(9, m_nLuck)) = 0 then
      Result := nBasePower + nPower
    else
      Result := nBasePower + Random(nPower + 1);
  end
  else
  begin
    Result := nBasePower + Random(nPower + 1);
    if m_nLuck < 0 then
    begin
      if Random(10 - _MAX(0, -m_nLuck)) = 0 then
        Result := nBasePower;
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    PlayObject := TPlayObject(Self);
    //Result:=Result * PlayObject.m_nPowerMult + ROUND(Result * (PlayObject.m_nPowerMultPoint / 100));
    Result := ROUND(Result * (PlayObject.m_nPowerRate / 100));
    if PlayObject.m_boPowerItem then
      Result := ROUND(m_rPowerItem * Result);
  end;
  if m_boAutoChangeColor then
  begin
    Result := Result * m_nAutoChangeIdx + 1;
  end;
  if m_boFixColor then
  begin
    Result := Result * m_nFixColorIdx + 1;
  end;
  if (nMagicID > -1) and (nMagicID < 100) then
  begin
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if TPlayobject(Self).m_MagicPOwerList[nMagicID] > 0 then
        Result := Result * (100 + TPlayobject(Self).m_MagicPOwerList[nMagicID] * 3) div
          100;
    end;
  end;
end;

procedure TBaseObject.DamageHealth(nDamage: Integer; ntype: integer); //004BE3FC
var
  nSpdam, n                                            : Integer;
  useritem                                             : PTUserItem;
begin
  if ((((m_LastHiter = nil) or (not m_LastHiter.m_boUnMagicShield)) and m_boMagicShield)
    or m_boSupperMagicShield) and (nDamage > 0) and (m_WAbil.MP > 0) then
  begin
    nSpdam := Round(nDamage * 1.5);
    if integer(m_WAbil.MP) >= nSpdam then
    begin
      m_WAbil.MP := m_WAbil.MP - nSpdam;
      nSpdam := 0;
    end
    else
    begin
      nSpdam := nSpdam - m_WAbil.MP;
      m_WAbil.MP := 0;
    end;
    nDamage := Round(nSpdam / 1.5);
    HealthSpellChanged();
  end;
  //带有盾牌
  if (nDamage > 0) and (m_UseItems[13].wIndex > 0) then
  begin
    Randomize;
    n := Random(100);
    if n < g_Config.btShieldRate then
    begin
      n := m_UseItems[13].btValue[12];

      SysMsg('盾牌防御成功，本次伤害免除' + Inttostr(n) + '%', c_Red, t_Hint);
      n := nDamage * n div 100;
      Dec(nDamage, n);
    end;
  end;

  if ntype = 1 then
  begin
    if nDamage > 0 then
    begin
      if (m_WAbil.HP - nDamage) > 0 then
      begin
        m_WAbil.HP := m_WAbil.HP - nDamage;
      end
      else
      begin
        m_WAbil.HP := 0;
      end;
    end
    else
    begin
      if (m_WAbil.HP - nDamage) < m_WAbil.MaxHP then
      begin
        m_WAbil.HP := m_WAbil.HP - nDamage;
      end
      else
      begin
        m_WAbil.HP := m_WAbil.MaxHP;
      end;
    end;
  end;

  if ntype = 2 then
  begin
    if nDamage > 0 then
    begin
      if (m_WAbil.MP - nDamage) > 0 then
      begin
        m_WAbil.MP := m_WAbil.MP - nDamage;
      end
      else
      begin
        m_WAbil.MP := 0;
      end;
    end
    else
    begin
      if (m_WAbil.MP - nDamage) < m_WAbil.MaxMP then
      begin
        m_WAbil.MP := m_WAbil.MP - nDamage;
      end
      else
      begin
        m_WAbil.MP := m_WAbil.MaxMP;
      end;
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    TPlayObject(Self).m_nAddYQ := 10;
    if TPlayObject(Self).ysmasterplayer <> nil then         //是元神则缓慢增长元气
    begin

      TPlayObject(Self).ysmasterplayer.m_naddYQ := 10;
    end;
  end;
end;

function TBaseObject.GetBackDir(nDir: integer): Integer;    //004B2708
begin
  Result := 0;
  case nDir of
    DR_UP: Result := DR_DOWN;
    DR_DOWN: Result := DR_UP;
    DR_LEFT: Result := DR_RIGHT;
    DR_RIGHT: Result := DR_LEFT;
    DR_UPLEFT: Result := DR_DOWNRIGHT;
    DR_UPRIGHT: Result := DR_DOWNLEFT;
    DR_DOWNLEFT: Result := DR_UPRIGHT;
    DR_DOWNRIGHT: Result := DR_UPLEFT;
  end;
end;

function TBaseObject.CharPushed(nDir, nPushCount: Integer): integer; //004C2F90
var
  i, nx, ny, olddir, oldx, oldy, nBackDir              : integer;
begin
  try
    Result := 0;
    olddir := m_btDirection;
    oldx := m_nCurrX;
    oldy := m_nCurrY;
    m_btDirection := ndir;
    nBackDir := GetBackDir(ndir);
    for i := 0 to nPushCount - 1 do
    begin
      GetFrontPosition(nx, ny);
      if m_PEnvir.CanWalk(nX, nY, False) then
      begin
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then
        begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          //SendRefMsg(RM_PUSH, GetBackDir(ndir), m_nCurrX, m_nCurrY, 0, '');
          SendRefMsg(RM_PUSH, nBackDir, m_nCurrX, m_nCurrY, 0, '');
          Inc(Result);
          if m_btRaceServer >= RC_ANIMAL then
            m_dwWalkTick := m_dwWalkTick + 800;
        end
        else
          break;
      end
      else
        break;
    end;
    //m_btDirection:=GetBackDir(ndir);
    //m_btDirection:=GetBackDir(nBackDir);
    m_btDirection := nBackDir;
    if Result = 0 then
      m_btDirection := olddir;
  except
    MainOutMessage('[Exception] CharPushed');
  end;

end;

function TBaseObject.CharPushedX(nDir, nPushCount: Integer): integer; //004C2F90
var
  i, nx, ny, olddir, oldx, oldy, nBackDir              : integer;
begin
  try
    Result := 0;
    olddir := m_btDirection;
    oldx := m_nCurrX;
    oldy := m_nCurrY;
    m_btDirection := ndir;
    nBackDir := GetBackDir(ndir);
    for i := 0 to nPushCount - 1 do
    begin
      GetFrontPosition(nx, ny);
      if m_PEnvir.CanWalk(nX, nY, False) then
      begin
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then
        begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          //SendRefMsg(RM_PUSH, GetBackDir(ndir), m_nCurrX, m_nCurrY, 0, '');
          SendRefMsg(RM_PUSHX, nBackDir, m_nCurrX, m_nCurrY, 0, '');
          Inc(Result);
          if m_btRaceServer >= RC_ANIMAL then
            m_dwWalkTick := m_dwWalkTick + 800;
        end
        else
          break;
      end
      else
        break;
    end;

    SendRefMsg(RM_PUSHX, nBackDir, m_nCurrX, m_nCurrY, 1, '');
    //    StruckDamage(nPushCount*2);
    //    SendRefMsg(RM_STRUCK,nPushCount*2, m_WAbil.HP, m_WAbil.MaxHP,Integer(Self),'');

      //m_btDirection:=GetBackDir(ndir);
      //m_btDirection:=GetBackDir(nBackDir);
    m_btDirection := nBackDir;
    if Result = 0 then
      m_btDirection := olddir;
  except
    MainOutMessage('[Exception] CharPushed');
  end;

end;

function TBaseObject.MagPassThroughMagic(sx, sy, tx, ty, ndir, magpwr: integer;
  undeadattack: Boolean): integer;                            //004C69F4
var
  i, tcount, acpwr                                     : integer;
  BaseObject                                           : TBaseObject;
  //   n14,n18:integer;
begin
  tcount := 0;
  for i := 0 to 12 do
  begin
    BaseObject := TBaseObject(m_PEnvir.GetMovingObject(sx, sy, True));
    if BaseObject <> nil then
    begin
      if IsProperTarget(BaseObject) then
      begin
        if Random(10) >= BaseObject.m_nAntiMagic then
        begin
          if undeadattack then
            acpwr := Round(magpwr * 1.5)
          else
            acpwr := magpwr;
          BaseObject.SendDelayMsg(self, RM_MAGSTRUCK, 0, acpwr, 0, 0, '', 600);
          Inc(tcount);
        end;
      end;
    end;
    if not ((abs(sx - tx) <= 0) and (abs(sy - ty) <= 0)) then
    begin
      ndir := GetNextDirection(sx, sy, tx, ty);
      if not m_PEnvir.GetNextPosition(sx, sy, ndir, 1, sx, sy) then
        break;
    end
    else
      break;
  end;
  Result := tcount;

end;

procedure TPlayObject.SendSocket(DefMsg: pTDefaultMessage; sMsg: string); //004CAB38
var
  MsgHdr                                               : TMsgHeader;
  nSendBytes                                           : Integer;
  tBuff                                                : PChar;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::SendSocket..';
begin

  if m_booffline and (DefMsg <> nil) and (DefMsg.Ident <> SM_OUTOFCONNECTION) then
    exit;                                                   //脱机中不用发送信息给客户端
  // if (m_btRaceServer = RC_YSBJECT) then
  //   exit; //如果是原神
  tBuff := nil;
  try
    MsgHdr.dwCode := RUNGATECODE;
    MsgHdr.nSocket := m_nSocket;
    MsgHdr.wGateIndex := m_nGSocketIdx;
    MsgHdr.wIdent := GM_DATA;

    //    MsgHdr.nUserListIndex := 0;
        //004CAB9A
    if DefMsg <> nil then
    begin
      if sMsg <> '' then
      begin
        MsgHdr.nLength := Length(sMsg) + SizeOf(TDefaultMessage) + 1;
        nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
        GetMem(tBuff, nSendBytes + SizeOf(Integer));
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)],
          SizeOf(TDefaultMessage));
        Move(sMsg[1], tBuff[SizeOf(TDefaultMessage) + SizeOf(TMsgHeader) +
          SizeOf(Integer)], Length(sMsg) + 1);
      end
      else
      begin                                                 //004CAC29
        MsgHdr.nLength := SizeOf(TDefaultMessage);
        nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
        GetMem(tBuff, nSendBytes + SizeOf(Integer));
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)],
          SizeOf(TDefaultMessage));
      end;
    end
    else
    begin                                                   //004CAC7F
      if sMsg <> '' then
      begin
        MsgHdr.nLength := -(Length(sMsg) + 1);
        nSendBytes := abs(MsgHdr.nLength) + SizeOf(TMsgHeader);
        GetMem(tBuff, nSendBytes + SizeOf(Integer));
        Move(nSendBytes, tBuff^, SizeOf(Integer));
        Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
        Move(sMsg[1], tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg) + 1);
      end;                                                  //004CACF0
    end;                                                    //004CACF0
    if not RunSocket.AddGateBuffer(m_nGateIdx, tBuff) then
    begin
      FreeMem(tBuff);
      //MainOutMessage('SendSocket Buffer Fail ' + IntToStr(m_nGateIdx));
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

procedure TPlayObject.SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag,
  nSeries: Word; sMsg: string; boencode: Boolean = false);    //004CAD6C
begin
  m_DefMsg := MakeDefaultMsg(wIdent, nRecog, nParam, nTag, nSeries);
  if sMsg <> '' then
  begin
    if boencode then
      SendSocket(@m_DefMsg, (sMsg))
    else
      SendSocket(@m_DefMsg, EncodeString(sMsg));
  end
  else
    SendSocket(@m_DefMsg, '');
end;

procedure TPlayObject.ClientQueryUserName(target: TBaseObject; x, y: integer); //004DA8E8
var
  uname                                                : string;
  TagColor                                             : Integer;
  Def                                                  : TDefaultMessage;
begin
  if CretInNearXY(target, x, y) then
  begin
    tagcolor := GetCharColor(target);
    Def := MakeDefaultMsg(SM_USERNAME, Integer(target), tagcolor, 0, 0);
    uname := target.GetShowName;
    SendSocket(@Def, EncodeString(uname));
  end
  else
    SendDefMessage(SM_GHOST, integer(target), x, y, 0, '');
end;

function TBaseObject.GetShowName: string;                   //004C129C
var
  sShowName, Name1                                     : string;
  UserItem                                             : PTUserItem;
begin
  sShowName := m_sCharName;
  if (byistopnpc in [1..7]) or (m_nNewLevel >= 0) then
    Result := sShowName
  else
    Result := FilterShowName(sShowName);

  if (m_Master <> nil) and (not m_Master.m_boObMode) then
  begin
    if (not m_bohorse) then
    begin
      Name1 := Result;
      if (Pos('豹', m_sCharName) > 0) and (m_Master.m_btRaceServer = RC_PLAYOBJECT) and
        (TPlayObject(m_Master).M_monitemMake > 0) then
      begin
        UserItem := TPlayObject(m_Master).GetItems(TPlayObject(m_Master).M_monitemMake);
        if (UserItem <> nil) and (UserItem.btValue[13] = 2) then
        begin
          Name1 := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        end;

      end;

      Result := inttostr(m_btSlaveExpLevel) + '级' + Result + '(' + m_Master.m_sCharName +
        ')-' + Name1;
    end
    else

      Result := Result + '(' + m_Master.m_sCharName + ')';
    if (m_btRaceServer = 17) then
      Result := m_sCharName;                                //如果是公主

  end;
  if m_boPetOnSell then
  begin
    //  Result := inttostr(m_btSlaveExpLevel) + '级' + Result + '(' +m_PetSellCharName+ ')';
  end;
  if m_isBeFsBoss then
    Result := '  ';
  if (m_btRaceServer = 3) and (m_sNewName <> '') then
    Result := m_sNewName;
  if m_nNewLevel >= 0 then
    result := m_sNewName;
end;

procedure TAnimalObject.Attack(TargeTBaseObject: TBaseObject; nDir: Integer); //004C9380
begin
  inherited AttackDir(TargeTBaseObject, 0, nDir);
end;

procedure TAnimalObject.Attack1(TargeTBaseObject: TBaseObject; ntype: integer; nDir:
  Integer);                                                   //004C9380
begin
  inherited AttackDir(TargeTBaseObject, ntype, nDir);
end;

constructor TAnimalObject.Create;                           //004C9190
begin
  inherited;
  m_nNotProcessCount := 0;
  m_nTargetX := -1;
  dwTick3F0 := Random(4) * 500 + 1000;
  dwTick3F4 := GetTickCount();
  m_btRaceServer := RC_ANIMAL;
  m_dwHitTick := GetTickCount - LongWord(Random(3000));
  m_dwWalkTick := GetTickCount - LongWord(Random(3000));
  m_dwSearchEnemyTick := GetTickCount();
  m_boRunAwayMode := False;
  m_dwRunAwayStart := GetTickCount();
  m_dwRunAwayTime := 0;
end;

procedure TAnimalObject.GotoTargetXY;                       //004C9694
var
  I                                                    : Integer;
  nDir                                                 : Integer;
  n10                                                  : Integer;
  n14                                                  : Integer;
  n20                                                  : Integer;
  nOldX                                                : Integer;
  nOldY                                                : Integer;
begin
  if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then
  begin
    n10 := m_nTargetX;
    n14 := m_nTargetY;
    dwTick3F4 := GetTickCount();
    nDir := DR_DOWN;
    if n10 > m_nCurrX then
    begin
      nDir := DR_RIGHT;
      if n14 > m_nCurrY then
        nDir := DR_DOWNRIGHT;
      if n14 < m_nCurrY then
        nDir := DR_UPRIGHT;
    end
    else
    begin                                                   //004C9728
      if n10 < m_nCurrX then
      begin
        nDir := DR_LEFT;
        if n14 > m_nCurrY then
          nDir := DR_DOWNLEFT;
        if n14 < m_nCurrY then
          nDir := DR_UPLEFT;
      end
      else
      begin                                                 //004C9760
        if n14 > m_nCurrY then
          nDir := DR_DOWN
        else
          if n14 < m_nCurrY then
            nDir := DR_UP;
      end;
    end;
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    WalkTo(nDir, False);
    n20 := Random(3);
    for I := DR_UP to DR_UPLEFT do
    begin
      if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then
      begin
        if n20 <> 0 then
          Inc(nDir)
        else
          if nDir > 0 then
            Dec(nDir)
          else
            nDir := DR_UPLEFT;
        if (nDir > DR_UPLEFT) then
          nDir := DR_UP;
        WalkTo(nDir, False);
      end;
    end;
  end;                                                      //004C980B
end;
{
procedure TAnimalObject.runtoTargetXY; //004C9694
var
 I     :Integer;
 nDir  :Integer;
 n10   :Integer;
 n14   :Integer;
 n20   :Integer;
 nOldX :Integer;
 nOldY :Integer;
begin
 if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then begin
   n10:=m_nTargetX;
   n14:=m_nTargetY;
   dwTick3F4:=GetTickCount();
   nDir:=DR_DOWN;
   if n10 > m_nCurrX then begin
     nDir:=DR_RIGHT;
     if n14 > m_nCurrY then nDir:=DR_DOWNRIGHT;
     if n14 < m_nCurrY then nDir:=DR_UPRIGHT;
   end else begin //004C9728
     if n10 < m_nCurrX then begin
       nDir:=DR_LEFT;
       if n14 > m_nCurrY then nDir:=DR_DOWNLEFT;
       if n14 < m_nCurrY then nDir:=DR_UPLEFT;
     end else begin //004C9760
       if n14 > m_nCurrY then nDir:=DR_DOWN
       else if n14 < m_nCurrY then nDir:=DR_UP;
     end;
  end;
   nOldX:=m_nCurrX;
   nOldY:=m_nCurrY;
   walkTo(nDir,False);
   n20:=Random(3);
   for I := DR_UP to DR_UPLEFT do begin
     if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then begin
       if n20 <> 0 then Inc(nDir)
       else if nDir > 0 then Dec(nDir)
       else nDir:=DR_UPLEFT;
       if (nDir > DR_UPLEFT) then nDir:=DR_UP;
       runTo(nDir,False);
     end;
   end;
 end; //004C980B
end;
}

function TAnimalObject.Operate(ProcessMsg: pTProcessMessage): Boolean; //004C9280
begin
  //  Result:=False;
  if (ProcessMsg.wIdent = RM_STRUCK) then
  begin
    if (ProcessMsg.BaseObject = Self) and (TBaseObject(ProcessMsg.nParam3
      {AttackBaseObject}) <> nil) then
    begin
      SetLastHiter(TBaseObject(ProcessMsg.nParam3 {AttackBaseObject}));
      Struck(TBaseObject(ProcessMsg.nParam3 {AttackBaseObject})); {0FFEC}
      BreakHolySeizeMode();                                 //中止被诱惑状态
      if (m_Master <> nil) and
        (TBaseObject(ProcessMsg.nParam3) <> m_Master) and
        (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) then
      begin

        m_Master.SetPKFlag(TBaseObject(ProcessMsg.nParam3));
      end;
      if g_Config.boMonSayMsg then
        MonsterSayMsg(TBaseObject(ProcessMsg.nParam3), s_UnderFire);
    end;
    Result := True;
  end
  else
  begin                                                     //004C932C
    Result := inherited Operate(ProcessMsg);
  end;
end;

procedure TAnimalObject.Run;                                //004C936C
begin
  inherited;
  if m_isBeFsBoss then
  begin
    if GetTickCount - m_befsbossStartdw > m_befsBossTime then
    begin
      MakeGhost;
      if self.m_Master <> nil then
        m_Master.m_hasFsBoss := false;

    end;
  end;
end;

procedure TAnimalObject.Struck(Hiter: TBaseObject);         //004C93A8
var
  btDir                                                : Byte;
begin
  m_dwStruckTick := GetTickCount;
  if Hiter <> nil then
  begin
    if (m_TargetCret = nil) or GetAttackDir(m_TargetCret, btDir) or (Random(6) = 0) then
    begin
      if IsProperTarget(Hiter) then
        SetTargetCreat(Hiter);
    end;
  end;                                                      //004C941D
  if m_boAnimal then
  begin
    m_nMeatQuality := m_nMeatQuality - Random(300);
    if m_nMeatQuality < 0 then
      m_nMeatQuality := 0;
  end;
  //if m_Abil.Level < 50 then
  m_dwHitTick := m_dwHitTick + LongWord(150 - _MIN(130, m_Abil.Level * 4));
  //WalkTime := WalkTime + (300 - _MIN(200, (Abil.Level div 5) * 20));
end;

procedure TBaseObject.RecalcAbilitys;                       //004C03B0
var
  Abil                                                 : TAbility;
  boOldHideMode                                        : Boolean;
  nOldLight                                            : Integer;
  I                                                    : Integer;
  StdItem                                              : pTStdItem;
  boRecallSuite1                                       : Boolean;
  boRecallSuite2                                       : Boolean;
  boRecallSuite3                                       : Boolean;
  boRecallSuite4                                       : Boolean;
  boMoXieSuite1                                        : Boolean;
  boMoXieSuite2                                        : Boolean;
  boMoXieSuite3                                        : Boolean;
  boHongMoSuite1                                       : Boolean;
  boHongMoSuite2                                       : Boolean;
  boHongMoSuite3                                       : Boolean;
  boSpirit1                                            : Boolean;
  boSpirit2                                            : Boolean;
  boSpirit3                                            : Boolean;
  boSpirit4                                            : Boolean;
  pUnit_Item                                           : pTUnit_Item;
  //  PlayObject:TPlayObject;
begin
  FillChar(m_AddAbil, SizeOf(TAddAbility), #0);
  Abil := m_WAbil;
  m_WAbil := m_Abil;
  m_WAbil.HP := Abil.HP;
  m_WAbil.MP := Abil.MP;
  m_WAbil.Weight := 0;
  m_WAbil.WearWeight := 0;
  m_WAbil.HandWeight := 0;
  m_btAntiPoison := 0;
  m_nPoisonRecover := 0;
  m_nHealthRecover := 0;
  m_nSpellRecover := 0;
  m_nAntiMagic := 1;
  m_nLuck := 0;
  m_nHitSpeed := 0;
  m_boExpItem := False;
  m_rExpItem := 0;
  m_boPowerItem := False;
  m_rPowerItem := 0;
  boOldHideMode := m_boHideMode;
  m_boHideMode := False;
  m_boTeleport := False;
  m_btMobSlaveLevel := 0;
  m_boDearMove := False;
  m_boParalysis := False;
  m_boMagicParalysis := False;
  m_boRevival := False;
  m_boUnRevival := False;
  m_boFlameRing := False;
  m_boRecoveryRing := False;
  m_boAngryRing := False;
  m_boMagicShield := False;
  m_boDoubleAC := False;
  m_boDoubleMAC := False;
  m_boUnMagicShield := False;
  m_boMuscleRing := False;
  m_boFastTrain := False;
  m_boProbeNecklace := False;
  m_boSupermanItem := False;
  m_boGuildMove := False;
  m_boUnParalysis := False;
  m_boExpItem := False;
  m_boPowerItem := False;
  m_boNoDropItem := False;
  m_boNoDropUseItem := False;
  m_bopirit := False;
  // m_btHorseType      := 0;
  m_btDressEffType := 0;

  m_nMoXieSuite := 0;
  boMoXieSuite1 := False;
  boMoXieSuite2 := False;
  boMoXieSuite3 := False;
  m_db3B0 := 0;
  m_nHongMoSuite := 0;
  boHongMoSuite1 := False;
  boHongMoSuite2 := False;
  boHongMoSuite3 := False;

  boSpirit1 := False;
  boSpirit2 := False;
  boSpirit3 := False;
  boSpirit4 := False;

  m_boRecallSuite := False;
  boRecallSuite1 := False;
  boRecallSuite2 := False;
  boRecallSuite3 := False;
  boRecallSuite4 := False;
  m_boDoubleAC := False;
  m_boDoubleMAC := False;

  m_dwPKDieLostExp := 0;
  m_nPKDieLostLevel := 0;
  m_btMobSlaveLevel := 0;
  for I := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    if (m_UseItems[I].wIndex <= 0) or (m_UseItems[I].Dura <= 0) then
      Continue;
    GetAccessory(m_UseItems[I], m_AddAbil);
    StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if m_UseItems[I].DarkProp.btMagicID < 100 then
        TPlayobject(Self).m_MagicPOwerList[m_UseItems[I].DarkProp.btMagicID] :=
          m_UseItems[I].DarkProp.btMagicPower;
    end;
    if StdItem = nil then
      Continue;
    if (I = U_WEAPON) or (I = U_RIGHTHAND) or (I = U_DRESS) then
    begin
      if I = U_DRESS then
      begin
        Inc(m_WAbil.WearWeight, StdItem.Weight);
      end
      else
      begin
        Inc(m_WAbil.HandWeight, StdItem.Weight);
      end;
      //新增开始
      if (Stditem.AniCount = 184) or (StdItem.Shape = 184) then
        m_boDoubleAC := true;
      if (Stditem.AniCount = 185) or (StdItem.Shape = 185) then
        m_boDoubleMAC := True;

      if StdItem.AniCount = 120 then
        m_boFastTrain := True;
      if StdItem.AniCount = 121 then
        m_boProbeNecklace := True;
      if StdItem.AniCount = 145 then
        m_boGuildMove := True;
      if StdItem.AniCount = 111 then                        //隐身
      begin
        m_wStatusTimeArr[STATE_TRANSPARENT {8 0x70}] := 6 * 10 * 1000;
        m_boHideMode := True;
      end;
      if StdItem.AniCount = 191 then
        m_boDearMove := True;
      if StdItem.AniCount = 112 then
        m_boTeleport := True;
      if StdItem.AniCount = 113 then
        m_boParalysis := True;
      if StdItem.AniCount = 114 then
        m_boRevival := True;
      if StdItem.AniCount = 115 then
        m_boFlameRing := True;
      if StdItem.AniCount = 116 then
        m_boRecoveryRing := True;
      if StdItem.AniCount = 117 then
        m_boAngryRing := True;
      if StdItem.AniCount = 118 then
        m_boMagicShield := True;
      if StdItem.AniCount = 119 then
        m_boMuscleRing := True;
      if StdItem.AniCount = 135 then
      begin
        boMoXieSuite1 := True;
        Inc(m_nMoXieSuite, StdItem.Weight div 10);
      end;
      if StdItem.AniCount = 138 then
      begin
        Inc(m_nHongMoSuite, StdItem.Weight);
      end;
      if StdItem.AniCount = 139 then
        m_boUnParalysis := True;
      if StdItem.AniCount = 140 then
        m_boSupermanItem := True;
      if StdItem.AniCount = 141 then
      begin
        m_boExpItem := True;
        m_rExpItem := m_rExpItem + (m_UseItems[i].Dura / g_Config.nItemExpRate);
      end;
      if StdItem.AniCount = 142 then
      begin
        m_boPowerItem := True;
        m_rPowerItem := m_rPowerItem + (m_UseItems[i].Dura / g_Config.nItemPowerRate);
      end;
      if (StdItem.AniCount = 182) and (not m_boExpItem) then
      begin
        m_boExpItem := True;
        m_rExpItem := m_rExpItem + (m_UseItems[i].DuraMax / g_Config.nItemExpRate);
      end;
      if (StdItem.AniCount = 183) and (not m_boPowerItem) then
      begin
        m_boPowerItem := True;
        m_rPowerItem := m_rPowerItem + (m_UseItems[i].DuraMax / g_Config.nItemPowerRate);
      end;

      if StdItem.AniCount = 143 then
        m_boUnMagicShield := True;
      if StdItem.AniCount = 144 then
        m_boUnRevival := True;
      if StdItem.AniCount = 170 then
        m_boAngryRing := True;
      if StdItem.AniCount = 171 then
        m_boNoDropItem := True;
      if StdItem.AniCount = 172 then
        m_boNoDropUseItem := True;
      if StdItem.AniCount = 150 then
      begin                                                 //麻痹护身
        m_boParalysis := True;
        m_boMagicShield := True;
      end;
      if StdItem.Shape = 188 then
        m_boSupperParalysis := True;
      if StdItem.AniCount = 151 then
      begin                                                 //麻痹火球
        m_boParalysis := True;
        m_boFlameRing := True;
      end;
      if StdItem.AniCount = 152 then
      begin                                                 //麻痹防御
        m_boParalysis := True;
        m_boRecoveryRing := True;
      end;
      if StdItem.AniCount = 153 then
      begin                                                 //麻痹负载
        m_boParalysis := True;
        m_boMuscleRing := True;
      end;
      if StdItem.Shape = 154 then
      begin                                                 //护身火球
        m_boMagicShield := True;
        m_boFlameRing := True;
      end;
      if StdItem.AniCount = 155 then
      begin                                                 //护身防御
        m_boMagicShield := True;
        m_boRecoveryRing := True;
      end;
      if StdItem.AniCount = 156 then
      begin                                                 //护身负载
        m_boMagicShield := True;
        m_boMuscleRing := True;
      end;

      if StdItem.AniCount = 157 then
      begin                                                 //传送麻痹
        m_boTeleport := True;
        m_boParalysis := True;
      end;

      if StdItem.AniCount = 158 then
      begin                                                 //传送护身
        m_boTeleport := True;
        m_boMagicShield := True;
      end;

      if StdItem.AniCount = 159 then
      begin                                                 //传送探测
        m_boTeleport := True;
        m_boProbeNecklace := True;
      end;
      if StdItem.AniCount = 160 then
      begin                                                 //传送复活
        m_boTeleport := True;
        m_boRevival := True;
      end;
      if StdItem.AniCount = 161 then
      begin                                                 //麻痹复活
        m_boParalysis := True;
        m_boRevival := True;
      end;
      if StdItem.AniCount = 162 then
      begin                                                 //护身复活
        m_boMagicShield := True;
        m_boRevival := True;
      end;
      if StdItem.AniCount = 180 then
      begin                                                 //PK 死亡掉经验
        m_dwPKDieLostExp := StdItem.DuraMax * g_Config.dwPKDieLostExpRate;
        //        m_nPKDieLostLevel:=1;
      end;
      if StdItem.AniCount = 181 then
      begin                                                 //PK 死亡掉等级
        m_nPKDieLostLevel := StdItem.DuraMax div g_Config.nPKDieLostLevelRate;
      end;
      //新增结束
    end
    else
    begin
      Inc(m_WAbil.WearWeight, StdItem.Weight);
    end;
    Inc(m_WAbil.Weight, StdItem.Weight);
    if (i = U_WEAPON) then
    begin
      if (StdItem.Source - 1 - 10) < 0 then
        m_AddAbil.btWeaponStrong := StdItem.Source;         //强度+
      if (StdItem.Source <= -1) and (StdItem.Source >= -50) then // -1 至 -50
        m_AddAbil.bt1DF := m_AddAbil.bt1DF + -StdItem.Source; //神圣+
      if (StdItem.Source <= -51) and (StdItem.Source >= -100) then // -51 至 - 100
        m_AddAbil.bt1DF := m_AddAbil.bt1DF + (StdItem.Source + 50); //神圣-
      //   Continue;
    end;
    if (i = U_RIGHTHAND) then
    begin
      if StdItem.Shape in [1..50] then
        m_btDressEffType := StdItem.Shape;
      if StdItem.Shape in [51..100] then
        //   m_btHorseType:=StdItem.Shape - 50;
       //    Continue;
    end;

    if (I = U_DRESS) then
    begin
      if m_UseItems[I].btValue[5] > 0 then
        m_btDressEffType := m_UseItems[I].btValue[5];
      if StdItem.AniCount > 0 then
        m_btDressEffType := StdItem.AniCount;
      //  Continue;
    end;
    //新增开始
    if (StdItem.Shape = 146) or (StdItem.AniCount = 146) then
      m_boMagicParalysis := True;
    if StdItem.Shape = 139 then
      m_boUnParalysis := True;
    if StdItem.Shape = 140 then
      m_boSupermanItem := True;
    if StdItem.Shape = 141 then
    begin
      m_boExpItem := True;
      m_rExpItem := m_rExpItem + (m_UseItems[i].Dura / g_Config.nItemExpRate);
    end;
    if StdItem.Shape = 142 then
    begin
      m_boPowerItem := True;
      m_rPowerItem := m_rPowerItem + (m_UseItems[i].Dura / g_Config.nItemPowerRate);
    end;
    if StdItem.Shape = 182 then
    begin
      m_boExpItem := True;
      m_rExpItem := m_rExpItem + (m_UseItems[i].DuraMax / g_Config.nItemExpRate);
    end;
    if StdItem.Shape = 183 then
    begin
      m_boPowerItem := True;
      m_rPowerItem := m_rPowerItem + (m_UseItems[i].DuraMax / g_Config.nItemPowerRate);
    end;
    if StdItem.Shape = 143 then
      m_boUnMagicShield := True;
    if StdItem.Shape = 144 then
      m_boUnRevival := True;
    if StdItem.Shape = 170 then
      m_boAngryRing := True;
    if StdItem.Shape = 171 then
      m_boNoDropItem := True;
    if StdItem.Shape = 172 then
      m_boNoDropUseItem := True;

    if StdItem.Shape = 150 then
    begin                                                   //麻痹护身
      m_boParalysis := True;
      m_boMagicShield := True;
    end;
    if StdItem.Shape = 151 then
    begin                                                   //麻痹火球
      m_boParalysis := True;
      m_boFlameRing := True;
    end;
    if StdItem.Shape = 152 then
    begin                                                   //麻痹防御
      m_boParalysis := True;
      m_boRecoveryRing := True;
    end;
    if StdItem.Shape = 153 then
    begin                                                   //麻痹负载
      m_boParalysis := True;
      m_boMuscleRing := True;
    end;
    if StdItem.Shape = 154 then
    begin                                                   //护身火球
      m_boMagicShield := True;
      m_boFlameRing := True;
    end;
    if StdItem.Shape = 155 then
    begin                                                   //护身防御
      m_boMagicShield := True;
      m_boRecoveryRing := True;
    end;
    if StdItem.Shape = 156 then
    begin                                                   //护身负载
      m_boMagicShield := True;
      m_boMuscleRing := True;
    end;

    if StdItem.Shape = 157 then
    begin                                                   //传送麻痹
      m_boTeleport := True;
      m_boParalysis := True;
    end;

    if StdItem.Shape = 158 then
    begin                                                   //传送护身
      m_boTeleport := True;
      m_boMagicShield := True;
    end;

    if StdItem.Shape = 159 then
    begin                                                   //传送探测
      m_boTeleport := True;
      m_boProbeNecklace := True;
    end;
    if StdItem.Shape = 160 then
    begin                                                   //传送复活
      m_boTeleport := True;
      m_boRevival := True;
    end;
    if StdItem.Shape = 161 then
    begin                                                   //麻痹复活
      m_boParalysis := True;
      m_boRevival := True;
    end;
    if StdItem.Shape = 162 then
    begin                                                   //护身复活
      m_boMagicShield := True;
      m_boRevival := True;
    end;
    if StdItem.Shape = 180 then
    begin                                                   //PK 死亡掉经验
      m_dwPKDieLostExp := StdItem.DuraMax * g_Config.dwPKDieLostExpRate;
      //        m_nPKDieLostLevel:=1;
    end;
    if StdItem.Shape = 181 then
    begin                                                   //PK 死亡掉等级
      m_nPKDieLostLevel := StdItem.DuraMax div g_Config.nPKDieLostLevelRate;
    end;
    //新增结束
  //if (i = U_NECKLACE) then begin
    if StdItem.Shape = 120 then
      m_boFastTrain := True;
    if StdItem.Shape = 121 then
      m_boProbeNecklace := True;
    if StdItem.Shape = 123 then
      boRecallSuite1 := True;
    if StdItem.Shape = 145 then
      m_boGuildMove := True;
    if StdItem.Shape = 127 then
      boSpirit1 := True;
    if StdItem.Shape = 135 then
    begin
      boMoXieSuite1 := True;
      Inc(m_nMoXieSuite, StdItem.AniCount);
    end;
    if StdItem.Shape = 138 then
    begin
      boHongMoSuite1 := True;
      Inc(m_nHongMoSuite, StdItem.AniCount);
    end;
    //end;
    //if (i = U_RINGR) or (i = U_RINGL) then begin
    if StdItem.Shape = 111 then
    begin
      m_wStatusTimeArr[STATE_TRANSPARENT {8 0x70}] := 6 * 10 * 1000;
      m_boHideMode := True;
    end;
    if StdItem.Shape = 190 then
      m_boSupperMagicShield := True;
    if stditem.Shape = 193 then
      Inc(m_btMobSlaveLevel);

    if StdItem.Shape = 191 then
      m_boDearMove := True;
    if StdItem.Shape = 112 then
      m_boTeleport := True;
    if StdItem.Shape = 113 then
      m_boParalysis := True;
    if StdItem.Shape = 114 then
      m_boRevival := True;
    if StdItem.Shape = 189 then
      m_boSupperRevival := True;

    if StdItem.Shape = 115 then
      m_boFlameRing := True;
    if StdItem.Shape = 116 then
      m_boRecoveryRing := True;
    if StdItem.Shape = 117 then
      m_boAngryRing := True;
    if StdItem.Shape = 118 then
      m_boMagicShield := True;
    if StdItem.Shape = 119 then
      m_boMuscleRing := True;
    if StdItem.Shape = 122 then
      boRecallSuite2 := True;
    if StdItem.Shape = 128 then
      boSpirit2 := True;
    if StdItem.Shape = 133 then
    begin
      boMoXieSuite2 := True;
      Inc(m_nMoXieSuite, StdItem.AniCount);
    end;
    if StdItem.Shape = 136 then
    begin
      boHongMoSuite2 := True;
      Inc(m_nHongMoSuite, StdItem.AniCount);
    end;
    //end;
    //if (i = U_ARMRINGL) or (i = U_ARMRINGR) then begin
    if StdItem.Shape = 124 then
      boRecallSuite3 := True;
    if StdItem.Shape = 126 then
      boSpirit3 := True;
    if StdItem.Shape = 145 then
      m_boGuildMove := True;
    if StdItem.Shape = 134 then
    begin
      boMoXieSuite3 := True;
      Inc(m_nMoXieSuite, StdItem.AniCount);
    end;
    if StdItem.Shape = 137 then
    begin
      boHongMoSuite3 := True;
      Inc(m_nHongMoSuite, StdItem.AniCount);
    end;
    //end;
    //if (i = U_HELMET) then begin
    if StdItem.Shape = 125 then
      boRecallSuite4 := True;
    if StdItem.Shape = 129 then
      boSpirit4 := True;
    //end;
  end;

  if boRecallSuite1 and
    boRecallSuite2 and
    boRecallSuite3 and
    boRecallSuite4 then
    m_boRecallSuite := True;
  if boMoXieSuite1 and
    boMoXieSuite2 and
    boMoXieSuite3 then
    Inc(m_nMoXieSuite, 50);
  if boHongMoSuite1 and
    boHongMoSuite2 and
    boHongMoSuite3 then
    Inc(m_AddAbil.wHitPoint, 2);

  if boSpirit1 and
    boSpirit2 and
    boSpirit3 and
    boSpirit4 then
    m_bopirit := True;

  m_WAbil.Weight := RecalcBagWeight();

  if m_boTransparent and (m_wStatusTimeArr[STATE_TRANSPARENT {8 0x70}] > 0) then  //004C08D7
    m_boHideMode := True;

  if m_boHideMode then
  begin                                                     //004C08E8
    if not boOldHideMode then
    begin
      m_nCharStatus := GetCharStatus();
      StatusChanged();
    end;
  end
  else
  begin
    if boOldHideMode then
    begin                                                   //004C091B
      m_wStatusTimeArr[STATE_TRANSPARENT {8 0x70}] := 0;    //0x70
      m_nCharStatus := GetCharStatus();
      StatusChanged();
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then //01-20 增加此行，只有类型为人物的角色才重新计算攻击敏捷
    RecalcHitSpeed();
  nOldLight := m_nLight;
  if (m_UseItems[U_RIGHTHAND].wIndex > 0) and (m_UseItems[U_RIGHTHAND].Dura > 0) then
    m_nLight := 3
  else
    m_nLight := 0;
  if nOldLight <> m_nLight then
    SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    Inc(m_btSpeedPoint, m_AddAbil.wSpeedPoint);
    Inc(m_btHitPoint, m_AddAbil.wHitPoint);
    Inc(m_btAntiPoison, m_AddAbil.wAntiPoison);
    Inc(m_nPoisonRecover, m_AddAbil.wPoisonRecover);
    Inc(m_nHealthRecover, m_AddAbil.wHealthRecover);
    Inc(m_nSpellRecover, m_AddAbil.wSpellRecover);
    Inc(m_nAntiMagic, m_AddAbil.wAntiMagic);
    Inc(m_nLuck, m_AddAbil.btLuck);
    Dec(m_nLuck, m_AddAbil.btUnLuck);
    m_nHitSpeed := m_AddAbil.nHitSpeed;                     //004C0A53
  end;
  m_WAbil.MaxHP := _MIN(High(Word), m_Abil.MaxHP + m_AddAbil.wHP);
  m_WAbil.MaxMP := _MIN(High(Word), m_Abil.MaxMP + m_AddAbil.wMP);

  m_WAbil.AC := MakeLong(LoWord(m_AddAbil.wAC) + LoWord(m_Abil.AC), HiWord(m_AddAbil.wAC)
    + HiWord(m_Abil.AC));
  m_WAbil.MAC := MakeLong(LoWord(m_AddAbil.wMAC) + LoWord(m_Abil.MAC),
    HiWord(m_AddAbil.wMAC) + HiWord(m_Abil.MAC));
  m_WAbil.DC := MakeLong(LoWord(m_AddAbil.wDC) + LoWord(m_Abil.DC), HiWord(m_AddAbil.wDC)
    + HiWord(m_Abil.DC));
  m_WAbil.MC := MakeLong(LoWord(m_AddAbil.wMC) + LoWord(m_Abil.MC), HiWord(m_AddAbil.wMC)
    + HiWord(m_Abil.MC));
  m_WAbil.SC := MakeLong(LoWord(m_AddAbil.wSC) + LoWord(m_Abil.SC), HiWord(m_AddAbil.wSC)
    + HiWord(m_Abil.SC));
  if m_wStatusTimeArr[STATE_DEFENCEUP {10 0x72}] > 0 then   //004C0BCD
    m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) + 2 + (m_Abil.Level div
      7));
  if m_wStatusTimeArr[STATE_MAGDEFENCEUP {11 0x74}] > 0 then //004C0C17
    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) + 2 + (m_Abil.Level
      div 7));

  if m_wStatusArrValue[0] > 0 then                          //  if n218 > 0 then
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + 2 +
      m_wStatusArrValue[0] {n218});

  if m_wStatusArrValue[1] > 0 then                          //  if n219 > 0 then
    m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + 2 +
      m_wStatusArrValue[1] {n219});

  if m_wStatusArrValue[2] > 0 then                          //  if n21A > 0 then
    m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + 2 +
      m_wStatusArrValue[2] {n21A});

  if m_wStatusArrValue[3] > 0 then                          //  if n21B > 0 then
    Inc(m_nHitSpeed, m_wStatusArrValue[3] {n21B});

  if m_wStatusArrValue[4] > 0 then
  begin                                                     //  if n21C > 0 then
    //Inc(m_WAbil.MaxHP,m_wStatusArrValue[4]{n21C});
    m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_wStatusArrValue[4]);
  end;

  if m_wStatusArrValue[5] > 0 then
  begin                                                     //  if n21D > 0 then
    //Inc(m_WAbil.MaxMP,m_wStatusArrValue[5]{n21D});
    m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + m_wStatusArrValue[5]);
  end;

  if m_wStatusArrValue[6] > 0 then
  begin //  if n21D > 0 then      //开启金刚
    //Inc(m_WAbil.MaxMP,m_wStatusArrValue[5]{n21D});

    m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) +
      m_btMagPowerDefencelevel + 2);

    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) +
      m_btMagPowerDefencelevel);

    m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + (m_btMagPowerDefencelevel + 2) *
      10);                                                    // m_wStatusArrValue[6]

    // m_WAbil.MaxMP:=_MIN(High(Word),m_WAbil.MaxMP + m_wStatusArrValue[6]);
  end;

  if m_wStatusArrValue[7] > 0 then
  begin //  if n21D > 0 then      //开启风影盾
    Inc(m_btSpeedPoint, lobyte(m_wStatusArrValue[7]));
    Inc(m_nAntiMagic, hibyte(m_wStatusArrValue[7]));
  end;
  if m_wStatusTimeArr[STATE_14] > 0 then
  begin                                                     //开启护身
    m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) +
      m_btMagzqDefencelevel);

    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) +
      m_btMagzqDefencelevel);

  end;

  if m_boFlameRing then
    AddItemSkill(1)
  else
    DelItemSkill(1);

  if m_boRecoveryRing then
    AddItemSkill(2)
  else
    DelItemSkill(2);

  if m_boMuscleRing then
  begin                                                     //活力
    Inc(m_WAbil.MaxWeight, m_WAbil.MaxWeight);
    Inc(m_WAbil.MaxWearWeight, m_WAbil.MaxWearWeight);
    Inc(m_WAbil.MaxHandWeight, m_WAbil.MaxHandWeight);
  end;
  if m_nMoXieSuite > 0 then
  begin                                                     //魔血
    if m_WAbil.MaxMP <= m_nMoXieSuite then
      m_nMoXieSuite := m_WAbil.MaxMP - 1;
    Dec(m_WAbil.MaxMP, m_nMoXieSuite);
    //Inc(m_WAbil.MaxHP,m_nMoXieSuite);
    m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_nMoXieSuite);
  end;

  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    SendUpdateMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '');
  end;

  if (m_btRaceServer >= RC_ANIMAL) and (m_btRaceServer <> RC_YSBJECT) then
  begin                                                     //004C0EA0
    MonsterRecalcAbilitys();
  end;
  //套装属性
  if (m_nItemUnitIndex >= 0) and (m_nItemUnitIndex < g_Item_UnitList.Count) then
  begin
    pUnit_Item := pTunit_Item(g_Item_UnitList.Objects[m_nItemUnitIndex]);

    if pUnit_Item.btHP > 0 then
      m_WAbil.MaxHP := m_WAbil.MaxHP + pUnit_Item.btHP;
    if pUnit_Item.btMP > 0 then
      m_WAbil.MaxMP := m_WAbil.MaxMP + pUnit_Item.btMP;
    if pUnit_Item.btAC1 > 0 then
      m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + pUnit_Item.btAC1, HiWord(m_WAbil.AC));
    if pUnit_Item.btDC1 > 0 then
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + pUnit_Item.btDC1, HiWord(m_WAbil.DC));
    if pUnit_Item.btMC1 > 0 then
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + pUnit_Item.btMC1, HiWord(m_WAbil.MC));
    if pUnit_Item.btSC1 > 0 then
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + pUnit_Item.btSC1, HiWord(m_WAbil.SC));
    if pUnit_Item.btMAC1 > 0 then
      m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + pUnit_Item.btMAC1,
        HiWord(m_WAbil.MAC));

    if pUnit_Item.btAC2 > 0 then
      m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) + pUnit_Item.btAC2);
    if pUnit_Item.btDC2 > 0 then
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + pUnit_Item.btDC2);
    if pUnit_Item.btMC2 > 0 then
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + pUnit_Item.btMC2);
    if pUnit_Item.btSC2 > 0 then
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + pUnit_Item.btSC2);
    if pUnit_Item.btMAC2 > 0 then
      m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) +
        pUnit_Item.btMAC2);
    if pUnit_Item.btHit > 0 then
      Inc(m_AddAbil.wHitPoint, pUnit_Item.btHit);
    if pUnit_Item.btSpeed > 0 then
      Inc(m_AddAbil.wSpeedPoint, pUnit_Item.btSpeed);
    if pUnit_Item.btAntiMagic > 0 then
      Inc(m_AddAbil.wAntiMagic, pUnit_Item.btAntiMagic);
    if pUnit_Item.btAntiPoison > 0 then
      Inc(m_AddAbil.wAntiPoison, pUnit_Item.btAntiPoison);
    if pUnit_Item.boParalysis then
      m_boParalysis := True;
    if pUnit_Item.boMagicShield then
      m_boMagicShield := true;
    if pUnit_Item.boRevival then
      m_boRevival := True;
    if pUnit_Item.boTeleport then
      m_boTeleport := True;
    if pUnit_Item.boProbeNecklace then
      m_boProbeNecklace := True;
    if pUnit_Item.boMuscleRing then
      m_boMuscleRing := True;
    if pUnit_Item.boFastTrain then
      m_boFastTrain := True;
    if pUnit_Item.boTransparent then
      m_boTransparent := True;

  end;

  //限制最高属性
  m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC)), _MIN(MAXHUMPOWER,
    HiWord(m_WAbil.AC)));
  m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC)), _MIN(MAXHUMPOWER,
    HiWord(m_WAbil.MAC)));
  m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.DC)), _MIN(MAXHUMPOWER,
    HiWord(m_WAbil.DC)));
  m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MC)), _MIN(MAXHUMPOWER,
    HiWord(m_WAbil.MC)));
  m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.SC)), _MIN(MAXHUMPOWER,
    HiWord(m_WAbil.SC)));

{$IF (SoftVersion = VERPRO) or (SoftVersion = VERENT)}
  if g_Config.boHungerSystem and g_Config.boHungerDecPower then
  begin
    case m_nHungerStatus of                                 //
      0..999:
        begin
          m_WAbil.DC := MakeLong(ROUND(LoWord(m_WAbil.DC) * 0.2), ROUND(HiWord(m_WAbil.DC)
            * 0.2));
          m_WAbil.MC := MakeLong(ROUND(LoWord(m_WAbil.MC) * 0.2), ROUND(HiWord(m_WAbil.MC)
            * 0.2));
          m_WAbil.SC := MakeLong(ROUND(LoWord(m_WAbil.SC) * 0.2), ROUND(HiWord(m_WAbil.SC)
            * 0.2));
        end;
      1000..1999:
        begin
          m_WAbil.DC := MakeLong(ROUND(LoWord(m_WAbil.DC) * 0.4), ROUND(HiWord(m_WAbil.DC)
            * 0.4));
          m_WAbil.MC := MakeLong(ROUND(LoWord(m_WAbil.MC) * 0.4), ROUND(HiWord(m_WAbil.MC)
            * 0.4));
          m_WAbil.SC := MakeLong(ROUND(LoWord(m_WAbil.SC) * 0.4), ROUND(HiWord(m_WAbil.SC)
            * 0.4));
        end;
      2000..2999:
        begin
          m_WAbil.DC := MakeLong(ROUND(LoWord(m_WAbil.DC) * 0.6), ROUND(HiWord(m_WAbil.DC)
            * 0.6));
          m_WAbil.MC := MakeLong(ROUND(LoWord(m_WAbil.MC) * 0.6), ROUND(HiWord(m_WAbil.MC)
            * 0.6));
          m_WAbil.SC := MakeLong(ROUND(LoWord(m_WAbil.SC) * 0.6), ROUND(HiWord(m_WAbil.SC)
            * 0.6));
        end;
      3000..3999:
        begin
          m_WAbil.DC := MakeLong(ROUND(LoWord(m_WAbil.DC) * 0.9), ROUND(HiWord(m_WAbil.DC)
            * 0.9));
          m_WAbil.MC := MakeLong(ROUND(LoWord(m_WAbil.MC) * 0.9), ROUND(HiWord(m_WAbil.MC)
            * 0.9));
          m_WAbil.SC := MakeLong(ROUND(LoWord(m_WAbil.SC) * 0.9), ROUND(HiWord(m_WAbil.SC)
            * 0.9));
        end;
    end;
  end;
{$IFEND}
  if m_boDoubleAC then
    m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC)),
      _MIN(MAXHUMPOWER, HiWord(m_WAbil.AC) * 2));
  if m_boDoubleMAC then
    m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC)),
      _MIN(MAXHUMPOWER, HiWord(m_WAbil.MAC) * 2));
  for i := Low(m_wPowerRate) to High(m_wPowerRate) do
  begin
    case i of
      0:
        begin
          m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC)),
            _MIN(MAXHUMPOWER, HiWord(m_WAbil.AC) * (m_wPowerRate[i] + 1)));
        end;
      1:
        begin
          m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC)),
            _MIN(MAXHUMPOWER, HiWord(m_WAbil.MAC) * (m_wPowerRate[i] + 1)));
        end;
      2:
        begin
          m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.DC)),
            _MIN(MAXHUMPOWER, HiWord(m_WAbil.DC) * (m_wPowerRate[i] + 1)));
        end;
      3:
        begin
          m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MC)),
            _MIN(MAXHUMPOWER, HiWord(m_WAbil.MC) * (m_wPowerRate[i] + 1)));
        end;
      4:
        begin
          m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.SC)),
            _MIN(MAXHUMPOWER, HiWord(m_WAbil.SC) * (m_wPowerRate[i] + 1)));
        end;
      5:
        begin
          m_WAbil.MaxHP := m_WAbil.MaxHP * (m_wPowerRate[i] + 1);
        end;
      6:
        begin
          m_WAbil.MaxMP := m_WAbil.MaxMP * (m_wPowerRate[i] + 1);
        end;
    end;
  end;

end;

procedure TBaseObject.BreakOpenHealth();                    //004BDCD0
begin
  if m_boShowHP then
  begin
    m_boShowHP := False;
    m_nCharStatusEx := m_nCharStatusEx xor STATE_OPENHEATH;
    m_nCharStatus := GetCharStatus();
    SendRefMsg(RM_CLOSEHEALTH, 0, 0, 0, 0, '');
  end;
end;

procedure TBaseObject.MakeOpenHealth();                     //004BDC7C
begin
  m_boShowHP := True;
  m_nCharStatusEx := m_nCharStatusEx or STATE_OPENHEATH;
  m_nCharStatus := GetCharStatus();
  SendRefMsg(RM_OPENHEALTH, 0, m_WAbil.HP, m_WAbil.MaxHP, 0, '');
end;

procedure TBaseObject.IncHealthSpell(nHP, nMP: Integer);    //004BCAA4
begin
  if (nHP < 0) or (nMP < 0) then
    exit;
  if (m_WAbil.HP + nHP) >= m_WAbil.MaxHP then
    m_WAbil.HP := m_WAbil.MaxHP
  else
    Inc(m_WAbil.HP, nHP);
  if (m_WAbil.MP + nMP) >= m_WAbil.MaxMP then
    m_WAbil.MP := m_WAbil.MaxMP
  else
    Inc(m_WAbil.MP, nMP);
  HealthSpellChanged();
  // MainOutMessage('加血'+inttostr(nhp));
end;

procedure TBaseObject.ItemDamageRevivalRing();              //004C022C
var
  i                                                    : integer;
  pSItem                                               : PTStdItem;
  nDura, tDura                                         : Integer;
  PlayObject                                           : TPlayObject;
begin
  for i := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    if m_UseItems[i].wIndex > 0 then
    begin
      pSItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
      if pSItem <> nil then
      begin
        //        if (i = U_RINGR) or (i = U_RINGL) then begin
        if (pSItem.Shape in [114, 160, 161, 162]) or (((i = U_WEAPON) or (i =
          U_RIGHTHAND)) and (pSItem.AniCount in [114, 160, 161, 162])) then
        begin
          nDura := m_UseItems[i].Dura;
          tDura := Round(nDura / 1000 {1.03});
          Dec(nDura, 1000);
          if nDura <= 0 then
          begin
            nDura := 0;
            m_UseItems[i].Dura := nDura;
            if m_btRaceServer = RC_PLAYOBJECT then
            begin
              PlayObject := TPlayObject(Self);
              PlayObject.SendDelItems(@m_UseItems[i]);
            end;                                            //004C0310
            m_UseItems[i].wIndex := 0;
            RecalcAbilitys();
          end
          else
          begin                                             //004C0331
            m_UseItems[i].Dura := nDura;
          end;
          if tDura <> Round(nDura / 1000 {1.03}) then
          begin
            SendMsg(Self, RM_DURACHANGE, i, nDura, m_UseItems[i].DuraMax, 0, '');
          end;
          //break;
        end;                                                //004C0397
        //        end;//004C0397
      end; //004C0397 if pSItem <> nil then begin
    end; //if UseItems[i].wIndex > 0 then begin
  end; // for i:=Low(UseItems) to High(UseItems) do begin
end;

procedure TBaseObject.Run;                                  //004C7720
var
  i                                                    : integer;
  boChg                                                : Boolean;
  boNeedRecalc                                         : Boolean;
  nHP, nMP, n18                                        : Integer; //
  dwC, dwInChsTime                                     : LongWord;
  ProcessMsg                                           : TProcessMessage;
  BaseObject                                           : TBaseObject;
  nCheckCode                                           : Integer;
  dwRunTick                                            : LongWord;
  nInteger                                             : Integer;
resourcestring
  sExceptionMsg0                                         =
    '[Exception] TBaseObject::Run 0';
  sExceptionMsg1                                         =
    '[Exception] TBaseObject::Run 1';
  sExceptionMsg2                                         =
    '[Exception] TBaseObject::Run 2';
  sExceptionMsg3                                         =
    '[Exception] TBaseObject::Run 3';
  sExceptionMsg4                                         =
    '[Exception] TBaseObject::Run 4 Code:%d';
  sExceptionMsg5                                         =
    '[Exception] TBaseObject::Run 5';
  sExceptionMsg6                                         =
    '[Exception] TBaseObject::Run 6';
begin
  nCheckCode := 0;
  dwRunTick := GetTickCount();
  try

    while (GetTickCount - dwRunTick < 200) and GetMessage(@ProcessMsg) do
    begin
      nCheckCode := 1000;
      Operate(@ProcessMsg);
      nCheckCode := 1001;
    end;

  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg0);
      MainOutMessage(E.Message);
      raise;
    end;

  end;
  //SetProcessName('TBaseObject.Run 1');
  //004C7798
  try
    {
   if (m_boSuperMan) and(sYsnameMaster='')  then
   begin
     m_WAbil.HP := m_WAbil.MaxHP;
     m_WAbil.MP := m_WAbil.MaxMP;
   end;
   }
   //004C77DA
    dwC := (GetTickCount() - m_dwHPMPTick) div 20;
    m_dwHPMPTick := GetTickCount();
    Inc(m_nHealthTick, dwC);
    Inc(m_nSpellTick, dwC);
    //004C781D
    if not m_boDeath then
    begin
      if (m_WAbil.HP < m_WAbil.MaxHP) and (m_nHealthTick >= g_Config.nHealthFillTime)
        then
      begin
        n18 := (m_WAbil.MaxHP div 75) + 1;
        //nPlus = m_WAbility.MaxHP / 15 + 1;
        if (m_WAbil.HP + n18) < m_WAbil.MaxHP then
        begin
          Inc(m_WAbil.HP, n18);
        end
        else
        begin
          m_WAbil.HP := m_WAbil.MaxHP;
        end;
        HealthSpellChanged;
      end;
      //004C78AF
      if (m_WAbil.MP < m_WAbil.MaxMP) and (m_nSpellTick >= g_Config.nSpellFillTime) then
      begin
        n18 := (m_WAbil.MaxMP div 18) + 1;
        if (m_WAbil.MP + n18) < m_WAbil.MaxMP then
        begin
          Inc(m_WAbil.MP, n18);
        end
        else
        begin
          m_WAbil.MP := m_WAbil.MaxMP;
        end;
        HealthSpellChanged;
      end;

      //004C7934
    // if  m_btRaceServer = RC_PLAYOBJECT  then
      // SysMsg ('你的HP='+inttostr(m_WAbil.HP), c_Green,t_Hint);
      if m_WAbil.HP = 0 then
      begin
        if (((m_LastHiter = nil) or not m_LastHiter.m_boUnRevival {防复活}) or
          (m_boSupperRevival)) and m_boRevival and (GetTickCount - m_dwRevivalTick >
          g_Config.dwRevivalTime {60 * 1000}) then
        begin
          m_dwRevivalTick := GetTickCount();
          ItemDamageRevivalRing;
          m_WAbil.HP := m_WAbil.MaxHP;
          HealthSpellChanged;
          SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'}, c_Green, t_Hint);
        end;
        // if  m_btRaceServer = RC_PLAYOBJECT  then
         //  SysMsg ('你的HP=0', c_Green,t_Hint);
        if m_WAbil.HP = 0 then
          Die;

      end;
      if m_nHealthTick >= g_Config.nHealthFillTime then
        m_nHealthTick := 0;
      if m_nSpellTick >= g_Config.nSpellFillTime then
        m_nSpellTick := 0;
    end
    else
    begin
      if (GetTickCount() - m_dwDeathTick > g_Config.dwMakeGhostTime {3 * 60 * 1000}) then
        MakeGhost();
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg1);
      MainOutMessage(E.Message);
      raise;
    end;

  end;

  //004C7A34
  try
    if not m_boDeath and ((m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nIncHealing > 0))
      then
    begin
      //004C7A7A
      dwInChsTime := 600 - _MIN(400, m_Abil.Level * 10);

      if ((GetTickCount - m_dwIncHealthSpellTick) >= dwInChsTime) and not m_boDeath then
      begin
        dwC := _MIN(200, (GetTickCount - m_dwIncHealthSpellTick - dwInChsTime));
        m_dwIncHealthSpellTick := GetTickCount() + dwC;
        if (m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nPerHealing > 0) then
        begin
          //004C7B1C

          if (m_nPerHealth <= 0) then
            m_nPerHealth := 1;
          if (m_nPerSpell <= 0) then
            m_nPerSpell := 1;
          if (m_nPerHealing <= 0) then
            m_nPerHealing := 1;

          //004C7B67
          if m_nIncHealth < m_nPerHealth then
          begin
            nHP := m_nIncHealth;
            m_nIncHealth := 0;
          end
          else
          begin
            //004C7B94
            nHP := m_nPerHealth;
            Dec(m_nIncHealth, m_nPerHealth);
          end;

          //004C7BB2
          if m_nIncSpell < m_nPerSpell then
          begin
            nMP := m_nIncSpell;
            m_nIncSpell := 0;
          end
          else
          begin
            //004C7BDF
            nMP := m_nPerSpell;
            Dec(m_nIncSpell, m_nPerSpell);
          end;

          //004C7BFD
          if m_nIncHealing < m_nPerHealing then
          begin
            Inc(nHP, m_nIncHealing);
            m_nIncHealing := 0;
          end
          else
          begin
            //004C7C2A
            Inc(nHP, m_nPerHealing);
            Dec(m_nIncHealing, m_nPerHealing);
          end;
          m_nPerHealth := (m_Abil.Level div 10 + 5);
          m_nPerSpell := (m_Abil.Level div 10 + 5);
          m_nPerHealing := 5;
          IncHealthSpell(nHP, nMP);

          //004C7C9B
          if m_WAbil.HP = m_WAbil.MaxHP then
          begin
            m_nIncHealth := 0;
            m_nIncHealing := 0;
          end;
          if m_WAbil.MP = m_WAbil.MaxMP then
          begin
            m_nIncSpell := 0;
          end;
        end;
      end;
    end
    else
    begin                                                   //004C7CEA
      m_dwIncHealthSpellTick := GetTickCount();
    end;
    //004C7CF8
    if (m_nHealthTick < -g_Config.nHealthFillTime) and (m_WAbil.HP > 1) then
    begin                                                   //Jacky ????
      dec(m_WAbil.HP);
      Inc(m_nHealthTick, g_Config.nHealthFillTime);
      HealthSpellChanged();
    end;
    //检查HP/MP值是否大于最大值，大于则降低到正常大小
    boNeedRecalc := False;
    if m_WAbil.HP > m_WAbil.MaxHP then
    begin
      boNeedRecalc := True;
      m_WAbil.HP := m_WAbil.MaxHP - 1;
    end;
    if m_WAbil.MP > m_WAbil.MaxMP then
    begin
      boNeedRecalc := True;
      m_WAbil.MP := m_WAbil.MaxMP - 1;
    end;
    if boNeedRecalc then
      HealthSpellChanged();

  except
    MainOutMessage(sExceptionMsg2);
  end;

  //004C7D59
  //TBaseObject.Run 3 清理目标对象
  try
    if (m_TargetCret <> nil) then
    begin
      if ((GetTickCount() - m_dwTargetFocusTick) > 30000) or
        m_TargetCret.m_boDeath or
        m_TargetCret.m_boGhost or
        (m_TargetCret.m_PEnvir <> m_PEnvir) or // 08/06 增加，弓箭卫士在人物进入房间后再出来，还会攻击人物(人物的攻击目标没清除)
      (abs(m_TargetCret.m_nCurrX - m_nCurrX) > 15) or
        (abs(m_TargetCret.m_nCurrY - m_nCurrY) > 15) then
      begin
        //004C7DE4
        m_TargetCret := nil;
      end;
    end;
    //004C7DEF
    if (m_LastHiter <> nil) then
    begin
      if (((GetTickCount() - m_LastHiterTick) > 30000) and
        (m_wStatusTimeArr[POISON_DECHEALTH {0 0x60}] = 0)) or //1.5更新 中毒不触发
      m_LastHiter.m_boDeath or
        m_LastHiter.m_boGhost then
      begin
        //004C7E34
        m_LastHiter := nil;
      end;
    end;
    //004C7E3F
    //
    if (m_ExpHitter <> nil) then
    begin
      if (((GetTickCount() - m_ExpHitterTick) > 6000) and
        (m_wStatusTimeArr[POISON_DECHEALTH {0 0x60}] = 0)) or //1.5更新 中毒不触发
      m_ExpHitter.m_boDeath or
        m_ExpHitter.m_boGhost then
      begin
        //004C7E84
        m_ExpHitter := nil;
      end;
    end;
    //004C7E8F
    if (m_Master <> nil) then
    begin
      m_boNoItem := True;
      //宝宝变色
      if m_boAutoChangeColor and (GetTickCount - m_dwAutoChangeColorTick >
        g_Config.dwBBMonAutoChangeColorTime) then
      begin
        m_dwAutoChangeColorTick := GetTickCount();
        case m_nAutoChangeIdx of                            //
          0: nInteger := STATE_TRANSPARENT;
          1: nInteger := POISON_STONE;
          2: nInteger := POISON_DAOCAO1;
          3: nInteger := POISON_DAOCAO2;
          4: nInteger := POISON_DECHEALTH;
          5: nInteger := POISON_LOCKSPELL;
          6: nInteger := POISON_DAMAGEARMOR;
        else
          begin
            m_nAutoChangeIdx := 0;
            nInteger := STATE_TRANSPARENT;
          end;
        end;
        Inc(m_nAutoChangeIdx);
        m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
        StatusChanged();
      end;
      if m_boFixColor and (m_nFixStatus <> m_nCharStatus) then
      begin
        case m_nFixColorIdx of                              //
          0: nInteger := STATE_TRANSPARENT;
          1: nInteger := POISON_STONE;
          2: nInteger := POISON_DAOCAO1;
          3: nInteger := POISON_DAOCAO2;
          4: nInteger := POISON_DECHEALTH;
          5: nInteger := POISON_LOCKSPELL;
          6: nInteger := POISON_DAMAGEARMOR;
        else
          begin
            m_nFixColorIdx := 0;
            nInteger := STATE_TRANSPARENT;
          end;
        end;
        m_nCharStatus := (m_nCharStatusEx and $FFFFF) or (($80000000 shr nInteger) or 0);
        m_nFixStatus := m_nCharStatus;
        StatusChanged();
      end;

      // 宝宝在主人死亡后死亡处理
      if (m_Master.m_boDeath and ((GetTickCount - m_Master.m_dwDeathTick) > 1000)) then
      begin
        if g_Config.boMasterDieMutiny and (m_Master.m_LastHiter <> nil) and
          (Random(g_Config.nMasterDieMutinyRate) = 0) then
        begin
          m_Master := nil;
          m_btSlaveExpLevel := High(g_Config.SlaveColor);
          RecalcAbilitys();

          m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower,
            HiWord(m_WAbil.DC) * g_Config.nMasterDieMutinyPower);
          if g_Config.nMasterDieMutinySpeed <> 0 then
            m_nWalkSpeed := m_nWalkSpeed div g_Config.nMasterDieMutinySpeed;
          RefNameColor;
          RefShowName;
        end
        else
        begin
          //004C7EFF
          m_WAbil.HP := 0;
        end;
      end;
      if m_Master.m_boGhost and ((GetTickCount - m_Master.m_dwGhostTick) > 1000) then

      begin
        if not m_boPetOnSell then
          MakeGhost
        else
        begin
          m_PetSellCharName := m_Master.m_sCharName;
          m_Master := nil;                                  //豹子在摆摊中

        end;
      end;

    end;
    //004C7F0B
    //清除宝宝列表中已经死亡及叛变的宝宝信息
    for i := m_SlaveList.Count - 1 downto 0 do
    begin
      if TBaseObject(m_SlaveList.Items[i]).m_boDeath or
        TBaseObject(m_SlaveList.Items[i]).m_boGhost or
        (TBaseObject(m_SlaveList.Items[i]).m_Master <> Self) then

        m_SlaveList.Delete(i);
    end;
    //004C7F8A
    if m_boHolySeize and ((GetTickCount() - m_dwHolySeizeTick) > m_dwHolySeizeInterval)
      then
    begin
      BreakHolySeizeMode();
    end;

    if (m_bolinghunqiang and ((GetTickCount() - m_dwlinghunqiangTick) >
      m_dwlinghunqiangInterval)) or (m_boDeath and m_bolinghunqiang) then
    begin
      m_bolinghunqiang := false;
      SendRefMsg(RM_linghunqiang, 0, 1, 0, 0, '');
    end;
    if (m_bolinghunqiang and ((GetTickCount() - m_dwlinghunqiangTick) <
      m_dwlinghunqiangInterval)) then
    begin
      if m_TargetCret <> nil then
      begin
        m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX,
          m_TargetCret.m_nCurrY);
        if Integer(GetTickCount - m_dwHitTick) > m_nNextHitTime then
        begin
          m_dwHitTick := GetTickCount();
          AttackDir(nil, 0, m_btDirection);
          //  Attack(m_TargetCret,m_btDirection);
          dec(m_dwlinghunqiangInterval, 1000);
        end;
      end;
    end;

    //004C7FB7
    if m_boCrazyMode and ((GetTickCount() - m_dwCrazyModeTick) > m_dwCrazyModeInterval)
      then
    begin
      BreakCrazyMode();
    end;
    if m_boShowHP and ((GetTickCount() - m_dwShowHPTick) > m_dwShowHPInterval) then
    begin
      BreakOpenHealth();
    end;
  except
    MainOutMessage(sExceptionMsg3);
  end;

  //SetProcessName('TBaseObject.Run ');
  //004C802F
  try
    nCheckCode := 4;
    // 减少PK值开始
    if (GetTickCount() - m_dwDecPkPointTick) > g_Config.dwDecPkPointTime {120000} then
    begin
      m_dwDecPkPointTick := GetTickCount();
      if m_nPkPoint > 0 then
      begin
        DecPKPoint(g_Config.nDecPkPointCount {1});
      end;
    end;
    // 减少PK值结束

    //检查照明物品及PK状态 开始
    nCheckCode := 41;
    if (GetTickCount - m_DecLightItemDrugTick) > g_Config.dwDecLightItemDrugTime {500}
      then
    begin
      Inc(m_DecLightItemDrugTick, g_Config.dwDecLightItemDrugTime {500});
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        UseLamp();
        CheckPKStatus();
      end;
    end;
    //检查照明物品及PK状态 结束

    nCheckCode := 42;
    if (GetTickCount - m_dwCheckRoyaltyTick) > 10000 then
    begin
      m_dwCheckRoyaltyTick := GetTickCount();
      if m_Master <> nil then
      begin
        if (g_dwSpiritMutinyTick > GetTickCount) and (m_btSlaveExpLevel < 5) then
        begin
          m_dwMasterRoyaltyTick := 0;
        end;

        //宝宝叛变  开始
        nCheckCode := 423;
        if (m_btRaceServer <> RC_YSBJECT) and (GetTickCount > m_dwMasterRoyaltyTick) then
        begin
          for I := 0 to m_Master.m_SlaveList.Count - 1 do
          begin
            nCheckCode := 424;
            if m_Master.m_SlaveList.Items[i] = Self then
            begin
              nCheckCode := 425;
              m_Master.m_SlaveList.Delete(i);
              break;
            end;
          end;
          m_Master := nil;
          m_WAbil.HP := m_WAbil.HP div 10;
          nCheckCode := 426;
          RefShowName();
        end;
        //宝宝叛变 结束
        nCheckCode := 427;
        if m_dwMasterTick <> 0 then
        begin
          if (GetTickCount - m_dwMasterTick) > 12 * 60 * 60 * 1000 then
          begin
            m_WAbil.HP := 0;
          end;
        end;
      end;                                                  //004C81DB
    end;
    nCheckCode := 43;
    if (GetTickCount - m_dwVerifyTick) > 30 * 1000 then
    begin
      m_dwVerifyTick := GetTickCount();
      // 清组队已死亡成员
      if (m_GroupOwner <> nil) then
      begin
        if m_GroupOwner.m_boDeath or m_GroupOwner.m_boGhost then
        begin
          m_GroupOwner := nil;
        end;
      end;
      nCheckCode := 44;
      if m_GroupOwner = Self then
      begin
        for I := m_GroupMembers.Count - 1 downto 0 do
        begin
          BaseObject := TBaseObject(m_GroupMembers.Objects[i]);
          if BaseObject.m_boDeath or (BaseObject.m_boGhost) then
            m_GroupMembers.Delete(i);
        end;
      end;
      // 清组队已死亡成员 结束
      nCheckCode := 45;
      // 检查交易双方 状态
      if (m_DealCreat <> nil) and (m_DealCreat.m_boGhost) then
        m_DealCreat := nil;
      nCheckCode := 46;
      if not m_boDenyRefStatus then
        m_PEnvir.VerifyMapTime(m_nCurrX, m_nCurrY, Self);   //刷新在地图上位置的时间
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg4, [nCheckCode]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;

  //SetProcessName('TBaseObject.Run 5');
  try
    boChg := False;
    boNeedRecalc := False;

    for i := Low(m_wPowerRateTick) to High(m_wPowerRateTick) do
    begin                                                   //004C832E
      begin
        if (m_wPowerRate[i] > 0) and (GetTickCount() > m_wPowerRateTick[i]) then
        begin
          m_wPowerRate[i] := 0;

          case i of
            0:
              begin
                SysMsg('防御力回复正常', c_Green, t_Hint);
              end;
            1:
              begin

                SysMsg('魔御力回复正常', c_Green, t_Hint);
              end;
            2:
              begin

                SysMsg('攻击力回复正常', c_Green, t_Hint);
              end;
            3:
              begin
                SysMsg('魔法力回复正常', c_Green, t_Hint);
              end;
            4:
              begin
                SysMsg('道术回复正常', c_Green, t_Hint);
              end;
            5:
              begin
                SysMsg('体力值回复正常', c_Green, t_Hint);
              end;
            6:
              begin
                SysMsg('魔法值回复正常', c_Green, t_Hint);
              end;

          end;
          RecalcAbilitys();
          SendMsg(self, RM_ABILITY, 0, 0, 0, 0, '');
          RefShowName;
        end;
      end;
    end;

    for i := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do
    begin                                                   //004C832E
      if (m_wStatusTimeArr[i] > 0) and (m_wStatusTimeArr[i] < 60000) then
      begin
        if ((GetTickCount() - m_dwStatusArrTick[i]) > 1000) then
        begin
          if not (i in [14]) then
            Dec(m_wStatusTimeArr[i]);
          Inc(m_dwStatusArrTick[i], 1000);
          if (m_wStatusTimeArr[i] > 0) and (m_wStatusTimeArr[i] < 2) then
          begin
            bochg := true;
            if (I = STATE_DEFENCEUP) then
            begin
              boNeedRecalc := True;
              SysMsg('防御力恢复正常', c_Green, t_Hint);
            end;
            if (I = STATE_MAGDEFENCEUP) then
            begin
              boNeedRecalc := True;
              SysMsg('抗魔法力恢复正常', c_Green, t_Hint);
            end;
          end;
          if (m_wStatusTimeArr[i] = 0) then
          begin
            boChg := True;
            case i of
              STATE_TRANSPARENT:
                begin
                  m_boHideMode := False;
                end;

              STATE_BUBBLEDEFENCEUP:
                begin
                  m_boAbilMagBubbleDefence := False;
                end;
            end;
          end;
        end;
      end;
    end;

    /////////////
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_YSBJECT) then
    begin                                                   //如果是人或者原神需要下面运算
      if (m_wStatusTimeArr[STATE_14] = 1) then
      begin
        m_wStatusTimeArr[STATE_14] := 0;
        boNeedRecalc := True;
        m_boAbilMagzqDefence := false;
        boChg := true;
        //  m_wStatusTimeArr[STATE_14] :=0;
        SysMsg('护身真气被击破', c_Green, t_Hint);

      end;

      if (m_wStatusArrValue[6] = 1) then
      begin
        m_wStatusArrValue[6] := 0;
        SysMsg('金刚护体被击破', c_Green, t_Hint);
        m_boAbilMagPowerDefence := false;                   //金刚护体
        SendRefMsg(RM_MAGADDABILTY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');       //属性重新计算
        boNeedRecalc := True;
      end;

      for i := Low(m_wStatusArrValue) to High(m_wStatusArrValue) do
      begin
        if m_wStatusArrValue {218} [i] > 0 then
        begin

          if (GetTickCount() > m_dwStatusArrTimeOutTick {220} [i]) then
          begin
            m_wStatusArrValue[i] := 0;
            boNeedRecalc := True;
            case i of
              0:
                begin
                  SysMsg('攻击力回复正常', c_Green, t_Hint);
                end;
              1:
                begin
                  SysMsg('魔法力回复正常', c_Green, t_Hint);
                end;
              2:
                begin
                  SysMsg('道术回复正常', c_Green, t_Hint);
                end;
              3:
                begin
                  SysMsg('攻击速度回复正常', c_Green, t_Hint);
                end;
              4:
                begin
                  SysMsg('体力回复正常', c_Green, t_Hint);
                end;
              5:
                begin
                  SysMsg('魔法值回复正常', c_Green, t_Hint);
                end;

              7:
                begin
                  SysMsg('魔法闪避,物理闪避回复正常', c_Green, t_Hint);
                  m_boAbilMagfyDefence := false;
                  SendRefMsg(RM_MAGADDABILTY, 0, 0, 0, 0, '');
                  SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
                end;
              8:
                begin

                  SendRefMsg(RM_MAGADDABILTY, 0, 0, 0, 0, '');
                  SysMsg('上古神魔的力量慢慢弱去，你的身体恢复正常。', c_Green, t_Hint);

                end;
            end;
          end;
        end;
      end;
      //////////
    end; //   if ( m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_YSBJECT)  begin  //如果是人或者原神需要下面运算

    //004C84F5
    if boChg then
    begin
      m_nCharStatus := GetCharStatus();
      StatusChanged();
    end;
    //004C8511
    if boNeedRecalc then
    begin
      RecalcAbilitys();
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage(sExceptionMsg5);
  end;

  //SetProcessName('TBaseObject.Run 6');
  //004C855A
  try
    if (GetTickCount - m_dwPoisoningTick) > g_Config.dwPosionDecHealthTime {2500} then
    begin
      m_dwPoisoningTick := GetTickCount();
      if m_wStatusTimeArr[POISON_DECHEALTH {0 0x60}] > 0 then
      begin                                                 //中绿毒少血
        if m_boAnimal then
          Dec(m_nMeatQuality, 1000);
        DamageHealth(m_btGreenPoisoningPoint + 1, 1);       //少红血
        m_nHealthTick := 0;
        m_nSpellTick := 0;
        HealthSpellChanged();
      end;
      if m_wStatusTimeArr[POISON_DAOCAO1] > 0 then
      begin                                                 //中诅咒少魔法血
        if m_boAnimal then
          Dec(m_nMeatQuality, 1000);
        DamageHealth(m_btGreenPoisoningPoint + 1, 2);       //少蓝血
        m_nHealthTick := 0;
        m_nSpellTick := 0;
        HealthSpellChanged();
      end;

    end;
  except
    MainOutMessage(sExceptionMsg6);
  end;
  {
  if boOpenHealth then begin
    if (GetTickCount() - dwOpenHealthStart) > dwOpenHealthTime then begin
      BreakOpenHealth();
    end;
  end;
  }
  g_nBaseObjTimeMin := GetTickCount - dwRunTick;
  if g_nBaseObjTimeMax < g_nBaseObjTimeMin then
    g_nBaseObjTimeMax := g_nBaseObjTimeMin;

end;

function TPlayObject.DayBright: Byte;
begin
  Result := 0;
  if m_PEnvir.m_boDarkness then
    Result := 1
  else
    if m_PEnvir.m_boDayLight then
      Result := 0;
end;

function TBaseObject.GetFrontPosition(var nX: Integer; var nY: Integer): Boolean;  //004B2790
var
  Envir                                                : TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case m_btDirection of                                     //
    DR_UP:
      begin
        if nY > 0 then
          Dec(nY);
      end;
    DR_UPRIGHT:
      begin
        if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then
        begin
          Inc(nX);
          Dec(nY);
        end;
      end;
    DR_RIGHT:
      begin
        if nX < (Envir.m_nWidth - 1) then
          Inc(nX);
      end;
    DR_DOWNRIGHT:
      begin
        if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then
        begin
          Inc(nX);
          Inc(nY);
        end;
      end;
    DR_DOWN:
      begin
        if nY < (Envir.m_nHeight - 1) then
          Inc(nY);
      end;
    DR_DOWNLEFT:
      begin
        if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then
        begin
          Dec(nX);
          Inc(nY);
        end;
      end;
    DR_LEFT:
      begin
        if nX > 0 then
          Dec(nX);
      end;
    DR_UPLEFT:
      begin
        if (nX > 0) and (nY > 0) then
        begin
          Dec(nX);
          Dec(nY);
        end;
      end;
  end;
  Result := True;
end;

procedure TBaseObject.SpaceMove(sMap: string; nX, nY: Integer; nInt: Integer); //004BCD1C
  function GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer): Boolean;
  var
    n14, n18, n1C                                      : Integer;
  begin
    Result := False;
    if Envir.m_nWidth < 80 then
      n18 := 3
    else
      n18 := 10;
    if Envir.m_nHeight < 150 then
    begin
      if Envir.m_nHeight < 50 then
        n1C := 2
      else
        n1C := 15;
    end
    else
      n1C := 50;
    n14 := 0;
    while (True) do
    begin
      if Envir.CanWalk(nX, nY, True) then
      begin
        Result := True;
        break;
      end;
      if nX < (Envir.m_nWidth - n1C - 1) then
        Inc(nX, n18)
      else
      begin
        nX := Random(Envir.m_nWidth);
        if nY < (Envir.m_nHeight - n1C - 1) then
          Inc(nY, n18)
        else
          nY := Random(Envir.m_nHeight);
      end;
      Inc(n14);
      if n14 >= 201 then
        break;
    end;
  end;
var
  I                                                    : Integer;
  Envir, OldEnvir                                      : TEnvirnoment;
  nOldX, nOldY                                         : Integer;
  bo21                                                 : Boolean;
  PlayObject                                           : TPlayObject;
begin

  if (m_btRaceServer = RC_PLAYOBJECT) and (Tplayobject(self).m_boArrow) and (nInt < 2)
    then
  begin                                                     //人物在夺宝中如果要飞
    SysMsg('现在不能使用', c_Green, t_Hint);
    exit;
  end;
  Envir := g_MapManager.FindMap(sMap);
  if Envir <> nil then
  begin
    if nServerIndex = Envir.nServerIndex then
    begin
      OldEnvir := m_PEnvir;
      nOldX := m_nCurrX;
      nOldY := m_nCurrY;
      bo21 := False;

      //  m_PEnvir.DeleteFromMap(m_nCurrX,m_nCurrY,OS_MOVINGOBJECT,Self);
      if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) <> 1 then
        exit;
      m_VisibleHumanList.Clear;
      for I := 0 to m_VisibleItems.Count - 1 do
      begin
        Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
      end;
      m_VisibleItems.Clear;
      for I := 0 to m_VisibleActors.Count - 1 do
      begin
        Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
      end;
      m_VisibleActors.Clear;
      m_VisibleEvents.Clear;                                //01/21 移动时清除列表
      m_PEnvir := Envir;
      m_sMapName := Envir.sMapName;
      m_nCurrX := nX;
      m_nCurrY := nY;
      if GetRandXY(m_PEnvir, m_nCurrX, m_nCurrY) then
      begin
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
        SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, m_sMapName);
        if nInt = 1 then
        begin
          SendRefMsg(RM_SPACEMOVE_SHOW2, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
        end
        else
          SendRefMsg(RM_SPACEMOVE_SHOW, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
        RefShowName();                                      //新加 06 5.12
        m_dwMapMoveTick := GetTickCount();
        m_bo316 := True;
        bo21 := True;
        //心魔宝宝不能带出地图
        // 2009-2-28 10:15:54
        if (m_btRaceServer = RC_PLAYOBJECT) and (not m_PEnvir.m_boCANRECALLEVIL) then
          TPlayObject(Self).EvilRoyalty;
      end;                                                  //004BCFA9
      if not bo21 then
      begin
        m_PEnvir := OldEnvir;
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
      end;
    end
    else
    begin                                                   //004BCFF6
      if GetRandXY(Envir, nX, nY) then
      begin
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          DisappearA();
          m_bo316 := True;
          PlayObject := TPlayObject(Self);
          PlayObject.m_sSwitchMapName := Envir.sMapName;
          PlayObject.m_nSwitchMapX := nX;
          PlayObject.m_nSwitchMapY := nY;
          PlayObject.m_boSwitchData := True;
          PlayObject.m_nServerIndex := Envir.nServerIndex;
          PlayObject.m_boEmergencyClose := True;
          PlayObject.m_boReconnection := True;
        end
        else
          KickException();
      end;
    end;
  end;
end;

procedure TPlayObject.RefUserState();                       //004D6870
var
  n8                                                   : Integer;
begin
  n8 := 0;
  if m_PEnvir.m_boFightZone then
    n8 := n8 or 1;
  if m_PEnvir.m_boSAFE then
    n8 := n8 or 2;
  if m_boInFreePKArea then
    n8 := n8 or 4;
  SendDefMessage(SM_AREASTATE, n8, 0, 0, 0, '');
end;

procedure TBaseObject.RefShowName();                        //004BF0C4
begin
  SendRefMsg(RM_USERNAME, 0, 0, 0, 0, GetShowName);

end;

procedure TPlayObject.RefMyStatus();
begin
  RecalcAbilitys();
  SendMsg(Self, RM_MYSTATUS, 0, 0, 0, 0, '');
end;

function TBaseObject.Operate(ProcessMsg: pTProcessMessage): Boolean; //004C716C
var
  nDamage                                              : Integer;
  nTargetX                                             : Integer;
  nTargetY                                             : Integer;
  nPower                                               : Integer;
  nRage                                                : Integer;
  TargetBaseObject                                     : TBaseObject;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::Operate ';
begin
  Result := False;
  try
    case ProcessMsg.wIdent of
      RM_MAGSTRUCK,
        RM_MAGSTRUCK_MINE:
        begin                                               //10025

          //  if (ProcessMsg.BaseObject = Self) and (TBaseObject(ProcessMsg.nParam3{AttackBaseObject}) <> nil) then begin
          //  SetLastHiter(TBaseObject(ProcessMsg.nParam3{AttackBaseObject}));
          //  end;
          if (ProcessMsg.wIdent = RM_MAGSTRUCK) and
            (m_btRaceServer >= RC_ANIMAL) and
            (not bo2BF) and (m_Abil.Level < 50) then
          begin
            m_dwWalkTick := m_dwWalkTick + 800 + LongWord(Random(1000));
          end;
          nDamage := GetMagStruckDamage(TBaseObject(ProcessMsg.BaseObject)
            {AttackBaseObject}, ProcessMsg.nParam1);          //  nil   xjs
          //  MainOutMessage(IntToStr(nDamage));
          if nDamage > 0 then
          begin
            StruckDamage(nDamage);
            HealthSpellChanged();
            SendRefMsg(RM_STRUCK_MAG, nDamage, m_WAbil.HP, m_WAbil.MaxHP,
              Integer(ProcessMsg.BaseObject), '');

            if m_btRaceServer <> RC_PLAYOBJECT then
            begin
              if m_boAnimal then
                Dec(m_nMeatQuality, nDamage * 1000);
              SendMsg(Self, RM_STRUCK, nDamage, m_WAbil.HP, m_WAbil.MaxHP,
                Integer(ProcessMsg.BaseObject) {AttackBaseObject}, '');
            end;
          end;
          if m_boFastParalysis then
          begin
            m_wStatusTimeArr[POISON_STONE] := 1;
            m_boFastParalysis := False;
          end;
        end;
      RM_MAGHEALING:
        begin                                               //10026
          if (m_nIncHealing + ProcessMsg.nParam1) < 300 then
          begin
            if m_btRaceServer = RC_PLAYOBJECT then
            begin
              Inc(m_nIncHealing, ProcessMsg.nParam1);
              m_nPerHealing := 5;
            end
            else
            begin
              Inc(m_nIncHealing, ProcessMsg.nParam1);
              m_nPerHealing := 5;
            end;
          end
          else
            m_nIncHealing := 300;
        end;
      RM_10101:
        begin                                               //10101
          SendRefMsg(Integer(ProcessMsg.BaseObject),
            ProcessMsg.wParam {nPower},
            ProcessMsg.nParam1 {HP},
            ProcessMsg.nParam2 {MaxHP},
            ProcessMsg.nParam3 {AttackSrc},
            ProcessMsg.sMsg);
          if (Integer(ProcessMsg.BaseObject) = RM_STRUCK) and (m_btRaceServer <>
            RC_PLAYOBJECT) then
          begin
            SendMsg(Self, Integer(ProcessMsg.BaseObject),
              ProcessMsg.wParam,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3 {AttackBaseObject},
              ProcessMsg.sMsg);
          end;
          if m_boFastParalysis then
          begin
            m_wStatusTimeArr[POISON_STONE] := 1;
            m_boFastParalysis := False;
          end;
        end;
      RM_DELAYMAGIC:
        begin                                               //10154 004C726E
          nPower := ProcessMsg.wParam;
          nTargetX := LoWord(ProcessMsg.nParam1);
          nTargetY := HiWord(ProcessMsg.nParam1);
          nRage := ProcessMsg.nParam2;
          TargetBaseObject := TBaseObject(ProcessMsg.nParam3);

          //  LoWord(m_WAbil.MAC) + Random(SmallInt(HiWord(m_WAbil.MAC) - LoWord(m_WAbil.MAC)) + 1)
          if (TargetBaseObject <> nil) and (nPower > LoWord(m_WAbil.MAC) +
            Random(SmallInt(HiWord(m_WAbil.MAC) - LoWord(m_WAbil.MAC)) + 1)) then
          begin
            // and  (TargetBaseObject.GetMagStruckDamage(Self,nPower)>0)    then begin

            SetTargetCreat {0FFF2}(TargetBaseObject);
            //  nPower:= TargetBaseObject.GetMagStruckDamage(Self,nPower);
            if TargetBaseObject.m_btRaceServer >= RC_ANIMAL then
              nPower := ROUND(nPower / 1.2);
            if (abs(nTargetX - TargetBaseObject.m_nCurrX) <= nRage) and (abs(nTargetY -
              TargetBaseObject.m_nCurrY) <= nRage) then
              TargetBaseObject.SendMsg(Self, RM_MAGSTRUCK, 0, nPower, 0, 0, '');
          end;
        end;
      RM_10155:
        begin                                               //10155
          MapRandomMove(ProcessMsg.sMsg, ProcessMsg.wParam);
        end;
      RM_DELAYPUSHED:
        begin
          nPower := ProcessMsg.wParam;
          nTargetX := LoWord(ProcessMsg.nParam1);
          nTargetY := HiWord(ProcessMsg.nParam1);
          nRage := ProcessMsg.nParam2;
          TargetBaseObject := TBaseObject(ProcessMsg.nParam3);
          if (TargetBaseObject <> nil) then
          begin
            TargetBaseObject.CharPushed(nPower, nRage);
          end;
        end;
      RM_POISON:
        begin                                               //10300 004C74AB
          TargetBaseObject := TBaseObject(ProcessMsg.nParam2);
          if TargetBaseObject <> nil then
          begin
            if IsProperTarget {FFF4}(TargetBaseObject) then
            begin
              SetTargetCreat {0FFF2}(TargetBaseObject);
              if (m_btRaceServer = RC_PLAYOBJECT) and (TargetBaseObject.m_btRaceServer =
                RC_PLAYOBJECT) then
              begin
                SetPKFlag(TargetBaseObject);
              end;
              SetLastHiter(TargetBaseObject);

            end;
            MakePosion(ProcessMsg.wParam {中毒类型}, ProcessMsg.nParam1 {nPower},
              ProcessMsg.nParam3 {});
          end
          else
            MakePosion(ProcessMsg.wParam {中毒类型}, ProcessMsg.nParam1 {nPower},
              ProcessMsg.nParam3);

        end;
      RM_TRANSPARENT:
        begin                                               //10308
          MagicManager.MagMakePrivateTransparent(Self, ProcessMsg.nParam1);
        end;
      RM_DOOPENHEALTH:
        begin                                               //10412
          MakeOpenHealth();
        end;
{$IF CHECKNEWMSG = 1}
    else
      begin
        MainOutMessage(format('人物: %s 消息: Ident %d Param %d P1 %d P2 %d P3 %d Msg %s',
          [m_sCharName,
          ProcessMsg.wIdent,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.sMsg]));
      end;
{$IFEND}
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg);
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

function TBaseObject.CheckMapEnvir(X: string; Y: string; MapName: string; EnvirMode:
  string): string;
var
  I                                                    : Integer;
begin
  for i := 0 to length(MapEnvirList) - 1 do
  begin
    //MainOutMessage(MapEnvirList[i,0]+':'+MapEnvirList[i,1]+':'+MapEnvirList[i,2]+':'+MapEnvirList[i,3]+':'+MapEnvirList[i,4]+':');
    if MapEnvirList[i, 2] = EnvirMode then
    begin
      if MapEnvirList[i, 0] = X then
      begin
        if MapEnvirList[i, 1] = Y then
        begin
          if MapEnvirList[i, 3] = MapName then
          begin
            Result := MapEnvirList[i, 4];
          end;
        end;
      end;
    end;
  end;

end;

function TPlayObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
var
  CharDesc                                             : TmyCharDesc;
  YSOnBaoZi                                            : TYsOnBaozi;
  ysfenghao                                            : TYSfenghao;
  szCharDesc                                           : TmyszCharDesc;
  SpyFly                                               : TSpyFly;
  YSskillEffect                                        : TYSskillEffect;
  onhorse                                              : Tonhorse;
  nObjCount, ndreshape, m_btwing                       : integer;
  CharDress                                            : TCharDress;
  s1C, horsename, stemp                                : string;
  MessageBodyWL                                        : TMessageBodyWL;
  MessageBodyW                                         : TMessageBodyW;
  ShortMessage                                         : TShortMessage;
  OAbility                                             : TOAbility;
  myOAbility                                           : TMYOAbility;
  dwDelayTime                                          : LongWord;
  nMsgCount, i                                         : Integer;
  nPower                                               : Integer;
  //  Charxue:dword ;
  StdItem                                              : pTStdItem;
  horsepos                                             : integer;
  monhorse                                             : Tbaseobject;
  SUBABILITYDATA                                       : TSUBABILITYDATA;
  magaddtype                                           : integer;
  SELLITEMFLAG                                         : TSELLITEMFLAG;
  sCharName, smapname                                  : string;
  sm47dat                                              : TSM47dat;
  sm5960dat                                            : TSM5960dat;
  MAGICFIRE                                            : tMAGICFIRE;
  hum                                                  : Tplayobject;
  YSFLAG                                               : integer;
  YSPoint                                              : integer;
  buffer                                               : array[0..1000] of char;
  GoLable                                              : string;
  nCOunt                                               : Integer;
  w20                                                  : Word;

begin
  Result := True;
  //    MainOutMessage(IntToStr(ProcessMsg.wIdent)); //调试
  case ProcessMsg.wIdent of
    CM_QUERYUSERNAME:
      begin                                                 //80
        ClientQueryUserName(TPlayObject(ProcessMsg.nParam1), ProcessMsg.nParam2,
          ProcessMsg.nParam3);                                //004D7931
      end;
    CM_QUERYBAGITEMS:
      begin                                                 //0x81
        //    ClientQueryBagItems();//004D793E
      end;
    CM_QUERYUSERSTATE:
      begin                                                 //82
        ClientQueryUserState(TPlayObject(ProcessMsg.nParam1), ProcessMsg.nParam2,
          ProcessMsg.nParam3);
      end;
    CM_QUERYUSERSET:
      begin
        ClientQueryUserSet(ProcessMsg);
      end;
    CM_DROPITEM:
      begin                                                 //1000
        if ClientDropItem(ProcessMsg.sMsg, ProcessMsg.nParam1) then
          SendDefMessage(SM_DROPITEM_SUCCESS, ProcessMsg.nParam1, 0, 0, 0,
            ProcessMsg.sMsg)
        else
          SendDefMessage(SM_DROPITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0, ProcessMsg.sMsg);
      end;
    CM_PICKUP:
      begin                                                 //1001  004D78F9
        if (m_nCurrX = ProcessMsg.nParam2) and (m_nCurrY = ProcessMsg.nParam3) then
          ClientPickUpItem();
      end;
    CM_OPENDOOR:
      begin                                                 //1002
        ClientOpenDoor(ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    CM_TAKEONITEM:
      begin                                                 //1003
        // MainOutMessage('CM_TAKEONITEM'+ProcessMsg.sMsg);
        ClientTakeOnItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_TAKEOFFITEM:
      begin                                                 //1004
        ClientTakeOffItems(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    654:                                                    //留言
      begin
        ClientBBs(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    192:                                                    //旗座
      begin
        ClientFlags(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
          ProcessMsg.sMsg);
      end;
    3082:                                                   //灵珠模式
      begin
        if (sYsname <> '') and g_Config.boUseLingzu then
        begin                                               //如果是元神消失
          // hum:=nil;
          // hum:= UserEngine.GetPlayObjectEx(sYsnameMaster);
          hum := self.Ysplayer;
          if Hum <> nil then
          begin
            if (hum <> nil) and (m_PEnvir <> nil) and       // 要跟随主人
            ((m_PEnvir <> hum.m_PEnvir) or
              (abs(m_nCurrX - hum.m_nCurrX) > 5) or
              (abs(m_nCurrY - hum.m_nCurrY) > 5)) then
            begin

              SysMsg('你的元神分身距离你太远，无法幻化为灵珠！', c_Red, t_Hint);
              Exit;
            end;

            if (GetTickCount - hum.m_nLingzhuTime) < 5000 then
            begin

              SysMsg('魂魄力量暂时无法聚拢，你的元神分身不能幻化为灵珠！', c_Red,
                t_Hint);

            end
            else
            begin
              Inc(hum.m_btLingzhuMode);
              hum.m_nLingzhuTime := GetTickCount;
              hum.m_btLingzhuMode := hum.m_btLingzhuMode mod 2;

              hum.SendRefMsg(RM_3082, hum.m_btLingzhuMode, 0, 0, 0, '');
              if hum.m_btLingzhuMode = 1 then
              begin
                SysMsg('魂魄力量聚拢，你的元神分身幻化成了元神灵珠!', c_Red, t_Hint);
                hum.m_boSuperMan := True;
              end
              else
              begin
                SysMsg('元神分身听到你的召唤，进入跟随模式!', c_Red, t_Hint);
                hum.m_boSuperMan := False;
              end;
            end;
          end;
        end;

      end;
    198:
      begin
        ClientCHECKITEMBOXCF(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
      end;
    199:
      ClientGetScriptPic(Processmsg.sMsg, ProcessMsg.nParam2);
    CM_EAT:
      begin                                                 //1006
        ClientUseItems(ProcessMsg.nParam1, makelong(ProcessMsg.nParam2,
          ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    24242:
      begin                                                 //删除任务列表的内容
        ClientDelTask(ProcessMsg.nParam1);
      end;
    3021:
      begin                                                 //作揖
        SendRefMsg(RM_ZUOYI, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
      end;
    193:
      begin
        ClientMessageA(ProcessMsg.nParam1, ProcessMsg.nParam2);
      end;
    992:
      begin                                                 //凝练 //合成
        ClientMakeStone(ProcessMsg.nParam2, ProcessMsg.wParam, ProcessMsg.nParam3,
          ProcessMsg.nParam1, ProcessMsg.sMsg);

      end;
    34971:
      begin
        m_sParam[0] := IntToStr(ProcessMsg.nParam2);
        if g_ManageNPC <> nil then
          g_ManageNPC.GotoLable(self, '@ReadBook', False);
      end;
    627:
      begin
        DecodeBuffer(ProcessMsg.sMsg, @nPower, 4);
        ClientOpenMagicBox(ProcessMsg.nParam2, MakeLong(ProcessMsg.nParam3,
          ProcessMsg.wParam), nPower);
      end;
    3039:                                                   //快速购物
      begin
        //  ClientFastBuy(ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1,
          MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), 0,
          DecodeString(ProcessMsg.sMsg));
      end;

    4096:
      begin                                                 //商场
        ClientOpenSHOP(ProcessMsg.nParam2, ProcessMsg.sMsg);
      end;
    CM_BUTCH:
      begin                                                 //1007
        if not ClientGetButchItem(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2,
          ProcessMsg.nParam3, ProcessMsg.wParam, dwDelayTime) then
        begin
          if dwDelayTime <> 0 then
          begin
            nMsgCount := GetDigUpMsgCount();
            if nMsgCount >= g_Config.nMaxDigUpMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  //MainOutMessage('[游戏超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(format(g_sBunOverSpeed, [m_sCharName, dwDelayTime,
                    nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                IntToStr(m_nCurrY));
            end
            else
            begin
              if dwDelayTime < g_Config.dwDropOverSpeed then
              begin
                if m_boTestSpeedMode then
                  SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
                SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
                  IntToStr(ProcessMsg.nParam2));
              end
              else
              begin
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    CM_MAGICKEYCHANGE:
      begin                                                 //1008
        ClientChangeMagicKey(ProcessMsg.nParam1, ProcessMsg.nParam2);
      end;
    24246:
      begin
        m_boReconnection := True;
        m_boSoftClose := True;
        if sYsnameMaster <> '' then
        begin                                               //如果是元神消失
          // hum:=nil;
          // hum:= UserEngine.GetPlayObjectEx(sYsnameMaster);
          hum := self.ysmasterplayer;

          // hum.m_boSoftClose:=True;
          SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
          m_dwYsCallTick := GetTickCount();
          SendRefMsg(RM_510, 0, 1, 0, 42, '');
          if hum <> nil then
          begin
            hum.SysMsg('神奇的力量散去，你的元神分身开始沉睡。', c_Red, t_Hint);
            hum.m_dwYsCallTick := GetTickCount();
          end;
        end;
      end;
    106:
      begin
        m_sParam[0] := '1';
        if g_ManageNPC <> nil then
          g_ManageNPC.GotoLable(Self, '@logout', false);
      end;
    CM_SOFTCLOSE:
      begin                                                 //1009  004D79CB
        m_sParam[0] := '0';
        if g_ManageNPC <> nil then
          g_ManageNPC.GotoLable(Self, '@logout', false);
        m_boReconnection := True;
        m_boSoftClose := True;
        if sYsnameMaster <> '' then
        begin                                               //如果是元神消失
          // hum:=nil;
          // hum:= UserEngine.GetPlayObjectEx(sYsnameMaster);
          hum := self.ysmasterplayer;
          SendRefMsg(RM_510, 0, 1, 0, 42, '');
          if hum <> nil then
          begin
            hum.SysMsg('神奇的力量散去，你的元神分身开始沉睡。', c_Red, t_Hint);
            hum.m_dwYsCallTick := GetTickCount();
          end;
        end;

      end;
    840:
      begin
        if m_MyGuild <> nil then
          SendDefMessage(717, 0, 0, 0, 0, Format('%s/%d/%d/3/4',
            [TGuild(m_MyGuild).sGuildName, TGuild(m_MyGuild).nLevel,
            TGuild(m_MyGuild).nExp]));
        SendDefMessage(840, Integer(Self), 0, 1, 0, '');
      end;

    //客户端询问宝石数量
    688: SendDefMessage(688, Integer(Self), makeword(wGEMCOUNT[0], wGEMCOUNT[1]),
      wGEMCOUNT[2], 0, '');
    // 2009-12-23 9:39:37
    993:                                                    //熔炼宝石
      begin
        w20 := ProcessMsg.nParam2;
        ClientGemStone(Lobyte(w20), Hibyte(w20), ProcessMsg.nParam3, ProcessMsg.wParam,
          ProcessMsg.sMsg);
      end;
    CM_CLICKNPC:                                            //1010  004D79E4
      ClientClickNPC(ProcessMsg.nParam1);
    CM_MERCHANTDLGSELECT:                                   //1011
      ClientMerchantDlgSelect(ProcessMsg.nParam1, ProcessMsg.sMsg);
    CM_MERCHANTQUERYSELLPRICE:                              //1012
      ClientMerchantQuerySellPrice(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
        ProcessMsg.nParam3), ProcessMsg.sMsg);
    CM_USERSELLITEM:                                        //1013
      ClientUserSellItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
        ProcessMsg.nParam3), ProcessMsg.sMsg);

    CM_USERBUYITEM:                                         //1014  004D7AD4
      ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1,
        MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), 0, ProcessMsg.sMsg);

    CM_USERGETDETAILITEM:                                   //1015 004D7AB6
      ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, 0, ProcessMsg.nParam2,
        ProcessMsg.sMsg);

    CM_DROPGOLD:                                            //1016  004D7AFC
      if ProcessMsg.nParam1 > 0 then
        ClientDropGold(ProcessMsg.nParam1);

    CM_1017:                                                //1017
      SendDefMessage(1, 0, 0, 0, 0, '');

    CM_GROUPMODE:
      begin                                                 //1019
        if ProcessMsg.nParam2 = 0 then
          ClientGropuClose()
        else
          m_boAllowGroup := True;
        if m_boAllowGroup then
          SendDefMessage(SM_GROUPMODECHANGED, 0, 1, 0, 0, '')
        else
          SendDefMessage(SM_GROUPMODECHANGED, 0, 0, 0, 0, '');
      end;
    CM_CREATEGROUP:
      begin                                                 //1020
        ClientCreateGroup(Trim(ProcessMsg.sMsg));
      end;
    CM_ADDGROUPMEMBER:
      begin                                                 //1021
        ClientAddGroupMember(Trim(ProcessMsg.sMsg));
      end;
    CM_DELGROUPMEMBER:
      begin                                                 //1022
        ClientDelGroupMember(Trim(ProcessMsg.sMsg));
      end;
    CM_GROUPMEMBERXY:
      begin
        ClientgetGroupMemberxy();
      end;

    CM_USERREPAIRITEM:
      begin                                                 //1023 004D7A70
        ClientRepairItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
          ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    CM_MERCHANTQUERYREPAIRCOST:
      begin                                                 //1024 004D7A2A
        ClientQueryRepairCost(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
          ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    CM_DEALTRY:
      begin //1025                     //交易开始
        ClientDealTry(Trim(ProcessMsg.sMsg));
      end;
    69:
      begin //这个是客户端退出是包裹物品摆放的位置发送给服务器。下次登陆时可以还原包裹的物品位置
        ClientSendBagPos(ProcessMsg.wParam, ProcessMsg.sMsg);
        {
           Tbagitempos=record
            itemmake:integer;
            pos:word;    0..65   60..65  为 下面6个。
           end;

        }
     //  m_boReconnection:=true;
     //   m_bomustdels:=true;
     //   FrmIDSoc.SendHumanLogOutmsg(m_sUserID,m_nSessionID);
      end;
    3080:
      begin
        if (sYsname <> '') then
        begin
          if m_PEnvir.m_boNOYS then
          begin
            SysMsg('这里不能召唤元神！！！', c_Red, t_Hint);

          end
          else
          begin
            hum := nil;
            hum := UserEngine.GetPlayObjectEx(sYsname);
            //  hum:=Ysplayer;
            if hum = nil then
            begin
              if (m_nYsCallcount < 1) then
              begin
                SendDefMessage(38407, 0, 0, 0, 0, sYsname); // 名字

              end
              else
                if (GetTickCount - m_dwYsCallTick > _min((m_nYsCallcount + 10), 20) *
                  1000) then
                  SendDefMessage(38407, 0, 0, 0, 0, sYsname)
                else
                begin
                  SysMsg('你的元神分身还比较虚弱，如果召唤会损伤元神。', c_Red, t_Hint);
                end;
            end
            else
            begin
              hum.SendRefMsg(RM_510, 0, 1, 0, 42, '');
              SysMsg('神奇的力量散去，你的元神分身开始沉睡。', c_Red, t_Hint);
              Ysplayer := nil;
              hum.m_boReconnection := True;
              // hum.m_boSoftClose:=True;
              hum.SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
              m_dwYsCallTick := GetTickCount();
            end;
          end;                                              //else m_PEnvir.m_boNOYS
        end;                                                //   if (sYsname<>'')
      end;
    3076:
      begin
        ClientYsBagItem(ProcessMsg.sMsg);

      end;
    3077:
      begin
        ClientYsGoldChange(ProcessMsg.sMsg);
      end;

    979:
      begin
        //    SendDefMessage(980,ProcessMsg.nParam1,0,0,0,'');
      end;
    3072:
      begin
        m_bocanaddpickupitem := true;
        //  SendDefMessage(38400,integer(self),0,0,0,'');
        Clientgettime();
      end;
    3052:
      begin
        DecodeBuffer(processmsg.smsg, @YSPoint, 4);
        ClientPetHuanhua(ProcessMsg.nParam1, makelong(ProcessMsg.nParam2,
          ProcessMsg.nParam3), YSPoint, ProcessMsg.wParam);
      end;
    3073:
      begin                                                 //命令豹子去检取物品
        Clientmonpickup(ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    3074:
      begin                                                 //放到宠物背包中
        ClientStorageItemTomon(ProcessMsg.nParam1);
      end;
    3075:
      begin                                                 // 物品放回包裹中
        ClientTakeStorageItemFrommon(ProcessMsg.nParam1);
      end;
    34967:
      begin                                                 //CTR+P 宠物属性
        Clientgetslave();
      end;

    CM_DEALADDITEM:
      begin //1026                 //增加交易物品
        ClientAddDealItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_DEALDELITEM:
      begin                                                 //1027
        ClientDelDealItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_DEALCANCEL:
      begin                                                 //1028
        ClientCancelDeal();
      end;
    CM_DEALCHGGOLD:
      begin                                                 //1029
        ClientChangeDealGold(ProcessMsg.nParam1, ProcessMsg.nParam2);
      end;
    CM_DEALEND:
      begin                                                 //1030
        ClientDealEnd();
      end;
    CM_USERSTORAGEITEM:
      begin                                                 //1031
        ClientStorageItem(TObject(ProcessMsg.nParam1), MakeLong(ProcessMsg.nParam2,
          ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    CM_USERTAKEBACKSTORAGEITEM:
      begin                                                 //1032
        ClientTakeBackStorageItem(TObject(ProcessMsg.nParam1),
          MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
      end;
    CM_WANTMINIMAP:
      begin                                                 //1033
        ClientGetMinMap();
      end;
    CM_USERMAKEDRUGITEM:
      begin                                                 //1034
        ClientMakeDrugItem(TObject(ProcessMsg.nParam1), ProcessMsg.sMsg);
      end;
    CM_OPENGUILDDLG:
      begin                                                 //1035
        ClientOpenGuildDlg();
      end;
    CM_GUILDHOME:
      begin                                                 //1036
        ClientGuildHome();
      end;
    CM_GUILDMEMBERLIST, 837:
      begin
        ClientGuildMemberList(ProcessMsg.wIdent);
      end;
    CM_GUILDADDMEMBER:
      begin
        ClientGuildAddMember(ProcessMsg.sMsg);
      end;
    CM_GUILDDELMEMBER:
      begin
        ClientGuildDelMember(ProcessMsg.sMsg);
      end;
    CM_GUILDUPDATENOTICE:
      begin
        ClientGuildUpdateNotice(ProcessMsg.sMsg);
      end;
    CM_GUILDUPDATERANKINFO:
      begin                                                 //1041
        ClientGuildUpdateRankInfo(ProcessMsg.sMsg);
      end;
    CM_1042:
      begin
        if m_MyGuild <> nil then
          SysMsg('当前你所在的行会经验值为:' + IntToStr(TGuild(m_MyGuild).m_nBuildPoint),
            c_Red, t_Hint);
        //         MainOutMessage('[非法数据] ' + m_sCharName);
      end;
    CM_ADJUST_BONUS:
      begin
        ClientAdjustBonus(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;
    CM_GUILDALLY:
      begin                                                 //1044
        ClientGuildAlly();
      end;
    CM_GUILDBREAKALLY:
      begin                                                 //1045
        ClientGuildBreakAlly(ProcessMsg.sMsg);
      end;
{$IF CHECKNEWMSG = 1}
    CM_1046:
      begin
        MainOutMessage(format('%s/%d/%d/%d/%d/%d/%s',
          [m_sCharName,
          ProcessMsg.wIdent,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            DecodeString(ProcessMsg.sMsg)]));
      end;
    CM_1056:
      begin
        MainOutMessage(format('%s/%d/%d/%d/%d/%d/%s',
          [m_sCharName,
          ProcessMsg.wIdent,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            DecodeString(ProcessMsg.sMsg)]));
      end;
{$IFEND}
    CM_TURN:
      begin                                                 //3010    004D73DD
        if ClientChangeDir(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2
          {y}, ProcessMsg.wParam {dir}, dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          //   SendSocket(nil,sSTATUS_GOOD + IntToStr(GetTickCount));
          SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
            IntToStr(ProcessMsg.nParam2));                    //hint
        end
        else
        begin
          if dwDelayTime = 0 then
          begin
            // SendSocket(nil,sSTATUS_FAIL + IntToStr(GetTickCount))
            SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY))
          end
          else
          begin
            nMsgCount := GetTurnMsgCount();
            if nMsgCount >= g_Config.nMaxTurnMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  //MainOutMessage('[游戏超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(format(g_sBunOverSpeed, [m_sCharName, dwDelayTime,
                    nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                IntToStr(m_nCurrY));
            end
            else
            begin
              if dwDelayTime < g_Config.dwDropOverSpeed then
              begin
                SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
                  IntToStr(ProcessMsg.nParam2));
                if m_boTestSpeedMode then
                  SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    CM_WALK:
      begin                                                 //3011
        RunNewMapEvent(ProcessMsg.nParam1, ProcessMsg.nParam2, 5, '');
        if ClientWalkXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2
          {y}, ProcessMsg.boLateDelivery, dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
            IntToStr(ProcessMsg.nParam2));
          Inc(n5F8);
        end
        else
        begin
          if dwDelayTime = 0 then
          begin
            SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY))
          end
          else
          begin
            nMsgCount := GetWalkMsgCount();
            if nMsgCount >= g_Config.nMaxWalkMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  //MainOutMessage('[行走超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(format(g_sWalkOverSpeed, [m_sCharName, dwDelayTime,
                    nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                IntToStr(m_nCurrY));
              if m_boTestSpeedMode then
                SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                  dwDelayTime]), c_Red, t_Hint);
            end
            else
            begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode
                = 1) and m_boFilterAction then
              begin
                SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                  IntToStr(m_nCurrY));
                if m_boTestSpeedMode then
                  SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin

                if m_boTestSpeedMode then
                  SysMsg(format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;

    CM_HORSERUN:
      begin                                                 //3009
        //    if InSafeZone then  self.m_boInSafeArea
        if ClientHorseRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2
          {y}, ProcessMsg.boLateDelivery, dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
            IntToStr(ProcessMsg.nParam2));
          Inc(n5F8);
        end
        else
        begin

          if dwDelayTime = 0 then
          begin
            SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
              IntToStr(m_nCurrY));
          end
          else
          begin
            nMsgCount := GetRunMsgCount();
            if nMsgCount >= g_Config.nMaxRunMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  //MainOutMessage('[跑步超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(format(g_sRunOverSpeed, [m_sCharName, dwDelayTime,
                    nMsgCount]));
                end;

              end;
              //如果超速则发送攻击失败信息
              SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                IntToStr(m_nCurrY));
              if m_boTestSpeedMode then
                SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                  dwDelayTime]), c_Red, t_Hint);
            end
            else
            begin
              if m_boTestSpeedMode then
                SysMsg(format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent,
                  dwDelayTime]), c_Red, t_Hint);
              SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '',
                dwDelayTime);
              Result := False;
            end;
          end;

        end;
      end;
    CM_RUN:
      begin                                                 //3013
        RunNewMapEvent(ProcessMsg.nParam1, ProcessMsg.nParam2, 5, '');
        GoLable := CheckMapEnvir(IntToStr(ProcessMsg.nParam1),
          IntToStr(ProcessMsg.nParam2), m_sMapName, '1');
        if GoLable <> '' then
        begin
          g_FunctionNPC.GotoLable(Self, GoLable, False);
        end;
        if (m_boOnHorse or m_boOnBaozi) and (not m_boBaoZiAttacked) then
        begin                                               //3009
          if ClientHorseRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y}, ProcessMsg.boLateDelivery, dwDelayTime) then
          begin
            m_dwActionTick := GetTickCount;
            SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
              IntToStr(ProcessMsg.nParam2));
            Inc(n5F8);
          end
          else
          begin

            if dwDelayTime = 0 then
            begin
              SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                IntToStr(m_nCurrY));
            end
            else
            begin
              nMsgCount := GetRunMsgCount();
              if nMsgCount >= g_Config.nMaxRunMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red,
                      t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[跑步超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sRunOverSpeed, [m_sCharName, dwDelayTime,
                      nMsgCount]));
                  end;

                end;
                //如果超速则发送攻击失败信息
                SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                  IntToStr(m_nCurrY));
                if m_boTestSpeedMode then
                  SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if m_boTestSpeedMode then
                  SysMsg(format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '',
                  dwDelayTime);
                Result := False;
              end;
            end;

          end;
        end
        else
        begin

          if ClientRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x}, ProcessMsg.nParam2
            {y}, ProcessMsg.nParam3, dwDelayTime) then
          begin
            m_dwActionTick := GetTickCount;
            SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
              IntToStr(ProcessMsg.nParam2));
            Inc(n5F8);
          end
          else
          begin
            if dwDelayTime = 0 then
            begin
              SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                IntToStr(m_nCurrY));
            end
            else
            begin
              nMsgCount := GetRunMsgCount();
              if nMsgCount >= g_Config.nMaxRunMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red,
                      t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[跑步超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sRunOverSpeed, [m_sCharName, dwDelayTime,
                      nMsgCount]));
                  end;
                end;
                //如果超速则发送攻击失败信息
                SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                  IntToStr(m_nCurrY));
              end
              else
              begin
                if (dwDelayTime > g_Config.dwDropOverSpeed) and
                  (g_Config.btSpeedControlMode = 1) and m_boFilterAction then
                begin
                  SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                    IntToStr(m_nCurrY));
                  if m_boTestSpeedMode then
                    SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                      dwDelayTime]), c_Red, t_Hint);
                end
                else
                begin
                  if m_boTestSpeedMode then
                    SysMsg(format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent,
                      dwDelayTime]), c_Red, t_Hint);
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                    ProcessMsg.nParam1, ProcessMsg.nParam2, CM_RUN, '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;

          end;
        end;                                                //else;
      end;
    3020:
      begin
        SendDefMessage(SM_204, integer(self), 0, 0, 0, '');

      end;
    34984:                                                  //寻宝
      begin
        SendPetInfo(M_monitemmake, 9);
      end;
    CM_HIT,                                                 //3014
    CM_HEAVYHIT,                                            //3015
    CM_BIGHIT,                                              //3016
    CM_POWERHIT,                                            //3018
    CM_LONGHIT,                                             //3019
    CM_WIDEHIT,                                             //3024
    CM_CRSHIT,
      CM_TWNHIT,
      CM_3026HIT,
      CM_FIREHIT:
      begin                                                 //3025  :004D75BC
        if m_btLingzhuMode = 1 then
        begin

          SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY));  //hint
          Exit;
        end;
        SendSocket(nil, sSTATUS_GOOD + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY));
        //  SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' + IntToStr(ProcessMsg.nParam2));
        if ClientHitXY(ProcessMsg.wIdent {ident}, ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y}, ProcessMsg.nParam3, ProcessMsg.wParam {dir},
          ProcessMsg.boLateDelivery, dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          //  SendSocket(nil,sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1)+'/'+IntToStr(ProcessMsg.nParam2));
          Inc(n5F8);
        end
        else
        begin
          if dwDelayTime = 0 then
          begin
            SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY));  //hint
            // SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' + IntToStr(ProcessMsg.nParam2));
                 //解决攻击卡位现象
          end
          else
          begin
            nMsgCount := GetHitMsgCount();
            if nMsgCount >= g_Config.nMaxHitMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  //MainOutMessage('[攻击超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(format(g_sHitOverSpeed, [m_sCharName, dwDelayTime,
                    nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                IntToStr(m_nCurrY));
            end
            else
            begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode
                = 1) and m_boFilterAction then
              begin
                SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
                  IntToStr(ProcessMsg.nParam2));
                if m_boTestSpeedMode then
                  SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if m_boTestSpeedMode then
                begin
                  //SysMsg(format('操作延迟 Ident: %d Time: %d',[ProcessMsg.wIdent,dwDelayTime]),c_Red,t_Hint);
                  SysMsg('操作延迟 Ident: ' + IntToStr(ProcessMsg.wIdent) + ' Time: ' +
                    IntToStr(dwDelayTime), c_Red, t_Hint);
                end;
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;

    CM_SITDOWN:
      begin                                                 //3012
        GoLable := CheckMapEnvir(IntToStr(ProcessMsg.nParam1),
          IntToStr(ProcessMsg.nParam2), m_sMapName, '3');
        RunNewMapEvent(ProcessMsg.nParam1, ProcessMsg.nParam2, 6, '');
        if GoLable <> '' then
        begin
          g_FunctionNPC.GotoLable(Self, GoLable, False);
        end;
        if ClientSitDownHit(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam,
          dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount();
          SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
            IntToStr(ProcessMsg.nParam2));
        end
        else
        begin
          if dwDelayTime = 0 then
          begin
            SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
              IntToStr(m_nCurrY));
          end
          else
          begin
            nMsgCount := GetSiteDownMsgCount();
            if nMsgCount >= g_Config.nMaxSitDonwMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  //MainOutMessage('[游戏超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(format(g_sBunOverSpeed, [m_sCharName, dwDelayTime,
                    nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                IntToStr(m_nCurrY));
            end
            else
            begin
              if dwDelayTime < g_Config.dwDropOverSpeed then
              begin
                SendSocket(nil, sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1) + '/' +
                  IntToStr(ProcessMsg.nParam2));
                if m_boTestSpeedMode then
                  SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if m_boTestSpeedMode then
                  SysMsg(format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;
    //神龙献宝 3 显示 4 开始 5 停止或关闭
    34974:
      begin
        nCOunt := ProcessMsg.nParam2 and $FF;
        w20 := ProcessMsg.nParam2;

        case nCOunt of
          3: ;
          4:
            begin
              m_sParam[0] := IntToStr(HiByte(w20));
              if m_npc1 <> nil then
                TMerchant(m_NPC1).GotoLable(Self, '@StartErnie', False);
              //  SWYINFO.btType:=6;
             //   SWYINFO.btLevel:=4;
             //   SWYINFO.str:='竞争藏宝图';
           //     s1c:=EncodeBuffer(@SWYInfo,Length(SWYINFO.str)+3);
            //    SendDefMessage(34973,0,5,1,0,s1C,true);

            end;
          5:
            begin
              m_sParam[0] := '0';
              m_sParam[1] := '0';
              if m_npc1 <> nil then
                TMerchant(m_NPC1).GotoLable(Self, '@EndErnie', False);
            end;
        end;
        //  if g_FunctionNPC<>nil then
        //     g_FunctionNPC.GotoLable(Self,'@神龙献宝',false);
      end;
    59003:                                                  //彩虹精灵
      begin
        if g_ManageNPC <> nil then
          g_ManageNPC.GotoLable(Self, '@客服系统', false);

      end;
    1843:                                                   //使用镇魔符
      begin
        CLientAddZhenmoValue(makelong(ProcessMsg.nParam2, ProcessMsg.nParam3),
          ProcessMsg.nParam1);
      end;
    1824:                                                   //俘获心魔
      begin

        ClientAddMagic(makelong(ProcessMsg.nParam2, ProcessMsg.nParam3));
      end;
    854:                                                    //灵犀宝盒
      begin
        ClientAddLXBH(ProcessMsg.nParam2, ProcessMsg.nParam1, ProcessMsg.wParam);
      end;
    3041:                                                   //创建第二元神
      begin
        btHasYS2 := 1;
        nyssex_1 := Str_ToInt(m_sparam[0], 0);
        nysjob_1 := Str_ToInt(m_sparam[1], 0);
        SendRefMsg(RM_510, 0, 1, 0, 89, '');

        UserEngine.SendBroadCastMsg('恭喜玩家' + m_scharname +
          '在灵台仙人处分神成功，从而获得第二元神！', t_rSystem);

      end;
    3042:
      begin
        Randomize;
        YSPoint := Random(2);
        m_sParam[0] := Inttostr(YSPoint);                   //性别
        Randomize;
        YSFlag := Random(3);
        m_sParam[1] := Inttostr(YSFlag);                    //职业
        GetItemByName('灵符');
        SendDefMessage(3042, Integer(Self), MakeWord(YSPoint, YSFLAG), 0, 0, '');
      end;
    3043:                                                   //散魂
      begin
        if g_ManageNPC <> nil then
          g_ManageNPC.GotoLable(Self, '@元婴散魂', false);
      end;
    3040:
      begin
        ClientYuanYing(makelong(ProcessMsg.nParam2, ProcessMsg.nParam3));
      end;
    3046:
      begin
        m_sParam[0] := IntToStr(ProcessMsg.wParam);
        if g_ManageNPC <> nil then g_ManageNPC.GotoLable(self, '@离火封魔阵', false);
      end;
    3047:
      begin
        CallLHFMMon(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    1825:                                                   //装备附魔
      begin
        CLientAddEvil(makelong(ProcessMsg.nParam2, ProcessMsg.nParam3),
          ProcessMsg.nParam1);
      end;
    CM_SPELL:
      begin                                                 //3017  004D76FD
        // MainOutMessage(format('CM_SPELL wident=%d,wparam=%d,P1=%d,P2=%d,P3=%d',[ProcessMsg.wIdent,ProcessMsg.wParam,ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.nParam3]));
        SendSocket(nil, sSTATUS_GOOD + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY));
        if m_btLingzhuMode = 1 then
        begin

          SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY));  //hint
          Exit;
        end;
        if ClientSpellXY(ProcessMsg.wIdent, ProcessMsg.wParam, ProcessMsg.nParam1,
          ProcessMsg.nParam2, TBaseObject(ProcessMsg.nParam3), ProcessMsg.boLateDelivery,
          dwDelayTime) then
        begin
          m_dwActionTick := GetTickCount;
          //            SendSocket(nil,sSTATUS_GOOD + IntToStr(ProcessMsg.nParam1)+'/'+IntToStr(ProcessMsg.nParam2));
                   //   SendSocket(nil,sSTATUS_GOOD + IntToStr(m_nCurrX)+'/'+IntToStr(m_nCurrY));
          Inc(n5F8);
        end
        else
        begin
          if dwDelayTime = 0 then
          begin                                             //解决魔法卡位现象
            //  SendSocket(nil,sSTATUS_FAIL + IntToStr( m_nCurrX)+'/'+IntToStr( m_nCurrY));
            SendSocket(nil, sSTATUS_GOOD + IntToStr(m_nCurrX) + '/' +
              IntToStr(m_nCurrY));
          end
          else
          begin
            nMsgCount := GetSpellMsgCount();
            if nMsgCount >= g_Config.nMaxSpellMsgCount then
            begin
              Inc(m_nOverSpeedCount);
              if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
              begin
                if g_Config.boKickOverSpeed then
                begin
                  SysMsg(g_sKickClientUserMsg {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                  m_boEmergencyClose := True;
                end;
                if g_Config.boViewHackMessage then
                begin
                  //MainOutMessage('[魔法超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                  MainOutMessage(format(g_sSpellOverSpeed, [m_sCharName, dwDelayTime,
                    nMsgCount]));
                end;
              end;
              //如果超速则发送攻击失败信息
              SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                IntToStr(m_nCurrY));
            end
            else
            begin
              if (dwDelayTime > g_Config.dwDropOverSpeed) and (g_Config.btSpeedControlMode
                = 1) and m_boFilterAction then
              begin
                SendSocket(nil, sSTATUS_FAIL + IntToStr(m_nCurrX) + '/' +
                  IntToStr(m_nCurrY));
                if m_boTestSpeedMode then
                  SysMsg(format('速度异常 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if m_boTestSpeedMode then
                  SysMsg(format('操作延迟 Ident: %d Time: %d', [ProcessMsg.wIdent,
                    dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3, '',
                  dwDelayTime);
                Result := False;
              end;
            end;
          end;
        end;
      end;

    CM_SAY:
      begin                                                 //3030
        if ProcessMsg.sMsg <> '' then
        begin
          ProcessUserLineMsg(ProcessMsg.sMsg);
        end;
      end;
    CM_PASSWORD:
      begin
        ProcessClientPassword(ProcessMsg);
      end;

    197:
      begin
        ClientMapMove(ProcessMsg.nParam1, ProcessMsg.nParam2);

      end;
    CM_26771:
      begin                                                 //修改个性化签名
        if ProcessMsg.sMsg <> '' then
        begin
          if (GetTickCount() - m_dwLastModSytelNameTick) > 1000 * 60 then
            ModifyStylename(ProcessMsg.sMsg)
          else
            SysMsg('一分钟内只能修改一次', c_Red, t_Hint);
        end;

      end;

    CM_ADDFRIEND:
      begin                                                 //加友   66
        if ProcessMsg.sMsg <> '' then
        begin
          Addfriend(ProcessMsg.sMsg)
        end;
      end;

    CM_DELFRIEND:
      begin                                                 //删除好友  67
        if ProcessMsg.sMsg <> '' then
        begin
          Delfriend(ProcessMsg.sMsg)
        end;
      end;

    CM_ADDASK:
      begin                                                 //确认加友   68
        if ProcessMsg.sMsg <> '' then
        begin
          Confirmfriend(ProcessMsg.sMsg, ProcessMsg.nParam1)
        end;

      end;
    24244:                                                  //豹子摆摊增加物品  Tag 数量
      begin
        ClientPetSellAddItem(ProcessMsg.nParam3, ProcessMsg.sMsg);
      end;
    24243:
      begin
        //SendDefMessage(32981, ProcessMsg.nParam1, 5, 0, 0, '');
        ClientAskSell(ProcessMsg.nParam2);
      end;
    24245:                                                  //豹子摆摊
      begin
        if g_Config.boDisablePetSell then
          SysMsg('目前不能宠物摆摊！！！', c_Red, t_Hint)
        else
          ClientSendPetSell(ProcessMsg.sMsg, ProcessMsg.nParam2, ProcessMsg.nParam1)

      end;
    CM_SENDSELL:
      begin                                                 //确认加友   24241
        if not (m_boOnHorse or m_boOnBaozi or g_Config.boDisableSell) then
          ClientSendSell(ProcessMsg.sMsg, ProcessMsg.nParam2)
        else
          SysMsg('目前不能摆摊！！！', c_Red, t_Hint);

      end;
    26769:
      begin                                                 //发送输入的数量
        sendvalue(ProcessMsg.nParam1, ProcessMsg.sMsg);
      end;

    34832:
      begin                                                 //发送一个物品MAKEINDEX
        SendBOXITEM(ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3);
      end;
    ///
    38657:
      begin                                                 //排行榜开关
        //   MainOutMessage(format('n1=%d:n2=%d:n3=%d:wparam=%d',[ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.nParam3,ProcessMsg.wParam]));

        if g_Config.boUsePaihang and (ProcessMsg.nParam2 = 0) then  //用户自己点的 =0    =1 是服务器更新数据已经在升级模块里做的更新。
          SendDefMessage(38658, Integer(self), 47, 0, 0, '');
      end;
    ///
    38659:
      begin                                                 // 排行榜数据
        SendPaiHangbang(ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam);
        //  MainOutMessage(format('n1=%d:n2=%d:n3=%d:wparam=%d',[ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.nParam3,ProcessMsg.wParam]));
      end;

    // 2009-2-23 12:37:04
    34968:
      begin
        ClientAddZM(ProcessMsg.nParam2, MakeLong(ProcessMsg.nParam3, ProcessMsg.wParam));
      end;
    CM_TAKEHORSE:
      begin                                                 //hint 上马 下马
        if M_MonOnhorseItemMake = 0 then
          nPower := GetpetLevel(M_MonItemMake).montype
        else
          nPower := GetpetLevel(M_MonOnhorseItemMake).montype;
        nPower := nPower and 3;
        //元神
        if ysmasterplayer <> nil then
        begin
          if ysmasterplayer.M_monYSOnHorseitemmake = 0 then
            nPower := ysmasterplayer.GetpetLevel(ysmasterplayer.M_MonItemMake).montype
          else
            nPower :=
              ysmasterplayer.GetpetLevel(ysmasterplayer.M_MonYSOnhorseItemMake).montype;

          nPower := nPower and 3;
          if ((ysmasterplayer.M_MonYSOnhorseItemMake > 0) or (ysmasterplayer.M_MonItemMake
            > 0)) and (nPower > 0) and (not (m_boHavebeArp or m_boArrow)) then
          begin
            if ysmasterplayer.m_petBaseObject <> nil then
            begin
              if ysmasterplayer.m_petBaseObject.m_boOnSellItem then
              begin
                SysMsg('豹子在摆摊中，不能骑乘！！！', c_Red, t_Hint);
                exit;
              end;

            end;
            if m_boUsexushou and (not m_PEnvir.m_boNOQB) then
            begin
              if (not m_boOnBaozi) then
              begin
                m_boOnBaozi := true;
                ysmasterplayer.M_monYSOnHorseitemmake := ysmasterplayer.M_monitemmake;
                SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
                ysmasterplayer.Sendpetinfo(ysmasterplayer.M_monYSOnHorseitemmake, 7);
                horsename :=
                  ysmasterplayer.GetPetName(ysmasterplayer.M_monYSOnHorseitemmake);
                ysmasterplayer.makeslaveghost(horsename);
                m_boBaoZiAttacked := False;
                SendDefMessage(205, 3, 1, 1, 1, '');
                ysmasterplayer.M_monitemmake := 0;
              end
              else
              begin
                //骑战 必须二转
                if (not m_boBaoZiAttacked) and (nPower > 1) then
                begin
                  m_boBaoZiAttacked := True;
                  SendDefMessage(205, 1, 0, 0, 0, '');
                  ysmasterplayer.Sendpetinfo(ysmasterplayer.M_monYSOnHorseitemmake, 8);
                  ysmasterplayer.Sendpetinfo(ysmasterplayer.M_monYSOnHorseitemmake, 100);

                  // Sendpetinfo(M_mononhorseItemMake,100);
                 //  ysmasterplayer.Sendpetinfo(100);
                  m_nCharStatus := m_nCharStatus or 1;

                  SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
                  SendUpdateMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus,
                    0, 0, '');
                end
                else
                begin
                  horsename :=
                    ysmasterplayer.GetPetName(ysmasterplayer.M_monYSOnHorseitemmake);
                  m_boBaoZiAttacked := False;
                  m_boOnBaozi := false;
                  // MONSTORAGE(self);
                  if ysmasterplayer.M_monitemmake = 0 then  //此时没有跟随的豹子
                  begin
                    monhorse := ysmasterplayer.MakeSlave(horsename,
                      ysmasterplayer.M_monstoragehuoli,
                      ysmasterplayer.GetpetLevel(ysmasterplayer.M_monYSOnHorseitemmake).Level, 10, 10 * 24 * 60 * 60);
                    if monhorse <> nil then
                    begin
                      ysmasterplayer.m_PetBaseObject := monhorse;
                      monhorse.m_btGender :=
                        ysmasterplayer.GetpetLevel(ysmasterplayer.M_monYSOnHorseitemmake).montype and $3;
                      m_boOnBaozi := false;

                      ysmasterplayer.Sendpetinfo(ysmasterplayer.M_monYSOnHorseitemmake,
                        1);
                      ysmasterplayer.M_monitemmake :=
                        ysmasterplayer.M_MonYSOnHorseItemMake;
                    end;
                  end
                  else
                    ysmasterplayer.Sendpetinfo(ysmasterplayer.M_monYSonhorseItemMake, 0);
                  m_nCharStatus := m_ncharstatus and $FFFFFFFE;
                  ysmasterplayer.M_MonYSOnHorseItemMake := 0;
                  SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
                  SendDefMessage(205, 0, 0, 0, 0, '');
                  m_boBaoZiAttacked := False;
                  m_boOnBaozi := false;
                end;
                RecalcAbilitys();
                SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
              end;
              exit;
            end                                             // 如果已经穿上了驯兽衣服
            else
              SysMsg('请先穿上驯兽衣服,或者本地图不能骑豹！！！', c_Red, t_Hint);
          end;                                              //如果已经放出踏云豹

        end;
        if ((M_MonOnhorseItemMake > 0) or (M_MonItemMake > 0)) and (nPower > 0) and (not
          (m_boHavebeArp or m_boArrow)) then
        begin
          if m_petBaseObject <> nil then
          begin
            if m_petBaseObject.m_boOnSellItem then
            begin
              SysMsg('豹子在摆摊中，不能骑乘！！！', c_Red, t_Hint);
              exit;
            end;

          end;
          if m_boUsexushou and (not m_PEnvir.m_boNOQB) then
          begin
            if (not m_boOnBaozi) then
            begin
              m_boOnBaozi := true;
              M_monOnHorseitemmake := M_monitemmake;

              SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
              Sendpetinfo(M_MonItemMake, 2);
              M_monitemmake := 0;
              m_bohasMONSTORAGE := false;
              horsename := GetPetName(M_monOnHorseitemmake);
              makeslaveghost(horsename);
              m_PetBaseObject := nil;
              m_boBaoZiAttacked := False;
              SendDefMessage(205, 3, 1, 1, 1, '');
            end
            else
            begin
              //骑战 必须二转
              if (not m_boBaoZiAttacked) and (nPower > 1) then
              begin
                m_boBaoZiAttacked := True;
                SendDefMessage(205, 1, 0, 0, 0, '');
                Sendpetinfo(M_mononhorseItemMake, 6);
                Sendpetinfo(M_mononhorseItemMake, 100);
                m_nCharStatus := m_nCharStatus or 1;

                SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
                SendUpdateMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0,
                  0, '');
              end
              else
              begin
                if M_monitemmake = 0 then                   //此时没有跟随的豹子
                begin
                  horsename := GetPetName(M_mononhorseItemMake);

                  // MONSTORAGE(self);
                  monhorse := MakeSlave(horsename, M_monstoragehuoli,
                    GetpetLevel(M_MonOnhorseItemMake).Level, 10, 10 * 24 * 60 * 60);
                  if monhorse <> nil then
                  begin
                    m_PetBaseObject := monhorse;
                    monhorse.m_btGender := GetpetLevel(M_mononhorseItemMake).montype and
                      $3;
                    m_boOnBaozi := false;
                    m_nCharStatus := m_ncharstatus and $FFFFFFFE;
                    SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
                    SendDefMessage(205, 0, 0, 0, 0, '');
                    Sendpetinfo(M_mononhorseItemMake, 1);
                    m_bohasMONSTORAGE := True;
                  end;
                end
                else
                  Sendpetinfo(M_mononhorseItemMake, 0);
                M_monitemmake := M_MonOnHorseItemMake;
                M_MonOnHorseItemMake := 0;
                m_boBaoZiAttacked := False;
                m_boOnBaozi := false;

              end;
              RecalcAbilitys();
              SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
              SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
            end;
            exit;
          end                                               // 如果已经穿上了驯兽衣服
          else
            SysMsg('请先穿上驯兽衣服,或者本地图不能骑豹！！！', c_Red, t_Hint);
        end;                                                //如果已经放出踏云豹
        //////////////
        if (not m_PEnvir.m_boCANHORSE) or m_boHavebeArp or m_boArrow then
        begin
          SysMsg(' 不能骑马', c_Red, t_Hint);
          SendDefMessage(205, 0, 0, 0, 0, '');
          //  break;
        end
        else
        begin                                               //

          if not m_boOnHorse then
          begin                                             // 上马
            SendDefMessage(205, 1, 0, 0, 0, '');
            horsepos := CheckHorsepos;
            if horsepos > 0 then
            begin
              StdItem := UserEngine.GetStdItem(m_UseItems[horsepos].wIndex);

              if (stditem <> nil) then
              begin
                ArrestStringEx(stditem.Name, '(', ')', horsename);
                for i := m_SlaveList.Count - 1 downto 0 do
                begin
                  if TBaseObject(m_SlaveList.Items[i]).m_sCharName = horsename then
                  begin
                    TBaseObject(m_SlaveList.Items[i]).MakeGhost;
                    m_SlaveList.Delete(i);
                    m_boOnHorse := true;
                    m_btHorseType := StdItem.Shape;
                    break;
                  end;                                      //if
                end;                                        //for

              end;                                          //<>nil

            end;                                            //>0

          end                                               // not m_boOnHorse
          else
          begin                                             //下马
            SendDefMessage(205, 0, 0, 0, 0, '');

            horsepos := CheckHorsepos;
            if horsepos > 0 then
            begin
              StdItem := UserEngine.GetStdItem(m_UseItems[horsepos].wIndex);
              if stditem <> nil then
              begin

                //TBaseObject.MakeSlave(sMonName:String;nMakeLevel,nExpLevel,nMaxMob:Integer;dwRoyaltySec:LongWord)
                ArrestStringEx(stditem.Name, '(', ')', horsename);
                monhorse := MakeSlave(horsename, 0, 0, 10, 10 * 24 * 60 * 60);  // stditem.Name
                if monhorse <> nil then
                  monhorse.m_bohorse := true;
                m_boOnHorse := false;
              end;                                          //<>nil

            end;                                            // >0
          end;                                              //下马

          //   SendRefMsg(RM_SPYMOVE,PlayObject.m_btDirection,nTargetX, nTargetY,makelong(m_nCurrX,m_nCurrY),'');
          SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
          RecalcAbilitys();
          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        end;
      end;

    RM_WALK:
      begin                                                 //10002
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_WALK, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
            TBaseObject(ProcessMsg.BaseObject).m_nLight));
          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));

          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        end;
      end;
    RM_HORSERUN:
      begin                                                 //10003 004D860A
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HORSERUN, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
            TBaseObject(ProcessMsg.BaseObject).m_nLight));
          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        end;
      end;
    RM_RUN:
      begin                                                 //10003 004D860A
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_RUN, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
            TBaseObject(ProcessMsg.BaseObject).m_nLight));
          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        end;
      end;
    RM_HIT:
      begin                                                 //10004 004D871D
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HIT, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);

          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, 8));
          // SendSocket(@m_DefMsg,'');   //06.1.17 修改
        end;
      end;
    RM_HEAVYHIT:
      begin                                                 //004D88CD
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_HEAVYHIT, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      end;
    RM_BIGHIT:
      begin                                                 //004D893A
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_BIGHIT, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_SPELL:
      begin                                                 // 10007 004D8A12
        //  SendRefMsg(RM_SPELL,UserMagic.MagicInfo.btEffect,nTargetX,nTargetY,UserMagic.MagicInfo.wMagicId,'');

        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPELL,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,                             //nTargetX
            ProcessMsg.nParam2,                             //nTargetY
            ProcessMsg.wParam);                             //UserMagic.MagicInfo.btEffect
          SendSocket(@m_DefMsg, encodestring(IntToStr(ProcessMsg.nParam3)));  //UserMagic.MagicInfo.wMagicId   //hint  传世需要加密
          //  MainOutMessage('魔法SM_SPELL =17:');
        end;
      end;
    RM_SPELL2:
      begin                                                 //10008 004D8789
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_POWERHIT, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    {
    RM_POWERHIT: begin

    end;
    }
    RM_MOVEFAIL:
      begin                                                 //10010 004D8289
        m_DefMsg := MakeDefaultMsg(SM_MOVEFAIL, Integer(Self), m_nCurrX, m_nCurrY,
          m_btDirection);
        CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong;
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(CharDesc)));
      end;
    RM_LONGHIT:
      begin                                                 //10011 004D87F5
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_LONGHIT, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_WIDEHIT:
      begin                                                 //10012 004D8861
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_WIDEHIT, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_FIREHIT:
      begin                                                 //10014 004D89A6
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_FIREHIT, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
          SendDefMessage(SM_510, Integer(ProcessMsg.BaseObject), 1, 0, 96, '');
        end;
      end;
    RM_CRSHIT:
      begin                                                 //10014 004D89A6
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_CRSHIT, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_41:
      begin                                                 //10014 004D89A6
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_41, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;
      end;
    RM_47:
      begin
        //   AttackTarget.SendRefMsg(RM_47,1536,0,0,integer(self),'');
         // AttackTarget.SendRefMsg(RM_47,17,m_WAbil.HP,m_WAbil.MaxHP,integer(self),'');
        if (TBaseObject(ProcessMsg.BaseObject) <> Self) and g_Config.ShowHpPresent then
          m_DefMsg := MakeDefaultMsg(SM_47,
            Integer(ProcessMsg.BaseObject),
            round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP /
              _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100),  // TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            100, // TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,

            //  TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            //  TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
            ProcessMsg.wParam)
        else
          m_DefMsg := MakeDefaultMsg(SM_47,
            Integer(ProcessMsg.BaseObject),
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
            ProcessMsg.wParam);

        sm47dat.nFeature := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong;
        sm47dat.nStatus := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        sm47dat.nplayobject := ProcessMsg.nParam3;
        sm47dat.n4 := ProcessMsg.nParam1;
        SendSocket(@m_DefMsg, EncodeBuffer(@sm47dat, SizeOf(Tsm47dat)));

      end;

    RM_59:
      begin                                                 //10014 004D89A6
        if TBaseObject(ProcessMsg.BaseObject) <> Self then
        begin
          // SM47dat.w1:= $3b ;//破击剑法
          SM5960dat.w1 := $3B;
          //  SM5960dat.n4:= 16711932; //紫色
          m_DefMsg := MakeDefaultMsg(SM_25, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, encodebuffer(@SM5960dat, sizeof(tSM5960dat))); //
        end;
      end;
    RM_25:
      begin                                                 //10014 004D89A6
        if (TBaseObject(ProcessMsg.BaseObject) <> Self) and
          (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) then
        begin

          //  SM47dat.w1:= $3c ;// 破盾斩
          SM5960dat.w1 := ProcessMsg.nParam3;               //MagicId
          SM5960dat.n4 := tplayobject(ProcessMsg.BaseObject).m_nmagiccolor;  //紫色  16711932;

          m_DefMsg := MakeDefaultMsg(SM_25, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);

          SendSocket(@m_DefMsg, encodebuffer(@SM5960dat, sizeof(tSM5960dat))); //
        end;

      end;
    RM_linghunqiang:
      begin
        SendDelayMsg(Self, RM_linghunqiang2, 0, ProcessMsg.nParam1, 0,
          Integer(ProcessMsg.BaseObject), '', 800);

        {   m_DefMsg:=MakeDefaultMsg(803,Integer(ProcessMsg.BaseObject),0,0,0);
            YSFLAG:=0;
           SendSocket(@m_DefMsg, encodebuffer(@YSFLAG,4));//
         }

      end;
    RM_linghunqiang2:
      begin

        m_DefMsg := MakeDefaultMsg(803, ProcessMsg.nParam3, ProcessMsg.nParam1, 0, 0);
        YSFLAG := 0;
        SendSocket(@m_DefMsg, encodebuffer(@YSFLAG, 4));    //

      end;

    RM_PUSHx:
      begin
        m_DefMsg := MakeDefaultMsg(SM_PUSHX, Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);  //TBaseObject(ProcessMsg.BaseObject).m_btGender)    m_nLight
        szCharDesc.feature :=
          TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
        szCharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        szCharDesc.stop := ProcessMsg.nParam3;
        s1C := EncodeBuffer(@szCharDesc, SizeOf(tmyszCharDesc));
        SendSocket(@m_DefMsg, s1C);

      end;
    RM_ANYING:
      begin
        m_DefMsg := MakeDefaultMsg(11228,
          Integer(self), //Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.wParam);                               //flag =2 发光提示,3 直接电

        CharDesc.feature := 16711698;                       //GetFeature(Self);

        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, 4));

        //  SendMsg(self,RM_ANYING,2,m_nCurrX,m_nCurrY,0,'');
      end;
    RM_ZUOYI:
      begin
        SendDefMessage(3021,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.wParam,
          '');
      end;

    RM_dengyu1:
      begin
        m_DefMsg := MakeDefaultMsg(1,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.wParam);

        CharDesc.feature :=
          TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;

        if (TBaseObject(ProcessMsg.BaseObject) <> Self) and g_Config.ShowHpPresent then
          CharDesc.xue := makelong(round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP /
            _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100), 100)  //hint 角色的血量 100/100
        else
          CharDesc.xue := makelong(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);  //makelong(100,100)   //hint 角色的血量
        s1C := EncodeBuffer(@CharDesc, SizeOf(CharDesc));

        nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
        if ProcessMsg.sMsg <> '' then
          s1C := s1C + EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
        //   s1C:=s1C+ProcessMsg.sMsg + '/' + IntToStr(nObjCount);   //hint 修改

        SendSocket(@m_DefMsg, s1C);

      end;

    RM_TURN,
      RM_PUSH,

    RM_RUSH,
      RM_RUSHKUNG:
      begin                                                 //004D831D
        if (TBaseObject(ProcessMsg.BaseObject) <> Self) or (ProcessMsg.wIdent = RM_PUSH)
          or (ProcessMsg.wIdent = RM_RUSH) or (ProcessMsg.wIdent = RM_RUSHKUNG) then
        begin
          case ProcessMsg.wIdent of
            RM_PUSH:                                        //004D835F
              m_DefMsg := MakeDefaultMsg(SM_BACKSTEP, Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1 {x}, ProcessMsg.nParam2 {y}, ProcessMsg.wParam {dir});  // m_nLight //MakeWord(ProcessMsg.wParam{dir}, TBaseObject(ProcessMsg.BaseObject).m_btGender{light})
            RM_RUSH:                                        //004D83B9
              m_DefMsg := MakeDefaultMsg(SM_RUSH, Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
                ProcessMsg.nParam3)); //TBaseObject(ProcessMsg.BaseObject).m_btGender)    m_nLight
            RM_RUSHKUNG:                                    //004D8413
              m_DefMsg := MakeDefaultMsg(SM_RUSHKUNG, Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
                TBaseObject(ProcessMsg.BaseObject).m_btGender)); // m_nLight
          else
            begin                                           //004D846A
              m_DefMsg := MakeDefaultMsg(SM_TURN, Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
                TBaseObject(ProcessMsg.BaseObject).m_btGender)); //hint     出线的人物性别
            end;
          end;

          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));

          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus +
            TBaseObject(ProcessMsg.BaseObject).m_nBaoziStatus;
          if (TBaseObject(ProcessMsg.BaseObject) <> Self) and g_Config.ShowHpPresent then
            CharDesc.xue := makelong(round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP
              / _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100), 100)  //hint 角色的血量 100/100
          else
            CharDesc.xue := makelong(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
              TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);  //makelong(100,100)   //hint 角色的血量
          //心魔 黑翅膀
          if TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_YSBJECT then
          begin
            ndreshape := TBaseObject(ProcessMsg.BaseObject).GetDress;
            m_btwing := TMonsteys(ProcessMsg.BaseObject).m_btwing;

            CharDesc.xue := makelong(round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP
              / _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100),
              makeword(ndreshape, m_btwing));
          end;

          if (ProcessMsg.wIdent = RM_RUSH) or (ProcessMsg.wIdent = RM_PUSH) then
            s1C := EncodeBuffer(@CharDesc, 8)
          else
            s1C := EncodeBuffer(@CharDesc, SizeOf(CharDesc));

          nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
          if ProcessMsg.sMsg <> '' then
          begin
            if Tbaseobject(ProcessMsg.BaseObject).m_sCharName = '替身' then
              s1C := s1C + EncodeString(' ' + '/' + IntToStr(nObjCount))
            else
              //  s1C:=s1C +  EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
              stemp := ProcessMsg.sMsg + '/' + IntToStr(nObjCount);
            Fillchar(buffer, 1000, 0);
            strpcopy(@buffer[0], stemp);
            ysfenghao.b1 := 0;
            ysfenghao.n1 := TBaseObject(ProcessMsg.BaseObject).GetDress;
            ncount := 5;
            if TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT then
            begin
              copymemory(@buffer[length(stemp)], @ysfenghao, sizeof(Tysfenghao));
              ncount := sizeof(Tysfenghao);
            end
            else
              copymemory(@buffer[length(stemp) + 1], @ysfenghao.n1, 4);

            s1C := s1C + encodebuffer(@buffer[0], length(stemp) + ncount);
          end
          else
          begin
            if Tbaseobject(ProcessMsg.BaseObject).M_monitemmake > 0 then
            begin
              s1C := s1C + EncodeString(Tbaseobject(ProcessMsg.BaseObject).GetShowName +
                '/' + IntToStr(nObjCount))
            end;

          end;
          //   s1C:=s1C+ProcessMsg.sMsg + '/' + IntToStr(nObjCount);   //hint 修改

          if (ProcessMsg.wIdent = RM_TURN) and (ProcessMsg.sMsg <> '') then
          begin
            if (Tbaseobject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) and
              (Tplayobject(ProcessMsg.BaseObject).sYsnameMaster <> '') and
              (Tplayobject(ProcessMsg.BaseObject).m_boStartshow) then
            begin
              SendDefMessage(510, integer(ProcessMsg.BaseObject), 1, 0, 22, '');
              if (Tplayobject(ProcessMsg.BaseObject).sYsnameMaster = m_sCharName) then
                SysMsg('神奇的力量凝聚，你的元神分身被唤醒了。', c_Red, t_Hint);
              Tplayobject(ProcessMsg.BaseObject).m_boStartshow := false;
            end;
            if (Tbaseobject(ProcessMsg.BaseObject).m_sCharName = '替身') or
              (Tbaseobject(ProcessMsg.BaseObject).m_sCharName = '尸灵') then
            begin
              m_DefMsg := MakeDefaultMsg(20, Integer(ProcessMsg.BaseObject),
                ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
                TBaseObject(ProcessMsg.BaseObject).m_btGender)); //hint     出线的人物性别
              SendSocket(@m_DefMsg, s1C);
            end;
            m_DefMsg := MakeDefaultMsg(SM_TURN, Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1, ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
              TBaseObject(ProcessMsg.BaseObject).m_btGender)); //hint     出线的人物性别

          end;
          {  if (Tbaseobject(ProcessMsg.BaseObject).m_btRaceServer= RC_PLAYOBJECT) then begin
              CharDress.dress:=TBaseObject(ProcessMsg.BaseObject).GetDress;
              CharDress.bt:=0;
              s1C:=s1C+ encodebuffer(@CharDress,5);
              SendSocket(@m_DefMsg,s1C);
            end else begin
              SendSocket(@m_DefMsg,s1C);
            end;   }

          SendSocket(@m_DefMsg, s1C);
          if (ProcessMsg.wIdent = RM_TURN) and (ProcessMsg.sMsg <> '') then
          begin

            nObjCount := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong();

            ndreshape := TBaseObject(ProcessMsg.BaseObject).GetDress;

            m_DefMsg := MakeDefaultMsg(keyStringType.varSM_FEATURECHANGED,
              Integer(ProcessMsg.BaseObject),
              LoWord(nObjCount),
              HiWord(nObjCount),
              TBaseObject(ProcessMsg.BaseObject).GetFeatureEx);

            if ((Tbaseobject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) or
              (Tbaseobject(ProcessMsg.BaseObject).m_btRaceServer = RC_YSBJECT)) then
              SendSocket(@m_DefMsg, encodebuffer(@ndreshape, 4))
            else
              SendSocket(@m_DefMsg, '');

            m_DefMsg := MakeDefaultMsg(SM_USERNAME,
              Integer(ProcessMsg.BaseObject),
              GetCharColor(TBaseObject(ProcessMsg.BaseObject)), 0, 0);
            SendSocket(@m_DefMsg,
              EncodeString(TBaseObject(ProcessMsg.BaseObject).GetShowName));

            if TBaseObject(ProcessMsg.BaseObject).m_bolinghunqiang then
            begin
              m_DefMsg := MakeDefaultMsg(803, integer(ProcessMsg.BaseObject), 0, 0, 0);
              YSFLAG := 0;
              SendSocket(@m_DefMsg, encodebuffer(@YSFLAG, 4)); //

            end;

            //豹子摆摊
            if (TBaseObject(ProcessMsg.BaseObject).m_boPetOnSell) and
              (Tbaseobject(ProcessMsg.BaseObject).m_btRaceServer <> RC_PLAYOBJECT) then
            begin                                           //摆摊状态
              // SendDefMessage(SM_HIDE,Integer(ProcessMsg.BaseObject), Tbaseobject(ProcessMsg.BaseObject).m_wStatusTimeArr[STATE_14],100,154,'');
              m_DefMsg := MakeDefaultMsg(32982,
                Integer(ProcessMsg.BaseObject),
                Tbaseobject(ProcessMsg.BaseObject).m_nCurrX, //x
                Tbaseobject(ProcessMsg.BaseObject).m_nCurrY, //y
                Tbaseobject(ProcessMsg.BaseObject).m_btDirection); //方向

              if TBaseObject(ProcessMsg.BaseObject).m_nOnsellcount > 0 then
              begin                                         //开始摆摊   > 0
                SELLITEMFLAG.w1 := 0;
                SELLITEMFLAG.sellend := 0;

                if TBaseObject(ProcessMsg.BaseObject).m_nflagforsell then
                begin                                       //是否有旗帜
                  SELLITEMFLAG.bflag := 1;                  //
                  SELLITEMFLAG.flagcolor :=
                    TBaseObject(ProcessMsg.BaseObject).m_nflagforsellcolor;  //       4294917162红色 4284216761   绿色   //0黄色
                end
                else
                  SELLITEMFLAG.bflag := 0;
                sellitemflag.w1 := TBaseObject(ProcessMsg.BaseObject).m_nFlagType;
                StrPCopy(SELLITEMFLAG.SellName,
                  TBaseObject(ProcessMsg.BaseObject).m_Sonsellname);
              end
              else
              begin
                SELLITEMFLAG.w1 := 0;
                SELLITEMFLAG.sellend := 255;                //收摊
              end;

              s1C := EncodeBuffer(@SELLITEMFLAG, SizeOf(TSELLITEMFLAG));
              SendSocket(@m_DefMsg, s1C);

            end;

            if (Tbaseobject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) or
              ((Tbaseobject(ProcessMsg.BaseObject).m_btRaceServer = RC_YSBJECT) and
              (TMonsteys(ProcessMsg.BaseObject).m_btwing = 2)) then
            begin
              //   if Tplayobject(ProcessMsg.BaseObject).m_sfenghao<>'' then   begin
              //if Tplayobject(ProcessMsg.BaseObject).sYsnameMaster = '' then
              begin
                if Tbaseobject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT then
                  SendDefMessage(21292,
                    Integer(ProcessMsg.BaseObject),
                    makeword(8, Tplayobject(ProcessMsg.BaseObject).m_nfenghaolevel),
                    0,
                    0,
                    Tplayobject(ProcessMsg.BaseObject).m_sfenghao)
                else
                  SendDefMessage(21292,
                    Integer(ProcessMsg.BaseObject),
                    264,
                    0,
                    0,
                    Tplayobject(ProcessMsg.BaseObject).m_sfenghao)

              end;
              {   else
                 begin

                   SendDefMessage(21292,
                     Integer(ProcessMsg.BaseObject),
                               // 8,// makeword(8,1),//
                     makeword(8, Tplayobject(ProcessMsg.BaseObject).m_nfenghaolevel),
                     Tplayobject(ProcessMsg.BaseObject).GetYSfenghao(Tplayobject(ProcessMsg.BaseObject).M_YSfenghao),
                     0,'');
                 end; }
                 //   end;

              if Tplayobject(ProcessMsg.BaseObject).m_boHavebeArp then
              begin                                         //变身状态
                SendDefMessage(21292,
                  Integer(ProcessMsg.BaseObject),
                  64,
                  19,
                  Tplayobject(ProcessMsg.BaseObject).m_nApprNum,
                  '');
              end;
              if Tplayobject(ProcessMsg.BaseObject).m_bohashuanying then
              begin
                SendDefMessage(21292, Integer(ProcessMsg.BaseObject), 0, 16, 2, '');
              end;

              if Tplayobject(ProcessMsg.BaseObject).m_bohashuancai then
              begin
                SendDefMessage(21292, Integer(ProcessMsg.BaseObject), 0, 16, 1, '');
              end;

              if (Tbaseobject(ProcessMsg.BaseObject).m_wStatusArrValue[6] > 0) or
                (Tbaseobject(ProcessMsg.BaseObject).m_wStatusArrValue[7] > 0) or
                (Tbaseobject(ProcessMsg.BaseObject).m_wStatusArrValue[8] > 0) then
              begin
                magaddtype := 0;
                if TBaseObject(ProcessMsg.BaseObject).m_wStatusArrValue[6] > 0 then
                  inc(magaddtype, 1);
                if TBaseObject(ProcessMsg.BaseObject).m_wStatusArrValue[7] > 0 then
                  inc(magaddtype, 2);
                if TBaseObject(ProcessMsg.BaseObject).m_wStatusArrValue[8] > 0 then
                  inc(magaddtype, 4);

                SendDefMessage(21292, Integer(ProcessMsg.BaseObject), magaddtype, 0, 0,
                  '');

              end;

              if Tbaseobject(ProcessMsg.BaseObject).m_wStatusTimeArr[STATE_14] > 0 then
              begin
                SendDefMessage(SM_HIDE, Integer(ProcessMsg.BaseObject),
                  Tbaseobject(ProcessMsg.BaseObject).m_wStatusTimeArr[STATE_14], 100, 154,
                  '');
                //护身真气的状态
              end;

              if Tplayobject(ProcessMsg.BaseObject).m_boOnSellItem then
              begin                                         //摆摊状态
                // SendDefMessage(SM_HIDE,Integer(ProcessMsg.BaseObject), Tbaseobject(ProcessMsg.BaseObject).m_wStatusTimeArr[STATE_14],100,154,'');
                m_DefMsg := MakeDefaultMsg(SM_SELLITEM,
                  Integer(ProcessMsg.BaseObject),
                  Tbaseobject(ProcessMsg.BaseObject).m_nCurrX, //x
                  Tbaseobject(ProcessMsg.BaseObject).m_nCurrY, //y
                  Tbaseobject(ProcessMsg.BaseObject).m_btDirection); //方向

                if Tplayobject(ProcessMsg.BaseObject).m_nOnsellcount > 0 then
                begin                                       //开始摆摊   > 0
                  SELLITEMFLAG.w1 := 0;
                  SELLITEMFLAG.sellend := 0;

                  if Tplayobject(ProcessMsg.BaseObject).m_nflagforsell then
                  begin                                     //是否有旗帜
                    SELLITEMFLAG.bflag := 1;                //
                    SELLITEMFLAG.flagcolor := self.m_nflagforsellcolor;  //       4294917162红色 4284216761   绿色   //0黄色
                  end
                  else
                    SELLITEMFLAG.bflag := 0;

                  StrPCopy(SELLITEMFLAG.SellName,
                    Tplayobject(ProcessMsg.BaseObject).m_Sonsellname);
                end
                else
                begin
                  SELLITEMFLAG.w1 := 0;
                  SELLITEMFLAG.sellend := 255;              //收摊
                end;

                s1C := EncodeBuffer(@SELLITEMFLAG, SizeOf(TSELLITEMFLAG));
                SendSocket(@m_DefMsg, s1C);

              end;

            end;                                            // = RC_PLAYOBJECT

          end; //  if ProcessMsg.wIdent = RM_TURN
        end;
      end;
    RM_STRUCK,
      RM_STRUCK_MAG:
      begin                                                 //10020 004D8B28
        if ProcessMsg.wParam {nPower} > 0 then
        begin
          if ProcessMsg.BaseObject = Self then
          begin
            if TBaseObject(ProcessMsg.nParam3) {AttackBaseObject} <> nil then
            begin
              if (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) and
                (m_btRaceServer = RC_PLAYOBJECT) then
              begin
                SetPKFlag(TBaseObject(ProcessMsg.nParam3) {AttackBaseObject});
              end;
              SetLastHiter(TBaseObject(ProcessMsg.nParam3) {AttackBaseObject});
              {
              //反复活
              if TBaseObject(ProcessMsg.nParam3).m_boUnRevival then
                m_boRevival:=False;
              }
            end;                                            //004D8B67
            if PKLevel >= 2 then
              m_dw5D4 := GetTickCount();
            //if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) and (TBaseObject(ProcessMsg.nParam3) <> nil) then begin
            if (g_CastleManager.IsCastleMember(Self) <> nil) and
              (TBaseObject(ProcessMsg.nParam3) <> nil) then
            begin
              TBaseObject(ProcessMsg.nParam3).bo2B0 := True;
              TBaseObject(ProcessMsg.nParam3).m_dw2B4Tick := GetTickCount();
            end;
            m_nHealthTick := 0;
            m_nSpellTick := 0;
            Dec(m_nPerHealth);
            Dec(m_nPerSpell);
            m_dwStruckTick := GetTickCount();               //09/10
          end;                                              //4D8BE1
          if ProcessMsg.BaseObject <> nil then
          begin
            if ((ProcessMsg.BaseObject = Self) and (g_Config.boDisableSelfStruck)) or
              ((TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) and
              g_Config.boDisableStruck) then
            begin
              TBaseObject(ProcessMsg.BaseObject).SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0,
                0, 0, '');
            end
            else
            begin
              //// 攻击掉血显示
              {
              if g_Config.ShowHitHp = 1 then
              begin
                if (TBaseObject(ProcessMsg.BaseObject) <> Self) and g_Config.ShowHpPresent then
                  m_DefMsg := MakeDefaultMsg(SM_47,
                    Integer(ProcessMsg.BaseObject),
                    round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP / _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100), // TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                    100, // TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,

                                                   //  TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                                                   //  TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
                    ProcessMsg.wParam)
                else
                  m_DefMsg := MakeDefaultMsg(SM_47,
                    Integer(ProcessMsg.BaseObject),
                    TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                    TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
                    ProcessMsg.wParam);

                sm47dat.nFeature := TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong;
                sm47dat.nStatus := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
                sm47dat.nplayobject := ProcessMsg.nParam3;
                sm47dat.n4 := $20000; //ProcessMsg.nParam1;
                SendSocket(@m_DefMsg, EncodeBuffer(@sm47dat, SizeOf(Tsm47dat)));

              end;
              }
              /////////
              if (ProcessMsg.BaseObject <> Self) and g_Config.ShowHpPresent then
                m_DefMsg := MakeDefaultMsg(SM_STRUCK,
                  Integer(ProcessMsg.BaseObject),
                  round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP /
                    _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100),  // TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                  100, //TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
                  ProcessMsg.wParam)
              else
                m_DefMsg := MakeDefaultMsg(SM_STRUCK,
                  Integer(ProcessMsg.BaseObject),
                  TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                  TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
                  ProcessMsg.wParam);

              MessageBodyWL.lParam1 :=
                TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
              MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
              MessageBodyWL.lTag1 := ProcessMsg.nParam3;
              if ProcessMsg.wIdent = RM_STRUCK_MAG then
                MessageBodyWL.lTag2 := 0
              else
                MessageBodyWL.lTag2 := 131072;
              MessageBodyWL.lTag2 := 0;
              SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL,
                SizeOf(TMessageBodyWL)));
              //    TBaseObject(ProcessMsg.BaseObject).SysMsg('被HIT HP='+INTTOSTR(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP),c_Red,t_Hint);
               //   TBaseObject(ProcessMsg.BaseObject).SendRefMsg(RM_47,ProcessMsg.wParam,$20000,0,ProcessMsg.nParam3,'');  // $20000   掉血显示
                 // TBaseObject(ProcessMsg.BaseObject).SendRefMsg(RM_HEALTHSPELLCHANGED,0,0,0,0,'');
                 //
              TBaseObject(ProcessMsg.BaseObject).HealthSpellChanged;
              {  m_DefMsg:=MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
                       Integer(ProcessMsg.BaseObject),
                       TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                       TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP,
                       TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);

                SendSocket(@m_DefMsg,'') ;
                }
              if TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT then
              begin
                if TPlayObject(ProcessMsg.BaseObject).sYsnameMaster <> '' then
                begin
                  inc(TPlayObject(ProcessMsg.BaseObject).nyuanqi, _min(10,
                    ProcessMsg.wParam div 10));
                  TPlayObject(ProcessMsg.BaseObject).SendDefMessage(38417, 0,
                    TPlayObject(ProcessMsg.BaseObject).nyuanqi,
                    _Max(TPlayObject(ProcessMsg.BaseObject).nyuanqi, 100), 0, '');
                  inc(TPlayObject(ProcessMsg.BaseObject).nyuanqi, _min(10,
                    ProcessMsg.wParam div 10));
                  TPlayObject(ProcessMsg.BaseObject).SendDefMessage(38417, 0,
                    TPlayObject(ProcessMsg.BaseObject).nyuanqi,
                    _Max(TPlayObject(ProcessMsg.BaseObject).nyuanqi, 100), 0, '');
                end;
              end;
            end;
          end;
        end;
      end;
    RM_DEATH:
      begin                                                 //10021 004D8C9D
        if ProcessMsg.nParam3 = 1 then
        begin
          m_DefMsg := MakeDefaultMsg(SM_NOWDEATH,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);

        end
        else
        begin
          m_DefMsg := MakeDefaultMsg(SM_DEATH,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
        end;
        CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        TBaseObject(ProcessMsg.BaseObject).FeatureChanged;
        // TBaseObject(ProcessMsg.BaseObject).SendRefMsg(RM_21292, 0, 264, 0, 0, '');

      end;
    RM_DISAPPEAR:
      begin                                                 //10022 004D915C
        m_DefMsg := MakeDefaultMsg(SM_DISAPPEAR,
          Integer(ProcessMsg.BaseObject),
          0, 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_SKELETON:
      begin                                                 //10024 004D8D7B
        m_DefMsg := MakeDefaultMsg(SM_SKELETON,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.wParam);
        CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
      end;
    RM_USERNAME:
      begin                                                 //10043 004D9587
        m_DefMsg := MakeDefaultMsg(SM_USERNAME,
          Integer(ProcessMsg.BaseObject),
          GetCharColor(TBaseObject(ProcessMsg.BaseObject)), 0, 0);
        SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;

    RM_WINEXP:
      begin                                                 //10044 004D95FE
        m_DefMsg := MakeDefaultMsg(SM_WINEXP, m_Abil.Exp, LoWord(ProcessMsg.nParam1),
          HiWord(ProcessMsg.nParam1), 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_LEVELUP:
      begin                                                 //10045 004D965B
        if sYsnameMaster = '' then
          SaveToPlayList(self);                             //处理人物到 TOPPLAYLIST
        m_DefMsg := MakeDefaultMsg(SM_LEVELUP, m_Abil.Exp, m_Abil.Level, 0, 0);
        SendSocket(@m_DefMsg, '');
        //  m_DefMsg:=MakeDefaultMsg(SM_ABILITY,m_nGold,MakeWord(m_btJob,99),LoWord(m_nGameGold),HiWord(m_nGameGold));      //hint
        // if sYsnameMaster<>'' then YSFLAG:=255 else YSFLAG:=m_btGender*256+m_btJob;
          {  if sYsnameMaster<>'' then YSFLAG:=255 else YSFLAG:=256;
            if sysname<>'' then begin
               hum:=nil;
               hum:=UserEngine.GetPlayObjectEx(sysname);
               if hum<>nil then YSFLAG:=257 - hum.m_btGender;
            end;
          }

        if sysname <> '' then
        begin
          YSFLAG := (nyssex + 1) * 256 + 1;
          {
           hum:=nil;
           hum:=UserEngine.GetPlayObjectEx(sysname);
           if hum<>nil then YSFLAG:=(hum.m_btGender+1)*256+1;    }
        end
        else
          YSFLAG := 0;
        if sYsnameMaster <> '' then
          YSFLAG := $FF;                                    //m_btGender*  +m_btJob
        m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, m_btJob, YSFLAG, 0);  // m_nGameGold  //hint   m_btGender, m_nGameGold
        //0806 增加

    //  if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then
        begin
          GetOldAbil(OAbility);

          copymemory(@myOAbility, @OAbility, SizeOf(TOAbility));
          myOAbility.lingli := m_YSPoint;
          myOAbility.yuanqi := nyuanqi;

          //  myOAbility.yslevel:=345;
          SendSocket(@m_DefMsg, EncodeBuffer(@myOAbility, SizeOf(TmyOAbility)));
          // SendSocket(@m_DefMsg,EncodeBuffer(@OAbility,SizeOf(TOAbility)));
        end;

        //SendSocket(@m_DefMsg,EncodeBuffer(@m_WAbil,SizeOf(TAbility)));
        SUBABILITYDATA.nActiveMax := 60000;
        if m_nGamePoint > 60000 then
          m_nGamePoint := 60000;
        SUBABILITYDATA.nActive := m_nGamePoint;
        SUBABILITYDATA.color := 1;
        SUBABILITYDATA.jpactive := 100;                     //m_nPkPoint;
        SUBABILITYDATA.ubyte := 1;
        //    SUBABILITYDATA.jpactivemax   :=3000;
        m_DefMsg := MakeDefaultMsg(SM_SUBABILITY, MakeLong(MakeWord(m_nAntiMagic * 10,
          m_btCreditPoint), 0), MakeWord(m_btHitPoint, m_btSpeedPoint),
          MakeWord(m_btAntiPoison, m_nPoisonRecover), MakeWord(m_nHealthRecover,
          m_nSpellRecover));

        SendSocket(@m_DefMsg, EncodeBuffer(@SUBABILITYDATA, SizeOf(SUBABILITYDATA)));

      end;
    RM_CHANGENAMECOLOR:
      begin                                                 //10046 004D9555
        SendDefMessage(SM_CHANGENAMECOLOR,
          Integer(ProcessMsg.BaseObject),
          GetCharColor(TBaseObject(ProcessMsg.BaseObject)),
          0,
          0,
          '');
      end;
    RM_LOGON:
      begin                                                 //10050
        if m_PEnvir.m_boDARK then
          nObjCount := 1
        else
        begin
          case m_nBright of
            1: nObjCount := 0;
            3: nObjCount := 1;
          else
            nObjCount := 1;
          end;
        end;
        if m_PEnvir.m_boDAY then
          nObjCount := 0;
        m_DefMsg := MakeDefaultMsg(SM_NEWMAP, Integer(Self), m_nCurrX, m_nCurrY,
          nObjCount);
        if m_PEnvir.mirrorname = '' then
          smapname := ProcessMsg.sMsg
        else
          smapname := m_PEnvir.mirrorname;                  //地图镜像
        SendSocket(@m_DefMsg, EncodeString(smapname));      // m_sMapName
        SendMsg(Self, RM_CHANGELIGHT, 0, 0, 0, 0, '');
        SendLogon();
        SendServerConfig();
        ClientQueryUserName(Self, m_nCurrX, m_nCurrY);
        RefUserState();
        SendMapDescription();

        SendGoldInfo(True);
        if m_sDearName <> '' then
          CheckMarry();

        CheckMaster();
        CheckFriend();

        SendDefMessage(808, 1, 0, 0, 0, '');
        SendDefMessage(59002, m_ngamecode, 0, 0, 0, '');
        //SendDefMessage(SM_GAMEGOLDNAME,m_nGameGold,LoWord(m_nGamePoint),HiWord(m_nGamePoint),0,g_Config.sGameGoldName + #13 + g_Config.sGamePointName);
        m_DefMsg := MakeDefaultMsg(SM_VERSION_FAIL, -220920361, 0, 0, 0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_HEAR,
      RM_WHISPER,
      RM_CRY,
      RM_SYSMESSAGE,
      RM_GROUPMESSAGE,
      RM_SYSMESSAGE2,
      RM_GUILDMESSAGE,
      RM_SYSMESSAGE3,
      RM_MERCHANTSAY,
      rm_8941, rm_8942, Rm_768, RM_ColorMsg:
      begin

        case ProcessMsg.wIdent of                           //004D97B3
          RM_HEAR:
            begin
              if (ProcessMsg.BaseObject <> nil) and
                (TBaseObject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) and
                (tplayobject(ProcessMsg.BaseObject).m_bohasmagicfont) then
                m_DefMsg := MakeDefaultMsg(SM_HEAR, Integer(ProcessMsg.BaseObject),
                  MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0,
                  makeword(tplayobject(ProcessMsg.BaseObject).m_wmagicfontcolor,
                  tplayobject(ProcessMsg.BaseObject).m_wmagicfont))  //10030      //1 MAKEWORD(FCOLOR,FTYPE)
              else
                m_DefMsg := MakeDefaultMsg(SM_HEAR, Integer(ProcessMsg.BaseObject),
                  MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1);  //10030      //1 MAKEWORD(FCOLOR,FTYPE)

            end;
          RM_WHISPER: m_DefMsg := MakeDefaultMsg(SM_WHISPER,
            Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
            ProcessMsg.nParam2), 0, 1);                       //10031
          RM_CRY: m_DefMsg := MakeDefaultMsg(SM_HEAR, Integer(ProcessMsg.BaseObject),
            MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, 1); //10032
          RM_SYSMESSAGE: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE,
            Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
            ProcessMsg.nParam2), 151, 1);                     //10100 //0 红色
          rm_8942: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE,
            Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
            ProcessMsg.nParam2), 151, 10);                    //顶部漂黄字
          Rm_768: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE,
            Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
            ProcessMsg.nParam2), 0, 768);                     //顶部漂黄字
          //RM_SYSMESSAGE2: m_DefMsg:=MakeDefaultMsg(SM_SYSMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($DB,$FF),0,1);//10103
          //RM_SYSMESSAGE3: m_DefMsg:=MakeDefaultMsg(SM_GUILDMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($FF,$FC),0,1);//10105
          RM_ColorMsg: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE,
            Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
            ProcessMsg.nParam2), 0, 1);                       //顶部漂黄字
          RM_GROUPMESSAGE: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE,
            Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
            ProcessMsg.nParam2), 0, 1);                       //10102
          RM_GUILDMESSAGE: m_DefMsg := MakeDefaultMsg(SM_GUILDMESSAGE,
            Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
            ProcessMsg.nParam2), 0, 1);                       //10104
          RM_MERCHANTSAY:
            begin

              m_DefMsg := MakeDefaultMsg(SM_MERCHANTSAY, Integer(ProcessMsg.BaseObject),
                MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), ProcessMsg.nParam3, 1)

            end;
          rm_8941: m_DefMsg := MakeDefaultMsg(8941, Integer(ProcessMsg.BaseObject),
            MakeWord(ProcessMsg.nParam1, ProcessMsg.nParam2), 0, ProcessMsg.nParam3);  //10126
        end;
        if not ((sYsnameMaster <> '') and (ProcessMsg.wIdent = RM_HEAR)) then  //如果不是元神发
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
      end;

    RM_ABILITY:
      begin

        if sysname <> '' then
        begin
          YSFLAG := (nyssex + 1) * 256 + 2;                 // 1
        end
        else
          YSFLAG := 0;
        YSPoint := 0;
        if sYsnameMaster <> '' then
        begin
          YSFLAG := $FF;
          //   hum := self.ysmasterplayer;
           //  if hum <> nil then
           //    YSPoint := hum.m_YSPoint;
        end;
        // else
        YSPoint := m_YSPoint;
        m_DefMsg := MakeDefaultMsg(SM_ABILITY,
          m_nGold,
          m_btJob,
          YSFLAG,
          0);
        GetOldAbil(OAbility);
        copymemory(@myOAbility, @OAbility, SizeOf(TOAbility));
        myOAbility.lingli := YSPoint;                       //灵力值
        myOAbility.yuanqi := 100;

        SendSocket(@m_DefMsg, EncodeBuffer(@MyOAbility, SizeOf(TMYOAbility)));

      end;
    RM_HEALTHSPELLCHANGED:
      begin                                                 //10052
        if (ProcessMsg.BaseObject <> Self) and g_Config.ShowHpPresent then
          m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
            Integer(ProcessMsg.BaseObject),
            round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP /
              _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100),  // TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP,
            100) // TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
        else
          m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
            Integer(ProcessMsg.BaseObject),
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);

        SendSocket(@m_DefMsg, '');

      end;
    RM_DAYCHANGING:
      begin                                                 //10053
        if m_PEnvir.m_boDARK then nObjCount := 1
        else
        begin
          case m_nBright of
            1: nObjCount := 0;
            3: nObjCount := 1;
          else nObjCount := 1;
          end;
        end;
        s1c := EncodeBuffer(@m_PEnvir.m_WinsColor, 4);
        m_DefMsg := MakeDefaultMsg(SM_DAYCHANGING, -1, m_nBright,
          m_PEnvir.m_weatherEffect, m_PEnvir.m_WindSpeed);    //0，

        SendSocket(@m_DefMsg, S1C);
      end;
    RM_ITEMSHOW:
      begin                                                 //10110 004D9D01
        SendDefMessage(SM_ITEMSHOW,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.wParam,
          ProcessMsg.sMsg);
        UpdateVisibleItem(ProcessMsg.nParam2, ProcessMsg.nParam3,
          pTMapItem(ProcessMsg.nParam1));
        //hint 添加 物品 掉地只显示一次
      end;
    RM_ITEMHIDE:
      begin                                                 //10111 004D9D27
        SendDefMessage(SM_ITEMHIDE,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0,
          '');
      end;
    RM_DOOROPEN:
      begin                                                 //10112 004D9D6A
        SendDefMessage(SM_OPENDOOR_OK,
          0,
          ProcessMsg.nParam1,                               {x}
          ProcessMsg.nParam2,                               {y}
          0,
          '');
      end;
    RM_DOORCLOSE:
      begin                                                 //10113 004D9D8A
        SendDefMessage(SM_CLOSEDOOR,
          0,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          '');
      end;
    RM_SENDUSEITEMS: SendUseitems();
    RM_WEIGHTCHANGED:
      begin                                                 //10115 004D9DC4
        SendDefMessage(SM_WEIGHTCHANGED,
          m_WAbil.Weight,
          m_WAbil.WearWeight,
          m_WAbil.HandWeight,
          0,
          '');
      end;
    RM_FEATURECHANGED:
      begin                                                 //10116 004D9E1A
        m_DefMsg := MakeDefaultMsg(keyStringType.varSM_FEATURECHANGED,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam1),
          HiWord(ProcessMsg.nParam1),
          ProcessMsg.wParam);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);

        { SendDefMessage(varSM_FEATURECHANGED,//str_toint(myMuldecodeString(keystring.SM_FEATURECHANGED,Str_ToInt(arrip[6],0)),0),                 //hint  外观变化     SM_FEATURECHANGED
                        Integer(ProcessMsg.BaseObject),     //dwflag
                        LoWord(ProcessMsg.nParam1),            //w1  ProcessMsg.nParam1
                        HiWord(ProcessMsg.nParam1),             //w2 ProcessMsg.nParam1
                        ProcessMsg.wParam,                      //w3
                        ProcessMsg.sMsg ); //  ''   }
      end;
    RM_CLEAROBJECTS:
      begin                                                 //10117 004D9E71
        SendDefMessage(SM_CLEAROBJECTS,
          0,
          0,
          0,
          0,
          '');
      end;

    RM_CHANGEMAP:
      begin
        if m_PEnvir.m_boDARK then
          nObjCount := 1
        else
        begin
          case m_nBright of
            1: nObjCount := 0;
            3: nObjCount := 1;
          else
            nObjCount := 1;
          end;
        end;

        if m_PEnvir.m_boDAY then
          nObjCount := 0;
        if m_PEnvir.mirrorname = '' then
          smapname := ProcessMsg.sMsg
        else
          smapname := m_PEnvir.mirrorname;                  //地图镜像
        SendDefMessage(SM_CHANGEMAP, Integer(Self), m_nCurrX, m_nCurrY, nObjCount,
          smapname);
        RefUserState();
        SendMapDescription();
        SendServerConfig();
        CheckHorse;
        SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');

      end;
    RM_BUTCH:
      begin                                                 //10119 004D86B1
        if ProcessMsg.BaseObject <> nil then
        begin
          m_DefMsg := MakeDefaultMsg(SM_BUTCH,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          SendSocket(@m_DefMsg, '');
        end;

      end;
    RM_MAGICFIRE:
      begin                                                 //10120 004D8A90
        m_DefMsg := MakeDefaultMsg(SM_MAGICFIRE,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam2),
          HiWord(ProcessMsg.nParam2),                       // MakeLong(nTargetX,nTargetY)
          ProcessMsg.nParam1); // MakeWord(UserMagic.MagicInfo.btEffectType,UserMagic.MagicInfo.btEffect)
        MAGICFIRE.Targe := ProcessMsg.nParam3;
        if (TBaseobject(ProcessMsg.BaseObject).m_btRaceServer = RC_PLAYOBJECT) and
          tplayobject(ProcessMsg.BaseObject).m_bomagiccolorchange then
          MAGICFIRE.color := tplayobject(ProcessMsg.BaseObject).m_nmagiccolor;  //16711932; //紫色
        MAGICFIRE.count := ProcessMsg.wParam;
        SendSocket(@m_DefMsg, EncodeBuffer(@MAGICFIRE, SizeOf(tMAGICFIRE)));  //Integer(TargeTBaseObject)
      end;
    RM_MAGICFIREFAIL:
      begin                                                 //10121
        SendDefMessage(SM_MAGICFIRE_FAIL, Integer(ProcessMsg.BaseObject), 0, 0, 0, '');
      end;
    RM_SENDMYMAGIC: SendUseMagic;                           //10122

    RM_YSStart:
      begin
        if sYsnameMaster <> '' then
        begin                                               //如果是元神
          SendDefMessage(38409, integer(self), 0, 0, 0, m_sCharName);
        end;
      end;

    RM_MAGIC_LVEXP:
      begin                                                 //10123 004D9E8D
        SendDefMessage(SM_MAGIC_LVEXP,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          LoWord(ProcessMsg.nParam3),
          HiWord(ProcessMsg.nParam3),
          '');
      end;
    RM_DURACHANGE:
      begin                                                 //10125 004D9EB9
        SendDefMessage(SM_DURACHANGE,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          LoWord(ProcessMsg.nParam2),
          HiWord(ProcessMsg.nParam2),
          '');
      end;
    RM_MERCHANTDLGCLOSE:
      begin                                                 //10127 004D9ADF
        SendDefMessage(SM_MERCHANTDLGCLOSE,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_SENDFASTGOODSLIST:
      begin
        SendDefMessage(3039,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          ProcessMsg.sMsg, true);
      end;
    RM_SENDGOODSLIST:
      begin                                                 //10128 004D9AFC 3039,//
        SendDefMessage(SM_SENDGOODSLIST,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          ProcessMsg.sMsg);
      end;
    RM_SENDUSERSELL:
      begin                                                 //10129 004D9B1D
        SendDefMessage(SM_SENDUSERSELL,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          ProcessMsg.sMsg);
      end;
    RM_SENDBUYPRICE:
      begin                                                 //10130  004D9BAB
        SendDefMessage(SM_SENDBUYPRICE,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_USERSELLITEM_OK:
      begin                                                 //10131  004D9BC8
        SendDefMessage(SM_USERSELLITEM_OK,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_USERSELLITEM_FAIL:
      begin                                                 //10132  004D9BC8
        SendDefMessage(SM_USERSELLITEM_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_BUYITEM_SUCCESS:
      begin                                                 //10133  004D9C02
        SendDefMessage(SM_BUYITEM_SUCCESS,
          ProcessMsg.nParam1,
          LoWord(ProcessMsg.nParam2),
          HiWord(ProcessMsg.nParam2),
          0,
          '');
      end;
    RM_BUYITEM_FAIL:
      begin                                                 //10134  004D9C2C
        SendDefMessage(SM_BUYITEM_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_SENDDETAILGOODSLIST:
      begin                                                 //10135  004D9C83
        m_DefMsg := MakeDefaultMsg(SM_SENDDETAILGOODSLIST, ProcessMsg.nParam1,
          ProcessMsg.nParam2, ProcessMsg.nParam3, 0);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        { SendDefMessage(SM_SENDDETAILGOODSLIST,
                        ProcessMsg.nParam1,
                        ProcessMsg.nParam2,
                        ProcessMsg.nParam3,
                        0,
                                        ProcessMsg.sMsg);  }//hint
      end;
    RM_GOLDCHANGED:
      begin                                                 //10136  004D9DFA
        SendDefMessage(SM_GOLDCHANGED,
          m_nGold,
          LoWord(m_nGameGold),
          HiWord(m_nGameGold),
          0,
          '');
      end;
    RM_GAMEGOLDCHANGED:
      begin
        SendGoldInfo(False);
        {
        SendDefMessage(SM_GAMEGOLDNAME,
                       m_nGameGold,
                       LoWord(m_nGamePoint),
                       HiWord(m_nGamePoint),
                       0,
                       '');
        }
      end;
    RM_CHANGELIGHT:
      begin                                                 //10137  004D9EE6
        SendDefMessage(SM_CHANGELIGHT,
          Integer(ProcessMsg.BaseObject),
          TBaseObject(ProcessMsg.BaseObject).m_nLight,
          g_Config.nClientKey,
          0,
          '');
      end;
    RM_LAMPCHANGEDURA:
      begin                                                 //10138 004D9F0B
        SendDefMessage(SM_LAMPCHANGEDURA,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_CHARSTATUSCHANGED:
      begin                                                 //10139 004D9E44
        SendDefMessage(SM_CHARSTATUSCHANGED,
          Integer(ProcessMsg.BaseObject),
          LoWord(ProcessMsg.nParam1),                       //m_nCharStatus
          HiWord(ProcessMsg.nParam1),
          ProcessMsg.wParam,                                //m_nHitSpeed
          '');
      end;
    RM_GROUPCANCEL:
      begin                                                 //10140 004D9F28
        SendDefMessage(SM_GROUPCANCEL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_SENDUSERREPAIR,
      RM_SENDUSERSREPAIR:
      begin                                                 //10141 004D9B3C
        SendDefMessage(SM_SENDUSERREPAIR,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          '');
      end;
    RM_USERREPAIRITEM_OK:
      begin                                                 //10143  004D9CA6
        SendDefMessage(SM_USERREPAIRITEM_OK,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          0,
          '');
      end;
    RM_SENDREPAIRCOST:
      begin                                                 //10142  004D9CE4
        SendDefMessage(SM_SENDREPAIRCOST,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_USERREPAIRITEM_FAIL:
      begin                                                 //10144  004D9CC7
        SendDefMessage(SM_USERREPAIRITEM_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_USERSTORAGEITEM:
      begin                                                 //10146  004D9B5B
        SendDefMessage(SM_SENDUSERSTORAGEITEM,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          '');
      end;
    RM_USERGETBACKITEM:
      begin //10147  004D9B7A  SM_SAVEITEMLIST
        SendSaveItemList(ProcessMsg.nParam1);
      end;
    RM_SENDDELITEMLIST:
      begin //10148  004D9D48  //SM_DELITEMS
        SendDelItemList(TStringList(ProcessMsg.nParam1));
        TStringList(ProcessMsg.nParam1).Free;
        ClientQueryBagItems;
      end;
    RM_USERMAKEDRUGITEMLIST:
      begin                                                 //10149  004D9B8A
        SendDefMessage(SM_SENDUSERMAKEDRUGITEMLIST,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0,
          0,
          ProcessMsg.sMsg);
      end;
    RM_MAKEDRUG_SUCCESS:
      begin                                                 //10150 004D9C49
        SendDefMessage(SM_MAKEDRUG_SUCCESS,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_MAKEDRUG_FAIL:
      begin                                                 //10151 004D9C66
        SendDefMessage(SM_MAKEDRUG_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_ALIVE:
      begin                                                 //10153 004D8E09
        m_DefMsg := MakeDefaultMsg(SM_ALIVE,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.wParam);
        CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);

        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
      end;
    rm_10206:
      begin
        m_DefMsg := MakeDefaultMsg(803,
          Integer(ProcessMsg.BaseObject),
          1,
          0,
          0); //   TBaseObject(ProcessMsg.BaseObject).m_nLight)
        MessageBodyWL.lParam1 := 0;
        s1C := EncodeBuffer(@MessageBodyWL, 4);
        SendSocket(@m_DefMsg, s1C);
      end;

    RM_DIGUP:
      begin                                                 //10200 004D91B4

        m_DefMsg := MakeDefaultMsg(SM_DIGUP,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_btGender));  //   TBaseObject(ProcessMsg.BaseObject).m_nLight)
        MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
        MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        MessageBodyWL.lTag1 := ProcessMsg.nParam3;
        MessageBodyWL.lTag1 := 0;
        s1C := EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL));
        SendSocket(@m_DefMsg, s1C);
        //06 05 12 增加
        SendDefMessage(SM_USERNAME,
          Integer(ProcessMsg.BaseObject),
          GetCharColor(TBaseObject(ProcessMsg.BaseObject)),
          0,
          0,
          TBaseObject(ProcessMsg.BaseObject).GetShowName);

      end;
    RM_DIGDOWN:
      begin                                                 //10201 004D9254
        m_DefMsg := MakeDefaultMsg(SM_DIGDOWN,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_FLYAXE:
      begin                                                 //10202 004D9358
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyW.Param1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyW.Param2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyW.Tag1 := LoWord(ProcessMsg.nParam3);
          MessageBodyW.Tag2 := HiWord(ProcessMsg.nParam3);
          m_DefMsg := MakeDefaultMsg(SM_FLYAXE,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW, SizeOf(TMessageBodyW)));
          if ProcessMsg.sMsg = 'ear' then
          begin

            m_DefMsg := MakeDefaultMsg(11228,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              1);
            SendSocket(@m_DefMsg, EncodeBuffer(@ProcessMsg.nParam3,
              SizeOf(ProcessMsg.nParam3)));
          end;

        end;

      end;
    RM_LIGHTING:
      begin                                                 //10204 004D93FD
        if TBaseObject(ProcessMsg.nParam3) <> nil then
        begin
          MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
          MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          MessageBodyWL.lTag2 := ProcessMsg.wParam;
          m_DefMsg := MakeDefaultMsg(SM_LIGHTING,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            TBaseObject(ProcessMsg.BaseObject).m_btDirection);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));
        end;
      end;
    RM_10205:
      begin                                                 //10205 004D949A
        SendDefMessage(SM_716,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1 {x},
          ProcessMsg.nParam2 {y},
          ProcessMsg.nParam3 {type},
          '');
      end;
    RM_CHANGEGUILDNAME:
      begin //10301 004D9F44  SM_CHANGEGUILDNAME
        SendChangeGuildName();
      end;
    RM_SUBABILITY:
      begin                                                 //10302
        SUBABILITYDATA.nActiveMax := 60000;
        if m_nGamePoint > 60000 then
          m_nGamePoint := 60000;
        SUBABILITYDATA.nActive := m_nGamePoint;
        //  SUBABILITYDATA.nunkown:=  1;
         // SUBABILITYDATA.wpk       :=100;//m_nPkPoint;
        SUBABILITYDATA.color := 1;
        SUBABILITYDATA.jpactive := m_nJpPoint;
        SUBABILITYDATA.ubyte := m_nluck;                    //幸运
        SUBABILITYDATA.btvalue1 := 0;                       //诅咒
        SUBABILITYDATA.btvalue2 := m_btMagicPoint;          //魔法命中
        SUBABILITYDATA.btvalue3 := m_btPoisonPoint;         //中毒命中
        SUBABILITYDATA.btvalue4 := 0;
        //  SUBABILITYDATA.jpactivemax   :=3000;
        m_DefMsg := MakeDefaultMsg(keyStringType.VARSM_SUBABILITY,  //str_toint(myMuldecodeString(keystring.SM_SUBABILITY,Str_ToInt(arrip[8],0)), 0 ),
          MakeLong(MakeWord(m_nAntiMagic * 10, m_btCreditPoint), 0),
            MakeWord(m_btHitPoint, m_btSpeedPoint), MakeWord(m_btAntiPoison,
            m_nPoisonRecover), MakeWord(m_nHealthRecover, m_nSpellRecover));

        SendSocket(@m_DefMsg, EncodeBuffer(@SUBABILITYDATA, SizeOf(SUBABILITYDATA)));

        //   SendDefMessage(38291,1,0,0,0,''); 个性化签名

       {    SendDefMessage(SM_SUBABILITY,
                        MakeLong(MakeWord(m_nAntiMagic,m_btCreditPoint),0), //声望   m_btCreditPoint
                        MakeWord(m_btHitPoint,m_btSpeedPoint),
                        MakeWord(m_btAntiPoison,m_nPoisonRecover),
                        MakeWord(m_nHealthRecover,m_nSpellRecover),
                        EncodeBuffer(@SUBABILITYDATA,SizeOf(SUBABILITYDATA)));  // ''
           }
      end;
    RM_BUILDGUILD_OK:
      begin                                                 //10303 004D9F51
        SendDefMessage(SM_BUILDGUILD_OK,
          0,
          0,
          0,
          0,
          '');
      end;
    RM_BUILDGUILD_FAIL:
      begin                                                 //10304 004D9F6D
        SendDefMessage(SM_BUILDGUILD_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_DONATE_OK:
      begin                                                 //10305 004D9FA7
        SendDefMessage(SM_DONATE_OK,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_DONATE_FAIL:
      begin                                                 //10306 004D9F8A
        SendDefMessage(SM_DONATE_FAIL,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          '');
      end;
    RM_MYSTATUS:
      begin
        SendDefMessage(SM_MYSTATUS, 0, GetMyStatus, 0, 0, '');
      end;
    RM_MENU_OK:
      begin                                                 //10309  004D9FC4
        SendDefMessage(SM_MENU_OK,
          ProcessMsg.nParam1,
          0,
          0,
          0,
          Replaceallstr(ProcessMsg.sMsg, '\', #13#10));
      end;
    //    RM_SPACEMOVE_FIRE,
    RM_SPACEMOVE_FIRE2:
      begin                                                 //10330 004D90BA
        if ProcessMsg.wIdent = RM_SPACEMOVE_FIRE then
        begin
          m_DefMsg := MakeDefaultMsg(SM_DISAPPEAR,          //  SM_SPACEMOVE_HIDE
            Integer(ProcessMsg.BaseObject),
            0,
            0,
            0);
        end
        else
        begin
          m_DefMsg := MakeDefaultMsg(SM_DISAPPEAR,          //SM_SPACEMOVE_HIDE2
            Integer(ProcessMsg.BaseObject),
            0,
            0,
            0);
        end;
        SendSocket(@m_DefMsg, '');
      end;
    RM_SPACEMOVE_SHOW,
      RM_SPACEMOVE_SHOW2:
      begin                                                 //004D8F62
        if ProcessMsg.wIdent = RM_SPACEMOVE_SHOW then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_btGender));  //     TBaseObject(ProcessMsg.BaseObject).m_nLight)
        end
        else
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW2,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_btGender));  //       TBaseObject(ProcessMsg.BaseObject).m_nLight)
        end;
        CharDesc.feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);

        CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        if (TBaseObject(ProcessMsg.BaseObject) <> Self) and g_Config.ShowHpPresent then
          CharDesc.xue := makelong(round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP /
            _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100), 100)  //hint 角色的血量 100/100
        else
          CharDesc.xue := makelong(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);
        s1C := EncodeBuffer(@CharDesc, SizeOf(TCharDesc));
        nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
        if ProcessMsg.sMsg <> '' then
        begin
          s1C := s1C + EncodeString(ProcessMsg.sMsg + '/' + IntToStr(nObjCount));
        end;
        SendSocket(@m_DefMsg, s1C);
      end;

    RM_TAKEHORSE:
      begin

        //  SendRefMsg(RM_TAKEHORSE,m_btDirection,m_nCurrX,m_nCurrY,0,'');
        m_DefMsg := MakeDefaultMsg(SM_TAKEHORSE,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          MakeWord(ProcessMsg.wParam, TBaseObject(ProcessMsg.BaseObject).m_btGender));  //1            //TBaseObject(ProcessMsg.BaseObject).m_nLight)
        if Tplayobject(ProcessMsg.BaseObject).ysmasterplayer <> nil then
        begin
          YSOnBaoZi.Feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          if TBaseObject(ProcessMsg.BaseObject).m_boBaoZiAttacked then
            YSOnBaoZi.btAttack := 2
          else
            YSOnBaoZi.btAttack := 0;
          s1C := EncodeBuffer(@YSOnBaoZi, SizeOf(TYSOnBaoZi));

          SendSocket(@m_DefMsg, s1C);

        end
        else
        begin

          chardesc.Feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          chardesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          if (TBaseObject(ProcessMsg.BaseObject) <> Self) and g_Config.ShowHpPresent then
            chardesc.xue := makelong(round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP
              / _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100), 100)  //hint 角色的血量 100/100
          else
            chardesc.xue := makelong(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
              TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);

          s1C := EncodeBuffer(@chardesc, SizeOf(Tchardesc));

          SendSocket(@m_DefMsg, s1C);
        end;
      end;
    RM_PetSellItem:
      begin
        if ProcessMsg.BaseObject <> self then
        begin
          m_DefMsg := MakeDefaultMsg(32982,
            Integer(ProcessMsg.BaseObject),
            Tbaseobject(ProcessMsg.BaseObject).m_nCurrX,    //x
            Tbaseobject(ProcessMsg.BaseObject).m_nCurrY,    //y
            Tbaseobject(ProcessMsg.BaseObject).m_btDirection); //方向

          if TBaseObject(ProcessMsg.BaseObject).m_nOnsellcount > 0 then
          begin                                             //开始摆摊   > 0
            SELLITEMFLAG.w1 := 0;
            SELLITEMFLAG.sellend := 0;

            if TBaseObject(ProcessMsg.BaseObject).m_nflagforsell then
            begin                                           //是否有旗帜
              SELLITEMFLAG.bflag := 1;                      //
              SELLITEMFLAG.flagcolor :=
                TBaseObject(ProcessMsg.BaseObject).m_nflagforsellcolor;  //       4294917162红色 4284216761   绿色   //0黄色
            end
            else
              SELLITEMFLAG.bflag := 0;
            sellitemflag.w1 := TBaseObject(ProcessMsg.BaseObject).m_nFlagType;
            StrPCopy(SELLITEMFLAG.SellName,
              TBaseObject(ProcessMsg.BaseObject).m_Sonsellname);
          end
          else
          begin
            SELLITEMFLAG.w1 := 0;
            SELLITEMFLAG.sellend := 255;                    //收摊
          end;

          s1C := EncodeBuffer(@SELLITEMFLAG, SizeOf(TSELLITEMFLAG));
          SendSocket(@m_DefMsg, s1C);
        end;
      end;
    RM_SELLITEM:
      begin
        if ProcessMsg.BaseObject <> self then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SELLITEM,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,                             //x
            ProcessMsg.nParam2,                             //y
            ProcessMsg.nParam3);                            //方向

          if ProcessMsg.wParam > 0 then
          begin                                             //开始摆摊   > 0
            SELLITEMFLAG.w1 := 0;
            SELLITEMFLAG.sellend := 0;

            if tplayobject(ProcessMsg.BaseObject).m_nflagforsell then
            begin                                           //是否有旗帜
              SELLITEMFLAG.bflag := 1;                      //
              SELLITEMFLAG.flagcolor :=
                TBaseObject(ProcessMsg.BaseObject).m_nflagforsellcolor;  //       4294917162红色 4284216761   绿色   //0黄色
            end
            else
              SELLITEMFLAG.bflag := 0;
            sellitemflag.w1 := TBaseObject(ProcessMsg.BaseObject).m_nFlagType;

            //   SELLITEMFLAG.bflag:=1; //   //是否有旗帜
            //   SELLITEMFLAG.flagcolor:=4294917162;  //  红色
            StrPCopy(SELLITEMFLAG.SellName, ProcessMsg.sMsg);
          end
          else
          begin
            SELLITEMFLAG.w1 := 0;
            SELLITEMFLAG.sellend := 255;                    //收摊
          end;

          s1C := EncodeBuffer(@SELLITEMFLAG, SizeOf(TSELLITEMFLAG));
          SendSocket(@m_DefMsg, s1C);
        end;
      end;

    RM_21292:
      begin
        if ProcessMsg.BaseObject = self then
          SendDefMessage(21292, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
            ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg)
        else
          SendDefMessage(21292, Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
            ProcessMsg.nParam2, ProcessMsg.nParam3, '');

      end;

    rm_21295:
      begin                                                 //烟火
        //   s1C:=EncodeBuffer(@ProcessMsg.nParam3,4);
         //  SendDefMessage(338,Integer(ProcessMsg.BaseObject),tplayobject(ProcessMsg.BaseObject).m_nCurrX, tplayobject(ProcessMsg.BaseObject).m_nCurrY,tplayobject(ProcessMsg.BaseObject).m_btDirection, s1C);
        m_DefMsg := MakeDefaultMsg(338, Integer(ProcessMsg.BaseObject),
          tplayobject(ProcessMsg.BaseObject).m_nCurrX,
          TBaseobject(ProcessMsg.BaseObject).m_nCurrY,
          TBaseobject(ProcessMsg.BaseObject).m_btDirection);
        s1C := EncodeBuffer(@ProcessMsg.nParam3, 4);
        SendSocket(@m_DefMsg, s1c);

      end;
    RM_3082:
      begin
        m_DefMsg := MakeDefaultMsg(3082,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.wParam,
          0,
          0);
        SendSocket(@m_DefMsg, '');
      end;
    RM_3046:
      begin
        m_DefMsg := MakeDefaultMsg(3046,
          0,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3);
        SendSocket(@m_DefMsg, '');
      end;
    RM_YSSKILL:
      begin
        m_DefMsg := MakeDefaultMsg(809,
          Integer(ProcessMsg.BaseObject),
          loword(ProcessMsg.nParam2),                       //60
          hiword(ProcessMsg.nParam2),                       //15
          0); //1            //TBaseObject(ProcessMsg.BaseObject).m_nLight)
        YSskillEffect.monId := ProcessMsg.nParam1;
        YSskillEffect.skilltype := 0;
        YSskillEffect.ysId := ProcessMsg.nParam3;
        s1C := EncodeBuffer(@YSskillEffect, SizeOf(TYSskillEffect));

        SendSocket(@m_DefMsg, s1C);
      end;

    RM_SPYMOVE:
      begin
        m_DefMsg := MakeDefaultMsg(SM_SPYMOVE,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          MakeWord(lobyte(ProcessMsg.wParam),
            TBaseObject(ProcessMsg.BaseObject).m_btGender)); //1            //TBaseObject(ProcessMsg.BaseObject).m_nLight)
        //   spyfly.nw1:=2116096256;
        //   spyfly.nw2:=0;
        //   spyfly.nw3:=15597806;
        spyfly.chardesc.Feature := TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
        spyfly.chardesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
        if (TBaseObject(ProcessMsg.BaseObject) <> Self) and g_Config.ShowHpPresent then
          spyfly.chardesc.xue :=
            makelong(round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP /
            _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100), 100)  //hint 角色的血量 100/100
        else
          spyfly.chardesc.xue := makelong(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP); //makelong($ee,$ee);

        spyfly.wsx := loword(ProcessMsg.nParam3);
        spyfly.wsy := hiword(ProcessMsg.nParam3);
        spyfly.ww4 := 65292; //这个导致 飞到目的地人物不显示
        spyfly.wflag := hibyte(ProcessMsg.wParam); // wflag:=0; //表示 蝙蝠。 //77 移行  //75 遁地
        s1C := EncodeBuffer(@spyfly, SizeOf(Tspyfly));
        //        if ProcessMsg.sMsg <> '' then begin
        //        s1C:=ProcessMsg.sMsg ;
         //       end;
        SendSocket(@m_DefMsg, s1C);
      end;

    RM_MAGADDABILTY:
      begin

        magaddtype := 0;
        if TBaseObject(ProcessMsg.BaseObject).m_wStatusArrValue[6] > 0 then
          inc(magaddtype, 1);
        if TBaseObject(ProcessMsg.BaseObject).m_wStatusArrValue[7] > 0 then
          inc(magaddtype, 2);
        if TBaseObject(ProcessMsg.BaseObject).m_wStatusArrValue[8] > 0 then
          inc(magaddtype, 4);

        if ProcessMsg.nParam1 > 0 then
          magaddtype := ProcessMsg.nParam1;

        m_DefMsg := MakeDefaultMsg(keyStringType.VARSM_MAGADDABILTY,  //str_toint(myMuldecodeString(keystring.SM_MAGADDABILTY,Str_ToInt(arrip[11],0)),0),    //
          Integer(ProcessMsg.BaseObject),
          magaddtype,                                       // ProcessMsg.nParam1
          ProcessMsg.nParam2,
          0); //1            //TBaseObject(ProcessMsg.BaseObject).m_nLight)
        if ProcessMsg.sMsg = '' then
          SendSocket(@m_DefMsg, '')
        else
          SendSocket(@m_DefMsg, encodestring(ProcessMsg.sMsg));
      end;

    RM_29:
      begin
        m_DefMsg := MakeDefaultMsg(SM_HIDE,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3); //1  154          //TBaseObject(ProcessMsg.BaseObject).m_nLight)

        SendSocket(@m_DefMsg, '');
      end;
    34896:
      begin
        Senddefmessage(34896, 0, 0, 0, 0, ProcessMsg.sMsg);
      end;
    RM_510:
      begin
        m_DefMsg := MakeDefaultMsg(SM_510,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3);

        SendSocket(@m_DefMsg, '');

      end;

    RM_RECONNECTION:
      begin                                                 //10332 004D8F3A
        m_boReconnection := True;
        SendDefMessage(SM_RECONNECT, 0, 0, 0, 0, ProcessMsg.sMsg);
      end;
    RM_HIDEEVENT:
      begin                                                 //10333 004D9334
        SendDefMessage(SM_HIDEEVENT,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          '');
      end;
    RM_SHOWEVENT:
      begin                                                 //10334 004D92B1
        ShortMessage.Ident := HiWord(ProcessMsg.nParam2);
        ShortMessage.wMsg := 0;
        m_DefMsg := MakeDefaultMsg(SM_SHOWEVENT,
          ProcessMsg.nParam1,
          ProcessMsg.wParam,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3);
        SendSocket(@m_DefMsg, EncodeBuffer(@ShortMessage, SizeOf(TShortMessage)));
      end;
    RM_ADJUST_BONUS:
      begin
        SendAdjustBonus();
      end;
    RM_10401:
      begin
        //    ChangeServerMakeSlave(pTSlaveInfo(ProcessMsg.nParam1));
        //    Dispose(pTSlaveInfo(ProcessMsg.nParam1));
      end;
    RM_OPENHEALTH:
      begin                                                 //10410 004D94BD
        if g_Config.ShowHpPresent then
          SendDefMessage(SM_OPENHEALTH,
            Integer(ProcessMsg.BaseObject),
            round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP /
              _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100),
            100,                                            //hint 角色的血量 100/100

            //  TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            //  TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
            0,
            '')
        else
          SendDefMessage(SM_OPENHEALTH,
            Integer(ProcessMsg.BaseObject),

            TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
            0,
            '');
      end;
    RM_CLOSEHEALTH:
      begin                                                 //10411 004D94EC
        SendDefMessage(SM_CLOSEHEALTH,
          Integer(ProcessMsg.BaseObject),
          0,                                                //0
          0,                                                //0
          0,                                                //0
          '');
      end;
    RM_FUSHEN:
      begin
        SendDefMessage(SM_CLOSEHEALTH,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,                               //0
          ProcessMsg.nParam2,                               //0
          ProcessMsg.nParam3,                               //0
          '');
      end;

    RM_BREAKWEAPON:
      begin                                                 //10413  004D9538
        SendDefMessage(SM_BREAKWEAPON,
          Integer(ProcessMsg.BaseObject),
          0,
          0,
          0,
          '');
      end;
    RM_10414:
      begin                                                 //10414  004D9509
        if g_Config.ShowHpPresent then
          SendDefMessage(SM_INSTANCEHEALGUAGE,
            Integer(ProcessMsg.BaseObject),
            round(TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP /
              _max(TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP, 1) * 100),
            100,                                            //hint 角色的血量 100/100

            //   TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            //   TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
            0,
            '')
        else
          SendDefMessage(SM_INSTANCEHEALGUAGE,
            Integer(ProcessMsg.BaseObject),
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
            0,
            '');

      end;
    RM_CHANGEFACE:
      begin                                                 //10415 004D8E97
        if (ProcessMsg.nParam1 <> 0) and (ProcessMsg.nParam2 <> 0) then
        begin
          m_DefMsg := MakeDefaultMsg(SM_CHANGEFACE,
            ProcessMsg.nParam1,
            LoWord(ProcessMsg.nParam2),
            HiWord(ProcessMsg.nParam2),
            0);
          CharDesc.feature := TBaseObject(ProcessMsg.nParam2).GetFeature(Self);

          CharDesc.Status := TBaseObject(ProcessMsg.nParam2).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
        end;
      end;
    RM_PASSWORD:
      begin                                                 //10416 004D9FE3
        SendDefMessage(SM_PASSWORD,
          0,
          0,
          0,
          0,
          '');
      end;
    RM_PLAYDICE:
      begin                                                 //10500 004D9FFF
        MessageBodyWL.lParam1 := ProcessMsg.nParam1;
        MessageBodyWL.lParam2 := ProcessMsg.nParam2;
        MessageBodyWL.lTag1 := ProcessMsg.nParam3;

        m_DefMsg := MakeDefaultMsg(SM_PLAYDICE,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.wParam,
          0,
          0);
        SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)) +
          EncodeString(ProcessMsg.sMsg));
      end;
    RM_PASSWORDSTATUS:
      begin
        m_DefMsg := MakeDefaultMsg(SM_PASSWORDSTATUS,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3);
        SendSocket(@m_DefMsg, ProcessMsg.sMsg);
      end;
  else
    begin                                                   //004DA0A0
      //inherited;//  Operate(@ProcessMsg);
      Result := inherited Operate(ProcessMsg);
      //未知协议
    //  mainoutmessage(inttostr(ProcessMsg.wIdent));
    end;
  end;
  //inherited;

end;

procedure TPlayObject.Run();                                //004D68D0
var
  tObjCount                                            : Integer;
  nInteger                                             : Integer;
  //wYear, wMonth, wDay,
  wHour                                                : Word;
  wMin                                                 : Word;
  wSec                                                 : Word;
  wMSec                                                : Word;
  //  w48:word;
  ProcessMsg                                           : TProcessMessage;
  boInSafeArea                                         : Boolean;
  boInSafezone                                         : Boolean;
  I                                                    : Integer;
  StdItem                                              : pTStdItem;
  UserItem                                             : pTUserItem;
  PlayObject                                           : TPlayObject;
  boTakeItem                                           : Boolean;
  Castle                                               : TUserCastle;
  NormNpc                                              : TNormNpc;
  ncode                                                : integer;
  hum                                                  : Tplayobject;
  nx, ny                                               : integer;
  EvilKillDate                                         : TEvilKillDate;
  pDelayCall                                           : pTDelayCall;
resourcestring
  sPayMentExpire                                       = '您的帐户充值时间已到期！！！';
  sDisConnectMsg                                       = '游戏被强行中断！！！';
  sExceptionMsg1                                         =
    '[Exception] TPlayObject::Run -> Operate 1 Code=%d';
  sExceptionMsg2                                         =
    '[Exception] TPlayObject::Run -> Operate 2 # %s Ident:%d Sender:%d wP:%d nP1:%d nP2:%d np3:%d Msg:%s';
  sExceptionMsg3                                         =
    '[Exception] TPlayObject::Run -> GetHighHuman';
  sExceptionMsg4                                         =
    '[Exception] TPlayObject::Run -> ClearObj';
begin

  if g_boExitServer then
    m_boEmergencyClose := True;
  //004D6901
  try
    if m_boDealing then
    begin
      if (GetPoseCreate <> m_DealCreat) or (m_DealCreat = Self) or (m_DealCreat = nil)
        then
        DealCancel();
    end;                                                    //004D6950
    ncode := 0;
    if m_boExpire then
    begin
      SysMsg(sPayMentExpire, c_Red, t_Hint);
      SysMsg(sDisConnectMsg, c_Red, t_Hint);
      m_boEmergencyClose := True;
      m_boExpire := False;
    end;                                                    //004D698E
    ncode := 1;
    if m_nTimerA > 0 then
    begin
      if (GetTickCount - m_nTimerTick) > m_nTimerA then
      begin
        m_nTimerA := 0;
        SendDefMessage(1833, Integer(self), 0, 300, 0, '');
        if g_ManageNPC <> nil then
          g_ManageNPC.GotoLable(Self, m_sTimerLable, False);
      end;
    end;
    if m_boFireHitSkill and ((GetTickCount - m_dwLatestFireHitTick) > 20 * 1000) then
    begin
      m_boFireHitSkill := False;
      case m_nFireHitSkillType of
        26:
          begin
            SysMsg(sSpiritsGone, c_Red, t_Hint);
            SendSocket(nil, '+UFIR');
          end;
        44:
          begin
            SysMsg('雷电的力量消失', c_Red, t_Hint);
            SendSocket(nil, '+UTHU');
          end;
      end;
    end;                                                    //004D69D7
    ncode := 2;
    if m_boTimeRecall and (GetTickCount > m_dwTimeRecallTick) then
    begin
      m_boTimeRecall := False;
      SpaceMove(m_sMoveMap, m_nMoveX, m_nMoveY, 0);
    end;                                                    //004D6A23
    ncode := 3;
    //////// DELAY 脚本运行检测   06.1.16

    if (GetTickCount - m_dwcheckdelaytick) > 1000 then
    begin

      if m_PEnvir.m_sDelayCall <> '' then
      begin
        if GetTickCount - m_MapDelayTick > m_PEnvir.m_nDelayCallTime then
        begin
          g_ManageNPC.GotoLable(Self, m_PEnvir.m_sDelayCall, False);
          m_MapDelayTick := GetTickCount;
        end;
      end;

      m_dwcheckdelaytick := GetTickCount();
      for I := DelayCallList.Count - 1 downto 0 do
      begin
        pDelayCall := pTDelayCall(DelayCallList[i]);
        if GetTickCount - pDelayCall.m_dwnnpcdelaytick > pDelayCall.m_nDelayTime then
        begin
          Dec(pDelayCall.m_nDelayCallCount);
          NormNpc := UserEngine.FindMerchant(TObject(pDelayCall.Npc));
          if NormNpc = nil then
            NormNpc := UserEngine.FindNPC(TObject(pDelayCall.npc));
          if NormNpc <> nil then
            NormNpc.GotoLable(self, pDelayCall.sLabel, False);
          pDelayCall.m_dwnnpcdelaytick := GetTickCount;
          if pDelayCall.m_nDelayCallCount = 0 then
          begin
            Dispose(pDelayCall);
            DelayCallList.Delete(i);

          end;
        end;
      end;
      if m_bonpcdelay then
      begin
        if GetTickCount - m_dwnnpcdelaytick > m_nnpcdelay then
        begin
          Dec(m_nDelayCallCount);
          if m_nDelayCallCount < 1 then
            m_bonpcdelay := false;
          NormNpc := UserEngine.FindMerchant(TObject(m_nnpc));
          if NormNpc = nil then
            NormNpc := UserEngine.FindNPC(TObject(m_nnpc));
          if NormNpc <> nil then
            NormNpc.GotoLable(self, M_Snpcgots, False);
          m_dwnnpcdelaytick := GetTickCount;
        end;
      end;
      ncode := 4;
      if m_boCheckNewYs then
      begin
        if sYsname <> '' then
        begin
          SendRefMsg(RM_SPYMOVE, makeword(m_btDirection, 214), 433, 169,
            makelong(m_nCurrX, m_nCurrY), '');
          SendRefMsg(RM_510, 0, 1, 0, 37, '');

          SysMsg('元神创建成功！', c_Red, t_Hint);
          SendYuanYingInfo;
          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          // SendDefMessage(38407,0,0,0,0,sYsname);
        end
        else
          SysMsg('元神创建失败，请换个其他名字！！(' + m_sCheckYS + ')', c_Red, t_Hint);
        m_boCheckNewYs := false;
      end;
      ncode := 41;
      if sYsnameMaster <> '' then
      begin                                                 //我是元神，
        //  hum:=nil;
        hum := UserEngine.GetPlayObjectEx(sYsnameMaster);
        //  hum := self.ysmasterplayer;
        if (hum <> nil) and (hum.m_boDeath or hum.m_boGhost or m_boDeath or m_boGhost or
          ((hum.m_PEnvir <> nil) and (hum.m_PEnvir.m_boNOYS))) then
        begin
          m_boReconnection := True;
          SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
          hum.m_dwYsCallTick := GetTickCount();
          //  hum.SysMsg('这里不能召唤元神，元神已经沉睡！！！', c_Red, t_Hint);
        end;
        m_boSuperMan := m_btLingzhuMode = 1;
        if (hum <> nil) and (m_PEnvir <> nil) and           // 要跟随主人
        (((hum.m_PEnvir <> nil) and (m_PEnvir <> hum.m_PEnvir)) or
          (abs(m_nCurrX - hum.m_nCurrX) > 20) or
          (abs(m_nCurrY - hum.m_nCurrY) > 20)) then
        begin
          hum.GetBackPosition(nX, nY);
          if hum.m_PEnvir.GetMovingObject(nX, nY, True) = nil then //如果没有其他人或怪物
          begin
            SpaceMove(hum.m_PEnvir.sMapName, nX, nY, 1);
            SendRefMsg(RM_3082, m_btLingzhuMode, 0, 0, 0, '');

          end;
        end;

        // SendRefMsg(RM_3082,hum.m_btLingzhuMode,0,0,0,'');

      end;
      ncode := 42;
      //////////   夺宝活动
      if m_boArrow then
      begin
        if GetTickCount - m_dwStatusArrTick[STATE_12] >= m_wStatusTimeArr[STATE_12] then
        begin
          if g_FunctionNPC <> nil then
          begin
            g_FunctionNPC.GotoLable(Self, m_SArrownpcgoto, False);
          end;
        end;
        if GetTickCount - m_nArrowtick > m_nArrowtime then
        begin
          if g_FunctionNPC <> nil then
          begin
            g_FunctionNPC.GotoLable(Self, m_SarrowTimernpc, False);
            m_nArrowtick := GetTickCount();
          end;
        end
      end;                                                  //m_boArrow

      ncode := 43;
      if m_boAddYQMode then
      begin
        nyuanqi := nyuanqi + 10;
        SendDefMessage(38417, 0, nyuanqi, _max(nyuanqi, 100), 0, '');
        if nyuanqi >= 100 then
          m_boAddYQMode := false;

      end;
      ncode := 44;
      if m_nAddYQ > 0 then
      begin
        nyuanqi := nyuanqi + m_nAddYQ;
        m_nAddYQ := 0;
        SendDefMessage(38417, 0, nyuanqi, _max(nyuanqi, 100), 0, '');
      end;
      if (nyuanqi < 100) then
      begin                                                 //将其改为元神元气快速长满。

        nyuanqi := nyuanqi + 30 - g_Config.VitaLityAddSpeed;
        SendDefMessage(38417, 0, nyuanqi, _max(nyuanqi, 100), 0, '');
      end;

      ncode := 46;
      if (m_boAddhpmode) then
      begin
        if GetTickCount < m_dwAddhpmodetick then
        begin
          if m_WAbil.hp <> m_WAbil.MaxHP then
            m_nIncHealth := m_WAbil.MaxHP;

        end
        else
        begin                                               //时间到
          SendDefMessage(510, integer(self), 0, 0, 1, '');
          m_boAddhpmode := false;
        end;

      end;

      ncode := 47;
      if (m_boAddmpmode) then
      begin
        if GetTickCount < m_dwAddmpmodetick then
        begin
          if m_WAbil.mp <> m_WAbil.MaxmP then
            //   IncHealthSpell(0,m_Abil.MaxmP);
            m_nIncSpell := m_WAbil.MaxmP;
          //  SendDefMessage(510,integer(self),1,1,m_nAddhealthmode,'');
        end
        else
        begin                                               //时间到
          SendDefMessage(510, integer(self), 0, 0, 2, '');
          m_boAddmpmode := false;
        end;

      end;

    end;                                                    //m_dwcheckdelaytick

    /////////////
    ///  每10秒消耗镇魔值
    ///
    if (m_nCallEvilCount > 0) and ((GetTickCount() - m_dwCheckEvilCtrl10SecDecPowerTick)
      > 10000) then
    begin

      m_dwCheckEvilCtrl10SecDecPowerTick := GetTickCount;
      Dec(m_nZMValue, g_Config.CallEvilConf.nEvilCtrl10SecDecPower);

      if m_nZMValue < 0 then
      begin
        m_nZMValue := 0;
        EvilRoyalty;
        m_nCallEvilCount := 0;
        FillChar(EvilKillDate, SizeOf(TEvilKillDate), #0);
        EvilKillDate.nZMValueMax := g_Config.CallEvilConf.nEvilCtrlMaxPower * 1000;
        EvilKillDate.nValue2 := $DAC;
        SendDefMessage(34968, 0, 1, 0, 0, EncodeBuffer(@EvilKillDate,
          SizeOf(EvilKillDate)), True);

      end
      else
      begin
        FillChar(EvilKillDate, SizeOf(TEvilKillDate), #0);
        EvilKillDate.nZMValueMax := g_Config.CallEvilConf.nEvilCtrlMaxPower * 1000;
        EvilKillDate.nValue2 := $DAC;
        EvilKillDate.nMonID := GetEvilId;
        SendDefMessage(34968, 0, 257, m_nZMValue * 1000, 0, EncodeBuffer(@EvilKillDate,
          SizeOf(EvilKillDate)), True);

      end;
      SendDefMessage(34968, Integer(Self), 3, m_nZMValue * 1000, 0, '');

    end;
    ncode := 5;

    if (GetTickCount - m_dwCheckDupObjTick) > 3000 then
    begin
      m_dwCheckDupObjTick := GetTickCount();
      GetStartPoint();
      tObjCount := m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY);
      if tObjCount >= 2 then
      begin
        if not bo2F0 then
        begin
          bo2F0 := True;
          m_dwDupObjTick := GetTickCount();
        end;
      end
      else
      begin
        bo2F0 := False;
      end;
      if (((tObjCount >= 3) and ((GetTickCount() - m_dwDupObjTick) > 3000))
        or (((tObjCount = 2) and ((GetTickCount() - m_dwDupObjTick) > 10000)))) and
          ((GetTickCount() - m_dwDupObjTick) < 20000) then
      begin
        if not m_booffline then
          CharPushed(Random(8), 1);                         //挂机的不走

      end;

    end;                                                    //004D6B09
    ncode := 6;
    Castle := g_CastleManager.InCastleWarArea(Self);

    if (Castle <> nil) and Castle.m_boUnderWar then
    begin
      ChangePKStatus(True);
    end;
    {
    if UserCastle.m_boUnderWar then begin
      ChangePKStatus(UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY));
    end;
    }//004D6B42
    ncode := 7;
    if (GetTickCount - dwTick578) > 1000 then
    begin
      dwTick578 := GetTickCount();
      DecodeTime(Now, wHour, wMin, wSec, wMSec);

      if g_Config.boDiscountForNightTime and ((wHour = g_Config.nHalfFeeStart) or (wHour
        = g_Config.nHalfFeeEnd)) then
      begin
        if (wMin = 0) and (wSec <= 30) and ((GetTickCount - m_dwLogonTick) > 60000) then
        begin
          LogonTimcCost();
          m_dwLogonTick := GetTickCount();
          m_dLogonTime := Now();
        end;
      end;                                                  //004D6BF5
      ncode := 8;
      if (m_MyGuild <> nil) then
      begin
        if TGuild(m_MyGuild).GuildWarList.Count > 0 then
        begin
          boInSafeArea := InSafeArea();
          if boInSafeArea <> m_boInSafeArea then
          begin
            m_boInSafeArea := boInSafeArea;
            RefNameColor();
          end;
        end;
      end;                                                  //004D6C43
      ncode := 9;
      //安全区通知
      if sYsnameMaster = '' then
      begin                                                 //是人物
        if (g_Config.SafeAreaHint = 1) and (GetTickCount - m_dwchecksafearea > 2000) then
        begin
          m_dwchecksafearea := GetTickCount;
          boInSafezone := InSafeZone;                       //InSafeArea();
          if boInSafezone <> m_boInSafezone then
          begin
            m_boInSafezone := boInSafezone;
            if m_boInSafezone then
              SysMsg('你已经进入安全区...', c_Red, t_Hint)
            else
              SysMsg('你已经离开安全区...', c_Red, t_Hint)
          end;
        end;
      end;
      ////////////
      ncode := 10;

      ncode := 11;
      if (Castle <> nil) and Castle.m_boUnderWar then
      begin
        if (m_PEnvir = Castle.m_MapPalace) and (m_MyGuild <> nil) then
        begin
          if not Castle.IsMember(Self) then
          begin
            if Castle.IsAttackGuild(TGuild(m_MyGuild)) then
            begin
              if Castle.CanGetCastle(TGuild(m_MyGuild)) then
              begin
                Castle.GetCastle(TGuild(m_MyGuild));
                UserEngine.SendServerGroupMsg(SS_211, nServerIndex,
                  TGuild(m_MyGuild).sGuildName);
                if Castle.InPalaceGuildCount <= 1 then
                  Castle.StopWallconquestWar();
              end;
            end;                                            //004D6D29
          end;
        end;                                                //004D6D29
      end
      else
      begin                                                 //004D6D1F
        ChangePKStatus(False);
      end;                                                  //004D6D29
      ncode := 12;
      if m_boNameColorChanged then
      begin
        m_boNameColorChanged := False;
        RefUserState();
        RefShowName();
      end;

    end;                                                    //004D6D4F
    if (GetTickCount - dwTick57C) > 2000 then
    begin
      dwTick57C := GetTickCount;
      ProcessSpiritSuite();                                 //检查祈祷套装是否生效
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg1, [ncode]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;

  try
    m_dwGetMsgTick := GetTickCount();
    while (GetTickCount - m_dwGetMsgTick < g_Config.dwHumanGetMsgTime) and
      GetMessage(@ProcessMsg) do
    begin

      if not Operate(@ProcessMsg) then
        break;

    end;

    if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then
    begin
      if m_boSwitchData then
      begin
        m_sMapName := m_sSwitchMapName;
        m_nCurrX := m_nSwitchMapX;
        m_nCurrY := m_nSwitchMapY;
      end;
      //这里人物下线 操作
      if not (m_boSoftClose and (sYsnameMaster = '') and (m_booffline or
        (g_Config.boSafeOffLine and InSafeZone and (not ((m_PetBaseObject <> nil) and
        (m_PetBaseObject.m_boPetOnSell)))))) then //如果是在脱机泡点中，人物不下线
        MakeGhost();

      if (m_boSoftClose and (m_booffline or (g_Config.boSafeOffLine and m_boInSafezone
        and (not ((m_PetBaseObject <> nil) and (m_PetBaseObject.m_boPetOnSell)))))) then
      begin
        m_boSoftClose := false;
        if not m_boReconnection then
          FrmIDSoc.SendHumanLogOutmsg(m_sUserID, m_nSessionID);
      end;

      if m_boKickFlag then
      begin
        SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
      end;

      if not m_boReconnection and m_boSoftClose then
      begin
        FrmIDSoc.SendHumanLogOutmsg(m_sUserID, m_nSessionID);
        //    MainOutMessage('if not m_boReconnection and m_boSoftClose then SendHumanLogOutmsg');
      end;
    end;
  except
    on e: Exception do
    begin
      if ProcessMsg.wIdent = 0 then
        MakeGhost(); // 11.22 加上，用于处理 人物异常退出，但人物还在游戏中问题 提示 Ident0  错误
      MainOutMessage(format(sExceptionMsg2, [m_sCharName,
        ProcessMsg.wIdent,
          Integer(ProcessMsg.BaseObject),
          ProcessMsg.wParam,
          ProcessMsg.nParam1,
          ProcessMsg.nParam2,
          ProcessMsg.nParam3,
          ProcessMsg.sMsg]));

      MainOutMessage(E.Message);
      raise;
    end;

  end;

  if GetTickCount - m_dwcheckhumitem > 2000 then
  begin
    m_dwcheckhumitem := GetTickCount;
    boTakeItem := False;
    //检查身上的装备有没不符合
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if m_UseItems[i].wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
        if StdItem <> nil then
        begin
          if not CheckItemsNeed(StdItem) then
          begin
            //        m_ItemList.Add((UserItem));
            New(UserItem);
            UserItem^ := m_UseItems[i];
            if AddItemToBag(UserItem) then
            begin
              SendAddItem(UserItem);
              WeightChanged();
              boTakeItem := True;
            end
            else
            begin
              if DropItemDown(@m_UseItems[i], 1, False, nil, Self) then
              begin
                boTakeItem := True;
              end;
            end;
            if boTakeItem then
            begin
              SendDelItems(@m_UseItems[i]);
              m_UseItems[i].wIndex := 0;
              RecalcAbilitys();
            end;

          end;
        end
        else
          m_UseItems[i].wIndex := 0;
      end;
    end;
  end;
  //{$IF (SoftVersion = VERPRO) or (SoftVersion = VERENT)}
  tObjCount := m_nGameGold;
  if m_boDecGameGold and (GetTickCount - m_dwDecGameGoldTick > m_dwDecGameGoldTime) then
  begin
    m_dwDecGameGoldTick := GetTickCount();
    if m_nGameGold >= m_nDecGameGold then
    begin
      Dec(m_nGameGold, m_nDecGameGold);
      nInteger := m_nDecGameGold;
    end
    else
    begin
      nInteger := m_nGameGold;
      m_nGameGold := 0;
      m_boDecGameGold := False;
      MoveToHome();
    end;
    if g_boGameLogGameGold then
    begin
      AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
        m_sMapName,
          m_nCurrX,
          m_nCurrY,
          m_sCharName,
          g_Config.sGameGoldName,
          nInteger,
          '-',
          'Auto']));
    end;
  end;

  if m_boIncGameGold and (GetTickCount - m_dwIncGameGoldTick > m_dwIncGameGoldTime) then
  begin
    m_dwIncGameGoldTick := GetTickCount();
    if m_nGameGold + m_nIncGameGold < 2000000 then
    begin
      Inc(m_nGameGold, m_nIncGameGold);
      nInteger := m_nIncGameGold;
    end
    else
    begin
      m_nGameGold := 2000000;
      nInteger := 2000000 - m_nGameGold;
      m_boIncGameGold := False;
    end;
    if g_boGameLogGameGold then
    begin
      AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
        m_sMapName,
          m_nCurrX,
          m_nCurrY,
          m_sCharName,
          g_Config.sGameGoldName,
          nInteger,
          '-',
          'Auto']));
    end;
  end;

  if not m_boDecGameGold and m_PEnvir.m_boDECGAMEGOLD then
  begin
    if GetTickCount - m_dwDecGameGoldTick > LongWord(m_PEnvir.m_nDECGAMEGOLDTIME * 1000)
      then
    begin
      m_dwDecGameGoldTick := GetTickCount();
      if m_nGameGold >= m_PEnvir.m_nDECGAMEGOLD then
      begin
        Dec(m_nGameGold, m_PEnvir.m_nDECGAMEGOLD);
        nInteger := m_PEnvir.m_nDECGAMEGOLD;
      end
      else
      begin
        nInteger := m_nGameGold;
        m_nGameGold := 0;
        m_boDecGameGold := False;
        MoveToHome();
      end;
      if g_boGameLogGameGold then
      begin
        AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
          m_sMapName,
            m_nCurrX,
            m_nCurrY,
            m_sCharName,
            g_Config.sGameGoldName,
            nInteger,
            '-',
            'Map']));
      end;
    end;
  end;

  if not m_boIncGameGold and m_PEnvir.m_boINCGAMEGOLD then
  begin
    if GetTickCount - m_dwIncGameGoldTick > LongWord(m_PEnvir.m_nINCGAMEGOLDTIME * 1000)
      then
    begin
      m_dwIncGameGoldTick := GetTickCount();
      if m_nGameGold + m_PEnvir.m_nINCGAMEGOLD <= 2000000 then
      begin
        Inc(m_nGameGold, m_PEnvir.m_nINCGAMEGOLD);
        nInteger := m_PEnvir.m_nINCGAMEGOLD;
      end
      else
      begin
        nInteger := 2000000 - m_nGameGold;
        m_nGameGold := 2000000;
      end;
      if g_boGameLogGameGold then
      begin
        AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
          m_sMapName,
            m_nCurrX,
            m_nCurrY,
            m_sCharName,
            g_Config.sGameGoldName,
            nInteger,
            '+',
            'Map']));
      end;
    end;
  end;

  if tObjCount <> m_nGameGold then
    SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
  //{$IFEND}

  if m_PEnvir.m_boINCGAMEPOINT then
  begin
    if (GetTickCount - m_dwIncGamePointTick > LongWord(m_PEnvir.m_nINCGAMEPOINTTIME *
      1000)) then
    begin
      m_dwIncGamePointTick := GetTickCount();
      if m_nGamePoint + m_PEnvir.m_nINCGAMEPOINT <= 2000000 then
      begin
        Inc(m_nGamePoint, m_PEnvir.m_nINCGAMEPOINT);
        nInteger := m_PEnvir.m_nINCGAMEPOINT;
      end
      else
      begin
        m_nGamePoint := 2000000;
        nInteger := 2000000 - m_nGamePoint;
      end;
      if g_boGameLogGamePoint then
      begin
        AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEPOINT,
          m_sMapName,
            m_nCurrX,
            m_nCurrY,
            m_sCharName,
            g_Config.sGamePointName,
            nInteger,
            '+',
            'Map']));
      end;
    end;
  end;

  if m_PEnvir.m_boDECHP and (GetTickCount - m_dwDecHPTick > LongWord(m_PEnvir.m_nDECHPTIME
    * 1000)) then
  begin
    m_dwDecHPTick := GetTickCount();
    if m_WAbil.HP > m_PEnvir.m_nDECHPPOINT then
    begin
      Dec(m_WAbil.HP, m_PEnvir.m_nDECHPPOINT);
    end
    else
    begin
      m_WAbil.HP := 0;
    end;
    HealthSpellChanged();
  end;

  if m_PEnvir.m_boINCHP and (GetTickCount - m_dwIncHPTick > LongWord(m_PEnvir.m_nINCHPTIME
    * 1000)) then
  begin
    m_dwIncHPTick := GetTickCount();
    if m_WAbil.HP + m_PEnvir.m_nDECHPPOINT < m_WAbil.MaxHP then
    begin
      Inc(m_WAbil.HP, m_PEnvir.m_nDECHPPOINT);
    end
    else
    begin
      m_WAbil.HP := m_WAbil.MaxHP;
    end;
    HealthSpellChanged();
  end;

  //降饥饿点
  if g_Config.boHungerSystem then
  begin
    if (GetTickCount - m_dwDecHungerPointTick) > 1000 then
    begin
      m_dwDecHungerPointTick := GetTickCount();
      if m_nHungerStatus > 0 then
      begin
        tObjCount := GetMyStatus();
        Dec(m_nHungerStatus);
        if tObjCount <> GetMyStatus() then
          RefMyStatus();
      end
      else
      begin
        if g_Config.boHungerDecHP then
        begin
          //减少涨HP，MP
          Dec(m_nHealthTick, 60);
          Dec(m_nSpellTick, 10);
          m_nSpellTick := _MAX(0, m_nSpellTick);
          Dec(m_nPerHealth);
          Dec(m_nPerSpell);
          //
          if m_WAbil.HP > m_WAbil.HP div 100 then
          begin
            Dec(m_WAbil.HP, _MAX(1, m_WAbil.HP div 100));
          end
          else
          begin
            if m_WAbil.HP <= 2 then
              m_WAbil.HP := 0;
          end;
          HealthSpellChanged();
        end;
      end;
    end;
  end;

  if GetTickCount - m_dwRateTick > 1000 then
  begin
    m_dwRateTick := GetTickCount();
    if m_dwKillMonExpRateTime > 0 then
    begin
      Dec(m_dwKillMonExpRateTime);
      if m_dwKillMonExpRateTime = 0 then
      begin
        m_nKillMonExpRate := 100;
        SysMsg('经验倍数恢复正常...', c_Red, t_Hint);
      end;
    end;
    if m_dwPowerRateTime > 0 then
    begin
      Dec(m_dwPowerRateTime);
      if m_dwPowerRateTime = 0 then
      begin
        m_nPowerRate := 100;
        SysMsg('攻击力倍数恢复正常...', c_Red, t_Hint);
      end;
    end;
  end;

  try //取得在线最高等级、PK、攻击力、魔法、道术 的人物
    if (g_HighLevelHuman = Self) and (m_boDeath or m_boGhost) then
      g_HighLevelHuman := nil;
    if (g_HighPKPointHuman = Self) and (m_boDeath or m_boGhost) then
      g_HighPKPointHuman := nil;
    if (g_HighDCHuman = Self) and (m_boDeath or m_boGhost) then
      g_HighDCHuman := nil;
    if (g_HighMCHuman = Self) and (m_boDeath or m_boGhost) then
      g_HighMCHuman := nil;
    if (g_HighSCHuman = Self) and (m_boDeath or m_boGhost) then
      g_HighSCHuman := nil;
    if (g_HighOnlineHuman = Self) and (m_boDeath or m_boGhost) then
      g_HighOnlineHuman := nil;

    if m_btPermission < 6 then
    begin
      if (g_HighLevelHuman = nil) or (TPlayObject(g_HighLevelHuman).m_boGhost) then
      begin
        g_HighLevelHuman := Self;
      end
      else
      begin
        if m_Abil.Level > TPlayObject(g_HighLevelHuman).m_Abil.Level then
          g_HighLevelHuman := Self;
      end;

      //最高PK
      if (g_HighPKPointHuman = nil) or (TPlayObject(g_HighPKPointHuman).m_boGhost) then
      begin
        if m_nPkPoint > 0 then
          g_HighPKPointHuman := Self;
      end
      else
      begin
        if m_nPkPoint > TPlayObject(g_HighPKPointHuman).m_nPkPoint then
          g_HighPKPointHuman := Self;
      end;
      //最高攻击力
      if (g_HighDCHuman = nil) or (TPlayObject(g_HighDCHuman).m_boGhost) then
      begin
        g_HighDCHuman := Self;
      end
      else
      begin
        if HiWord(m_WAbil.DC) > HiWord(TPlayObject(g_HighDCHuman).m_WAbil.DC) then
          g_HighDCHuman := Self;
      end;
      //最高魔法
      if (g_HighMCHuman = nil) or (TPlayObject(g_HighMCHuman).m_boGhost) then
      begin
        g_HighMCHuman := Self;
      end
      else
      begin
        if HiWord(m_WAbil.MC) > HiWord(TPlayObject(g_HighMCHuman).m_WAbil.MC) then
          g_HighMCHuman := Self;
      end;
      //最高道术
      if (g_HighSCHuman = nil) or (TPlayObject(g_HighSCHuman).m_boGhost) then
      begin
        g_HighSCHuman := Self;
      end
      else
      begin
        if HiWord(m_WAbil.SC) > HiWord(TPlayObject(g_HighSCHuman).m_WAbil.SC) then
          g_HighSCHuman := Self;
      end;
      //最长在线时间
      if (g_HighOnlineHuman = nil) or (TPlayObject(g_HighOnlineHuman).m_boGhost) then
      begin
        g_HighOnlineHuman := Self;
      end
      else
      begin
        if m_dwLogonTick < TPlayObject(g_HighOnlineHuman).m_dwLogonTick then
          g_HighOnlineHuman := Self;
      end;
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg3);
    end;
  end;

  try
    if g_Config.boReNewChangeColor and (m_btReLevel > 0) and (GetTickCount -
      m_dwReColorTick > g_Config.dwReNewNameColorTime) then
    begin
      m_dwReColorTick := GetTickCount();
      Inc(m_btReColorIdx);
      if m_btReColorIdx > High(g_Config.ReNewNameColor) then
        m_btReColorIdx := 0;
      m_btNameColor := g_Config.ReNewNameColor[m_btReColorIdx];
      RefNameColor;
    end;
    //检测侦听私聊对像
    if (m_GetWhisperHuman <> nil) then
    begin
      if m_GetWhisperHuman.m_boDeath or (m_GetWhisperHuman.m_boGhost) then
        m_GetWhisperHuman := nil;
    end;

    //  ProcessSpiritSuite();
  except

  end;

  //{$IF SoftVersion = VERDEMO}
   // if UserEngine.m_PlayObjectList.Count > ROUND(Random(g_Config.ClientConf.btItemSpeed) + g_Config.dwRunIntervalTime / 6) then begin
    //  PlayObject:=TPlayObject(UserEngine.m_PlayObjectList.Objects[0]);
    //  PlayObject.m_boEmergencyClose:=True;
  //  end;

  //{$IFEND}
  //{$IF SoftVersion = VERENT}

  //{$ELSE}
  //如果验证不正确，则控制处理
  //  if RemoteXORKey <> LocalXORKey then begin
  //{$IF DEBUG = 0}
  {  asm
      jz @@Start
      jnz @@Start
      db 0E8h
      @@Start:
    end;
  {$IFEND}
   {   if UserEngine.m_PlayObjectList.Count > Integer(g_Config.dwRunIntervalTime div 6) then begin
  {$IF DEBUG = 0}
   { asm
      jz @@Start
      jnz @@Start
      db 0E8h
      @@Start:
    end;
  {$IFEND}
      //  if Random(2) = 0 then m_boEmergencyClose:=True;     不下线
  {{$IF DEBUG = 0}
  {  asm
      jz @@Start
      jnz @@Start
      db 0E8h
      @@Start:
    end;
  {$IFEND}
  //      SysMsg('下线！！！',c_Red,t_Hint);
  {    end;
    end;
  {$IFEND}

  try
    if GetTickCount - m_dwClearObjTick > 10000 then
    begin
      m_dwClearObjTick := GetTickCount();
      if (m_DearHuman <> nil) and (m_DearHuman.m_boDeath or m_DearHuman.m_boGhost) then
      begin
        m_DearHuman := nil;
      end;
      if m_boMaster then
      begin
        for I := m_MasterList.Count - 1 downto 0 do
        begin
          PlayObject := TPlayObject(m_MasterList.Items[I]);
          if (PlayObject <> nil) and (PlayObject.m_boDeath or PlayObject.m_boGhost) then
          begin
            m_MasterList.Delete(I);
          end;
        end;
      end
      else
      begin
        if (m_MasterHuman <> nil) and (m_MasterHuman.m_boDeath or m_MasterHuman.m_boGhost)
          then
        begin
          m_MasterHuman := nil;
        end;
      end;
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg4);
      MainOutMessage(E.Message);
      raise;
    end;

  end;
  { if not m_boClientFlag and (m_nStep >= 9) and (g_Config.boCheckFail) then begin
     if m_nClientFlagMode = 1 then begin
       g_Config.nTestLevel:=Random(MAXUPLEVEL + 1);
     end else begin
       //Die();
    //   UserEngine.ClearItemList;
     end;
   end; }
  if (m_nAutoGetExpPoint > 0) and ((m_AutoGetExpEnvir = nil) or (m_AutoGetExpEnvir =
    m_PEnvir)) and (GetTickCount - m_dwAutoGetExpTick > m_nAutoGetExpTime) then
  begin
    m_dwAutoGetExpTick := GetTickCount();
    if not m_boAutoGetExpInSafeZone or (m_boAutoGetExpInSafeZone and InSafeZone) then
      GetExp(m_nAutoGetExpPoint);
  end;

  inherited Run;
end;

procedure TPlayObject.ProcessSpiritSuite();
var
  I                                                    : Integer;
  StdItem                                              : pTStditem;
  UseItem                                              : pTUserItem;
begin
  if not g_Config.boSpiritMutiny or not m_bopirit then
    exit;
  m_bopirit := False;
  for I := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    UseItem := @m_UseItems[I];
    if UseItem.wIndex <= 0 then
      Continue;
    StdItem := UserEngine.GetStdItem(UseItem.wIndex);
    if StdItem <> nil then
    begin
      if (StdItem.Shape = 126) or
        (StdItem.Shape = 127) or
        (StdItem.Shape = 128) or
        (StdItem.Shape = 129) then
      begin

        SendDelItems(UseItem);
        UseItem.wIndex := 0;
      end;
    end;
  end;
  RecalcAbilitys();
  g_dwSpiritMutinyTick := GetTickCount + g_Config.dwSpiritMutinyTime;
  UserEngine.SendBroadCastMsg('神之祈祷，天地震怒，尸横遍野...', t_System);
  SysMsg('祈祷发出强烈的宇宙效应' {，你已经得到' + IntToStr(nSpirit) + '倍的力量'},
    c_Green, t_Hint);

end;

procedure TPlayObject.LogonTimcCost();                      //004CA994
var
  n08                                                  : Integer;
  sC                                                   : string;
begin
  if (m_nPayMent = 2) or (g_Config.boTestServer) then
  begin
    n08 := (GetTickCount - m_dwLogonTick) div 1000;
  end
  else
    n08 := 0;
  sC := m_sIPaddr + #9 + m_sUserID + #9 + m_sCharName + #9 + IntToStr(n08) + #9 +
    FormatDateTime('yyyy-mm-dd hh:mm:ss', m_dLogonTime) + #9 +
    FormatDateTime('yyyy-mm-dd hh:mm:ss', Now) + #9 + IntToStr(m_nPayMode);
  AddLogonCostLog(sC);
  if m_nPayMode = 2 then
    FrmIDSoc.SendLogonCostMsg(m_sUserID, n08 div 60);

end;

function TBaseObject.MakePetghost(Baseobject: TBaseObject): boolean;
var
  i, nX, nY, id                                        : Integer;
begin
  result := false;
  for i := m_SlaveList.Count - 1 downto 0 do
  begin
    if TBaseObject(m_SlaveList.Items[i]) = Baseobject then
    begin
      TBaseObject(m_SlaveList.Items[i]).MakeGhost;
      m_SlaveList.Delete(i);
      break;
      result := true;
    end;                                                    //if
  end;                                                      //for
end;

function TBaseObject.MakeSlaveghost(sMonName: string): boolean; //004C37C0
var
  i, nX, nY, id                                        : Integer;
begin
  result := false;
  for i := m_SlaveList.Count - 1 downto 0 do
  begin
    if TBaseObject(m_SlaveList.Items[i]).m_sCharName = sMonName then
    begin
      TBaseObject(m_SlaveList.Items[i]).MakeGhost;
      m_SlaveList.Delete(i);
      break;
      result := true;
    end;                                                    //if
  end;                                                      //for
end;

function TBaseObject.MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob: Integer;
  dwRoyaltySec: LongWord; defaulX: Integer = 0; defaulY: Integer = 0): TBaseObject;  //004C37C0
var
  i, nX, nY, id                                        : Integer;
  MonObj                                               : TBaseObject;
  hum                                                  : TPlayObject;
begin
  Result := nil;

  for i := m_SlaveList.Count - 1 downto 0 do
    if TBaseObject(m_SlaveList.Items[i]).m_bohorse or
      TBaseObject(m_SlaveList.Items[i]).m_boTishen or
      (TBaseObject(m_SlaveList.Items[i]).m_sCharName = '丛林豹') or
      (TBaseObject(m_SlaveList.Items[i]).m_btRaceServer = RC_YSBJECT) then
    begin
      inc(nMaxMob);
    end;

  if m_SlaveList.Count < nMaxMob then
  begin
    if defaulX = 0 then
      GetFrontPosition(nX, nY)
    else
    begin
      nx := defaulX;
      ny := defaulY;
    end;
    MonObj := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY, sMonName);
    if MonObj <> nil then
    begin
      MonObj.m_Master := Self;
      MonObj.m_dwMasterRoyaltyTick := GetTickCount + dwRoyaltySec * 1000;
      MonObj.m_btSlaveMakeLevel := nMakeLevel;
      MonObj.m_btSlaveExpLevel := nExpLevel;
      MonObj.RecalcAbilitys;
      if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then
      begin
        MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP -
          MonObj.m_WAbil.HP) div 2;
      end;
      MonObj.RefNameColor;
      m_SlaveList.Add(MonObj);
      Result := MonObj;
      if (m_btRaceServer = RC_PLAYOBJECT) and (Tplayobject(self).sYsnameMaster <> '')
        then
      begin                                                 //告诉元神宝宝ID
        id := integer(MonObj);
        Tplayobject(self).SendDefMessage(38416, integer(self), 0, 0, 0, encodebuffer(@id,
          4));
      end;
    end;
  end;
end;

procedure TPlayObject.ClientSendSell(sData: string; nParam2: integer); //摆摊命令
var
  Name, s1C, sUserItemName                             : string;

  FriendHuman                                          : TPlayObject;
  sendsell                                             : TSendSell;
  Sendsellitem                                         : pTsellitem;
  MYSELLITEMFLAG                                       : tMYSELLITEMFLAG;
  i, j                                                 : integer;
  StdItem                                              : pTStdItem;
  StdItem24                                            : TStdItem;
  ClientItem                                           : TClientItem;
  UserItem                                             : pTUserItem;
  cansell                                              : boolean;
begin
  if ISsomeOneInNearXY(self.m_nCurrX, self.m_nCurrY) and not (m_boOnSellItem) then
  begin
    SysMsg('位置不能容纳，不能摆摊', c_Red, t_Hint);
    exit;
  end;
  if m_boArrow then
  begin
    SysMsg('现在不能摆摊', c_Green, t_Hint);
    exit;
  end;

  DecodeBuffer(sData, @sendsell, sizeof(TSendSell));
  name := strpas(sendsell.SellName);
  cansell := true;
  if nParam2 = 5 then
  begin
    m_DefMsg := MakeDefaultMsg(24243,
      Integer(Self),
      m_nCurrX,                                             //x
      m_nCurrY,                                             //y
      m_btDirection);                                       //方向

    SendSocket(@m_DefMsg, '');                              //发给自己。
    Exit;
  end;
  if nParam2 > MAXPETSELLCOUNT then
    nParam2 := MAXPETSELLCOUNT;

  if nParam2 > 0 then
  begin                                                     //  > 0
    MYSELLITEMFLAG.w1 := 0;                                 //开始摆摊
    MYSELLITEMFLAG.sellend := 0;

    if m_nflagforsell then
    begin                                                   //是否有旗帜
      MYSELLITEMFLAG.bflag := 1;                            //
      MYSELLITEMFLAG.flagcolor := self.m_nflagforsellcolor; //       4294917162红色 4284216761   绿色   //0黄色
    end
    else
      MYSELLITEMFLAG.bflag := 0;

    MYSELLITEMFLAG.w1 := Self.m_nFlagType;
    m_boOnSellItem := true;
    m_Sonsellname := name;
    m_nOnsellcount := nParam2;

    for i := 0 to nParam2 - 1 do
    begin
      for j := 0 to m_Itemlist.Count - 1 do
      begin
        UserItem := m_Itemlist.Items[j];
        if UserItem.MakeIndex = sendsell.Sellitems[i].nID then
          break;
      end;

      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem = nil then
        Continue;

      StdItem24 := StdItem^;
      if (StdItem24.Reserved = 11) or GetBoValue(UserItem, UserItem.wIndex, 0) then
      begin                                                 //如果有不能摆摊 Reserved = 11

        MYSELLITEMFLAG.w1 := 0;
        MYSELLITEMFLAG.sellend := 4;                        //不允许摆摊
        m_boOnSellItem := false;
        m_Sonsellname := '';
        m_nOnsellcount := 0;
        cansell := false;
        break;
      end;
      FillChar(ClientItem, SizeOf(TClientItem), #0);

      ItemUnit.GetItemAddValue(UserItem, StdItem24);        //极品数据
      //      CopyStdItemToOStdItem(@StdItem24, @OClientItem.S);
      ClientItem.s := StdItem24;

      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.S.Name := sUserItemName;
      ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
      ClientItem.DarkProperty := Useritem.DarkProp; //ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);

      ClientItem.S.NeedIdentify := sendsell.Sellitems[i].wTpye;
      ClientItem.S.Price := sendsell.Sellitems[i].nGod;
      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      m_Onsellitemarr[i] := ClientItem;

    end;

  end
  else
  begin
    MYSELLITEMFLAG.w1 := 0;
    MYSELLITEMFLAG.sellend := 255;                          //表示收摊
    m_boOnSellItem := false;
    m_Sonsellname := '';
    m_nOnsellcount := 0;
    for i := 0 to 9 do
      fillchar(m_Onsellitemarr[i], sizeof(TClientItem), #0);
  end;
  case m_btDirection of
    0, 1: m_btDirection := 1;
    2, 3, 4: m_btDirection := 3;
    5, 6: m_btDirection := 5;
    7: m_btDirection := 7;
  end;
  m_DefMsg := MakeDefaultMsg(32983,
    Integer(Self),
    m_nCurrX,                                               //x
    m_nCurrY,                                               //y
    m_btDirection);                                         //方向
  s1C := EncodeBuffer(@mySELLITEMFLAG, SizeOf(TmySELLITEMFLAG));
  SendSocket(@m_DefMsg, s1C);                               //发给自己。
  if cansell then //如果有不能摆摊物品。不发摆摊广播消息
    SendRefMsg(RM_SELLITEM, nParam2, m_nCurrX, m_nCurrY, m_btDirection, name); //发给别人
end;

procedure TPlayObject.ClientSendPetSell(sData: string; nParam2, nindex: integer);  //摆摊命令
var
  Name, s1C, sUserItemName                             : string;

  FriendHuman                                          : TPlayObject;
  sendsell                                             : TSendSell;
  Sendsellitem                                         : pTsellitem;
  MYSELLITEMFLAG                                       : tMYSELLITEMFLAG;
  i, j                                                 : integer;
  StdItem                                              : pTStdItem;
  StdItem24                                            : TStdItem;
  ClientItem                                           : TClientItem;
  UserItem                                             : pTUserItem;
  cansell                                              : boolean;
  BaseObject                                           : TBaseObject;
  SELLITEMFLAG                                         : TSELLITEMFLAG;
  onSellItemdata                                       : TonSellItemdata;
begin

  if ISsomeOneInNearXY(self.m_nCurrX, self.m_nCurrY) and not (m_boOnSellItem) then
  begin
    SysMsg('位置不能容纳，不能摆摊', c_Red, t_Hint);
    exit;
  end;
  if m_boArrow then
  begin
    SysMsg('现在不能摆摊', c_Green, t_Hint);
    exit;
  end;
  if m_PEnvir.boNODOSHOP then
  begin
    SysMsg('本地图禁止摆摊', c_Green, t_Hint);
    exit;
  end;
  DecodeBuffer(sData, @sendsell, sizeof(TSendSell));
  name := strpas(sendsell.SellName);
  BaseObject := nil;
  BaseObject := m_PetBaseObject;
  if BaseObject = nil then
  begin
    SysMsg('没有摆摊的豹子1', c_Red, t_Hint);
    exit;
  end;

  cansell := true;
  if nParam2 = 5 then
  begin
    m_DefMsg := MakeDefaultMsg(24243,
      Integer(Self),
      m_nCurrX,                                             //x
      m_nCurrY,                                             //y
      m_btDirection);                                       //方向
    SendSocket(@m_DefMsg, '');                              //发给自己。
    Exit;
  end;
  if nParam2 > 10 then
    nParam2 := 10;

  if nParam2 > 0 then
  begin                                                     //  > 0
    MYSELLITEMFLAG.w1 := 0;                                 //开始摆摊
    MYSELLITEMFLAG.sellend := 0;
    FillChar(SELLITEMFLAG, SizeOf(TSELLITEMFLAG), #0);
    SELLITEMFLAG.w1 := 0;
    SELLITEMFLAG.sellend := 0;

    if m_nflagforsell then
    begin                                                   //是否有旗帜
      MYSELLITEMFLAG.bflag := 1;                            //
      MYSELLITEMFLAG.flagcolor := self.m_nflagforsellcolor; //       4294917162红色 4284216761   绿色   //0黄色
      SELLITEMFLAG.bflag := 1;
      SELLITEMFLAG.flagcolor := self.m_nflagforsellcolor;
    end
    else
      MYSELLITEMFLAG.bflag := 0;
    sellitemflag.w1 := m_nFlagType;
    Fillchar(BaseObject.m_PetSellItem, Sizeof(TUserItem) * MAXPETSELLCOUNT, #0);
    BaseObject.m_boOnSellItem := true;
    BaseObject.m_Sonsellname := name;
    BaseObject.m_nOnsellcount := nParam2;

    for i := 0 to nParam2 - 1 do
    begin
      for j := m_Itemlist.Count - 1 downto 0 do
      begin
        UserItem := m_Itemlist.Items[j];
        if UserItem.MakeIndex = sendsell.Sellitems[i].nID then
          break;
      end;
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem = nil then
        Continue;

      StdItem24 := StdItem^;
      if (StdItem24.Reserved = 11) or GetBoValue(UserItem, UserItem.wIndex, 0) then
      begin                                                 //如果有不能摆摊 Reserved = 11

        MYSELLITEMFLAG.w1 := 0;
        MYSELLITEMFLAG.sellend := 4;                        //不允许摆摊
        BaseObject.m_boOnSellItem := false;
        BaseObject.m_Sonsellname := '';
        BaseObject.m_nOnsellcount := 0;
        cansell := false;
        break;
      end;
      FillChar(ClientItem, SizeOf(TClientItem), #0);

      ItemUnit.GetItemAddValue(UserItem, StdItem24);        //极品数据
      ClientItem.s := StdItem24;

      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.S.Name := sUserItemName;
      ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
      ClientItem.DarkProperty := Useritem.DarkProp; //ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);

      ClientItem.S.NeedIdentify := sendsell.Sellitems[i].wTpye;
      ClientItem.S.Price := sendsell.Sellitems[i].nGod;
      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      BaseObject.m_Onsellitemarr[i] := ClientItem;
      BaseObject.m_PetSellItem[i] := UserItem^;
      for j := m_Itemlist.Count - 1 downto 0 do
      begin
        UserItem := m_Itemlist.Items[j];
        if UserItem.MakeIndex = sendsell.Sellitems[i].nID then
        begin
          m_Itemlist.Delete(j);
          SendDelItems(UserItem);
          Break;
        end;
      end;

    end;

  end
  else
  begin
    MYSELLITEMFLAG.w1 := 0;
    MYSELLITEMFLAG.sellend := 255;                          //表示收摊
    m_boOnSellItem := false;
    m_Sonsellname := '';
    m_nOnsellcount := 0;
    for i := 0 to 9 do
      fillchar(m_Onsellitemarr[i], sizeof(TClientItem), #0);
  end;
  case m_btDirection of
    0, 1: m_btDirection := 1;
    2, 3, 4: m_btDirection := 3;
    5, 6: m_btDirection := 5;
    7: m_btDirection := 7;
  end;

  m_DefMsg := MakeDefaultMsg(32982,
    Integer(Integer(BaseObject)),
    BaseObject.m_nCurrX,                                    //x
    BaseObject.m_nCurrY,                                    //y
    BaseObject.m_btDirection);                              //方向

  fillchar(onSellItemdata, sizeof(tonSellItemdata), #0);
  onSellItemdata.n1 := 65537;                               //开窗口
  onSellItemdata.n2 := 10;
  onSellItemdata.w3 := BaseObject.m_nOnsellcount;           //物品个数

  StrPCopy(onSellItemdata.name, m_Sonsellname);
  j := 0;
  for i := 0 to 9 do
  begin
    if BaseObject.m_Onsellitemarr[i].MakeIndex <> 0 then
    begin
      onSellItemdata.Sellitemarr[j] := BaseObject.m_Onsellitemarr[i];
      inc(j);
    end;
  end;

  //    onSellItemdata.Sellitemarr:=Tplayobject(npc).m_Onsellitemarr[0];

  s1C := EncodeBuffer(@onSellItemdata, 52 + 10 + j * SizeOf(TClientItem));  // SizeOf(TonSellItemdata)

  SendSocket(@m_DefMsg, s1C);

  StrpCopy(SELLITEMFLAG.SellName, name);

  m_DefMsg := MakeDefaultMsg(32982,
    Integer(Integer(BaseObject)),
    BaseObject.m_nCurrX,                                    //x
    BaseObject.m_nCurrY,                                    //y
    BaseObject.m_btDirection);                              //方向

  s1C := EncodeBuffer(@SELLITEMFLAG, SizeOf(TSELLITEMFLAG));
  SendSocket(@m_DefMsg, s1C);                               //发给自己。
  if cansell then //如果有不能摆摊物品。不发摆摊广播消息
  begin
    BaseObject.SendRefMsg(RM_PetSellItem, nParam2, m_nCurrX, m_nCurrY, m_btDirection,
      name);                                                  //发给别人
    SendDefMessage(32981, Integer(self), 1, 0, 0, '');
    M_boPetOnSell := True;
    BaseObject.m_boPetOnSell := True;
    BaseObject.M_monSellitemmake := M_monitemmake;
    BaseObject.m_boSlaveRelax := True;
    UserEngine.m_PetSellList.Add(BaseObject);
    m_PetSellBaseObject := BaseObject;
    //  SendDefMessage(34977,Integer(Self),0,0,0,'');
    SendPetInfo(M_monitemmake, 3);
    M_monSellitemmake := M_monitemmake;
    M_monitemmake := 0;
  end
  else
  begin
    SendDefMessage(32981, Integer(self), 1, 104, 0, '');
    BaseObject.m_boOnSellItem := False;
    BaseObject.m_Sonsellname := '';
    BaseObject.m_nOnsellcount := 0;
  end;
end;

procedure TPlayObject.Confirmfriend(sData: string; nParam1: integer);
var
  FriendName                                           : string;
  // I:Integer;
  FriendHuman                                          : TPlayObject;
begin
  FriendName := decodestring(sData);
  FriendHuman := UserEngine.GeTPlayObject(FriendName);
  if FriendHuman <> nil then
  begin                                                     //对方在线
    if nParam1 = 1 then
    begin                                                   //同意好友
      m_FrientList.add(FriendName);
      SendDefMessage(450, 0, 0, 0, 0, FriendName);          //发给自己加好友
      Savefriend();
      FriendHuman.m_FrientList.add(m_sCharName);
      FriendHuman.SendDefMessage(450, 0, 0, 0, 0, m_sCharName); //发送对方，加自己为好友
      FriendHuman.Savefriend();
      //这里把列表保存到文件。
    end;
    if nParam1 = 2 then
    begin                                                   //拒绝
      FriendHuman.SysMsg('对方拒绝你的请求', c_Red, t_Hint);
    end;

  end
  else
    SysMsg('对方不在线', c_Red, t_Hint);
end;

procedure TPlayObject.Savefriend();
var
  sFileName, pDir                                      : string;
begin

  sFileName := g_Config.sFriendsDir + m_sCharName + '.txt';
  //m_FrientList.Lock;
  try
    m_FrientList.SaveToFile(sFileName);                     //覆盖原来文件。
  finally
    //    m_FrientList.UnLock;
  end;

end;

procedure TPlayObject.Delfriend(sData: string);
var
  FriendName                                           : string;
  I                                                    : Integer;
  FriendHuman                                          : TPlayObject;
begin
  FriendName := decodestring(sData);
  for I := 0 to m_FrientList.Count - 1 do
  begin
    if CompareText(m_FrientList.Strings[i], FriendName) = 0 then
    begin
      m_FrientList.Delete(i);
      Savefriend();                                         //这里把列表保存到文件
      SendDefMessage(451, 2, 0, 0, 0, FriendName);          //删除自己客户端上的好友
      break;
    end;
  end;                                                      //删除自己好友列表中的好友

  FriendHuman := UserEngine.GeTPlayObject(FriendName);

  if FriendHuman <> nil then
  begin                                                     //对方在线
    for I := 0 to FriendHuman.m_FrientList.Count - 1 do
    begin
      if CompareText(FriendHuman.m_FrientList.Strings[i], m_sCharName) = 0 then
      begin
        FriendHuman.m_FrientList.Delete(i);
        FriendHuman.Savefriend();                           //这里把列表保存到文件
        FriendHuman.SendDefMessage(451, 2, 0, 0, 0, m_sCharName);  //删除对方客户列表中我的名字
        break;
      end;
    end;

  end
  else
    SysMsg('对方不在线,对方的好友列表中没有删除你的名字', c_Red, t_Hint);
end;

procedure TPlayObject.Addfriend(sData: string);
var
  FriendName                                           : string;
  // I:Integer;
  FriendHuman                                          : TPlayObject;
begin

  FriendName := decodestring(sData);
  FriendHuman := UserEngine.GeTPlayObject(FriendName);
  if (FriendHuman <> nil) then
  begin                                                     //对方在线
    if not friendhuman.m_boAllowfriend then
    begin
      SysMsg('对方不允许加为好友', c_Red, t_Hint);
      exit;
    end;
    if FriendHuman <> self then
      FriendHuman.SendDefMessage(454, 2, 0, 0, 0, m_sCharName);  //发送这个消息，对方客户端会提示是否同意
  end
  else
    SysMsg('对方不在线', c_Red, t_Hint);
end;

procedure TPlayObject.ClientMakeStone(nCount, nType, ntype1, npcidx: Integer; sMsg:
  string);
var
  pIndex                                               : array[0..6] of integer;
  count, i                                             : Integer;
  ClientItem                                           : TClientItem;
  StdItem                                              : pTStdItem;
  UserItem                                             : PTUserItem;
  Npc                                                  : TNormNpc;
  sLabel                                               : string;
begin

  DecodeBuffer(sMsg, @pIndex, nCount * 4);

  for i := 0 to nCount - 1 do
  begin
    if i > 7 then Break;
    UserItem := GetItems(pIndex[i]);

    if UserItem <> nil then
    begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        m_UpDateItem[i].S := stdItem^;
        m_UpDateItem[i].MakeIndex := pIndex[i];
        m_UpDateItem[i].DarkProperty := Useritem.DarkProp; //ItemUnit.GetItemDarkProperty(UserItem.MakeIndex,UserItem.wIndex);
        case StdItem.StdMode of
          10, 11:
            sLabel := 'defitemlevel';
          5, 6:
            sLabel := 'equiplevel';
        else
          sLabel := 'jewitemlevel';

        end;
      end;

    end;
  end;
  Npc := UserEngine.FindMerchant(TObject(npcidx));
  if Npc = nil then
    Npc := UserEngine.FindNPC(TObject(npcidx));
  if Npc = nil then
  begin
    Npc := TNormNpc(m_Npc1);
    i := Integer(Npc);
  end;
  if Npc = nil then
    exit;
  m_nSuperBoxType := nType;

  m_sParam[0] := IntToStr(nCount);
  for I := 1 to nCount - 1 do
    m_sParam[i] := IntToStr(pindex[i - 1]);
  m_sParam[10] := IntToStr(pindex[nCount - 1]);
  if ((Npc.m_PEnvir = m_PEnvir) and
    (abs(Npc.m_nCurrX - m_nCurrX) < 15) and
    (abs(Npc.m_nCurrY - m_nCurrY) < 15)) or (Npc.m_boIsHide) then
  begin
    case nType of
      0:                                                    //凝练宝石
        begin
          if ntype1 = 1 then
            Npc.GotoLable(Self, '@@gemcondense', false)
          else
          begin
            SendDefMessage(SM_MAKESTONE, 0, 1, 0, 0, '');
            Npc.GotoLable(Self, '~@gemcondense_ok', false);

          end;
        end;
      1:                                                    //宝石合成
        begin
          if nType1 = 1 then
            sLabel := '@@gemcompound'
          else
          begin
            if m_wSmelBoxResult = 1 then
              sLabel := '@@gemcompoundok'
            else
              sLabel := '@@gemcompoundfail';
          end;

          Npc.GotoLable(Self, sLabel, false)
        end;
      2:                                                    //炼制宝鼎
        begin
          if nType1 = 1 then
            sLabel := '@@weaponcompound'
          else
          begin
            if m_wSmelBoxResult = 1 then
              sLabel := '@@weaponcompoundok'
            else
              sLabel := '@@weaponcompoundfail';
          end;

          Npc.GotoLable(Self, sLabel, false)
        end;
      3:
        begin
          if ntype1 = 1 then
            Npc.GotoLable(Self, '@@supercompound', false)
          else
          begin
            if m_wSmelBoxResult = 1 then
              sLabel := '@@supercompoundok'
            else
              sLabel := '@@supercompoundfail';
            Npc.GotoLable(Self, sLabel, false)
          end;
        end;
      5:
        begin

          if nType1 = 1 then
            sLabel := '@@commoncodense'
          else
          begin
            if m_wSmelBoxResult = 1 then
              sLabel := '@@commoncodenseok'
            else
              sLabel := '@@commoncodensefail';
          end;

          Npc.GotoLable(Self, sLabel, false)
        end;
      7:                                                    //碎片合成
        begin

          if ntype1 = 1 then
            Npc.GotoLable(Self, '@@' + sLabel, false)
          else
          begin
            if m_boSuperBoxResult then
            begin
              SendDefMessage(SM_MAKESTONE, 0, 1, 0, 7, '');
              Npc.GotoLable(Self, '@' + sLabel + 'ok', false);
            end
            else
            begin
              SendDefMessage(SM_MAKESTONE, 0, 0, 0, 7, '');
              Npc.GotoLable(Self, '@' + sLabel + 'fail', false);

            end;
          end;

        end;

    end;

  end;

end;

procedure TPlayObject.ClosePetSell();
var
  i                                                    : Integer;
  UserItem                                             : PTUserItem;
  n1, n2                                               : Integer;
  StdItem                                              : pTStdItem;
begin
  if (m_PetSellBaseObject <> nil) and (M_boPetOnSell) then
  begin
    m_PetSellBaseObject.M_boPetOnSell := False;
    M_boPetOnSell := False;
    for I := 0 to m_PetSellBaseObject.m_nOnsellcount - 1 do
    begin
      New(UserItem);
      UserItem^ := m_PetSellBaseObject.m_petSellItem[i];
      m_ItemList.Add(UserItem);
      SendAddItem(UserItem);
    end;
    n1 := M_monstoragelevel;
    n2 := M_monSellitemmake;
    UserItem := GetItems(M_monSellitemmake);
    if Useritem = nil then exit;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem = nil then exit;
    MakePetghost(m_PetSellBaseObject);
    m_PetSellBaseObject := nil;
    M_monSellitemmake := 0;
    //   ClientUseItems(M_monSellitemmake,0,Stditem.Name);
    if M_monitemmake = 0 then
    begin
      ClientUseItems(n2, 0, Stditem.Name);                  //重新召唤豹子

    end;
    M_boPetOnSell := False;

  end;
  GetPetSell(1);
end;

procedure TPlayObject.ClientAskSell(nType: Integer);
begin
  // MainOutMessage(IntToStr(ntype));
  case nType of
    0:                                                      //停止摆摊
      begin
        SendDefMessage(32981, 0, 0, 0, 0, '');

      end;
    2:                                                      //取回摆摊所得 元宝  ;
      begin
        if (m_PetSellBaseObject <> nil) then
        begin
          m_nGameGold := m_nGameGold + m_PetSellBaseObject.m_nGameGold;
          m_nGold := m_nGold + m_PetSellBaseObject.m_nGold;
          m_PetSellBaseObject.m_nGameGold := 0;
          m_PetSellBaseObject.m_nGold := 0;
          GoldChanged();
          SendGoldInfo(False);
        end;
        GetPetSell(0);
      end;
    5:
      begin
        if not M_boPetOnSell then
          SendDefMessage(32981, Integer(Self), ntype, 0, 0, '')
        else
          SendDefMessage(32981, 0, 0, 0, 0, '')
      end;
    3:
      begin
        SendDefMessage(32981, Integer(Self), ntype, 0, 0, '');
        ClosePetSell();
      end;
    7:
      begin
        if M_boPetOnSell then
        begin
          if m_PetSellBaseObject <> nil then
            SendDefMessage(34979, 0, 1, 0, 0, format('你的宠物豹在%s(%d:%d)为你守摊。',
              [m_PetBaseObject.m_penvir.sMapDesc, m_PetBaseObject.m_nCurrX,
              m_PetBaseObject.m_nCurrY]));
        end
        else
          SendDefMessage(34979, 0, 0, 0, 0, '没有摆摊的豹子');
        //  SendDefMessage(32981, 0, 7, 0, 0, '');
      end;
  end;
end;

procedure TPlayObject.ClientPetSellAddItem(nParam1: integer; sData: string);
var
  SendSell                                             : TSendSell;
  BaseObject                                           : TBaseObject;

  Sendsellitem                                         : pTsellitem;
  MYSELLITEMFLAG                                       : tMYSELLITEMFLAG;
  i, j, ii                                             : integer;
  StdItem                                              : pTStdItem;
  StdItem24                                            : TStdItem;
  ClientItem                                           : TClientItem;
  UserItem                                             : pTUserItem;
  cansell                                              : boolean;
  sUserItemName                                        : string;
  onSellItemdata                                       : TonSellItemdata;
  SELLITEMFLAG                                         : TSELLITEMFLAG;
  s1c                                                  : string;
begin
  BaseObject := nil;
  if m_bohasMONSTORAGE then
  begin                                                     //如果有丛林豹
    if m_PetBaseObject <> nil then
      BaseObject := m_PetBaseObject;
  end;
  if BaseObject = nil then
  begin
    SysMsg('没有摆摊的豹子', c_Red, t_Hint);
    exit;
  end;
  DecodeBuffer(sData, @SendSell, Sizeof(TSendSell));
  BaseObject.m_boOnSellItem := true;

  // Inc(BaseObject.m_nOnsellcount ,nParam1);
  for i := 0 to nParam1 - 1 do
  begin

    for j := m_Itemlist.Count - 1 downto 0 do
    begin
      UserItem := m_Itemlist.Items[j];
      if UserItem.MakeIndex = sendsell.Sellitems[i].nID then
        break;
    end;
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem = nil then
      Continue;

    StdItem24 := StdItem^;
    if (StdItem24.Reserved = 11) or GetBoValue(UserItem, UserItem.wIndex, 0) then
    begin                                                   //如果有不能摆摊 Reserved = 11

      MYSELLITEMFLAG.w1 := 0;
      MYSELLITEMFLAG.sellend := 4;                          //不允许摆摊
      BaseObject.m_boOnSellItem := false;
      BaseObject.m_Sonsellname := '';
      BaseObject.m_nOnsellcount := 0;
      cansell := false;
      break;
    end;
    FillChar(ClientItem, SizeOf(TClientItem), #0);
    ItemUnit.GetItemAddValue(UserItem, StdItem24);          //极品数据
    ClientItem.s := StdItem24;
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName <> '' then
      ClientItem.S.Name := sUserItemName;
    ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
    ClientItem.DarkProperty := Useritem.DarkProp; //ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);
    ClientItem.S.NeedIdentify := sendsell.Sellitems[i].wTpye;
    ClientItem.S.Price := sendsell.Sellitems[i].nGod;
    ClientItem.MakeIndex := UserItem.MakeIndex;
    ClientItem.Dura := UserItem.Dura;
    ClientItem.DuraMax := UserItem.DuraMax;

    BaseObject.m_Onsellitemarr[i + BaseObject.m_nOnsellcount] := ClientItem;
    BaseObject.m_PetSellItem[i + BaseObject.m_nOnsellcount] := UserItem^;
    for j := m_Itemlist.Count - 1 downto 0 do
    begin
      UserItem := m_Itemlist.Items[j];
      if UserItem.MakeIndex = sendsell.Sellitems[i].nID then
      begin
        m_Itemlist.Delete(j);
        SendDelItems(UserItem);
        Break;
      end;
    end;

  end;

  case m_btDirection of
    0, 1: m_btDirection := 1;
    2, 3, 4: m_btDirection := 3;
    5, 6: m_btDirection := 5;
    7: m_btDirection := 7;
  end;

  m_DefMsg := MakeDefaultMsg(32982,
    Integer(Integer(BaseObject)),
    BaseObject.m_nCurrX,                                    //x
    BaseObject.m_nCurrY,                                    //y
    BaseObject.m_btDirection);                              //方向

  fillchar(onSellItemdata, sizeof(tonSellItemdata), #0);
  onSellItemdata.n1 := $00020001;                           //开窗口
  onSellItemdata.n2 := 0;
  onSellItemdata.w3 := BaseObject.m_nOnsellcount + nparam1; //物品个数

  StrPCopy(onSellItemdata.name, m_Sonsellname);
  j := 0;
  for i := 0 to 9 do
  begin
    if BaseObject.m_Onsellitemarr[i].MakeIndex <> 0 then
    begin
      onSellItemdata.Sellitemarr[j] := BaseObject.m_Onsellitemarr[i];
      inc(j);
    end;
  end;

  //    onSellItemdata.Sellitemarr:=Tplayobject(npc).m_Onsellitemarr[0];

  s1C := EncodeBuffer(@onSellItemdata, 52 + 10 + j * SizeOf(TClientItem));  // SizeOf(TonSellItemdata)

  SendSocket(@m_DefMsg, s1C);

  StrpCopy(SELLITEMFLAG.SellName, SendSell.SellName);

  m_DefMsg := MakeDefaultMsg(32982,
    Integer(Integer(BaseObject)),
    BaseObject.m_nCurrX,                                    //x
    BaseObject.m_nCurrY,                                    //y
    BaseObject.m_btDirection);                              //方向

  s1C := EncodeBuffer(@SELLITEMFLAG, SizeOf(TSELLITEMFLAG));
  SendSocket(@m_DefMsg, s1C);                               //发给自己。
  if cansell then //如果有不能摆摊物品。不发摆摊广播消息
  begin

  end
  else
  begin
    SendDefMessage(32981, Integer(self), 1, 104, 0, '');
  end;

  Inc(BaseObject.m_nOnsellcount, nParam1);
end;

procedure TPlayObject.ClientFastbuy(nParam1, nIndex: integer; sItemName: string);
var
  Merchant                                             : TMerchant;
begin
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant = nil) or
    (not Merchant.m_bobuy) or
    (Merchant.m_PEnvir <> m_PEnvir) or
    (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
    (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then
    exit;

  Merchant.ClientFastBuyItem(Self, DecodeString(sItemName), nIndex);
end;

procedure TPlayObject.ClientOpenSHOP(nParam1: integer; sData: string);
var
  s                                                    : string;
  count, i, ii, nPrice                                 : integer;
  sitemid, sTemp, Temps                                : string;
  sItemName, sItemPrice, sJifen                        : string;
  boBuy                                                : Boolean;
  UserItem                                             : pTUserItem;
begin
  if shopfile = nil then
    exit;
  if nParam1 = 261 then                                     //商城直接购买
  begin
    s := '';
    sTemp := decodestring(sData);                           //'10105&4'
    sTemp := GetValidStr3(sTemp, sitemid, ['&']);
    m_nBuyItemnum := 1;
    if Pos('9999', sitemid) > 0 then
      Delete(sitemid, 1, 4);
    count := shopfile.Readinteger('00', 'count', 0);
    boBuy := False;
    for I := 1 to Count do
    begin
      sItemName := shopfile.ReadString('00', IntToStr(i), '');
      if Pos(sitemid, sItemName) = 5 then
      begin
        boBuy := True;
        stemp := sItemName;
        sTemp := GetValidStr3(sTemp, sitemName, ['|']);     //索引
        sTemp := GetValidStr3(sTemp, sitemName, ['|']);     //物品数据库idx
        sTemp := GetValidStr3(sTemp, sitemName, ['|']);     //物品数据库shape
        sTemp := GetValidStr3(sTemp, sitemName, ['|']);     //物品名字
        sTemp := GetValidStr3(sTemp, sitemPrice, ['|']);    //物品价格
        sTemp := GetValidStr3(sTemp, Temps, ['|']);         //是否直接购买
        sTemp := GetValidStr3(sTemp, sJifen, ['|']);        //积分
        m_sParam[0] := sItemName;
        m_sParam[1] := sItemPrice;
        m_sParam[2] := Temps;
        m_sParam[3] := sJifen;
        if Temps = '0' then
          g_SHOPNPC.GotoLable(Self, '@BuyshopItem' + Copy(sitemid, 5, Length(sitemid)),
            False)
        else
        begin
          Count := 1;
          nPrice := Str_ToInt(sItemPrice, 0);
          if not IsEnoughBag(count) then
          begin
            SysMsg('您的背包空位不够!', c_Red, t_Hint);
            Exit;
          end;
          if m_nGameGold >= nPrice then
          begin

            New(UserItem);
            if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
            begin
              UserItem.MakeIndex := GetItemNumberEx();
              if AddItemToBag(UserItem) then
              begin
                Dec(m_nGameGold, nPrice);
                SendAddItem(UserItem);

              end;
            end
            else
              Dispose(UserItem);

            gameGoldChanged();
          end
          else
            SysMsg('您的元宝数量不够!', c_Red, t_Hint);

        end;
        Break;
      end;
    end;
    if not boBuy then
    begin
      sTemp := decodestring(sData);                         //'10105&4'
      sTemp := GetValidStr3(sTemp, sitemid, ['&']);
      m_nBuyItemnum := str_toint(sTemp, 1);
      if m_NPC1 <> nil then
        TMerchant(m_NPC1).ClientFastBuyItem(Self, '', m_nBuyItemnum, Str_ToInt(sItemid,
          0));
    end;
  end;

  if nParam1 = 1 then
  begin                                                     //打开了商城
    s := shopfile.ReadString('00', 'MSG', '');
    SendDefMessage(4096, integer(self), 0, 0, 0, s);        //消息
    count := shopfile.Readinteger('00', 'count', 0);

    s := '';
    for i := 1 to count do
    begin
      Temps := shopfile.ReadString('00', inttostr(i), '');
      s := s + '&' + Copy(Temps, 0, 4) + '9999' + Copy(Temps, 5, Length(Temps));
    end;
    s := s + '&';
    SendDefMessage(4096, integer(self), 1, 0, 0, s);        //商品列表
    //首页
    s := '';
    count := shopfile.Readinteger('10', 'count', 0);
    for i := 1 to count do
      s := s + '&' + shopfile.ReadString('10', inttostr(i), '');
    s := '10' + s + '&';
    SendDefMessage(4096, integer(self), 2, 0, 0, s);        //小类

    s := '';
    count := shopfile.Readinteger('1010', 'count', 0);
    for i := 1 to count do
      s := s + '&1010' + shopfile.ReadString('1010', inttostr(i), '');
    s := '1010' + s + '&';
    SendDefMessage(4096, integer(self), 3, 0, 0, s);        //商品列表
  end;
  if nParam1 = 2 then
  begin                                                     //显示大类商品
    s := '';
    sitemid := decodestring(sData);
    if sitemid = '' then
      exit;
    count := shopfile.Readinteger(sitemid, 'count', 0);
    for i := 1 to count do
      s := s + '&' + shopfile.ReadString(sitemid, inttostr(i), '');
    s := sitemid + s + '&';
    SendDefMessage(4096, integer(self), 2, 0, 0, s);        //小类

    s := '';
    count := shopfile.Readinteger(sitemid + '10', 'count', 0);
    for i := 1 to count do
      s := s + '&' + sitemid + '10' + shopfile.ReadString(sitemid + '10', inttostr(i),
        '');
    s := sitemid + '10' + s + '&';
    SendDefMessage(4096, integer(self), 3, 0, 0, s);        //商品列表

  end;

  if nParam1 = 3 then
  begin                                                     //显示小类商品列表
    s := '';
    sitemid := decodestring(sData);
    if sitemid = '' then
      exit;
    count := shopfile.Readinteger(sitemid, 'count', 0);
    for i := 1 to count do
      s := s + '&' + sitemid + shopfile.ReadString(sitemid, inttostr(i), '');
    s := sitemid + s + '&';
    SendDefMessage(4096, integer(self), 3, 0, 0, s);        //小类
  end;

  if nParam1 = 4 then
  begin                                                     //显示商品的描述
    s := '';
    sitemid := decodestring(sData);
    Delete(sitemid, 1, 4);
    if sitemid = '' then
      exit;
    // sitemid:=Copy(sitemid,5,Length(sitemid));
   //  MainOutMessage(sitemid);

    s := shopfile.ReadString('DESC', sitemid, '');
    s := sitemid + '&' + s;
    SendDefMessage(4096, integer(self), 4, 0, 0, s);        //消息
  end;

  if nParam1 = 5 then
  begin                                                     //购买商品
    s := '';
    sTemp := decodestring(sData);                           //'10105&4'
    sTemp := GetValidStr3(sTemp, sitemid, ['&']);
    m_nBuyItemnum := str_toint(sTemp, 1);
    m_sParam[6] := sTemp;
    s := Copy(sItemid, 1, 4);
    sTemp := sItemid;
    if s <> '' then
    begin
      count := shopfile.Readinteger(s, 'count', 0);
      Delete(sTemp, 1, 4);
      for I := 1 to Count do
      begin
        sItemName := shopfile.ReadString(s, IntToStr(i), '');
        if Pos(sTemp, sItemName) = 1 then
        begin
          stemp := sItemName;
          sTemp := GetValidStr3(sTemp, sitemName, ['|']);   //索引
          sTemp := GetValidStr3(sTemp, sitemName, ['|']);   //物品数据库idx
          sTemp := GetValidStr3(sTemp, sitemName, ['|']);   //物品数据库shape
          sTemp := GetValidStr3(sTemp, sitemName, ['|']);   //物品名字
          sTemp := GetValidStr3(sTemp, sitemPrice, ['|']);  //物品价格
          sTemp := GetValidStr3(sTemp, Temps, ['|']);       //是否直接购买
          sTemp := GetValidStr3(sTemp, sJifen, ['|']);      //积分
          m_sParam[0] := sItemName;
          m_sParam[1] := sItemPrice;
          m_sParam[2] := Temps;
          m_sParam[3] := sJifen;
          if Temps = '0' then
            g_SHOPNPC.GotoLable(Self, '@BuyshopItem' + Copy(sitemid, 5, Length(sitemid)),
              False)
          else
          begin
            Count := Str_ToInt(m_sparam[6], 0);
            nPrice := Str_ToInt(sItemPrice, 0);
            if not IsEnoughBag(count) then
            begin
              SysMsg('您的背包空位不够!', c_Red, t_Hint);
              Exit;
            end;
            if m_nGameGold >= COunt * nPrice then
            begin

              for ii := 0 to Count - 1 do
              begin

                New(UserItem);
                if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
                begin
                  UserItem.MakeIndex := GetItemNumberEx();
                  if AddItemToBag(UserItem) then
                  begin
                    Dec(m_nGameGold, nPrice);
                    SendAddItem(UserItem);

                  end;
                end
                else
                  Dispose(UserItem);
              end;
              gameGoldChanged();
            end
            else
              SysMsg('您的元宝数量不够!', c_Red, t_Hint);

          end;
          Break;
        end;
      end;

    end;

    //  g_SHOPNPC.GotoLable(Self, '@BuyshopItem' + Copy(sitemid, 5, Length(sitemid)), False);
  end;

end;

procedure TPlayObject.SendPaiHangbang(nParam1, nParam2, nParam3: integer);
var
  PaiHangBangArray                                     : array[0..9] of TPaiHangBang;
  hanghuipaihang                                       : array[0..9] of Thanghuipaihang;
  YSpaihang                                            : array[0..9] of TYSpaihang;
  baozipaihang                                         : array[0..9] of Tbaozipaihang;
  Masterpaihang                                        : array[0..9] of TMasterpaihang;
  SavePaiHang                                          : pSavePaiHang;
  SelfPaiHang                                          : TPaiHangBang;
  I                                                    : Integer;
  StartPos                                             : Integer;
  TotlePos                                             : Integer;
  nType                                                : Integer;
  // nUpdateNum:Integer;
  sCharName                                            : string[14];
  sGuildName                                           : string[14];
  sendcount                                            : Integer;
  GroupList                                            : TStringList;
  TopGroupList                                         : TStringList;
  GroupTemp                                            : TGuild;
  //   List:TGStringList;
begin
  if m_boDeath or m_boGhost then
    exit;

  //  List:= TGStringList.Create;
  StartPos := nParam3;
  TotlePos := 4;
  nType := nParam1; { ===   英雄等级榜
  256全部        $100
  257  战士
  258  魔法
  259  道士
  260   按等级 =35 级别
  261          =36 级别
===
//1536 行会排行榜    $600
====
//1024  天地灵兽榜   $400
====
  768   元神排行     $300
  769   战士
  770   魔法
  771   道士
=====
  512   天下名师榜   $200

}
  if gettickcount - g_TopPlayListchecktick > 1000 * 60 * 1 then
  begin
    SavePlayListToFile();
    nUpdateNum := 100 + random(100);
    g_TopPlayListchecktick := gettickcount;
  end;

  sCharName := self.m_sCharName;
  if m_MyGuild <> nil then
    sGuildName := TGuild(m_MyGuild).sGuildName;
  fillchar(PaiHangBangArray, sizeof(PaiHangBangArray), #0);
  fillchar(hanghuipaihang, sizeof(hanghuipaihang), #0);
  fillchar(YSpaihang, sizeof(YSpaihang), #0);
  fillchar(baozipaihang, sizeof(baozipaihang), #0);
  fillchar(Masterpaihang, sizeof(Masterpaihang), #0);

  //nUpdateNum:=197;

  if (StartPos > 500) or (StartPos < 0) then
    StartPos := 1;
  if StartPos = 0 then
  begin                                                     //自己的排行位置

    if (nType >= $100) and (nType < $200) then
    begin                                                   //英雄榜

      TotlePos := g_TopPlayList.Count;
      SelfPaiHang.Index := INPlayList(sCharName, nType); //自己的名次     =0 就是没有名次
      strpcopy(@SelfPaiHang.CharName, sCharName);
      SelfPaiHang.Level := self.m_Abil.Level;
      SelfPaiHang.Job := self.m_btJob;
      SelfPaiHang.Sex := self.m_btGender;

      strpcopy(@SelfPaiHang.GuildName, sGuildName);
      SelfPaiHang.PreSent := self.wyslevel;
      SelfPaiHang.YsJob := self.nysjob;
      SelfPaiHang.YsLevel := self.wyslevel;

      // SendDefMessage(38660,TotlePos,nType, nUpdateNum,65535, '');   //自己的名次
      m_DefMsg := MakeDefaultMsg(38660, TotlePos, nType, nUpdateNum, 65535); //
      SendSocket(@m_DefMsg, EncodeBuffer(@SelfPaiHang, SizeOf(TPaiHangBang)));
    end;

    exit;
  end;
  // if StartPos>= g_TopPlayList.Count then  StartPos:=1;
  if (nType >= $100) and (nType < $200) then
  begin                                                     //英雄榜
    sendcount := 0;
    TotlePos := getPlayListcout(nType);                     //g_TopPlayList.Count;
    if StartPos >= TotlePos then
      StartPos := 1;
    for I := StartPos to TotlePos do
    begin

      SavePaiHang := TopPlayList(i, nType); { TODO 5 -oxjs -c整体 : 实现排行榜功能 }
      if SavePaiHang <> nil then
      begin
        PaiHangBangArray[sendcount].Index := sendcount + StartPos; //
        strpcopy(@PaiHangBangArray[sendcount].CharName, SavePaiHang.CharName);
        PaiHangBangArray[sendcount].Level := SavePaiHang.Level;
        PaiHangBangArray[sendcount].Job := SavePaiHang.Job;
        PaiHangBangArray[sendcount].Sex := SavePaiHang.Sex;
        if SavePaiHang.GuildName <> '无' then
          strpcopy(@PaiHangBangArray[sendcount].GuildName, SavePaiHang.GuildName);
        PaiHangBangArray[sendcount].PreSent := SavePaiHang.PreSent;
        PaiHangBangArray[sendcount].YsJob := SavePaiHang.YsJob;
        PaiHangBangArray[sendcount].YsLevel := SavePaiHang.YsLevel;
        inc(sendcount);
        if sendcount = 10 then
          break;
      end;
    end;
    if TotlePos = 0 then
      sendcount := 1;
    m_DefMsg := MakeDefaultMsg(38660, TotlePos, nType, nUpdateNum, sendcount); //
    SendSocket(@m_DefMsg, EncodeBuffer(@PaiHangBangArray, sendcount *
      SizeOf(TPaiHangBang)));
  end;
  if (nType = $600) then
  begin                                                     //行会榜
    GroupList := TStringList.Create;
    TopGroupList := TStringList.Create;
    GroupList.LoadFromFile(g_Config.sGuildFile);
    for i := 0 to GroupList.Count - 1 do
    begin
      //  MainOutMessage(IntToStr(i)+':'+GroupList[i]);
      GroupTemp := TGuild.create(GroupList[i]);
      if I = GroupList.Count - 1 then
        TopGroupList.CommaText := TopGroupList.CommaText +
          GroupTemp.LoadGuildPoint(GroupList[i]) + '=' + GroupList[i]
      else
        TopGroupList.CommaText := TopGroupList.CommaText +
          GroupTemp.LoadGuildPoint(GroupList[i]) + '=' + GroupList[i] + ',';
      GroupTemp.Free;

    end;
    //    MainOutMessage('值:'+TopGroupList.CommaText);
    TopGroupList.Sort;
    for I := 0 to TopGroupList.Count - 1 do
    begin
      hanghuipaihang[i].ID := i;                            //+StartPos
      strpcopy(@hanghuipaihang[i].GuildName, TopGroupList[i]);
      hanghuipaihang[i].topCharNum := 10;                   //猛将数
      hanghuipaihang[i].YscharNUM := 10;
      hanghuipaihang[i].GuildCharCount := 100;
      hanghuipaihang[i].GuildExp := CarDinal(TopGroupList.Values[TopGroupList[i]]);
    end;
    sendcount := TopGroupList.Count;
    TotlePos := TopGroupList.Count;
    m_DefMsg := MakeDefaultMsg(38660, TotlePos, nType + 1, nUpdateNum, sendcount); //
    SendSocket(@m_DefMsg, EncodeBuffer(@hanghuipaihang, sendcount *
      SizeOf(thanghuipaihang)));
  end;
  if (nType = $400) then
  begin                                                     //天地灵兽榜
    for I := 0 to 9 do
    begin
      baozipaihang[i].ID := i + StartPos;
      strpcopy(@baozipaihang[i].baoziName, '豹子名字');
      baozipaihang[i].baozilevel := i + 6;
      baozipaihang[i].baoziexp := i + 10;
      baozipaihang[i].baozifenghao := '天下第一豹';
      baozipaihang[i].baoziMaster := '是我啊';
      baozipaihang[i].MasterJob := 1;

    end;
    TotlePos := 0;
    m_DefMsg := MakeDefaultMsg(38660, TotlePos, nType, nUpdateNum, 1); //
    SendSocket(@m_DefMsg, EncodeBuffer(@baozipaihang, 1 * SizeOf(Tbaozipaihang)));
  end;
  if (nType >= $300) and (nType < $400) then
  begin                                                     //元神排行榜
    for I := 0 to 9 do
    begin
      YSpaihang[i].ID := i + StartPos;
      strpcopy(@YSpaihang[i].YSCharName, '元神名字');
      YSpaihang[i].YSlevel := 45;
      YSpaihang[i].YSjob := 1;
      YSpaihang[i].YSjipin := 2;
      YSpaihang[i].YSMasterCharName := '元神主人';
      YSpaihang[i].MasterLevel := 55;
      YSpaihang[i].MasterGuildName := '主人行会';

    end;
    TotlePos := 0;
    m_DefMsg := MakeDefaultMsg(38660, TotlePos, nType, nUpdateNum, 1); //
    SendSocket(@m_DefMsg, EncodeBuffer(@YSpaihang, SizeOf(tYSpaihang)));
  end;
  if (nType = $200) then
  begin                                                     //天下名师榜
    for I := 0 to 9 do
    begin
      Masterpaihang[i].ID := i + StartPos;
      strpcopy(@Masterpaihang[i].MasterCharName, '名师名字' + inttostr(i));
      Masterpaihang[i].TudiCount := 13;                     //徒弟数量
      Masterpaihang[i].level := 100;
      Masterpaihang[i].job := 2;
      Masterpaihang[i].Sex := 1;
      // Masterpaihang[i].MasterGuildName:='名师行会';
      strpcopy(@Masterpaihang[i].MasterGuildName, '名师行会' + inttostr(i));

    end;
    TotlePos := 0;
    m_DefMsg := MakeDefaultMsg(38660, TotlePos, nType, nUpdateNum, 1); //
    SendSocket(@m_DefMsg, EncodeBuffer(@Masterpaihang, SizeOf(tMasterpaihang)));
  end;

end;

procedure TPlayObject.sendBOXITEM(nParam1, nParam2, nParam3: integer);
var
  Npc                                                  : TNormNpc;
  UserItem                                             : PTUserItem;
  StdItem                                              : pTStdItem;
begin
  if m_boDeath or m_boGhost then
    exit;
  Npc := UserEngine.FindMerchant(TObject(nParam1));
  if Npc = nil then
    Npc := UserEngine.FindNPC(TObject(nParam1));
  if Npc = nil then
    exit;
  if ((Npc.m_PEnvir = m_PEnvir) and
    (abs(Npc.m_nCurrX - m_nCurrX) < 15) and
    (abs(Npc.m_nCurrY - m_nCurrY) < 15)) or (Npc.m_boIsHide) then
  begin

    m_bocheckboxitem := makelong(nParam2, nParam3);
    UserItem := GetItems(m_bocheckboxitem);
    if UserItem = nil then Exit;                            //物品id不对直接退出
    StdItem := UserEngine.GetStdItem(Useritem.wIndex);
    if stditem = nil then exit;
    case m_nboxbacktype of
      1:                                                    //存
        begin
          if (StdItem.StdMode = 45) and (StdItem.AniCount < 4) and (StdItem.AniCount > 0)
            then
          begin
            if wGEMCOUNT[StdItem.AniCount - 1] >= 200 then
            begin
              SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
                '仓库里面的宝石数量已经超过200个');
              Exit;
            end;
            Inc(wGEMCOUNT[StdItem.AniCount - 1]);
            WeightChanged();
            SendDefMessage(SM_STORAGE_OK, 0, 0, 0, 0, '');

            SendDefMessage(38288, 1, 255, 0, 0, '');        //物品归还
            DelItem(UserItem);

          end
          else
          begin
            SysMsg('该物品不是宝石类物品', c_Red, t_Hint);

          end;

        end;
      6:
        begin
          m_sParam[0] := stditem.Name;
          m_sParam[1] := Inttostr(uSeritem.MakeIndex);
          if not Npc.GotoLable(Self, '@' + stditem.Name, False) then
            Npc.GotoLable(Self, m_nboxid, False);
          SendDefMessage(38288, 1, 255, 0, 0, '');          //物品归还
        end;
      255:
        begin

        end;
    end;

    {   Npc.GotoLable(Self, '@getboxitem' + m_nboxid, False);
      //   SendDefMessage(34897,0,0, 0,0, '');
       if m_nboxbacktype = 1 then
         SendDefMessage(38288, 1, 255, 0, 0, ''); //物品归还
       if m_nboxbacktype = 2 then
         SendDefMessage(38288, 1, 0, 0, 0, ''); //物品消失
         }
  end;

end;

procedure TPlayObject.sendvalue(nParam1: integer; sData: string);
var
  vals, s18                                            : string;
  val                                                  : integer;
  Npc                                                  : TNormNpc;
begin

  //  g_ManageNPC.GotoLable(Self,'@getvalue',False);

  if m_boDeath or m_boGhost then
    exit;

  Npc := TNormNpc(m_npc1);
  if Npc = nil then
    Npc := UserEngine.FindMerchant(TObject(nParam1));
  if Npc = nil then
    Npc := UserEngine.FindNPC(TObject(nParam1));

  if Npc = nil then
    exit;

  if m_nsendid = sRECEIPTS then
  begin
    vals := decodestring(sData);
    val := str_toint(vals, 0);
    s18 := '存资金成功';
    case TUserCastle(Npc.m_Castle).ReceiptGolds(self, val) of
      -4: s18 := '输入的金币数不正确！！！';
      -3: s18 := '你已经达到在城内存放货物的限制了。';
      -2: s18 := '你没有那么多金币.';
      -1: s18 := '只有行会 ' + TUserCastle(Npc.m_Castle).m_sOwnGuild +
        ' 的掌门人才能使用！！！';
      1: Npc.GotoLable(self, sMAIN, False);
    end;
    if s18 <> '' then
      SendMsg(NPC, RM_MENU_OK, 0, Integer(Npc), 0, 0, s18);
    exit;
  end;
  if m_nsendid = sWITHDRAWAL then
  begin
    vals := decodestring(sData);
    val := str_toint(vals, 0);
    s18 := '取回资金成功';
    case TUserCastle(Npc.m_Castle).WithDrawalGolds(self, val) of
      -4: s18 := '输入的金币数不正确！！！';
      -3: s18 := '您无法携带更多的东西了。';
      -2: s18 := '该城内没有这么多金币.';
      -1: s18 := '只有行会 ' + TUserCastle(Npc.m_Castle).m_sOwnGuild +
        ' 的掌门人才能使用！！！';
      1: Npc.GotoLable(self, sMAIN, False);
    end;
    SendMsg(NPC, RM_MENU_OK, 0, Integer(Npc), 0, 0, s18);
    exit;
  end;
  if m_nsendid = sSCL_GUILDWAR then
  begin
    vals := decodestring(sData);
    Npc.ReQuestGuildWar(self, vals);
    Exit;
  end;
  if m_nsendid = sBUILDGUILDNOW then
  begin
    vals := decodestring(sData);
    Npc.GotoLable(Self, '@开始建立中', false);
    //  Npc.ReQuestBuildGuild(self, vals);
    Exit;
  end;

  if ((Npc.m_PEnvir = m_PEnvir) and
    (abs(Npc.m_nCurrX - m_nCurrX) < 15) and
    (abs(Npc.m_nCurrY - m_nCurrY) < 15)) or (Npc.m_boIsHide) then
  begin
    vals := decodestring(sData);
    if m_nsendtype = 0 then
    begin                                                   //表示输入的是字符串
      m_nSendstring := vals;
      m_DySval[m_nSendIdx] := vals;
      Npc.GotoLable(Self, m_nsendid, False);
    end;
    if m_nsendtype = 1 then
    begin
      val := str_toint(vals, 0);
      m_nMval[m_nSendIdx] := val;
      m_nSendValue := val;
      Npc.GotoLable(Self, m_nsendid, False);
    end;

  end;
  ////hint working;
end;

procedure TPlayObject.ModifyStylename(sData: string);
var
  ModStylename                                         : TClientSendModstyleName;
begin
  //   copymemory(@ModStylename,sData,sizeof(TClientSendModstyleName));
  DecodeBuffer(sData, @ModStylename, sizeof(TClientSendModstyleName));
  m_sSytleName := strpas(ModStylename.Name);
  m_dwLastModSytelNameTick := GetTickCount();
  SendDefMessage(38291, Integer(Self), 3, 1, 0, '');        //确认修改
  SysMsg('修改成功', c_Red, t_Hint);
end;

procedure TPlayObject.ProcessUserLineMsg(sData: string);    //004D1E54
var
  sCryCryMsg, sC, sCMD, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7:
    string;
  boDisableSayMsg                                      : Boolean;
  PlayObject                                           : TPlayObject;
  Monsterys                                            : Tbaseobject;
  nFlag                                                : Integer;
  nValue                                               : Integer;
  nLen                                                 : Integer;
  i                                                    : integer;
  st                                                   : string;
  Magic                                                : pTMagic;
  CharDesc                                             : TmyCharDesc;
  sUserCmd                                             : string;
  nUserCmdIndex                                        : Integer;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::ProcessUserLineMsg Msg = %s';
begin
  try
    nLen := Length(sData);
    if sData = '' then
      exit;

    if m_boSetStoragePwd then
    begin
      m_boSetStoragePwd := False;
      if (nLen > 3) and (nLen < 8) then
      begin
        m_sTempPwd := sData;
        m_boReConfigPwd := True;
        SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint);       {'请重复输入一次仓库密码：'}
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      end
      else
      begin
        SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint); {'输入的密码长度不正确！！！，密码长度必须在 4 - 7 的范围内，请重新设置密码。'}
      end;
      exit;
    end;
    if m_boReConfigPwd then
    begin
      m_boReConfigPwd := False;
      if CompareStr(m_sTempPwd, sData) = 0 then
      begin
        m_sStoragePwd := sData;
        m_boPasswordLocked := True;
        m_boCanGetBackItem := False;
        m_sTempPwd := '';
        SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint); {'密码设置成功！！，仓库已经自动上锁，请记好您的仓库密码，在取仓库时需要使用此密码开锁。'}
      end
      else
      begin
        m_sTempPwd := '';
        SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
      end;
      exit;
    end;
    if m_boUnLockPwd or m_boUnLockStoragePwd then
    begin
      if CompareStr(m_sStoragePwd, sData) = 0 then
      begin
        m_boPasswordLocked := False;
        if m_boUnLockPwd then
        begin
          if g_Config.boLockDealAction then
            m_boCanDeal := True;
          if g_Config.boLockDropAction then
            m_boCanDrop := True;
          if g_Config.boLockWalkAction then
            m_boCanWalk := True;
          if g_Config.boLockRunAction then
            m_boCanRun := True;
          if g_Config.boLockHitAction then
            m_boCanHit := True;
          if g_Config.boLockSpellAction then
            m_boCanSpell := True;
          if g_Config.boLockSendMsgAction then
            m_boCanSendMsg := True;
          if g_Config.boLockUserItemAction then
            m_boCanUseItem := True;
          if g_Config.boLockInObModeAction then
          begin
            m_boObMode := False;
            m_boAdminMode := False;
          end;
          m_boLockLogoned := True;
          SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
        end;
        if m_boUnLockStoragePwd then
        begin
          if g_Config.boLockGetBackItemAction then
            m_boCanGetBackItem := True;
          SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
        end;

      end
      else
      begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then
        begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        end;
      end;
      m_boUnLockPwd := False;
      m_boUnLockStoragePwd := False;
      exit;
    end;

    if m_boCheckOldPwd then
    begin
      m_boCheckOldPwd := False;
      if m_sStoragePwd = sData then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        m_boSetStoragePwd := True;
      end
      else
      begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then
        begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          m_boPasswordLocked := True;
        end;
      end;
      exit;
    end;

    if sData[1] <> '@' then
    begin

      ProcessSayMsg(sData);
      exit;
    end;
    sC := Copy(sData, 2, Length(sData) - 1);
    sC := GetValidStr3(sC, sCMD, [' ', ':', ',', #9]);

    if sC <> '' then
    begin
      sC := GetValidStr3(sC, sParam1, [' ', ':', ',', #9]);
      m_sParam[21] := sParam1;
    end;
    if sC <> '' then
    begin
      sC := GetValidStr3(sC, sParam2, [' ', ':', ',', #9]);
      m_sParam[22] := sParam2;

    end;
    if sC <> '' then
    begin
      sC := GetValidStr3(sC, sParam3, [' ', ':', ',', #9]);
      m_sParam[23] := sParam3;
    end;
    if sC <> '' then
    begin
      sC := GetValidStr3(sC, sParam4, [' ', ':', ',', #9]);
      m_sParam[24] := sParam4;
    end;
    if sC <> '' then
    begin
      sC := GetValidStr3(sC, sParam5, [' ', ':', ',', #9]);
      m_sParam[25] := sParam5;
    end;
    if sC <> '' then
    begin
      sC := GetValidStr3(sC, sParam6, [' ', ':', ',', #9]);
      m_sParam[26] := sParam6;
    end;
    if sC <> '' then
    begin
      sC := GetValidStr3(sC, sParam7, [' ', ':', ',', #9]);
      m_sParam[27] := sParam7;
    end;

    sUserCmd := UpperCase(scmd);
    nValue := g_UserCMDList.IndexOf(sUserCmd);
    if nValue >= 0 then
    begin

      nUserCmdIndex := Integer(g_UserCMDList.Objects[nValue]);
      if g_FunctionNPC <> nil then
        g_FunctionNPC.GotoLable(Self, '@UserCmd' + Inttostr(nUserCmdIndex), false);
      exit;
    end;
    //新密码命令
    if CompareText(sCMD, g_GameCommand.PASSWORDLOCK.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        exit;
      end;
      if m_sStoragePwd = '' then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boSetStoragePwd := True;
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        exit;
      end;
      if m_btPwdFailCount > 3 then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        exit;
      end;
      if m_sStoragePwd <> '' then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boCheckOldPwd := True;
        SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
        exit;
      end;
      exit;
    end;
    //新密码命令

    if CompareText(sCMD, g_GameCommand.SETPASSWORD.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        exit;
      end;

      if m_sStoragePwd = '' then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boSetStoragePwd := True;
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
      end
      else
      begin
        SysMsg(g_sAlreadySetPasswordMsg, c_Red, t_Hint);
      end;
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.UNPASSWORD.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        exit;
      end;
      if not m_boPasswordLocked then
      begin
        m_sStoragePwd := '';
        SysMsg(g_sOldPasswordIsClearMsg, c_Green, t_Hint);
      end
      else
      begin
        SysMsg(g_sPleaseUnLockPasswordMsg, c_Red, t_Hint);
      end;
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CHGPASSWORD.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        exit;
      end;
      if m_btPwdFailCount > 3 then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        exit;
      end;
      if m_sStoragePwd <> '' then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boCheckOldPwd := True;
        SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
      end
      else
      begin
        SysMsg(g_sNoPasswordSetMsg, c_Red, t_Hint);
      end;
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.UNLOCKSTORAGE.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        exit;
      end;
      if m_sStoragePwd <> '' then
      begin
        if not m_boUnLockStoragePwd then
        begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
          m_boUnLockStoragePwd := True;
        end
        else
        begin
          SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
        end;
      end
      else
      begin
        SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
      end;
      exit;
    end;
    if Comparetext(sCmd, 'ReadBook') = 0 then
    begin
      SendDefMessage(34971, Integer(Self), Str_ToInt(sParam1, 1), 0, 0, '');
      Exit;
    end;

    if CompareText(sCMD, 'SignMove') = 0 then
    begin
      if (m_btPermission >= 6) then
      begin
        CmdUserMoveXY(sDieMap, IntToStr(wDieX), IntToStr(wDieY));
        sDieMap := '';
        wDieX := 0;
        wDieY := 0;
        Exit;
      end;
    end;
    if CompareText(sCMD, g_GameCommand.UNLOCK.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        exit;
      end;
      if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
        exit;
      end;
      if m_sStoragePwd <> '' then
      begin
        if not m_boUnLockPwd then
        begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
          m_boUnLockPwd := True;
        end
        else
        begin
          SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
        end;
      end
      else
      begin
        SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
      end;
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.LOCK.sCmd) = 0 then
    begin
      if not g_Config.boPasswordLockSystem then
      begin
        SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
        exit;
      end;
      if not m_boPasswordLocked then
      begin
        if m_sStoragePwd <> '' then
        begin
          m_boPasswordLocked := True;
          m_boCanGetBackItem := False;
          SysMsg(g_sLockStorageSuccessMsg, c_Green, t_Hint);
        end
        else
        begin
          SysMsg(g_sStorageNoPasswordMsg, c_Green, t_Hint);
        end;
      end
      else
      begin
        SysMsg(g_sStorageAlreadyLockMsg, c_Red, t_Hint);
      end;
      exit;
    end;
    {
    if CompareText(sCMD,g_GameCommand.LOCK.sCmd) = 0 then begin
      if not m_boPasswordLocked then begin
        m_sStoragePwd:='';
        SysMsg(g_sStoragePasswordClearMsg,c_Green,t_Hint);
      end else begin
        SysMsg(g_sPleaseUnloadStoragePasswordMsg,c_Red,t_Hint);
      end;
      exit;
    end;
    }

    if CompareText(sCMD, g_GameCommand.MakeItemDrop.sCmd) = 0 then
    begin
      CmdMakeItemAndDrop(@g_GameCommand.MakeItemDrop, sParam1, Str_ToInt(sparam2, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.MEMBERFUNCTIONEX.sCmd) = 0 then
    begin
      CmdMemberFunctionEx(g_GameCommand.MEMBERFUNCTIONEX.sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.MEMBERFUNCTIONEX1.sCmd) = 0 then
    begin
      CmdMemberFunctionEx1(g_GameCommand.MEMBERFUNCTIONEX1.sCmd, sParam1);
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.DEAR.sCmd) = 0 then
    begin
      CmdSearchDear(g_GameCommand.DEAR.sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.MASTER.sCmd) = 0 then
    begin
      CmdSearchMaster(g_GameCommand.MASTER.sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.MASTERECALL.sCmd) = 0 then
    begin
      CmdMasterRecall(g_GameCommand.MASTERECALL.sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DEARRECALL.sCmd) = 0 then
    begin
      CmdDearRecall(g_GameCommand.DEARRECALL.sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.ALLOWDEARRCALL.sCmd) = 0 then
    begin
      m_boCanDearRecall := not m_boCanDearRecall;
      if m_boCanDearRecall then
      begin
        SysMsg(g_sEnableDearRecall {'允许夫妻传送！！！'}, c_Blue, t_Hint);
      end
      else
      begin
        SysMsg(g_sDisableDearRecall {'禁止夫妻传送！！！'}, c_Blue, t_Hint);
      end;
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.ALLOWMASTERRECALL.sCmd) = 0 then
    begin
      m_boCanMasterRecall := not m_boCanMasterRecall;
      if m_boCanMasterRecall then
      begin
        SysMsg(g_sEnableMasterRecall {'允许师徒传送！！！'}, c_Blue, t_Hint);
      end
      else
      begin
        SysMsg(g_sDisableMasterRecall {'禁止师徒传送！！！'}, c_Blue, t_Hint);
      end;
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.DATA.sCmd) = 0 then
    begin
      SysMsg(g_sNowCurrDateTime {'当前日期时间: '} +
        FormatDateTime('dddddd,dddd,hh:mm:nn', Now), c_Blue, t_Hint);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.PRVMSG.sCmd) = 0 then
    begin
      CmdPrvMsg(g_GameCommand.PRVMSG.sCmd, g_GameCommand.PRVMSG.nPermissionMin, sParam1);
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.ALLOWMSG.sCmd) = 0 then
    begin
      m_boHearWhisper := not m_boHearWhisper;
      if m_boHearWhisper then
        SysMsg(g_sEnableHearWhisper {'[允许私聊]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableHearWhisper {'[禁止私聊]'}, c_Green, t_Hint);
      exit;
    end;

    if CompareText(sCMD, '禁止私聊') = 0 then
    begin
      m_boHearWhisper := not m_boHearWhisper;
      if m_boHearWhisper then
        SysMsg(g_sEnableHearWhisper {'[允许私聊]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableHearWhisper {'[禁止私聊]'}, c_Green, t_Hint);
      exit;
    end;

    if CompareText(sCMD, '允许好友') = 0 then
    begin
      m_boAllowfriend := not m_boAllowfriend;
      if m_boAllowfriend then
        SysMsg('[允许好友]', c_Green, t_Hint)
      else
        SysMsg('[禁止好友]', c_Green, t_Hint);
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.LETSHOUT.sCmd) = 0 then
    begin
      m_boBanShout := not m_boBanShout;
      if m_boBanShout then
        SysMsg(g_sEnableShoutMsg {'[允许群聊]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableShoutMsg {'[禁止群聊]'}, c_Green, t_Hint);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.LETTRADE.sCmd) = 0 then
    begin
      m_boAllowDeal := not m_boAllowDeal;
      if m_boAllowDeal then
        SysMsg(g_sEnableDealMsg {'[允许交易]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableDealMsg {'[禁止交易]'}, c_Green, t_Hint);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.BANGUILDCHAT.sCmd) = 0 then
    begin
      m_boBanGuildChat := not m_boBanGuildChat;
      if m_boBanGuildChat then
        SysMsg(g_sEnableGuildChat {'[允许行会聊天]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableGuildChat {'[禁止行会聊天]'}, c_Green, t_Hint);
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.LETGUILD.sCmd) = 0 then
    begin
      m_boAllowGuild := not m_boAllowGuild;
      if m_boAllowGuild then
        SysMsg(g_sEnableJoinGuild {'[允许加入行会]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableJoinGuild {'[禁止加入行会]'}, c_Green, t_Hint);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.ENDGUILD.sCmd) = 0 then
    begin
      CmdEndGuild();
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.AUTHALLY.sCmd) = 0 then
    begin
      if IsGuildMaster then
      begin
        TGuild(m_MyGuild).m_boEnableAuthAlly := not TGuild(m_MyGuild).m_boEnableAuthAlly;
        if TGuild(m_MyGuild).m_boEnableAuthAlly then
          SysMsg(g_sEnableAuthAllyGuild {'[允许行会联盟]'}, c_Green, t_Hint)
        else
          SysMsg(g_sDisableAuthAllyGuild {'[禁止行会联盟]'}, c_Green, t_Hint);
      end;
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.ALLOWGROUPCALL.sCmd) = 0 then
    begin
      CmdAllowGroupReCall(sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.GROUPRECALLL.sCmd) = 0 then
    begin
      CmdGroupRecall(g_GameCommand.GROUPRECALLL.sCmd);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.ALLOWGUILDRECALL.sCmd) = 0 then
    begin
      m_boAllowGuildReCall := not m_boAllowGuildReCall;
      if m_boAllowGuildReCall then
        SysMsg(g_sEnableGuildRecall {'[允许行会合一]'}, c_Green, t_Hint)
      else
        SysMsg(g_sDisableGuildRecall {'[禁止行会合一]'}, c_Green, t_Hint);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.GUILDRECALLL.sCmd) = 0 then
    begin
      CmdGuildRecall(g_GameCommand.GUILDRECALLL.sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.AUTH.sCmd) = 0 then
    begin
      if IsGuildMaster then
        ClientGuildAlly();
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.AUTHCANCEL.sCmd) = 0 then
    begin
      if IsGuildMaster then
        ClientGuildBreakAlly(sParam1);
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.DIARY.sCmd) = 0 then
    begin
      CmdViewDiary(g_GameCommand.DIARY.sCmd, Str_ToInt(sParam1, 0));
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.ATTACKMODE.sCmd) = 0 then
    begin
      CmdChangeAttackMode(Str_ToInt(sParam1, -1), sParam1, sParam2, sParam3, sParam4,
        sParam5, sParam6, sParam7);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.REST.sCmd) = 0 then
    begin
      CmdChangeSalveStatus();
      exit;
    end;

    if CompareText(sCMD, 'HorseRest') = 0 then
    begin
      CmdChangehorseStatus();
      exit;
    end;

    if CompareText(sCMD, 'HorseRest') = 0 then
    begin
      CmdChangehorseStatus();
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.TAKEONHORSE.sCmd) = 0 then
    begin
      CmdTakeOnHorse(sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.TAKEOFHORSE.sCmd) = 0 then
    begin
      CmdTakeOffHorse(sCmd, sParam1);
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.MAPINFO.sCmd) = 0 then
    begin
      ShowMapInfo(sParam1, sParam2, sParam3);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CLEARBAG.sCmd) = 0 then
    begin
      CmdClearBagItem(@g_GameCommand.CLEARBAG, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHOWUSEITEMINFO.sCmd) = 0 then
    begin
      CmdShowUseItemInfo(@g_GameCommand.SHOWUSEITEMINFO, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.BINDUSEITEM.sCmd) = 0 then
    begin
      CmdBindUseItem(@g_GameCommand.BINDUSEITEM, sParam1, sParam2, sParam3);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SBKDOOR.sCmd) = 0 then
    begin                                                   //004D2610
      CmdSbkDoorControl(g_GameCommand.SBKDOOR.sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.USERMOVE.sCmd) = 0 then
    begin
      CmdUserMoveXY(g_GameCommand.USERMOVE.sCmd, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SEARCHING.sCmd) = 0 then
    begin
      CmdSearchHuman(g_GameCommand.SEARCHING.sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.LOCKLOGON.sCmd) = 0 then
    begin
      CmdLockLogin(@g_GameCommand.LOCKLOGON);
      exit;
    end;
    if (m_btPermission >= 2) and (length(sData) > 2) then
    begin
      //if sData[2] = '!' then begin
      if (m_btPermission >= 6) and ((sData[2] = g_GMRedMsgCmd) or (sData[2] = '~') or
        (sData[2] = '%') or (sData[2] = '#')) then
      begin

        if GetTickCount - m_dwSayMsgTick > 2000 then
        begin
          m_dwSayMsgTick := GetTickCount();
          st := sData;
          sData := Copy(sData, 3, length(sData) - 2);
          if length(sData) > g_Config.nSayRedMsgMaxLen then
          begin
            sData := Copy(sData, 1, g_Config.nSayRedMsgMaxLen);
          end;

          if g_Config.boShutRedMsgShowGMName then
            sC := m_sCharName + ': ' + sData
          else
            sC := sData;
          if st[2] = '~' then
            UserEngine.SendBroadCastMsg(sC, t_hSystem);
          if st[2] = '#' then
            UserEngine.SendBroadCastMsg(sC, t_rSystem);
          if st[2] = '%' then
            UserEngine.SendBroadCastMsg(sC, t_tSystem);
          if st[2] = g_GMRedMsgCmd then
            UserEngine.SendBroadCastMsg(sC, t_GM);
        end;
        exit;
      end;
    end;
    //004D2C70
    if CompareText(sCMD, g_GameCommand.HUMANLOCAL.sCmd) = 0 then
    begin
      CmdHumanLocal(@g_GameCommand.HUMANLOCAL, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.MOVE.sCmd) = 0 then
    begin
      CmdMapMove(@g_GameCommand.MOVE, sParam1);
      Exit;
    end;                                                    //004D2CD0
    if CompareText(sCMD, g_GameCommand.POSITIONMOVE.sCmd) = 0 then
    begin
      CmdPositionMove(@g_GameCommand.POSITIONMOVE, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.INFO.sCmd) = 0 then
    begin
      CmdHumanInfo(@g_GameCommand.INFO, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.MOBLEVEL.sCmd) = 0 then
    begin
      CmdMobLevel(@g_GameCommand.MOBLEVEL, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.MOBCOUNT.sCmd) = 0 then
    begin
      CmdMobCount(@g_GameCommand.MOBCOUNT, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.HUMANCOUNT.sCmd) = 0 then
    begin
      CmdHumanCount(@g_GameCommand.HUMANCOUNT, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.KICK.sCmd) = 0 then
    begin
      CmdKickHuman(@g_GameCommand.KICK, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.TING.sCmd) = 0 then
    begin
      CmdTing(@g_GameCommand.TING, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.SUPERTING.sCmd) = 0 then
    begin
      CmdSuperTing(@g_GameCommand.SUPERTING, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.MAPMOVE.sCmd) = 0 then
    begin
      CmdMapMoveHuman(@g_GameCommand.MAPMOVE, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHUTUP.sCmd) = 0 then
    begin
      CmdShutup(@g_GameCommand.SHUTUP, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.MAP.sCmd) = 0 then
    begin
      CmdShowMapInfo(@g_GameCommand.MAP, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.RELEASESHUTUP.sCmd) = 0 then
    begin
      CmdShutupRelease(@g_GameCommand.RELEASESHUTUP, sParam1, True);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHUTUPLIST.sCmd) = 0 then
    begin
      CmdShutupList(@g_GameCommand.SHUTUPLIST, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.GAMEMASTER.sCmd) = 0 then
    begin
      CmdChangeAdminMode(g_GameCommand.GAMEMASTER.sCmd,
        g_GameCommand.GAMEMASTER.nPermissionMin, sParam1, not m_boAdminMode);
      Exit;
    end;
    if CompareText(sCMD, 'Say') = 0 then
    begin
      if g_FunctionNPC <> nil then
        g_FunctionNPC.GetValValue(self, sParam1, i, sc);
      ProcessSayMsg(sc);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.OBSERVER.sCmd) = 0 then
    begin
      CmdChangeObMode(g_GameCommand.OBSERVER.sCmd, g_GameCommand.OBSERVER.nPermissionMin,
        sParam1, not m_boObMode);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.SUEPRMAN.sCmd) = 0 then
    begin
      CmdChangeSuperManMode(g_GameCommand.OBSERVER.sCmd,
        g_GameCommand.OBSERVER.nPermissionMin, sParam1, not m_boSuperMan);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.LEVEL.sCmd) = 0 then
    begin
      CmdChangeLevel(@g_GameCommand.LEVEL, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.SABUKWALLGOLD.sCmd) = 0 then
    begin
      CmdShowSbkGold(@g_GameCommand.SABUKWALLGOLD, sParam1, sParam2, sParam3);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.RECALL.sCmd) = 0 then
    begin
      CmdRecallHuman(@g_GameCommand.RECALL, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.REGOTO.sCmd) = 0 then
    begin
      CmdReGotoHuman(@g_GameCommand.REGOTO, sParam1);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHOWFLAG.sCmd) = 0 then
    begin
      CmdShowHumanFlag(g_GameCommand.SHOWFLAG.sCmd,
        g_GameCommand.SHOWFLAG.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHOWOPEN.sCmd) = 0 then
    begin
      CmdShowHumanUnitOpen(g_GameCommand.SHOWOPEN.sCmd,
        g_GameCommand.SHOWOPEN.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHOWUNIT.sCmd) = 0 then
    begin
      CmdShowHumanUnit(g_GameCommand.SHOWUNIT.sCmd,
        g_GameCommand.SHOWUNIT.nPermissionMin, sParam1, sParam2);
      Exit;
    end;
    if CompareText(sCMD, g_GameCommand.ATTACK.sCmd) = 0 then
    begin
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.MOB.sCmd) = 0 then
    begin
      CmdMob(@g_GameCommand.MOB, sParam1, Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0),
        sParam4);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.MOBNPC.sCmd) = 0 then
    begin
      CmdMobNpc(g_GameCommand.MOBNPC.sCmd, g_GameCommand.MOBNPC.nPermissionMin, sParam1,
        sParam2, sParam3, sParam4);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.NPCSCRIPT.sCmd) = 0 then
    begin
      CmdNpcScript(g_GameCommand.NPCSCRIPT.sCmd, g_GameCommand.NPCSCRIPT.nPermissionMin,
        sParam1, sParam2, sParam3);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DELNPC.sCmd) = 0 then
    begin
      CmdDelNpc(g_GameCommand.DELNPC.sCmd, g_GameCommand.DELNPC.nPermissionMin, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.RECALLMOB.sCmd) = 0 then
    begin
      CmdRecallMob(@g_GameCommand.RECALLMOB, sParam1, Str_ToInt(sParam2, 0),
        Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0), Str_ToInt(sParam5, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.LUCKYPOINT.sCmd) = 0 then
    begin
      CmdLuckPoint(g_GameCommand.LUCKYPOINT.sCmd,
        g_GameCommand.LUCKYPOINT.nPermissionMin, sParam1, sParam2, sParam3);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.LOTTERYTICKET.sCmd) = 0 then
    begin
      CmdLotteryTicket(g_GameCommand.LOTTERYTICKET.sCmd,
        g_GameCommand.LOTTERYTICKET.nPermissionMin, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.RELOADGUILD.sCmd) = 0 then
    begin
      CmdReloadGuild(g_GameCommand.RELOADGUILD.sCmd,
        g_GameCommand.RELOADGUILD.nPermissionMin, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.RELOADLINENOTICE.sCmd) = 0 then
    begin
      CmdReloadLineNotice(g_GameCommand.RELOADLINENOTICE.sCmd,
        g_GameCommand.RELOADLINENOTICE.nPermissionMin, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.RELOADABUSE.sCmd) = 0 then
    begin
      CmdReloadAbuse(g_GameCommand.RELOADABUSE.sCmd,
        g_GameCommand.RELOADABUSE.nPermissionMin, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.FREEPENALTY.sCmd) = 0 then
    begin
      CmdFreePenalty(@g_GameCommand.FREEPENALTY, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.PKPOINT.sCmd) = 0 then
    begin
      CmdPKpoint(@g_GameCommand.PKPOINT, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.INCPKPOINT.sCmd) = 0 then
    begin
      CmdIncPkPoint(@g_GameCommand.INCPKPOINT, sParam1, Str_ToInt(sParam2, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.MAKE.sCmd) = 0 then
    begin
      CmdMakeItem(@g_GameCommand.MAKE, sParam1, Str_ToInt(sParam2, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.VIEWWHISPER.sCmd) = 0 then
    begin
      CmdViewWhisper(@g_GameCommand.VIEWWHISPER, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.REALIVE.sCmd) = 0 then
    begin
      CmdReAlive(@g_GameCommand.REALIVE, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.KILL.sCmd) = 0 then
    begin
      CmdKill(@g_GameCommand.KILL, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SMAKE.sCmd) = 0 then
    begin
      CmdSmakeItem(@g_GameCommand.SMAKE, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0),
        Str_ToInt(sParam3, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CHANGEJOB.sCmd) = 0 then
    begin
      CMdChangeJob(@g_GameCommand.CHANGEJOB, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CHANGEGENDER.sCmd) = 0 then
    begin
      CmdChangeGender(@g_GameCommand.CHANGEGENDER, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.HAIR.sCmd) = 0 then
    begin
      CmdHair(@g_GameCommand.HAIR, sParam1, Str_ToInt(sParam2, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.BONUSPOINT.sCmd) = 0 then
    begin
      CmdBonuPoint(@g_GameCommand.BONUSPOINT, sParam1, Str_ToInt(sParam2, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DELBONUSPOINT.sCmd) = 0 then
    begin
      CmdDelBonuPoint(@g_GameCommand.DELBONUSPOINT, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.RESTBONUSPOINT.sCmd) = 0 then
    begin
      CmdRestBonuPoint(@g_GameCommand.RESTBONUSPOINT, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SETPERMISSION.sCmd) = 0 then
    begin
      CmdSetPermission(@g_GameCommand.SETPERMISSION, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.RENEWLEVEL.sCmd) = 0 then
    begin
      CmdReNewLevel(@g_GameCommand.RENEWLEVEL, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DELGOLD.sCmd) = 0 then
    begin
      CmdDelGold(@g_GameCommand.DELGOLD, sParam1, Str_ToInt(sParam2, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.ADDGOLD.sCmd) = 0 then
    begin
      CmdAddGold(@g_GameCommand.ADDGOLD, sParam1, Str_ToInt(sParam2, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.GAMEGOLD.sCmd) = 0 then
    begin
      CmdGameGold(@g_GameCommand.GAMEGOLD, sParam1, sParam2, Str_ToInt(sParam3, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.GAMEPOINT.sCmd) = 0 then
    begin
      CmdGamePoint(@g_GameCommand.GAMEPOINT, sParam1, sParam2, Str_ToInt(sParam3, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CREDITPOINT.sCmd) = 0 then
    begin
      CmdCreditPoint(@g_GameCommand.CREDITPOINT, sParam1, sParam2, Str_ToInt(sParam3,
        0));
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.BigBag.sCmd) = 0 then
    begin
      CmdBigBag(@g_GameCommand.BigBag, sParam1);
      exit;
    end;

    if CompareText(sCMD, g_GameCommand.TRAINING.sCmd) = 0 then
    begin
      CmdTrainingSkill(@g_GameCommand.TRAINING, sParam1, sParam2, Str_ToInt(sParam3, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DELETEITEM.sCmd) = 0 then
    begin
      CmdDeleteItem(@g_GameCommand.DELETEITEM, sParam1, sParam2, Str_ToInt(sParam3, 1));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DELETESKILL.sCmd) = 0 then
    begin
      CmdDelSkill(@g_GameCommand.DELETESKILL, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.TRAININGSKILL.sCmd) = 0 then
    begin
      CmdTrainingMagic(@g_GameCommand.TRAININGSKILL, sParam1, sParam2, Str_ToInt(sParam3,
        0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CLEARMISSION.sCmd) = 0 then
    begin
      CmdClearMission(@g_GameCommand.CLEARMISSION, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.STARTQUEST.sCmd) = 0 then
    begin
      CmdStartQuest(@g_GameCommand.STARTQUEST, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DENYIPLOGON.sCmd) = 0 then
    begin
      CmdDenyIPaddrLogon(@g_GameCommand.DENYIPLOGON, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CHANGEDEARNAME.sCmd) = 0 then
    begin
      CmdChangeDearName(@g_GameCommand.CHANGEDEARNAME, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CHANGEMASTERNAME.sCmd) = 0 then
    begin
      CmdChangeMasterName(@g_GameCommand.CHANGEMASTERNAME, sParam1, sParam2, sParam3);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CLEARMON.sCmd) = 0 then
    begin
      CmdClearMapMonster(@g_GameCommand.CLEARMON, sParam1, sParam2, sParam3);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DENYACCOUNTLOGON.sCmd) = 0 then
    begin
      CmdDenyAccountLogon(@g_GameCommand.DENYACCOUNTLOGON, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DENYCHARNAMELOGON.sCmd) = 0 then
    begin
      CmdDenyCharNameLogon(@g_GameCommand.DENYCHARNAMELOGON, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DELDENYIPLOGON.sCmd) = 0 then
    begin
      CmdDelDenyIPaddrLogon(@g_GameCommand.DELDENYIPLOGON, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DELDENYACCOUNTLOGON.sCmd) = 0 then
    begin
      CmdDelDenyAccountLogon(@g_GameCommand.DELDENYACCOUNTLOGON, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DELDENYCHARNAMELOGON.sCmd) = 0 then
    begin
      CmdDelDenyCharNameLogon(@g_GameCommand.DELDENYCHARNAMELOGON, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHOWDENYIPLOGON.sCmd) = 0 then
    begin
      CmdShowDenyIPaddrLogon(@g_GameCommand.SHOWDENYIPLOGON, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHOWDENYACCOUNTLOGON.sCmd) = 0 then
    begin
      CmdShowDenyAccountLogon(@g_GameCommand.SHOWDENYACCOUNTLOGON, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHOWDENYCHARNAMELOGON.sCmd) = 0 then
    begin
      CmdShowDenyCharNameLogon(@g_GameCommand.SHOWDENYCHARNAMELOGON, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.MISSION.sCmd) = 0 then
    begin
      CmdMission(@g_GameCommand.MISSION, sParam1, sParam2);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.MOBPLACE.sCmd) = 0 then
    begin
      CmdMobPlace(@g_GameCommand.MOBPLACE, sParam1, sParam2, sParam3, sParam4);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SETMAPMODE.sCmd) = 0 then
    begin
      CmdSetMapMode(g_GameCommand.SETMAPMODE.sCmd, sParam1, sParam2, sParam3, sParam4);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.SHOWMAPMODE.sCmd) = 0 then
    begin
      CmdShowMapMode(g_GameCommand.SHOWMAPMODE.sCmd, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CLRPASSWORD.sCmd) = 0 then
    begin
      CmdClearHumanPassword(g_GameCommand.CLRPASSWORD.sCmd,
        g_GameCommand.CLRPASSWORD.nPermissionMin, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.CONTESTPOINT.sCmd) = 0 then
    begin
      CmdContestPoint(@g_GameCommand.CONTESTPOINT, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.STARTCONTEST.sCmd) = 0 then
    begin
      CmdStartContest(@g_GameCommand.STARTCONTEST, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.ENDCONTEST.sCmd) = 0 then
    begin
      CmdEndContest(@g_GameCommand.ENDCONTEST, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.ANNOUNCEMENT.sCmd) = 0 then
    begin
      CmdAnnouncement(@g_GameCommand.ANNOUNCEMENT, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DISABLESENDMSG.sCmd) = 0 then
    begin
      CmdDisableSendMsg(@g_GameCommand.DISABLESENDMSG, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.ENABLESENDMSG.sCmd) = 0 then
    begin
      CmdEnableSendMsg(@g_GameCommand.ENABLESENDMSG, sParam1);
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.REFINEWEAPON.sCmd) = 0 then
    begin
      CmdRefineWeapon(@g_GameCommand.REFINEWEAPON, Str_ToInt(sParam1, 0),
        Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
      exit;
    end;
    if CompareText(sCMD, g_GameCommand.DISABLESENDMSGLIST.sCmd) = 0 then
    begin
      CmdDisableSendMsgList(@g_GameCommand.DISABLESENDMSGLIST);
      exit;
    end;
    if m_btPermission > 4 then
    begin
      if CompareText(sCMD, g_GameCommand.BACKSTEP.sCmd) = 0 then
      begin
        CmdBackStep(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 1));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.BALL.sCmd) = 0 then
      begin                                                 //精神波
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.CHANGELUCK.sCmd) = 0 then
      begin
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.HUNGER.sCmd) = 0 then
      begin
        CmdHunger(g_GameCommand.HUNGER.sCmd, sParam1, Str_ToInt(sParam2, 0));
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.NAMECOLOR.sCmd) = 0 then
      begin
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.TRANSPARECY.sCmd) = 0 then
      begin
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.LEVEL0.sCmd) = 0 then
      begin
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.SETFLAG.sCmd) = 0 then
      begin                                                 //004D3BDD
        PlayObject := UserEngine.GeTPlayObject(sParam1);
        if PlayObject <> nil then
        begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestFlagStatus(nFlag, nValue);
          if PlayObject.GetQuestFalgStatus(nFlag) = 1 then
          begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green,
              t_Hint);
          end
          else
          begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green,
              t_Hint);
          end;
        end
        else
        begin
          SysMsg('@' + g_GameCommand.SETFLAG.sCmd + ' 人物名称 标志号 数字(0 - 1)',
            c_Red, t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SETOPEN.sCmd) = 0 then
      begin
        PlayObject := UserEngine.GeTPlayObject(sParam1);
        if PlayObject <> nil then
        begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestUnitOpenStatus(nFlag, nValue);
          if PlayObject.GetQuestUnitOpenStatus(nFlag) = 1 then
          begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green,
              t_Hint);
          end
          else
          begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green,
              t_Hint);
          end;
        end
        else
        begin
          SysMsg('@' + g_GameCommand.SETOPEN.sCmd + ' 人物名称 标志号 数字(0 - 1)',
            c_Red, t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SETUNIT.sCmd) = 0 then
      begin
        PlayObject := UserEngine.GeTPlayObject(sParam1);
        if PlayObject <> nil then
        begin
          nFlag := Str_ToInt(sParam2, 0);
          nValue := Str_ToInt(sParam3, 0);
          PlayObject.SetQuestUnitStatus(nFlag, nValue);
          if PlayObject.GetQuestUnitStatus(nFlag) = 1 then
          begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON', c_Green,
              t_Hint);
          end
          else
          begin
            SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF', c_Green,
              t_Hint);
          end;
        end
        else
        begin
          SysMsg('@' + g_GameCommand.SETUNIT.sCmd + ' 人物名称 标志号 数字(0 - 1)',
            c_Red, t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.RECONNECTION.sCmd) = 0 then
      begin
        CmdReconnection(sCmd, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DISABLEFILTER.sCmd) = 0 then
      begin
        CmdDisableFilter(sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CHGUSERFULL.sCmd) = 0 then
      begin
        CmdChangeUserFull(sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CHGZENFASTSTEP.sCmd) = 0 then
      begin
        CmdChangeZenFastStep(sCmd, sParam1);
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.OXQUIZROOM.sCmd) = 0 then
      begin
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.GSA.sCmd) = 0 then
      begin
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CHANGEITEMNAME.sCmd) = 0 then
      begin
        CmdChangeItemName(g_GameCommand.CHANGEITEMNAME.sCmd, sParam1, sParam2, sParam3);
        exit;
      end;
      if (m_btPermission >= 5) or (g_Config.boTestServer) then
      begin

        if CompareText(sCMD, g_GameCommand.FIREBURN.sCmd) = 0 then
        begin
          CmdFireBurn(Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0), Str_ToInt(sParam3,
            0));
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.TESTFIRE.sCmd) = 0 then
        begin
          CmdTestFire(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0),
            Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
          exit;
        end;
        if CompareText(sCMD, 'testanying') = 0 then
        begin
          CmdTestanying(sCmd, 0, -1, Str_ToInt(sParam1, 0), 0);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.TESTSTATUS.sCmd) = 0 then
        begin
          CmdTestStatus(sCmd, Str_ToInt(sParam1, -1), Str_ToInt(sParam2, 0));
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.DELGAMEGOLD.sCmd) = 0 then
        begin
          CmdDelGameGold(g_GameCommand.DELGAMEGOLD.sCmd, sParam1, Str_ToInt(sParam2, 0));
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.ADDGAMEGOLD.sCmd) = 0 then
        begin
          CmdAddGameGold(g_GameCommand.ADDGAMEGOLD.sCmd, sParam1, Str_ToInt(sParam2, 0));
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.TESTGOLDCHANGE.sCmd) = 0 then
        begin
          exit;
        end;

        if CompareText(sCMD, g_GameCommand.RELOADADMIN.sCmd) = 0 then
        begin
          CmdReLoadAdmin(g_GameCommand.RELOADADMIN.sCmd);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADNPC.sCmd) = 0 then
        begin
          CmdReloadNpc(sParam1);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADMANAGE.sCmd) = 0 then
        begin
          CmdReloadManage(@g_GameCommand.RELOADMANAGE, sParam1);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADROBOTMANAGE.sCmd) = 0 then
        begin
          CmdReloadRobotManage();
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADROBOT.sCmd) = 0 then
        begin
          CmdReloadRobot();
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADMONITEMS.sCmd) = 0 then
        begin
          CmdReLoadMonitems();
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADDIARY.sCmd) = 0 then
        begin
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADITEMDB.sCmd) = 0 then
        begin
          FrmDB.LoadItemsDB();
          SysMsg('物品数据库重新加载完成。', c_Green, t_Hint);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADMAGICDB.sCmd) = 0 then
        begin
          //FrmDB.LoadMagicDB();
          //SysMsg('魔法数据库重新加载完成。',c_Green,t_Hint);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADMONSTERDB.sCmd) = 0 then
        begin
          FrmDB.LoadMonsterDB();
          SysMsg('怪物数据库重新加载完成。', c_Green, t_Hint);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.RELOADMINMAP.sCmd) = 0 then
        begin
          FrmDB.LoadMinMap();
          g_MapManager.ReSetMinMap();
          SysMsg('小地图配置重新加载完成。', c_Green, t_Hint);
          exit;
        end;

        if CompareText(sCMD, g_GameCommand.ADJUESTLEVEL.sCmd) = 0 then
        begin
          CmdAdjuestLevel(@g_GameCommand.ADJUESTLEVEL, sParam1, Str_ToInt(sParam2, 1));
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.ADJUESTEXP.sCmd) = 0 then
        begin
          CmdAdjuestExp(@g_GameCommand.ADJUESTEXP, sParam1, sParam2);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.ADDGUILD.sCmd) = 0 then
        begin
          CmdAddGuild(@g_GameCommand.ADDGUILD, sParam1, sParam2);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.DELGUILD.sCmd) = 0 then
        begin
          CmdDelGuild(@g_GameCommand.DELGUILD, sParam1);
          exit;
        end;
        if (CompareText(sCMD, g_GameCommand.CHANGESABUKLORD.sCmd) = 0) then
        begin
          CmdChangeSabukLord(@g_GameCommand.CHANGESABUKLORD, sParam1, sParam2, True);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.FORCEDWALLCONQUESTWAR.sCmd) = 0 then
        begin
          CmdForcedWallconquestWar(@g_GameCommand.FORCEDWALLCONQUESTWAR, sParam1);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.ADDTOITEMEVENT.sCmd) = 0 then
        begin
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.ADDTOITEMEVENTASPIECES.sCmd) = 0 then
        begin
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.ITEMEVENTLIST.sCmd) = 0 then
        begin
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.STARTINGGIFTNO.sCmd) = 0 then
        begin
          exit;
        end;
        if CompareText(sCMD, 'fireflower') = 0 then
        begin
          //  SendDefMessage(100,0,38656,10,768,'林风广告');
          SendRefMsg(rm_21295, 0, 0, 0, strtoint(sParam1), '');
          exit;
        end;
        if CompareText(sCMD, 'magiccolor') = 0 then
        begin
          m_nmagiccolor := str_toint(sParam1, 0);
          m_bomagiccolorchange := true;
          exit;
        end;

        if CompareText(sCMD, 'magicfont') = 0 then
        begin
          m_wmagicfont := str_toint(sParam1, 0);
          m_wmagicfontcolor := str_toint(sParam2, 0);
          m_bohasmagicfont := true;
          exit;
        end;

        if CompareText(sCMD, 'makeplay') = 0 then
        begin
          // for i:= 1 to  str_toint(sParam2,1) do begin
          Monsterys := UserEngine.RegenMonsterysByName(sParam1, self);
          if Monsterys = nil then
            exit;
          // Monsterys.m_boLoginNoticeOK:=true;
          //  Monsterys.m_nSoftVersionDate:=20091212;
          Monsterys.m_boNoItem := true;                     //不会暴装备
          Monsterys.m_Master := self;                       //是我的宝宝
          Monsterys.m_dwMasterRoyaltyTick := GetTickCount + 240 * 60 * 60 * 1000;

          //   Monsterys.m_btSlaveMakeLevel := 7;
           //  Monsterys.m_btSlaveExpLevel := 7;

          Monsterys.RecalcAbilitys();
          Monsterys.RecalcHitSpeed();

          //   Monsterys.RefNameColor();
          m_SlaveList.Add(Monsterys);
          SendRefMsg(RM_510, 0, 1, 0, 24, '');
          //  Monsterys.SendDelayMsg(Monsterys,RM_510,0, 1 ,0,25,'',800);
          Monsterys.SendRefMsg(RM_510, 0, 1, 0, 25, '');
          //  n18:=UserEngine.m_MonGenList.Count - 1;
          //  if n18 < 0 then n18:=0;
          //  MonGen:=UserEngine.m_MonGenList.Items[UserEngine.m_MonGenList.Count - 1];
          //  MonGen.CertList.Add(BaseObject);
           // BaseObject.m_PEnvir.AddObject(1);
          //  BaseObject.m_boAddToMaped:=True;
        //   UserEngine.m_PlayObjectList.AddObject(sParam1,PlayObject);

           // CmdMemberFunction(g_GameCommand.MEMBERFUNCTION.sCmd,sParam1);
        //   end;

          exit;
        end;
        if CompareText(sCMD, 'makeys') = 0 then
        begin
          //   if NewYsRcd(m_sUserID,sParam1,'1','0','0',m_sCharName,m_nSessionID) then begin
          //    end;
               //  if sYsname='' then  begin
          if sParam3 = '0' then
            nValue := 1
          else
            nValue := 21;

          UserEngine.NewHumanYS(self, m_sUserID, sParam1, nValue, Str_ToInt(sParam2, 0),
            strtoint(sParam3), self.m_sCharName, m_nSessionID);
          //   NewHumanYS(PlayObject:TPlayObject;sAccount,sChrName:String;bHair,bJob,bSex:byte;sYsnameMaster:String;nSessionID:Integer);
                 //   m_boCheckNewYs:=true;
                 //  sYsname:=sParam1;
                 //  SendDefMessage(38407,0,0,0,0,sYsname);
                 //   end;
          exit;
        end;

        if CompareText(sCMD, 'useskill') = 0 then
        begin
          // for i:= 1 to  str_toint(sParam2,1) do begin
        //    Monsterys:= UserEngine.RegenMonsterysByName(sParam1,self);
          for i := m_SlaveList.Count - 1 downto 0 do
          begin
            if TBaseObject(m_SlaveList.Items[i]).m_btRaceServer = RC_YSBJECT then
            begin
              Monsterys := TBaseObject(m_SlaveList.Items[i]);
              if Monsterys.m_sCharName = sParam2 then
                break;
            end;
          end;
          if Monsterys <> nil then
          begin
            Magic := UserEngine.FindMagic(sParam1);
            if Magic <> nil then
            begin
              if GetMagicInfo(Magic.wMagicID) <> nil then
              begin
                Monsterys.nskill := Magic.wMagicID;
                SysMsg('你的元神' + Monsterys.m_sCharName + '开始使用技能：' + sParam1,
                  c_Red, t_Hint);
              end
              else
                SysMsg('你的元神' + Monsterys.m_sCharName + '没有学习该技能', c_Red,
                  t_Hint);
            end;                                            //Magic <> nil
          end;                                              //   Monsterys<>nil
          exit;
        end;
        if CompareText(sCMD, 'makemsg') = 0 then
        begin
          {  m_DefMsg:=MakeDefaultMsg(11228,
                                        0 , //Integer(self)
                                         m_nCurrX,
                                         m_nCurrY,
                                         3);   // m_btDirection

            CharDesc.feature:=16711698;//GetFeature(Self);
          //  CharDesc.Status:=m_nCharStatus;
            SendSocket(@m_DefMsg,EncodeBuffer(@CharDesc,4));
          //  SendMsg(self,RM_dengyu1,m_btDirection,m_nCurrX,m_nCurrY,0,GetShowName);
          }//  integer(self)
         //  SendDefMessage(strtoint(sParam1),strtoint(sParam2),strtoint(sParam3),strtoint(sParam4),strtoint(sParam5),'<Task title=师徒>你的徒弟</Task>');
          SendDefMessage(615, 1862607616, 200, 0, 0, '');
          m_DefMsg := MakeDefaultMsg(41,
            Integer(self),
            8960,
            28421,                                          // 2821,
            256);
          CharDesc.feature := 200;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, 4));

          exit;
        end;

        if CompareText(sCMD, 'tq') = 0 then
        begin
          m_PEnvir.m_weatherEffect := str_toint(sParam1, 0);
          for I := 0 to UserEngine.m_PlayObjectList.Count - 1 do
          begin
            PlayObject := TPlayObject(UserEngine.m_PlayObjectList.Objects[I]);
            if (not PlayObject.m_boDeath) and (not PlayObject.m_boGhost) and (m_PEnvir =
              PlayObject.m_PEnvir) then
              PlayObject.SendMsg(self, RM_DAYCHANGING, 0, 0, 0, 0, '');
          end;                                              //for
          exit;
        end;

        if CompareText(sCMD, g_GameCommand.DELETEALLITEMEVENT.sCmd) = 0 then
        begin
          exit;
        end
        else
          if CompareText(sCMD, g_GameCommand.STARTITEMEVENT.sCmd) = 0 then
          begin
            exit;
          end
          else
            if CompareText(sCMD, g_GameCommand.ITEMEVENTTERM.sCmd) = 0 then
            begin
              exit;
            end
            else
              if CompareText(sCMD, g_GameCommand.ADJUESTTESTLEVEL.sCmd) = 0 then
              begin
                exit;
              end
              else
                if CompareText(sCMD, g_GameCommand.OPDELETESKILL.sCmd) = 0 then
                begin
                  exit;
                end
                else
                  if CompareText(sCMD, g_GameCommand.CHANGEWEAPONDURA.sCmd) = 0 then
                  begin
                    exit;
                  end
                  else
                    if CompareText(sCMD, g_GameCommand.RELOADGUILDALL.sCmd) = 0 then
                    begin
                      exit;
                    end
                    else
                      if CompareText(sCMD, g_GameCommand.SPIRIT.sCmd) = 0 then
                      begin
                        CmdSpirtStart(g_GameCommand.SPIRIT.sCmd, sParam1);
                        exit;
                      end
                      else
                        if CompareText(sCMD, g_GameCommand.SPIRITSTOP.sCmd) = 0 then
                        begin
                          CmdSpirtStop(g_GameCommand.SPIRITSTOP.sCmd, sParam1);
                          exit;
                        end
                        else
                          if CompareText(sCMD, g_GameCommand.TESTSERVERCONFIG.sCmd) = 0
                            then
                          begin
                            SendServerConfig();
                            exit;
                          end
                          else
                            if CompareText(sCMD, g_GameCommand.SERVERSTATUS.sCmd) = 0
                              then
                            begin
                              SendServerStatus();
                              exit;
                            end
                            else
                              if CompareText(sCMD, g_GameCommand.TESTGETBAGITEM.sCmd) = 0
                                then
                              begin
                                CmdTestGetBagItems(@g_GameCommand.TESTGETBAGITEM,
                                  sParam1);
                                exit;
                              end
                              else
                                if CompareText(sCMD, g_GameCommand.MOBFIREBURN.sCmd) = 0
                                  then
                                begin
                                  CmdMobFireBurn(@g_GameCommand.MOBFIREBURN, sParam1,
                                    sParam2, sParam3, sParam4, sParam5, sParam6);
                                  exit;
                                end
                                else
                                  if CompareText(sCMD, g_GameCommand.TESTSPEEDMODE.sCmd)
                                    = 0 then
                                  begin
                                    CmdTestSpeedMode(@g_GameCommand.TESTSPEEDMODE);
                                    exit;
                                  end
                                  else
                                  begin

                                  end;                      //else begin

      end;
    end;                                                    //004D52B5
    SysMsg('@' + sCMD + ' 此命令不正确，或没有足够的权限！！！', c_Red, t_Hint);
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg, [sData]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;
// else begin//004D4D8B

procedure TPlayObject.ProcessSayMsg(sData: string);
var
  boDisableSayMsg                                      : Boolean;
  sC, sCryCryMsg, sParam1                              : string;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject.ProcessSayMsg Msg = %s';
begin
  try
    if length(sData) > g_Config.nSayMsgMaxLen then
    begin
      sData := Copy(sData, 1, g_Config.nSayMsgMaxLen);
    end;

    if {(sData = m_sOldSayMsg) and}((GetTickCount - m_dwSayMsgTick) <
      g_Config.dwSayMsgTime {3 * 1000}) then
    begin
      Inc(m_nSayMsgCount);
      if m_nSayMsgCount >= g_Config.nSayMsgCount {2} then
      begin
        m_boDisableSayMsg := True;
        m_dwDisableSayMsgTick := GetTickCount + g_Config.dwDisableSayMsgTime {60 * 1000};
        SysMsg(format(g_sDisableSayMsg, [g_Config.dwDisableSayMsgTime div (60 * 1000)]),
          c_Red, t_Hint);
        //'[由于你重复发相同的内容，%d分钟内你将被禁止发言...]'
      end;
    end
    else
    begin                                                   //004D4DF6
      m_dwSayMsgTick := GetTickCount();
      m_nSayMsgCount := 0;
    end;

    if GetTickCount >= m_dwDisableSayMsgTick then
      m_boDisableSayMsg := False;
    boDisableSayMsg := m_boDisableSayMsg;
    g_DenySayMsgList.Lock;
    try
      if g_DenySayMsgList.GetIndex(m_sCharName) >= 0 then
        boDisableSayMsg := True;
    finally
      g_DenySayMsgList.UnLock;
    end;
    if not boDisableSayMsg then
    begin
      m_sOldSayMsg := sData;
      if sData[1] = '/' then
      begin
        sC := Copy(sData, 2, length(sData) - 1);
        if CompareText(Trim(sC), Trim(g_GameCommand.WHO.sCmd)) = 0 then
        begin
          if (m_btPermission < g_GameCommand.WHO.nPermissionMin) then
          begin
            SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
            exit;
          end;
          HearMsg(format(g_sOnlineCountMsg, [UserEngine.PlayObjectCount]));
          exit;
        end;                                                //004D4F03
        if CompareText(Trim(sC), Trim(g_GameCommand.TOTAL.sCmd)) = 0 then
        begin
          if (m_btPermission < g_GameCommand.TOTAL.nPermissionMin) then
          begin
            SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
            exit;
          end;
          HearMsg(format(g_sTotalOnlineCountMsg, [g_nTotalHumCount]));
          exit;
        end;                                                //004D4F5B
        sC := GetValidStr3(sC, sParam1, [' ']);
        if not m_boFilterSendMsg then
          Whisper(sParam1, sC);
        exit;
      end;
      if sData[1] = '!' then
      begin
        if length(sData) >= 2 then
        begin
          if sData[2] = '!' then
          begin
            sC := Copy(sData, 3, length(sData) - 2);
            SendGroupText(m_sCharName + ': ' + sC);
            exit;
          end;
          if sData[2] = '~' then
          begin
            if m_MyGuild <> nil then
            begin
              sC := Copy(sData, 3, length(sData) - 2);
              TGuild(m_MyGuild).SendGuildMsg(m_sCharName + ': ' + sC);
              UserEngine.SendServerGroupMsg(SS_208, nServerIndex,
                TGuild(m_MyGuild).sGuildName + '/' + m_sCharName + '/' + sC);
            end;
            exit;
          end;
        end;                                                //004D512C
        if not m_PEnvir.m_boQUIZ then
        begin
          if (GetTickCount - m_dwShoutMsgTick) > 10 * 1000 then
          begin
            if m_Abil.Level <= g_Config.nCanShoutMsgLevel then
            begin
              //SysMsg('你的等级要在' + IntToStr(g_nCanShoutMsgLevel + 1) + '级以上才能用此功能！！！',c_Red,t_Hint);
              SysMsg(format(g_sYouNeedLevelMsg, [g_Config.nCanShoutMsgLevel + 1]), c_Red,
                t_Hint);

              exit;
            end;
            m_dwShoutMsgTick := GetTickCount();
            sC := Copy(sData, 2, length(sData) - 1);
            sCryCryMsg := '(!)' + m_sCharName + ': ' + sC;
            if m_boFilterSendMsg then
            begin
              SendMsg(nil, RM_CRY, 0, 0, $FFFF, 0, sCryCryMsg);
            end
            else
            begin
              UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 50,
                g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, sCryCryMsg);
            end;
            exit;
          end;

          SysMsg(format(g_sYouCanSendCyCyLaterMsg, [10 - (GetTickCount - m_dwShoutMsgTick)
            div 1000]), c_Red, t_Hint);

          exit;
        end;
        SysMsg(g_sThisMapDisableSendCyCyMsg {'本地图不允许喊话！！！'}, c_Red, t_Hint);
        exit;
      end;                                                  //004D5299
      if m_boFilterSendMsg then
      begin //如果禁止发信息，则只向自己发信息
        SendMsg(Self, RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, 0,
          m_sCharName + ':' + sData);
      end
      else
      begin
        inherited;
      end;
      //      ProcessSayMsg(sData);
      exit;
    end;
    SysMsg(g_sYouIsDisableSendMsg {'禁止聊天'}, c_Red, t_Hint);
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg, [sData]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

function TPlayObject.ClientHitXY(wIdent: Word; nX, nY, w3, nDir: Integer; boLateDelivery:
  Boolean; var dwDelayTime: LongWord): Boolean;               //004CB7F8
var
  n14, n18                                             : Integer;
  StdItem                                              : PTStdItem;
  dwAttackTime, dwCheckTime                            : LongWord;
  nt                                                   : Integer;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::ClientHitXY';
begin

  Result := False;
  dwDelayTime := 0;
  try
    if not m_boCanHit then
      exit;
    if m_boOnBaozi and (not m_boBaoZiAttacked) then
    begin
      SysMsg('必须在骑战状态下才可以攻击', c_Red, t_Hint);
      exit;
    end;
    if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
      g_Config.ClientConf.boParalyCanHit) then
      exit;                                                 //防麻
    if true then
    begin                                                   // not boLateDelivery
      if not CheckActionStatus(wIdent, dwDelayTime) then
      begin
        m_boFilterAction := False;
        exit;
      end;
      m_boFilterAction := True;
      dwAttackTime := _MAX(0, Integer(g_Config.dwHitIntervalTime) - m_nHitSpeed *
        g_Config.ClientConf.btItemSpeed);                     //防止负数出错
      dwCheckTime := GetTickCount - m_dwAttackTick;
      if dwCheckTime < dwAttackTime then
      begin
        Inc(m_dwAttackCount);
        dwDelayTime := dwAttackTime - dwCheckTime;
        if dwDelayTime > g_Config.dwDropOverSpeed then
        begin
          if m_dwAttackCount >= 4 then
          begin
            m_dwAttackTick := GetTickCount();
            m_dwAttackCount := 0;
            dwDelayTime := g_Config.dwDropOverSpeed;
            if m_boTestSpeedMode then
              SysMsg('攻击忙复位！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
          end
          else
            m_dwAttackCount := 0;
          exit;
        end
        else
        begin
          if m_boTestSpeedMode then
            SysMsg('攻击步忙！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
          exit;
        end;
      end;
    end;

    //  if not m_boDeath then begin
    //    if ((nX = m_nCurrX) and (nY = m_nCurrY)) or ((self.sYsnameMaster <> '') and (wIdent = CM_HIT)) then

    begin
      Result := True;
      m_dwAttackTick := GetTickCount();
      if (wIdent = CM_HEAVYHIT) and (m_UseItems[U_WEAPON].Dura > 0) then
      begin                                                 //挖矿
        if GetFrontPosition(n14, n18) and not m_PEnvir.CanWalk(n14, n18, False) then
        begin                                               //sub_004B2790
          StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
          if (StdItem <> nil) and (StdItem.Shape = 19) then
          begin                                             //鹤嘴锄
            RunNewMapEvent(nX, nY, 3, StdItem.Name);
            if PileStones(n14, n18) then
              SendSocket(nil, '+DIG');
            Dec(m_nHealthTick, 30);
            Dec(m_nSpellTick, 50);
            m_nSpellTick := _MAX(0, m_nSpellTick);
            Dec(m_nPerHealth, 2);
            Dec(m_nPerSpell, 2);
            exit;
          end;
        end;
      end;
      if wIdent = CM_HIT then
        AttackDir(nil, 0, nDir);
      if wIdent = CM_HEAVYHIT then
        AttackDir(nil, 1, nDir);
      if wIdent = CM_BIGHIT then
        AttackDir(nil, 2, nDir);
      if wIdent = CM_POWERHIT then
        AttackDir(nil, 3, nDir);
      if wIdent = CM_LONGHIT then
        AttackDir(nil, 4, nDir);
      if wIdent = CM_WIDEHIT then
        AttackDir(nil, 5, nDir);
      if wIdent = CM_FIREHIT then
        AttackDir(nil, 7, nDir);
      if wIdent = CM_CRSHIT then
        AttackDir(nil, 8, nDir);
      if wIdent = CM_TWNHIT then
        AttackDir(nil, 9, nDir);
      if wIdent = CM_3026HIT then
      begin
        if (w3 = 59) and m_bo59kill then
          nt := 10;
        if (w3 = 60) and m_bo60kill then
          NT := 11;
        if (w3 = 40) then
          nt := 12;                                         //残影
        if (w3 = 41) then
          nt := 13;                                         //血影   #+SHAD!
        if (w3 = 42) then
          nt := 14;
        if (w3 = 43) then
          nt := 15;                                         //抱月
        if (w3 = 44) then
          nt := 16;                                         //雷霆
        if (w3 = 88) then
          nt := 88;                                         //雷霆
        AttackDir(nil, NT, nDir);
      end;
      if (m_MagicPowerHitSkill <> nil) and (m_UseItems[U_WEAPON].Dura > 0) then
      begin
        Dec(m_btAttackSkillCount);
        if m_btAttackSkillPointCount = m_btAttackSkillCount then
        begin
          m_boPowerHit := True;
          case m_MagicPowerHitType of
            7: SendSocket(nil, '+PWR');
            40: SendSocket(nil, '+VIS'); // CIR 抱月  VIS  残影   血影   #+SHAD!
            41: SendSocket(nil, '+SHAD');
          end;
        end;
        if m_btAttackSkillCount <= 0 then
        begin
          m_btAttackSkillCount := 5 - m_MagicPowerHitSkill.btLevel; // 7 增加概率
          m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
        end;
      end;
      Dec(m_nHealthTick, 30);
      Dec(m_nSpellTick, 100);
      m_nSpellTick := _MAX(0, m_nSpellTick);
      Dec(m_nPerHealth, 2);
      Dec(m_nPerSpell, 2);                                  //004CBB62
    end;
    //  end else Result:=False;
  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg);
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

function TPlayObject.ClientHorseRunXY(wIdent: Word; nX, nY: Integer; boLateDelivery:
  Boolean;
  var dwDelayTime: LongWord): Boolean;
var
  n14                                                  : Integer;
  dwCheckTime                                          : LongWord;
begin
  Result := False;
  dwDelayTime := 0;

  if not m_boCanRun then
    exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
    g_Config.ClientConf.boParalyCanRun) then
    exit;                                                   //防麻
  if not boLateDelivery then
  begin

    if not CheckActionStatus(wIdent, dwDelayTime) then
    begin
      m_boFilterAction := False;
      exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwRunIntervalTime then
    begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwRunIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwDropOverSpeed then
      begin
        if m_dwMoveCount >= 4 then
        begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwDropOverSpeed;
          if m_boTestSpeedMode then
            SysMsg('马跑步忙复位！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
        end
        else
          m_dwMoveCount := 0;
        exit;
      end
      else
      begin
        if m_boTestSpeedMode then
          SysMsg('马跑步忙！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
        exit;
      end;
    end;
  end;

  m_dwMoveTick := GetTickCount();
  m_bo316 := False;
{$IF DEBUG = 1}
  //   SysMsg(format('当前X:%d 当前Y:%d 目标X:%d 目标Y:%d',[m_nCurrX,m_nCurrY,nX,nY]),c_Green,t_Hint);
{$IFEND}
  n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  if HorseRunTo(n14, False) then
  begin
    if m_boTransparent and (m_boHideMode) then
      m_wStatusTimeArr[STATE_TRANSPARENT {0 0x70}] := 1;    //004CB212

    if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
      Result := True;
    Dec(m_nHealthTick, 60);
    Dec(m_nSpellTick, 10);
    m_nSpellTick := _MAX(0, m_nSpellTick);
    Dec(m_nPerHealth);
    Dec(m_nPerSpell);
  end
  else
  begin
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
  end;
end;

function TPlayObject.ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX, nTargetY:
  Integer; TargeTBaseObject: TBaseObject; boLateDelivery: Boolean; var dwDelayTime:
  LongWord): Boolean;                                         //004CBCEC
var
  UserMagic                                            : pTUserMagic;
  nSpellPoint                                          : Integer;
  n14                                                  : Integer;
  BaseObject                                           : TBaseObject;
  dwCheckTime                                          : LongWord;
  boIsWarrSkill                                        : Boolean;
  hum                                                  : TplayObject;
begin
  Result := False;
  dwDelayTime := 0;
  //   MainOutMessage('check1');
  if not m_boCanSpell then
    exit;
  // MainOutMessage('check2');
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
    g_Config.ClientConf.boParalyCanSpell) then
    exit;                                                   //防麻

  //  MainOutMessage('check3');
  UserMagic := GetMagicInfo(nKey);
  if (nKey >= 78) and (nKey < 87) then
  begin
    //  hum:=nil;
    //  hum:=UserEngine.GetPlayObjectEx(sYsname);
    hum := self.Ysplayer;
    if hum <> nil then
    begin
      UserMagic := hum.GetMagicInfo(nKey);
    end;
  end;
  if UserMagic = nil then
    exit;
  if (pos(UserMagic.MagicInfo.sMagicName, m_PEnvir.m_sNotAllowUseMagic) > 0) then
  begin
    SysMsg('本地图禁止使用该技能', c_Red, t_Hint);
    exit;
  end;
  boIsWarrSkill := MagicManager.IsWarrSkill(UserMagic.wMagIdx);

  if not boLateDelivery and not boIsWarrSkill then
  begin
    //   MainOutMessage('check41');
    if not CheckActionStatus(wIdent, dwDelayTime) then
    begin
      m_boFilterAction := False;
      exit;
      //  MainOutMessage('not CheckActionStatus');

    end;
    //   MainOutMessage('check42');
   //if  sYsnameMaster='' then begin

    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMagicAttackTick;
    if dwCheckTime < m_dwMagicAttackInterval then
    begin
      Inc(m_dwMagicAttackCount);
      dwDelayTime := m_dwMagicAttackInterval - dwCheckTime;
      if dwDelayTime > g_Config.dwMagicHitIntervalTime div 3 then
      begin
        if m_dwMagicAttackCount >= 4 then
        begin
          m_dwMagicAttackTick := GetTickCount();
          m_dwMagicAttackCount := 0;
          dwDelayTime := g_Config.dwMagicHitIntervalTime div 3;
          if m_boTestSpeedMode then
            SysMsg('魔法忙复位！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
        end
        else
          m_dwMagicAttackCount := 0;
        exit;
        //   MainOutMessage('魔法忙复位');
      end
      else
      begin
        if m_boTestSpeedMode then
          SysMsg('魔法忙！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
        exit;
        //    MainOutMessage('魔法忙！');
      end;
    end;
  end;
  //  MainOutMessage('check5');
//end; // if sYsnameMaster=''
  Dec(m_nSpellTick, 450);
  m_nSpellTick := _MAX(0, m_nSpellTick);

  if boIsWarrSkill then
  begin
    //m_dwMagicAttackInterval:=0;
    //m_dwMagicAttackInterval:=g_Config.dwMagicHitIntervalTime; //01/21 改成此行
  end
  else
  begin
    m_dwMagicAttackInterval := UserMagic.MagicInfo.dwDelayTime +
      g_Config.dwMagicHitIntervalTime;
  end;
  m_dwMagicAttackTick := GetTickCount();
  case UserMagic.wMagIdx of                                 //
    SKILL_ERGUM {12}:
      begin                                                 //刺杀剑法
        if m_MagicErgumSkill <> nil then
        begin
          if not m_boUseThrusting then
          begin
            ThrustingOnOff(True);
            SendSocket(nil, '+LNG');
          end
          else
          begin
            ThrustingOnOff(False);
            SendSocket(nil, '+ULNG');
          end;
        end;
        Result := True;
      end;
    SKILL_BANWOL {25}:
      begin                                                 //半月弯刀
        if m_MagicBanwolSkill <> nil then
        begin
          if not m_boUseHalfMoon then
          begin
            HalfMoonOnOff(True);
            SendSocket(nil, '+WID');
          end
          else
          begin
            HalfMoonOnOff(False);
            SendSocket(nil, '+UWID');
          end;
        end;
        Result := True;
      end;

    SKILL_43 {43}:
      begin                                                 //抱月
        if m_Magic43Skill <> nil then
        begin
          if not m_bo43kill then
          begin
            baoMoonOnOff(True);
            SendSocket(nil, '+CIR');                        //CIR
          end
          else
          begin
            baoMoonOnOff(False);
            SendSocket(nil, '+UCIR');
          end;
        end;
        Result := True;
      end;

    SKILL_FIRESWORD {26}, SKILL_44:
      begin                                                 //烈火剑法
        if m_MagicFireSwordSkill <> nil then
        begin
          if AllowFireHitSkill then
          begin
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then
            begin
              if nSpellPoint > 0 then
              begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              case UserMagic.wMagIdx of
                SKILL_FIRESWORD: SendSocket(nil, '+FIR');
                SKILL_44: SendSocket(nil, '+THU');          //雷霆剑
              end;

            end;
          end;
        end;
        Result := True;
      end;
    SKILL_MOOTEBO {27}:
      begin                                                 //野蛮冲撞
        Result := True;

        if (GetTickCount - m_dwDoMotaeboTick) > 3 * 1000 then
        begin
          m_dwDoMotaeboTick := GetTickCount();
          m_btDirection := nTargetX;
          nSpellPoint := GetSpellPoint(UserMagic);
          if m_WAbil.MP >= nSpellPoint then
          begin
            if nSpellPoint > 0 then
            begin
              DamageSpell(nSpellPoint);
              HealthSpellChanged();
            end;
            if DoMotaebo(m_btDirection, UserMagic.btLevel, 0) then
            begin
              if UserMagic.btLevel < 3 then
              begin
                if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] < m_Abil.Level then
                begin
                  TrainSkill(UserMagic, Random(3) + 1);
                  if not CheckMagicLevelup(UserMagic) then
                  begin

                    SendDelayMsg(Self,
                      RM_MAGIC_LVEXP,
                      0,
                      UserMagic.MagicInfo.wMagicId,
                      UserMagic.btLevel,
                      UserMagic.nTranPoint,
                      '', 1000);
                  end;
                end;
              end;
            end;
          end;
        end;                                                //004CC1B5
      end;
    62:
      begin                                                 //突斩
        Result := True;
        if (GetTickCount - m_dwDoMotaeboTick) > 3 * 1000 then
        begin
          m_dwDoMotaeboTick := GetTickCount();
          m_btDirection := nTargetX;
          nSpellPoint := GetSpellPoint(UserMagic);
          if m_WAbil.MP >= nSpellPoint then
          begin
            if nSpellPoint > 0 then
            begin
              DamageSpell(nSpellPoint);
              HealthSpellChanged();
            end;
            if DoMotaebo(m_btDirection, UserMagic.btLevel, 2) then
            begin
              if UserMagic.btLevel < 3 then
              begin
                if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] < m_Abil.Level then
                begin
                  TrainSkill(UserMagic, Random(3) + 1);
                  if not CheckMagicLevelup(UserMagic) then
                  begin

                    SendDelayMsg(Self,
                      RM_MAGIC_LVEXP,
                      0,
                      UserMagic.MagicInfo.wMagicId,
                      UserMagic.btLevel,
                      UserMagic.nTranPoint,
                      '', 1000);
                  end;
                end;
              end;
            end;
          end;
        end;                                                //004CC1B5

      end;

    40:
      begin                                                 //
        if m_MagicCrsSkill <> nil then
        begin
          if not m_boCrsHitkill then
          begin
            SkillCrsOnOff(True);
            SendSocket(nil, '+CRS');
          end
          else
          begin
            SkillCrsOnOff(False);
            SendSocket(nil, '+UCRS');
          end;
        end;
        Result := True;
      end;
    59:
      begin //              破击剑法         #+PJ! #+UPJ!
        if m_Magic59Skill <> nil then
        begin
          if not m_bo59kill then
          begin
            Skill59OnOff(True);
            SendSocket(nil, '+PJ');
          end
          else
          begin
            Skill59OnOff(False);
            SendSocket(nil, '+UPJ');
          end;
        end;
        Result := True;
      end;
    60:
      begin                                                 //破盾斩     +PD!
        if m_Magic60Skill <> nil then
        begin
          if not m_bo60kill then
          begin

            SendSocket(nil, '+PD');                         //#+PD!
            Skill60OnOff(True);
          end
          else
          begin

            SendSocket(nil, '+UPD');
            Skill60OnOff(False);
          end;
        end;
        Result := True;
      end;
  else
    begin
      //   MainOutMessage('check6');
      n14 := GetNextDirection(m_nCurrX, m_nCurrY, nTargetX, nTargetY);
      m_btDirection := n14;
      BaseObject := nil;
      //检查目标角色，与目标座标误差范围，如果在误差范围内则修正目标座标
      if CretInNearXY(TargeTBaseObject, nTargetX, nTargetY) then
      begin
        BaseObject := TargeTBaseObject;
        nTargetX := BaseObject.m_nCurrX;
        nTargetY := BaseObject.m_nCurrY;
      end;
      if ((nTargetX = 0) or (nTargetY = 0)) and (sYsnameMaster <> '') then
      begin
        nTargetX := m_nCurrX;
        nTargetY := m_nCurrY;
      end;

      //  MainOutMessage('开始魔法1！');
      if not DoSpell(UserMagic, nTargetX, nTargetY, BaseObject) then
      begin
        SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
      end;
      Result := True;
    end;
  end;
end;

//004C42C0

function TPlayObject.RunTo(btDir: Byte; boFlag: boolean; nDestX, nDestY: Integer):
  Boolean;
var
  nOldX, nOldY                                         : Integer;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::RunTo';
begin
  Result := False;
  try
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}:
        begin
          if (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY -
              2, True) > 0) then
          begin

            Dec(m_nCurrY, 2);
          end;
        end;
      DR_UPRIGHT {1}:
        begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY
              - 2, True) > 0) then
          begin

            Inc(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
      DR_RIGHT {2}:
        begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2,
              m_nCurrY, True) > 0) then
          begin

            Inc(m_nCurrX, 2);
          end;
        end;
      DR_DOWNRIGHT {3}:
        begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 2) and
            (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 2, m_nCurrY
              + 2, True) > 0) then
          begin

            Inc(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWN {4}:
        begin
          if (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY +
              2, True) > 0) then
          begin

            Inc(m_nCurrY, 2);
          end;
        end;
      DR_DOWNLEFT {5}:
        begin
          if (m_nCurrX > 1) and
            (m_nCurrY < m_PEnvir.m_nHeight - 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY
              + 2, True) > 0) then
          begin

            Dec(m_nCurrX, 2);
            Inc(m_nCurrY, 2);
          end;
        end;
      DR_LEFT {6}:
        begin
          if (m_nCurrX > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2,
              m_nCurrY, True) > 0) then
          begin

            Dec(m_nCurrX, 2);
          end;
        end;
      DR_UPLEFT {7}:
        begin
          if (m_nCurrX > 1) and
            (m_nCurrY > 1) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 2, m_nCurrY
              - 2, True) > 0) then
          begin

            Dec(m_nCurrX, 2);
            Dec(m_nCurrY, 2);
          end;
        end;
    end;
    if ((m_nCurrX <> nOldX) or (m_nCurrY <> nOldY))
      {and ((m_nCurrX = nDestX) and (m_nCurrY = nDestY))} then
    begin
      if Walk(RM_RUN) then
        Result := True
      else
      begin
        {   m_nCurrX:=nOldX;
           m_nCurrY:=nOldY;
        //   m_PEnvir.MoveToMovingObject(nOldX,nOldY,Self,m_nCurrX,m_nCurrY,True);  }
        m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nOldX, nOldY, True);
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;

      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

//004C42C0

function TPlayObject.HorseRunTo(btDir: Byte; boFlag: boolean): Boolean;
var
  n10, n14                                             : Integer;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::HorseRunTo';
begin
  Result := False;
  try
    n10 := m_nCurrX;
    n14 := m_nCurrY;
    m_btDirection := btDir;
    case btDir of
      DR_UP {0}:
        begin
          if (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY - 3, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY -
              3, True) > 0) then
          begin

            Dec(m_nCurrY, 3);
          end;
        end;
      DR_UPRIGHT {1}:
        begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
            (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY - 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY - 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY - 3, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY
              - 3, True) > 0) then
          begin

            Inc(m_nCurrX, 3);
            Dec(m_nCurrY, 3);
          end;
        end;
      DR_RIGHT {2}:
        begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3,
              m_nCurrY, True) > 0) then
          begin

            Inc(m_nCurrX, 3);
          end;
        end;
      DR_DOWNRIGHT {3}:
        begin
          if (m_nCurrX < m_PEnvir.m_nWidth - 3) and
            (m_nCurrY < m_PEnvir.m_nHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 1, m_nCurrY + 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 2, m_nCurrY + 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX + 3, m_nCurrY + 3, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX + 3, m_nCurrY
              + 3, True) > 0) then
          begin

            Inc(m_nCurrX, 3);
            Inc(m_nCurrY, 3);
          end;
        end;
      DR_DOWN {4}:
        begin
          if (m_nCurrY < m_PEnvir.m_nHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX, m_nCurrY + 3, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX, m_nCurrY +
              3, True) > 0) then
          begin

            Inc(m_nCurrY, 3);
          end;
        end;
      DR_DOWNLEFT {5}:
        begin
          if (m_nCurrX > 2) and
            (m_nCurrY < m_PEnvir.m_nHeight - 3) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY + 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY + 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY + 3, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY
              + 3, True) > 0) then
          begin

            Dec(m_nCurrX, 3);
            Inc(m_nCurrY, 3);
          end;
        end;
      DR_LEFT {6}:
        begin
          if (m_nCurrX > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3,
              m_nCurrY, True) > 0) then
          begin

            Dec(m_nCurrX, 3);
          end;
        end;
      DR_UPLEFT {7}:
        begin
          if (m_nCurrX > 2) and
            (m_nCurrY > 2) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 1, m_nCurrY - 1, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 2, m_nCurrY - 2, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.CanWalkEx(m_nCurrX - 3, m_nCurrY - 3, g_Config.boDiableHumanRun or
              ((m_btPermission > 9) and g_Config.boGMRunAll) {True})) and
            (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX - 3, m_nCurrY
              - 3, True) > 0) then
          begin

            Dec(m_nCurrX, 3);
            Dec(m_nCurrY, 3);
          end;
        end;
    end;
    //    SysMsg(format('原X:%d 原Y:%d 新X:%d 新Y:%d',[n10,n14,m_nCurrX,m_nCurrY]),c_Green,t_Hint);
    if (m_nCurrX <> n10) or (m_nCurrY <> n14) then
    begin
      if Walk(RM_HORSERUN) then
        Result := True
      else
      begin
        {   m_nCurrX:=n10;
           m_nCurrY:=n14;
           m_PEnvir.MoveToMovingObject(n10,n14,Self,m_nCurrX,m_nCurrX,True)    }
        m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, n10, n14, True);
        m_nCurrX := n10;
        m_nCurrY := n14;
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TPlayObject.ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer; var
  dwDelayTime: LongWord): Boolean;                            //004CB11C
var
  nDir                                                 : Integer;
  dwCheckTime                                          : integer; //LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if not m_boCanRun then
    exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
    g_Config.ClientConf.boParalyCanRun) then
    exit;                                                   //防麻

  if nFlag <> wIdent then
  begin

    if not CheckActionStatus(wIdent, dwDelayTime) then
    begin
      m_boFilterAction := False;
      exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwRunIntervalTime then
    begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwRunIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwRunIntervalTime div 3 then
      begin
        if m_dwMoveCount >= 4 then
        begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwRunIntervalTime div 3;
          if m_boTestSpeedMode then
            SysMsg('跑步忙复位！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
        end
        else
          m_dwMoveCount := 0;
        exit;
      end
      else
      begin
        if m_boTestSpeedMode then
          SysMsg('跑步忙！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
        exit;
      end;
    end;
  end;
  {
  if (GetTickCount - m_dwMoveTick) < 600 then begin
    Inc(m_dwMoveCount);
    Inc(m_dwMoveCountA);
  end else begin
    m_dwMoveCount:=0;
    if m_dwMoveCountA > 0 then Dec(m_dwMoveCountA);
  end;
  }
  ////////
  dwCheckTime := GetTickCount - m_dwtuzhanMoveTick;
  //  SysMsg('CheckTime' + IntTOStr(dwCheckTime),c_Red,t_Hint);
  if dwCheckTime < g_Config.dwRunIntervalTime div 4 then
    exit;

  m_dwtuzhanMoveTick := GetTickCount();
  /////////
  m_dwMoveTick := GetTickCount();                           //06.02.04
  //  if (m_dwMoveCount < 4) and (m_dwMoveCountA < 6) then begin
  m_bo316 := False;
  nDir := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  if RunTo(nDir, False, nX, nY) then
  begin
    if m_boTransparent and (m_boHideMode) then
      m_wStatusTimeArr[STATE_TRANSPARENT {0 0x70}] := 1;    //004CB212

    if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
      Result := True;
    Dec(m_nHealthTick, 60);
    Dec(m_nSpellTick, 10);
    m_nSpellTick := _MAX(0, m_nSpellTick);
    Dec(m_nPerHealth);
    Dec(m_nPerSpell);
  end
  else
  begin
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
  end;
  {
    end else begin
      Inc(m_dwOverSpeedCount);
      //if m_dwOverSpeedCount > 8 then m_boEmergencyClose:=True;
      SysMsg('跑步超速！！！',c_Red,t_Hint);
      if boViewHackMessage then begin
        MainOutMessage('[11002-Run] ' + m_sCharName + ' ' + DateToStr(Now));
      end;
    end;
  }
end;

function TPlayObject.ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery: Boolean;
  var dwDelayTime: LongWord): Boolean;                        //004CAF08
var
  n14, n18, n1C                                        : Integer;
  dwCheckTime                                          : integer; //LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  if not m_boCanWalk then
    exit;
  if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
    g_Config.ClientConf.boParalyCanWalk) then
    exit;                                                   //防麻

  if not boLateDelivery then
  begin
    if not CheckActionStatus(wIdent, dwDelayTime) then
    begin
      m_boFilterAction := False;
      exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwMoveTick;
    if dwCheckTime < g_Config.dwWalkIntervalTime then
    begin
      Inc(m_dwMoveCount);
      dwDelayTime := g_Config.dwWalkIntervalTime - dwCheckTime;
      if dwDelayTime > g_Config.dwWalkIntervalTime div 3 then
      begin
        if m_dwMoveCount >= 4 then
        begin
          m_dwMoveTick := GetTickCount();
          m_dwMoveCount := 0;
          dwDelayTime := g_Config.dwWalkIntervalTime div 3;
          if m_boTestSpeedMode then
            SysMsg('走路忙复位！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
        end
        else
          m_dwMoveCount := 0;
        exit;
      end
      else
      begin
        if m_boTestSpeedMode then
          SysMsg('走路忙！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
        exit;
      end;
    end;
  end;
  {
  if (GetTickCount - m_dwMoveTick) < 600 then begin
    Inc(m_dwMoveCount);
    Inc(m_dwMoveCountA);
  end else begin
    m_dwMoveCount:=0;
    if m_dwMoveCountA > 0 then Dec(m_dwMoveCountA);
  end;
  }
  ////////
  dwCheckTime := GetTickCount - m_dwtuzhanMoveTick;
  if dwCheckTime < g_Config.dwWalkIntervalTime div 4 then
    exit;                                                   //如果间隔时间小于 600 毫秒
  m_dwtuzhanMoveTick := GetTickCount();

  /////////

  m_dwMoveTick := GetTickCount();                           // 06.02.04
  //  if (m_dwMoveCount < 4) and (m_dwMoveCountA < 6) then begin
  m_bo316 := False;
  n18 := m_nCurrX;
  n1C := m_nCurrY;
  n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
  {   if not m_boClientFlag then begin
       if (n14 = 0) and (m_nStep = 0) then Inc(m_nStep)
       else
       if (n14 = 4) and (m_nStep = 1) then Inc(m_nStep)
       else
       if (n14 = 6) and (m_nStep = 2) then Inc(m_nStep)
       else
       if (n14 = 2) and (m_nStep = 3) then Inc(m_nStep)
       else
       if (n14 = 1) and (m_nStep = 4) then Inc(m_nStep)
       else
       if (n14 = 5) and (m_nStep = 5) then Inc(m_nStep)
       else
 //      if (n14 = 3) and (m_nStep = 6) then Inc(m_nStep)
       if (n14 = 7) and (m_nStep = 6) then Inc(m_nStep)
       else
 //      if (n14 = 7) and (m_nStep = 7) then Inc(m_nStep)
       if (n14 = 3) and (m_nStep = 7) then Inc(m_nStep)
       else begin
       //  Dec(m_nGameGold,m_nStep);
       //  GameGoldChanged;
          m_nStep:=0;
       end;
       //SysMsg(IntTOStr(m_nStep),c_Green,t_Hint);
    {    if m_nStep <> 0 then begin
         Inc(m_nGameGold);
         GameGoldChanged;
       end;
  }//hint    gamegold
 {
 0
 4
 6
 2
 1
 5
 7
 3
 }
   {  end;  }

  if WalkTo(n14, False) then
  begin
    if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
      Result := True;
    Dec(m_nHealthTick, 10);
  end
  else
  begin
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
  end;
  {
  end else begin
    Inc(m_dwOverSpeedCount);
    //if m_dwOverSpeedCount > 8 then m_boEmergencyClose:=True;
    SysMsg('走步超速！！！',c_Red,t_Hint);
    if boViewHackMessage then begin
      MainOutMessage('[11002-Walk] ' + m_sCharName + ' ' + DateToStr(Now));
    end;
  end;
  }
end;
//004BC900

procedure TPlayObject.ThrustingOnOff(boSwitch: Boolean);
begin
  m_boUseThrusting := boSwitch;
  if m_boUseThrusting then
  begin
    SysMsg(sThrustingOn, c_Green, t_Hint);
  end
  else
  begin
    SysMsg(sThrustingOff, c_Green, t_Hint);
  end;
end;
//004BC980

procedure TPlayObject.HalfMoonOnOff(boSwitch: Boolean);
begin
  m_boUseHalfMoon := boSwitch;
  if m_boUseHalfMoon then
  begin
    SysMsg(sHalfMoonOn, c_Green, t_Hint);
  end
  else
  begin
    SysMsg(sHalfMoonOff, c_Green, t_Hint);
  end;
end;

procedure TPlayObject.baoMoonOnOff(boSwitch: Boolean);
begin
  m_bo43kill := boSwitch;
  if m_bo43kill then
  begin
    SysMsg('使用抱月刀法', c_Green, t_Hint);
  end
  else
  begin
    SysMsg('不使用抱月刀法', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.SkillCrsOnOff(boSwitch: Boolean);
begin
  m_boCrsHitkill := boSwitch;
  if m_boCrsHitkill then
  begin
    SysMsg(sCrsHitOn, c_Green, t_Hint);
  end
  else
  begin
    SysMsg(sCrsHitOff, c_Green, t_Hint);
  end;
end;

procedure TPlayObject.Skill59OnOff(boSwitch: Boolean);
begin
  m_bo59kill := boSwitch;
  if m_bo59kill then
  begin
    SysMsg('使用破击剑法', c_Green, t_Hint);
  end
  else
  begin
    SysMsg('不使用破击剑法', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.Skill60OnOff(boSwitch: Boolean);
begin
  m_bo60kill := boSwitch;
  if m_bo60kill then
  begin
    SysMsg('使用破盾斩 ', c_Green, t_Hint);
  end
  else
  begin
    SysMsg('不使用破盾斩 ', c_Green, t_Hint);
  end;
end;

function TPlayObject.AllowFireHitSkill(): Boolean;          //004BCA00
begin
  Result := False;
  if (GetTickCount - m_dwLatestFireHitTick) > 10 * 1000 then
  begin
    m_dwLatestFireHitTick := GetTickCount();
    m_boFireHitSkill := True;
    case m_nFireHitSkillType of
      26:
        begin
          SysMsg(sFireSpiritsSummoned, c_Green, t_Hint);
        end;
      44:
        begin
          SysMsg('你被赋予雷电的力量', c_Green, t_Hint);
        end;
    end;

    Result := True;
  end
  else
  begin
    if m_nFireHitSkillType = 26 then
      SysMsg(sFireSpiritsFail, c_Red, t_Hint)
    else
      SysMsg('召唤雷电精灵失败', c_Red, t_Hint);
  end;
end;

procedure TBaseObject.MapRandomMove(sMapName: string; nInt: Integer); //004BCB54
var
  oEnvir, Envir                                        : TEnvirnoment;
  n10, n14, n18                                        : Integer;
begin
  oEnvir := m_PEnvir;
  Envir := g_MapManager.FindMap(sMapName);
  if Envir <> nil then
  begin
    if Envir.m_nHeight < 150 then
    begin
      if Envir.m_nHeight < 30 then
      begin
        n18 := 2;
      end
      else
        n18 := 20;
    end
    else
      n18 := 50;
    n10 := Random(Envir.m_nWidth - n18 - 1) + n18;
    n14 := Random(Envir.m_nHeight - n18 - 1) + n18;
    SpaceMove(sMapName, n10, n14, nInt);
  end;
end;

function TPlayObject.FindBaseObject(TargeTBaseObject: TBaseObject): Boolean;
var
  I                                                    : Integer;
  nCX, nCY                                             : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  BaseObject                                           : TBaseObject;
begin
  Result := False;
  if m_PEnvir = nil then
  begin
    MainOutMessage('CretInNearXY nil PEnvir');
    exit;
  end;

  for nCX := m_nCurrX - 10 to m_nCurrX + 10 do
  begin
    for nCY := m_nCurrY - 10 to m_nCurrY + 10 do
    begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil)
        then
      begin
        for I := 0 to MapCellInfo.ObjList.Count - 1 do
        begin
          OSObject := MapCellInfo.ObjList.Items[i];
          if OSObject = nil then
            continue;
          if OSObject.btType = OS_MOVINGOBJECT then
          begin
            BaseObject := TBaseObject(OSObject.CellObj);
            if BaseObject <> nil then
            begin
              if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject) then
              begin
                Result := True;
                exit;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.ClientBBs(nNpc: integer; sMsg: string);
var
  Merchant                                             : TMerchant;
  UserItem                                             : PTUserItem;
  sName                                                : string;
  sComment                                             : string;
  buf                                                  : PChar;
begin
  Merchant := UserEngine.FindMerchant(TObject(nNpc));
  if Merchant <> nil then
  begin
    sName := DecodeString(sMsg);
    sName := FormatDateTime('yyyy年mm月dd日hh点nn分玩家 ', now) + m_scharName + ' 留言: '
      + sName;
    Merchant.m_bbsList.Add(sName);

  end;
end;

procedure TPlayObject.ClientFlags(nItemIdx: integer; x, y: Integer; sMsg: string);
var
  Merchant                                             : TMerchant;
  UserItem                                             : PTUserItem;
  sName                                                : string;
  sComment                                             : string;
  buf                                                  : PChar;
  StdItem                                              : pTStdItem;
begin
  Merchant := UserEngine.FindMerchant(x, y, m_PEnvir.sMapName);
  if Merchant <> nil then
  begin
    UserItem := GetItems(nItemIdx);
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (UserItem <> nil) and (StdItem <> nil) then
    begin
      GetMem(buf, Length(sMsg));
      DecodeBuffer(sMsg, buf, Length(sMsg));
      sName := StrPas(buf);
      Inc(buf, Length(sName) + 1);

      sComment := StrPas(buf);
      Merchant.m_scharName := sName;
      Merchant.m_sComments := m_scharName + ':\' + sComment;
      Merchant.m_wappr := Stditem.AniCount;

      Merchant.RefShowName;
      Merchant.FeatureChanged;
      Merchant.SearchViewRange;

      SendDelItems(UserItem);
      DelItem(UserItem);
      Merchant.SaveComment;
    end;
  end;
end;

procedure TPlayObject.ClientClickNPC(NPC: Integer);         //004DBA10
var
  NormNpc                                              : TNormNpc;
  I, j, nCheck                                         : INTEGER;
  bofind                                               : boolean;
  onSellItemdata                                       : TonSellItemdata;
  s1C                                                  : string;
  nIdent                                               : Integer;
  BaseObject                                           : TBaseObject;
begin
  try

    if not m_boCanDeal then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotTryDealMsg);
      exit;
    end;
    if m_boDeath or m_boGhost then
      exit;
    // ===================
    nCheck := 0;
    NormNpc := UserEngine.FindMerchant(TObject(NPC));
    if NormNpc = nil then
      NormNpc := UserEngine.FindNPC(TObject(NPC));
    nCheck := 1;
    if NormNpc <> nil then
    begin
      if m_boOnSellItem and (not NormNpc.m_bodoshop) then
        exit;

      if (NormNpc.m_PEnvir = m_PEnvir) and (abs(NormNpc.m_nCurrX - m_nCurrX) <= 15) and
        (abs(NormNpc.m_nCurrY - m_nCurrY) <= 15) then
      begin
        nCheck := 2;
        NormNpc.Click(Self);
        exit;
      end;
    end;                                                    //004DBA9C

    // ====================

    bofind := false;
    nCheck := 10;
    BaseObject := nil;
    if FindBaseObject(TBaseObject(npc)) then
      BaseObject := TBaseObject(npc);

    nCheck := 11;
    if (BaseObject <> nil) and (BaseObject.m_boOnSellItem) then
    begin                                                   //说明点的是摆摊的人物。
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
        nIdent := 64672
      else
        nIdent := 32982;
      m_DefMsg := MakeDefaultMsg(nIdent,
        NPC,
        BaseObject.m_nCurrX,                                //x
        BaseObject.m_nCurrY,                                //y
        BaseObject.m_btDirection);                          //方向
      fillchar(onSellItemdata, sizeof(tonSellItemdata), #0);
      if BaseObject.M_monSellitemmake = M_monSellitemmake then //自己的豹子
        onSellItemdata.n1 := 65537
      else
        onSellItemdata.n1 := 65536;                         //开窗口

      onSellItemdata.n2 := 0;
      onSellItemdata.w3 := BaseObject.m_nOnsellcount;       //物品个数

      StrPCopy(onSellItemdata.name, BaseObject.m_Sonsellname);
      j := 0;
      for i := 0 to 9 do
      begin
        if BaseObject.m_Onsellitemarr[i].MakeIndex <> 0 then
        begin
          onSellItemdata.Sellitemarr[j] := BaseObject.m_Onsellitemarr[i];
          inc(j);
        end;
      end;
      nCheck := 12;
      //    onSellItemdata.Sellitemarr:=Tplayobject(npc).m_Onsellitemarr[0];

      s1C := EncodeBuffer(@onSellItemdata, 52 + 10 + j * SizeOf(TClientItem));  // SizeOf(TonSellItemdata)

      SendSocket(@m_DefMsg, s1C);
      exit;

    end;

  except
    on e: Exception do
    begin
      MainOutMessage(format('TPlayObject.ClientClickNPC %s  Check=%d',
        [NormNpc.m_sCharName, nCheck]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;

end;

//004C4DB8

function TBaseObject.AddItemToBag(UserItem: PTUserItem): Boolean;
//var StdItem:pTStdItem;
begin
  Result := False;
  if m_ItemList.Count < m_bMaxBagitem then
  begin                                                     //  MAXBAGITEM
    m_ItemList.Add(UserItem);
    WeightChanged();

    Result := True;
  end;
end;

//4C9BD0

function TPlayObject.GetRangeHumanCount: Integer;
begin
  Result := UserEngine.GetMapOfRangeHumanCount(m_PEnvir, m_nCurrX, m_nCurrY, 10);
end;

procedure TBaseObject.sub_4C713C(Magic: pTUserMagic);       //004C713C
begin
  if Magic.MagicInfo.wMagicId = 28 then
    if Magic.btLevel >= 2 then
      m_boAbilSeeHealGauge := True;
end;
//004DA734

procedure TPlayObject.GetStartPoint;
var
  I                                                    : Integer;
  nXY                                                  : Integer;
begin
  try
    g_StartPointList.Lock;
    for I := 0 to g_StartPointList.Count - 1 do
    begin
      if g_StartPointList.Strings[i] = m_PEnvir.sMapName then
      begin
        nXY := Integer(g_StartPointList.Objects[i]);
        if (abs(m_nCurrX - LoWord(nXY)) < 50) and (abs(m_nCurrY - HiWord(nXY)) < 50) then
        begin
          m_sHomeMap := g_StartPointList.Strings[i];
          m_nHomeX := LoWord(nXY);
          m_nHomeY := HiWord(nXY);
          break;
        end;
      end;
    end;
    if PKLevel >= 2 then
    begin
      m_sHomeMap := g_Config.sRedHomeMap;
      m_nHomeX := g_Config.nRedHomeX;
      m_nHomeY := g_Config.nRedHomeY;
    end;
  finally
    g_StartPointList.UnLock;
  end;
end;

procedure TPlayObject.MobPlace(sX, sY, sMonName, sCount: string); //004C1508
begin

end;

function TBaseObject.GetQuestFalgStatus(nFlag: integer): Integer; //004C1490
var
  n10, n14                                             : Integer;
begin
  Result := 0;
  Dec(nFlag);
  if nFlag < 0 then
    exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestFlag)) < 0 then
  begin
    if ((128 shr n14) and (m_QuestFlag[n10])) <> 0 then
      Result := 1
    else
      Result := 0;
  end;
end;

procedure TBaseObject.SetQuestFlagStatus(nFlag: Integer; nValue: Integer); //004C1508
var
  n10, n14                                             : Integer;
  bt15                                                 : Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then
    exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestFlag)) < 0 then
  begin
    bt15 := m_QuestFlag[n10];
    if nValue = 0 then
    begin
      m_QuestFlag[n10] := (not (128 shr n14)) and (bt15);
    end
    else
    begin
      m_QuestFlag[n10] := (128 shr n14) or (bt15);
    end;
  end;
end;

function TBaseObject.GetQuestUnitOpenStatus(nFlag: integer): Integer; //004C159C
var
  n10, n14                                             : Integer;
begin
  Result := 0;
  Dec(nFlag);
  if nFlag < 0 then
    exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then
  begin
    if ((128 shr n14) and (m_QuestUnitOpen[n10])) <> 0 then
      Result := 1
    else
      Result := 0;
  end;
end;

procedure TBaseObject.SetQuestUnitOpenStatus(nFlag: Integer; nValue: Integer); //004C1614
var
  n10, n14                                             : Integer;
  bt15                                                 : Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then
    exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then
  begin
    bt15 := m_QuestUnitOpen[n10];
    if nValue = 0 then
    begin
      m_QuestUnitOpen[n10] := (not (128 shr n14)) and (bt15);
    end
    else
    begin
      m_QuestUnitOpen[n10] := (128 shr n14) or (bt15);
    end;
  end;
end;

function TBaseObject.GetQuestUnitStatus(nFlag: integer): Integer; //004C16A8
var
  n10, n14                                             : Integer;
begin
  Result := 0;
  Dec(nFlag);
  if nFlag < 0 then
    exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then
  begin
    if ((128 shr n14) and (m_QuestUnit[n10])) <> 0 then
      Result := 1
    else
      Result := 0;
  end;
end;

procedure TBaseObject.SetQuestUnitStatus(nFlag: Integer; nValue: Integer); //004C1720
var
  n10, n14                                             : Integer;
  bt15                                                 : Byte;
begin
  Dec(nFlag);
  if nFlag < 0 then
    exit;
  n10 := nFlag div 8;
  n14 := (nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then
  begin
    bt15 := m_QuestUnit[n10];
    if nValue = 0 then
    begin
      m_QuestUnit[n10] := (not (128 shr n14)) and (bt15);
    end
    else
    begin
      m_QuestUnit[n10] := (128 shr n14) or (bt15);
    end;
  end;
end;

procedure TPlayObject.CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName: string;
  nLevel: Integer);
var
  Magic                                                : pTMagic;
  UserMagic                                            : pTUserMagic;
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) or (sHumanName = '') or (sSkillName =
    '') or (nLevel < 0) then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称  技能名称 修炼等级(0-3)', c_Red,
      t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  Magic := UserEngine.FindMagic(sSkillName);
  if Magic = nil then
  begin
    SysMsg(format('%s 技能名称不正确！！！', [sSkillName]), c_Red, t_Hint);
    exit;
  end;

  if PlayObject.IsTrainingSkill(Magic.wMagicId) then
  begin
    SysMsg(format('%s 技能已修炼过了！！！', [sSkillName]), c_Red, t_Hint);
    exit;
  end;
  New(UserMagic);
  UserMagic.MagicInfo := Magic;
  UserMagic.wMagIdx := Magic.wMagicId;
  if not Magic.wMagicId in [87..90] then
    nLevel := _MIN(3, nLevel);
  UserMagic.btLevel := nLevel;
  UserMagic.btKey := 0;
  UserMagic.nTranPoint := 0;
  PlayObject.m_MagicList.Add(UserMagic);
  PlayObject.SendAddMagic(UserMagic);
  PlayObject.RecalcAbilitys;
  SysMsg(format('%s 的 %s 技能修炼成功！！！', [sHumanName, sSkillName]), c_Green,
    t_Hint);
end;

procedure TPlayObject.CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string;
  nLevel: Integer);
var
  I                                                    : Integer;
  UserMagic                                            : pTUserMagic;
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or (sSkillName = '') or (nLevel <= 0) then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称  技能名称 修炼等级(0-3)', c_Red,
      t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format('%s不在线，或在其它服务器上！！', [sHumanName]), c_Red, t_Hint);
    exit;
  end;

  for I := 0 to PlayObject.m_MagicList.Count - 1 do
  begin
    UserMagic := PlayObject.m_MagicList.Items[I];
    if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then
    begin
      if not UserMagic.wMagIdx in [87..90] then
        nLevel := _MIN(3, nLevel);
      UserMagic.btLevel := nLevel;
      PlayObject.SendMsg(PlayObject,
        RM_MAGIC_LVEXP,
        0,
        UserMagic.MagicInfo.wMagicId,
        UserMagic.btLevel,
        UserMagic.nTranPoint,
        '');
      PlayObject.SysMsg(format('%s的修改炼等级为%d', [sSkillName, nLevel]), c_Green,
        t_Hint);
      SysMsg(format('%s的技能%s修炼等级为%d', [sHumanName, sSkillName, nLevel]), c_Green,
        t_Hint);
      break;
    end;
  end;
end;

procedure TPlayObject.CmdAddGameGold(sCmd, sHumName: string;
  nPoint: Integer);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < 6) then
    exit;
  if (sHumName = '') or (nPoint <= 0) then
  begin
    SysMsg('命令格式: @' + sCmd + ' 人物名称  金币数量', c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    if (PlayObject.m_nGameGold + nPoint) < 2000000 then
    begin
      Inc(PlayObject.m_nGameGold, nPoint);
    end
    else
    begin
      nPoint := 2000000 - PlayObject.m_nGameGold;
      PlayObject.m_nGameGold := 2000000;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的游戏点已增加' + IntToStr(nPoint) + '.', c_Green, t_Hint);
    PlayObject.SysMsg('游戏点已增加' + IntToStr(nPoint) + '.', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdDelGameGold(sCmd, sHumName: string;
  nPoint: Integer);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < 6) then
    exit;
  if (sHumName = '') or (nPoint <= 0) then
    exit;
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    if PlayObject.m_nGameGold > nPoint then
    begin
      Dec(PlayObject.m_nGameGold, nPoint);
    end
    else
    begin
      nPoint := PlayObject.m_nGameGold;
      PlayObject.m_nGameGold := 0;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的游戏点已减少' + IntToStr(nPoint) + '.', c_Green, t_Hint);
    PlayObject.SysMsg('游戏点已减少' + IntToStr(nPoint) + '.', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr: string;
  nGold: Integer);
var
  PlayObject                                           : TPlayObject;
  Ctr                                                  : Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sCtr <> '') then
  begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGold < 0) or (nGold >
    200000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGameGoldHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  case sCtr[1] of
    '=':
      begin
        PlayObject.m_nGamePoint := nGold;
      end;
    '+': Inc(PlayObject.m_nGameGold, nGold);
    '-': Dec(PlayObject.m_nGameGold, nGold);
  end;
  if g_boGameLogGameGold then
  begin
    AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGameGoldName,
        nGold,
        sCtr[1],
        m_sCharName]));
  end;
  GameGoldChanged();
  PlayObject.SysMsg(format(g_sGameCommandGameGoldHumanMsg, [g_Config.sGameGoldName,
    nGold, PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
  SysMsg(format(g_sGameCommandGameGoldGMMsg, [sHumanName, g_Config.sGameGoldName, nGold,
    PlayObject.m_nGameGold, g_Config.sGameGoldName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdGamePoint(Cmd: pTGameCmd; sHumanName, sCtr: string; nPoint:
  Integer);
var
  PlayObject                                           : TPlayObject;
  Ctr                                                  : Char;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sCtr <> '') then
  begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or (nPoint >
    100000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandGamePointHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  case sCtr[1] of
    '=':
      begin
        PlayObject.m_nGamePoint := nPoint;
      end;
    '+': Inc(PlayObject.m_nGamePoint, nPoint);
    '-': Dec(PlayObject.m_nGamePoint, nPoint);
  end;
  if g_boGameLogGamePoint then
  begin
    AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEPOINT,
      PlayObject.m_sMapName,
        PlayObject.m_nCurrX,
        PlayObject.m_nCurrY,
        PlayObject.m_sCharName,
        g_Config.sGamePointName,
        nPoint,
        sCtr[1],
        m_sCharName]));
  end;
  // GameGoldChanged();
  if PlayObject.m_nGamePoint > 3000 then
    PlayObject.m_nGamePoint := 3000;
  PlayObject.SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');

  PlayObject.SysMsg(format(g_sGameCommandGamePointHumanMsg, [nPoint,
    PlayObject.m_nGamePoint]), c_Green, t_Hint);
  SysMsg(format(g_sGameCommandGamePointGMMsg, [sHumanName, nPoint,
    PlayObject.m_nGamePoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdBigBag(Cmd: pTGameCmd; sHumanName: string); //调整包裹的命令
var
  Human                                                : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  Human := UserEngine.GeTPlayObject(sHumanName);
  if Human <> nil then
  begin
    Human.m_bMaxBagitem := 66;
    Human.SendDefMessage(38292, Integer(Human), 0, Human.m_bMaxBagitem, 0, '');
  end
  else
    SysMsg('对方不在线', c_Red, t_Hint);
end;

procedure TPlayObject.CmdCreditPoint(Cmd: pTGameCmd; sHumanName, sCtr: string; nPoint:
  Integer);
var
  PlayObject                                           : TPlayObject;
  Ctr                                                  : Char;
  nCreditpoint                                         : Integer;
begin
  Ctr := '1';
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sCtr <> '') then
  begin
    Ctr := sCtr[1];
  end;

  if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or (nPoint >
    High(Byte)) or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandCreditPointHelpMsg]), c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GetPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  case sCtr[1] of
    '=':
      begin
        if nPoint in [0..255] then
          PlayObject.m_btCreditPoint := nPoint;
      end;
    '+':
      begin
        nCreditpoint := PlayObject.m_btCreditPoint + nPoint;
        if nPoint in [0..255] then
          PlayObject.m_btCreditPoint := nCreditpoint;
      end;
    '-':
      begin
        nCreditpoint := PlayObject.m_btCreditPoint - nPoint;
        if nPoint in [0..255] then
          PlayObject.m_btCreditPoint := nCreditpoint;
      end;
  end;
  PlayObject.SysMsg(format(g_sGameCommandCreditPointHumanMsg, [nPoint,
    PlayObject.m_btCreditPoint]), c_Green, t_Hint);
  SysMsg(format(g_sGameCommandCreditPointGMMsg, [sHumanName, nPoint,
    PlayObject.m_btCreditPoint]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);  //004CD550
var
  PlayObject                                           : TPlayObject;
  nServerIndex                                         : integer;
begin
  if (m_btPermission < 6) then
    exit;
  if (sHumName = '') or (nCount <= 0) then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称  金币数量', c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    if (PlayObject.m_nGold + nCount) < PlayObject.m_nGoldMax then
    begin
      Inc(PlayObject.m_nGold, nCount);
    end
    else
    begin
      nCount := PlayObject.m_nGoldMax - PlayObject.m_nGold;
      PlayObject.m_nGold := PlayObject.m_nGoldMax;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的金币已增加' + IntToStr(nCount) + '.', c_Green, t_Hint);
    //004CD6F6
    if g_boGameLogGold then
      AddGameDataLog('14' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nCount) + #9 +
        '1' + #9 +
        sHumName);
  end
  else
  begin
    if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then
    begin
      SysMsg(sHumName + ' 现在' + IntToStr(nServerIndex) + '号服务器上', c_Green,
        t_Hint);
    end
    else
    begin
      FrontEngine.AddChangeGoldList(m_sCharName, sHumName, nCount);
      SysMsg(sHumName + ' 现在不在线，等其上线时金币将自动增加', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief: string);  //004CEBA0
var
  Human                                                : TPlayObject;
  boAddState                                           : Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if nServerIndex <> 0 then
  begin
    SysMsg('这个命令只能使用在主服务器上', c_Red, t_Hint);
    exit;
  end;
  if (sGuildName = '') or (sGuildChief = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 行会名称 掌门人名称', c_Red, t_Hint);
    exit;
  end;

  boAddState := False;
  Human := UserEngine.GeTPlayObject(sGuildChief);
  if Human = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sGuildChief]), c_Red, t_Hint);
    exit;
  end;
  if g_GuildManager.MemberOfGuild(sGuildChief) = nil then
  begin
    if g_GuildManager.AddGuild(sGuildName, sGuildChief) then
    begin
      UserEngine.SendServerGroupMsg(SS_205, nServerIndex, sGuildName + '/' +
        sGuildChief);
      SysMsg('行会名称: ' + sGuildName + ' 掌门人: ' + sGuildChief, c_Green, t_Hint);
      boAddState := True;
    end;
  end;                                                      //004CECB4
  if boAddState then
  begin
    Human.m_MyGuild := TObject(g_GuildManager.MemberOfGuild(Human.m_sCharName));
    if Human.m_MyGuild <> nil then
    begin
      Human.m_sGuildRankName := TGuild(Human.m_MyGuild).GetRankName(self,
        Human.m_nGuildRankNo);
      Human.RefShowName();
    end;
  end;                                                      //004CED14
  {
  if boAddState then begin
    SysMsg('YouScrewedUp',c_Red,t_Hint);
  end;
  }
end;

procedure TPlayObject.CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);
var
  PlayObject                                           : TPlayObject;
  dwExp                                                : LongWord;
  dwOExp                                               : LongWord;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 经验值', c_Red, t_Hint);
    exit;
  end;
  dwExp := Str_ToInt(sExp, 0);

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    dwOExp := PlayObject.m_Abil.Exp;
    PlayObject.m_Abil.Exp := dwExp;
    PlayObject.HasLevelUp(1);
    SysMsg(sHumanName + ' 经验调整完成。', c_Green, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[经验调整] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' +
        IntToStr(dwOExp) + ' -> ' + IntToStr(PlayObject.m_Abil.Exp) + ')');
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string;
  nLevel: Integer);
var
  PlayObject                                           : TPlayObject;
  nOLevel                                              : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sHumanName = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 等级', c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    nOLevel := PlayObject.m_Abil.Level;
    PlayObject.m_Abil.Level := _MAX(1, _MIN(MAXUPLEVEL, nLevel));
    PlayObject.HasLevelUp(-1);
    SysMsg(sHumanName + ' 等级调整完成。', c_Green, t_Hint);
    if g_Config.boShowMakeItemMsg then
      MainOutMessage('[等级调整] ' + m_sCharName + '(' + PlayObject.m_sCharName + ' ' +
        IntToStr(nOLevel) + ' -> ' + IntToStr(PlayObject.m_Abil.Level) + ')');
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdAdjustExp(Human: TPlayObject; nExp: Integer); //004CDDAC
begin
  if (m_btPermission < 6) then
    exit;
end;

procedure TPlayObject.CmdBackStep(sCmd: string; nType, nCount: Integer);
begin
  if (m_btPermission < 6) then
    exit;
  nType := _MIN(nType, 8);
  if nType = 0 then
  begin
    CharPushed(GetBackDir(m_btDirection), nCount);
  end
  else
  begin
    CharPushed(RanDom(nType), nCount);
  end;

end;

procedure TPlayObject.CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
var
  PlayObject                                           : TPlayObject;
  sMsg                                                 : string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumName = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 属性点数(不输入为查看点数)', c_Red,
      t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GetPlayObject(sHumName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    exit;
  end;
  if (nCount > 0) then
  begin
    PlayObject.m_nBonusPoint := nCount;
    PlayObject.SendMsg(self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    exit;
  end;
  sMsg :=
    format('未分配点数:%d 已分配点数:(DC:%d MC:%d SC:%d AC:%d MAC:%d HP:%d MP:%d HIT:%d SPEED:%d)',
    [PlayObject.m_nBonusPoint,
    PlayObject.m_BonusAbil.DC,
      PlayObject.m_BonusAbil.MC,
      PlayObject.m_BonusAbil.SC,
      PlayObject.m_BonusAbil.AC,
      PlayObject.m_BonusAbil.MAC,
      PlayObject.m_BonusAbil.HP,
      PlayObject.m_BonusAbil.MP,
      PlayObject.m_BonusAbil.Hit,
      PlayObject.m_BonusAbil.Speed
      ]);
  SysMsg(format('%s的属性点数为:%s', [sHumName, sMsg]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdChangeAdminMode(sCmd: string; nPermission: Integer; sParam1:
  string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    exit;
  end;

  m_boAdminMode := boFlag;
  if m_boAdminMode then
    SysMsg(sGameMasterMode, c_Green, t_Hint)
  else
    SysMsg(sReleaseGameMasterMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeAttackMode(nMode: Integer; sParam1, sParam2, sParam3,
  sParam4, sParam5, sParam6, sParam7: string);
var
  hum                                                  : TPlayObject;
begin
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0F4h
    db 0EBh
    db 004h
    db 0E8h
    @@Start:
  end;
{$IFEND}
  if sParam2 <> '' then
  begin
{$IF DEBUG = 0}
    asm
    jz @@Start
    jnz @@Start
    db 0F4h
    db 0EBh
    db 004h
    db 0E8h
    @@Start:
    end;
{$IFEND}
    ProcessUserCmd(sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7);
{$IF DEBUG = 0}
    asm
    jz @@Start
    jnz @@Start
    db 0F4h
    db 0EBh
    db 004h
    db 0E8h
    @@Start:
    end;
{$IFEND}
    exit;
  end;
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0F4h
    db 0EBh
    db 004h
    db 0E8h
    @@Start:
  end;
{$IFEND}
  if (nMode >= 0) and (nMode <= 4) then
    m_btAttatckMode := nMode
  else
  begin
    if m_btAttatckMode < HAM_PKATTACK then
      Inc(m_btAttatckMode)
    else
      m_btAttatckMode := HAM_ALL;
  end;
  //元神攻击模式
 // hum:=nil;
 // hum:=UserEngine.GetPlayObjectEx(sYsname);
  hum := self.Ysplayer;
  if hum <> nil then
  begin
    hum.m_btAttatckMode := m_btAttatckMode;
  end;

  case m_btAttatckMode of
    HAM_ALL: SysMsg(sAttackModeOfAll, c_Green, t_Hint);     //[攻击模式: 全体攻击]
    HAM_PEACE: SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint); //[攻击模式: 和平攻击]
    HAM_DEAR: SysMsg(sAttackModeOfDear, c_Green, t_Hint);   //[攻击模式: 和平攻击]
    HAM_MASTER: SysMsg(sAttackModeOfMaster, c_Green, t_Hint); //[攻击模式: 和平攻击]
    HAM_GROUP: SysMsg(sAttackModeOfGroup, c_Green, t_Hint); //[攻击模式: 编组攻击]
    HAM_GUILD: SysMsg(sAttackModeOfGuild, c_Green, t_Hint); //[攻击模式: 行会攻击]
    HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint); //[攻击模式: 红名攻击]
  end;
end;

procedure TPlayObject.CmdChangeDearName(Cmd: pTGameCmd; sHumanName, sDearName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or (sDearName = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 配偶名称(如果为 无 则清除)', c_Red,
      t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    if CompareText(sDearName, '无') = 0 then
    begin
      PlayObject.m_sDearName := '';
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' 的配偶名清除成功。', c_Green, t_Hint);
    end
    else
    begin
      PlayObject.m_sDearName := sDearName;
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' 的配偶名更改成功。', c_Green, t_Hint);
    end;
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
var
  PlayObject                                           : TPlayObject;
  nSex                                                 : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  nSex := -1;
  if (sSex = 'Man') or (sSex = '男') or (sSex = '0') then
  begin
    nSex := 0;
  end;
  if (sSex = 'WoMan') or (sSex = '女') or (sSex = '1') then
  begin
    nSex := 1;
  end;
  if (sHumanName = '') or (nSex = -1) then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 性别(男、女)', c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    if PlayObject.m_btGender <> nSex then
    begin
      PlayObject.m_btGender := nSex;
      PlayObject.FeatureChanged();
      SysMsg(PlayObject.m_sCharName + ' 的性别已改变。', c_Green, t_Hint);
    end
    else
    begin
      SysMsg(PlayObject.m_sCharName + ' 的性别未改变！！！', c_Red, t_Hint);
    end;
  end
  else
  begin
    SysMsg(sHumanName + '没有在线！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName: string);
var
  nMakeIndex, nItemIndex                               : Integer;
begin
  if (m_btPermission < 6) then
    exit;
  if (sMakeIndex = '') or (sItemIndex = '') or (sItemName = '') then
  begin
    SysMsg('命令格式: @' + sCmd + ' 物品编号 物品ID号 物品名称', c_Red, t_Hint);
    exit;
  end;
  nMakeIndex := Str_ToInt(sMakeIndex, -1);
  nItemIndex := Str_ToInt(sItemIndex, -1);
  if (nMakeIndex <= 0) or (nItemIndex < 0) then
  begin
    SysMsg('命令格式: @' + sCmd + ' 物品编号 物品ID号 物品名称', c_Red, t_Hint);
    exit;
  end;
  if ItemUnit.AddCustomItemName(nMakeIndex, nItemIndex, sItemName) then
  begin
    ItemUnit.SaveCustomItemName();
    SysMsg('物品名称设置成功。', c_Green, t_Hint);
    exit;
  end;

  SysMsg('此物品，已经设置了其它的名称！！！', c_Red, t_Hint);
end;

procedure TPlayObject.CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName: string);  //004CC714
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;

  if (sHumanName = '') or (sJobName = '') then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandChangeJobHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    if CompareText(sJobName, 'Warr') = 0 then
      PlayObject.m_btJob := 0;
    if CompareText(sJobName, 'Wizard') = 0 then
      PlayObject.m_btJob := 1;
    if CompareText(sJobName, 'Taos') = 0 then
      PlayObject.m_btJob := 2;
    PlayObject.HasLevelUp(1);
    PlayObject.SysMsg(g_sGameCommandChangeJobHumanMsg, c_Green, t_Hint);
    SysMsg(format(g_sGameCommandChangeJobMsg, [sHumanName]), c_Green, t_Hint);
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
var
  nOLevel                                              : Integer;
  nLevel                                               : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    exit;
  end;

  nLevel := Str_ToInt(sParam1, 1);
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
  end;
{$IFEND}
  nOLevel := m_Abil.Level;
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
  end;
{$IFEND}
  m_Abil.Level := _MIN(MAXUPLEVEL, nLevel);
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
  end;
{$IFEND}
  HasLevelUp(1);
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
  end;
{$IFEND}
  if g_Config.boShowMakeItemMsg then
  begin
{$IF DEBUG = 0}
    asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
    end;
{$IFEND}
    MainOutMessage(format(g_sGameCommandLevelConsoleMsg, [m_sCharName, nOLevel,
      m_Abil.Level]));
{$IF DEBUG = 0}
    asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
    end;
{$IFEND}
  end;
end;

procedure TPlayObject.CmdChangeMasterName(Cmd: pTGameCmd; sHumanName, sMasterName,
  sIsMaster: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or (sMasterName = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 师徒名称(如果为 无 则清除)', c_Red,
      t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    if CompareText(sMasterName, '无') = 0 then
    begin
      PlayObject.m_sMasterName := '';
      PlayObject.RefShowName;
      PlayObject.m_boMaster := False;
      SysMsg(sHumanName + ' 的师徒名清除成功。', c_Green, t_Hint);
    end
    else
    begin
      PlayObject.m_sMasterName := sMasterName;
      if (sIsMaster <> '') and (sIsMaster[1] = '1') then
        PlayObject.m_boMaster := True
      else
        PlayObject.m_boMaster := False;
      PlayObject.RefShowName;
      SysMsg(sHumanName + ' 的师徒名更改成功。', c_Green, t_Hint);
    end;
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeObMode(sCmd: string; nPermission: Integer; sParam1:
  string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    exit;
  end;
  if boFlag then
  begin
    SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, ''); //01/21 强行发送刷新数据到客户端，解决GM登录隐身有影子问题
  end;
  m_boObMode := boFlag;
  if m_boObMode then
  begin
    SysMsg(sObserverMode, c_Green, t_Hint);
  end
  else
    SysMsg(g_sReleaseObserverMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeSabukLord(Cmd: pTGameCmd; sCastleName, sGuildName: string;
  boFlag: Boolean);                                           //004CFE1C
var
  Guild                                                : TGuild;
  Castle                                               : TUserCastle;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;

  if (sCastleName = '') or (sGuildName = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 城堡名称 行会名称', c_Red, t_Hint);
    exit;
  end;
  Castle := g_CastleManager.Find(sCastleName);
  if Castle = nil then
  begin
    SysMsg(format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCastleName]), c_Red, t_Hint);
    exit;
  end;

  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then
  begin
    //4CFEC7
    AddGameDataLog('27' + #9 +
      Castle.m_sOwnGuild + #9 +
      '0' + #9 +
      '1' + #9 +
      'sGuildName' + #9 +
      m_sCharName + #9 +
      '0' + #9 +
      '1' + #9 +
      '0');
    Castle.GetCastle(Guild);
    if boFlag then
      UserEngine.SendServerGroupMsg(SS_211, nServerIndex, sGuildName);
    SysMsg(Castle.m_sName + ' 所属行会已经更改为 ' + sGuildName, c_Green, t_Hint);
  end
  else
  begin
    SysMsg('行会 ' + sGuildName + '还没建立！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdChangeSalveStatus;
var
  hum                                                  : TPlayObject;
  bohumslaveRelax                                      : boolean;
begin
  // hum:=nil;
  // hum:=UserEngine.GetPlayObjectEx(sYsname);
  hum := self.Ysplayer;
  if (hum <> nil) and (hum.m_SlaveList.Count > 0) then
  begin
    hum.m_boSlaveRelax := not hum.m_boSlaveRelax;
    if hum.m_boSlaveRelax then
      hum.SysMsg(sPetRest, c_Green, t_Hint)
    else
      hum.SysMsg(sPetAttack, c_Green, t_Hint)

  end;
  if m_SlaveList.Count > 0 then
  begin
    m_boSlaveRelax := not m_boSlaveRelax;
    if m_boSlaveRelax then
      SysMsg(sPetRest, c_Green, t_Hint)
    else
      SysMsg(sPetAttack, c_Green, t_Hint)
  end;

end;
//m_bohorserelax

procedure TPlayObject.CmdChangehorseStatus;
var
  i                                                    : integer;
begin
  if m_SlaveList.Count > 0 then
  begin
    for i := m_SlaveList.Count - 1 downto 0 do
    begin

      if TBaseObject(m_SlaveList.Items[i]).m_bohorse then
      begin
        TBaseObject(m_SlaveList.Items[i]).m_bohorserelax := not
          TBaseObject(m_SlaveList.Items[i]).m_bohorserelax;
        if TBaseObject(m_SlaveList.Items[i]).m_bohorserelax then
          SysMsg('马休息', c_Green, t_Hint)
        else
          SysMsg('马行动', c_Green, t_Hint);

        break;

      end;

    end;

  end;

end;

procedure TPlayObject.CmdChangeSuperManMode(sCmd: string; nPermission: Integer; sParam1:
  string; boFlag: Boolean);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    exit;
  end;
  m_boSuperMan := boFlag;
  if m_boSuperMan then
    SysMsg(sSupermanMode, c_Green, t_Hint)
  else
    SysMsg(sReleaseSupermanMode, c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeUserFull(sCmd, sUserCount: string);
var
  nCount                                               : Integer;
begin
  if (m_btPermission < 6) then
    exit;
  nCount := Str_ToInt(sUserCount, -1);
  if (sUserCount = '') or (nCount < 1) or ((sUserCount <> '') and (sUserCount[1] = '?'))
    then
  begin
    SysMsg('设置服务器最高上线人数。', c_Red, t_Hint);
    SysMsg('命令格式: @' + sCmd + ' 人数', c_Red, t_Hint);
    exit;
  end;
  g_Config.nUserFull := nCount;
  SysMsg(format('服务器上线人数限制: %d', [nCount]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdChangeZenFastStep(sCmd, sFastStep: string);
var
  nFastStep                                            : Integer;
begin
  if (m_btPermission < 6) then
    exit;
  nFastStep := Str_ToInt(sFastStep, -1);
  if (sFastStep = '') or (nFastStep < 1) or ((sFastStep <> '') and (sFastStep[1] = '?'))
    then
  begin
    SysMsg('设置怪物行动速度。', c_Red, t_Hint);
    SysMsg('命令格式: @' + sCmd + ' 速度', c_Red, t_Hint);
    exit;
  end;
  g_Config.nZenFastStep := nFastStep;
  SysMsg(format('怪物行动速度: %d', [nFastStep]), c_Green, t_Hint);
end;

procedure TPlayObject.MakeDropItemDown(Envir: TEnvirnoment; sItemName: string; nCount:
  Integer; x, y, nRand: Integer);
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
  MapItem, pr                                          : pTMapItem;
  sUserItemName                                        : string;
  dx, dy                                               : Integer;
begin

  if (sItemName = '') then
  begin
    // SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGamecommandMakeHelpMsg]), c_Red, t_Hint);
    exit;
  end;
  if (nCount <= 0) then
    nCount := 1;
  if (nCount > 10) then
    nCount := 10;

  for I := 0 to nCount - 1 do
  begin

    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
    begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);

      if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26] then
      begin
        if StdItem.Shape in [130, 131, 132] then
        begin
          UserEngine.GetUnknowItemValue(UserItem);
        end;
      end;

      UserItem.MakeIndex := GetItemNumberEx();              //制造的物品另行取得物品ID

      New(MapItem);
      MapItem.UserItem := UserItem^;
      MapItem.Name := FilterItemName(StdItem.Name);

      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
      begin
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          MapItem.Name := sUserItemName;
      end;

      MapItem.Looks := StdItem.Looks;
      if StdItem.StdMode = 45 then
      begin                                                 //林荤困, 格犁
        MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
      end;
      MapItem.AniCount := StdItem.AniCount;
      MapItem.Reserved := 0;
      MapItem.Count := 1;
      MapItem.OfBaseObject := nil;
      MapItem.dwCanPickUpTick := GetTickCount();
      MapItem.DropBaseObject := self;
      MapItem.DropName := self.m_sCharName;
      GetDropPosition(x, y, nRand, dx, dY);
      pr := nil;

      pr := Envir.AddToMap(dX, dY, OS_ITEMOBJECT, TObject(MapItem));
      if pr = MapItem then
      begin
        SendRefMsg(RM_ITEMSHOW, MapItem.Looks, integer(MapItem), dX, dY, MapItem.Name);

        if not IsCheapStuff(StdItem.StdMode) then
          //004C5716
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('7' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              //UserEngine.GetStdItemName(ui.wIndex) + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
              '0');

      end
      else
      begin
        Dispose(MapItem);
      end;

    end
    else
    begin                                                   //004CD114
      Dispose(UserItem);
      SysMsg(format(g_sGamecommandMakeItemNameNotFound, [sItemName]), c_Red, t_Hint);
      break;
    end;
  end;
end;

procedure TPlayObject.CmdMakeItemAndDrop(Cmd: pTGameCmd; sItemName: string; nCount:
  Integer);
var
  I, dx, dy                                            : Integer;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
  MapItem, pr                                          : pTMapItem;
  sUserItemName                                        : string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sItemName = '') then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGamecommandMakeHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  if (nCount <= 0) then
    nCount := 1;
  if (nCount > 10) then
    nCount := 10;
  if (m_btPermission < Cmd.nPermissionMax) then
  begin
    if not CanMakeItem(sItemName) then
    begin
      SysMsg(g_sGamecommandMakeItemNameOrPerMissionNot, c_Red, t_Hint);
      exit;
    end;
    //if UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurry) then begin
    if g_CastleManager.InCastleWarArea(Self) <> nil then
    begin
      SysMsg(g_sGamecommandMakeInCastleWarRange, c_Red, t_Hint);
      exit;
    end;
    if not InSafeZone then
    begin
      SysMsg(g_sGamecommandMakeInSafeZoneRange, c_Red, t_Hint);
      exit;
    end;
    nCount := 1;
  end;

  for I := 0 to nCount - 1 do
  begin

    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
    begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem.Price >= 15000) and not g_Config.boTestServer and (m_btPermission < 5)
        then
      begin
        Dispose(UserItem);
        Continue;
      end
      else
      begin
        if Random(g_Config.nMakeRandomAddValue {10}) = 0 then
          UserEngine.RandomUpgradeItem(UserItem);
      end;
      if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26] then
      begin
        if StdItem.Shape in [130, 131, 132] then
        begin
          UserEngine.GetUnknowItemValue(UserItem);
        end;
      end;
      if m_btPermission >= Cmd.nPermissionMax then
      begin
        UserItem.MakeIndex := GetItemNumberEx();            //制造的物品另行取得物品ID

      end;

      New(MapItem);
      MapItem.UserItem := UserItem^;
      MapItem.Name := FilterItemName(StdItem.Name);

      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
      begin
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
        if sUserItemName <> '' then
          MapItem.Name := sUserItemName;
      end;

      MapItem.Looks := StdItem.Looks;
      if StdItem.StdMode = 45 then
      begin                                                 //林荤困, 格犁
        MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
      end;
      MapItem.AniCount := StdItem.AniCount;
      MapItem.Reserved := 0;
      MapItem.Count := 1;
      MapItem.OfBaseObject := nil;
      MapItem.dwCanPickUpTick := GetTickCount();
      MapItem.DropName := self.m_sCharName;
      MapItem.DropBaseObject := self;
      GetDropPosition(m_nCurrX, m_nCurrY, 5, dX, dY);
      pr := nil;

      pr := m_PEnvir.AddToMap(dX, dY, OS_ITEMOBJECT, TObject(MapItem));
      if pr = MapItem then
      begin
        SendRefMsg(RM_ITEMSHOW, MapItem.Looks, integer(MapItem), dX, dY, MapItem.Name);

        if not IsCheapStuff(StdItem.StdMode) then
          //004C5716
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('7' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              //UserEngine.GetStdItemName(ui.wIndex) + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
              '0');

      end
      else
      begin
        Dispose(MapItem);
      end;

      if g_Config.boShowMakeItemMsg and (m_btPermission >= 6) then
        MainOutMessage('[制造物品] ' + m_sCharName + ' ' + sItemName + '(' +
          IntToStr(UserItem.MakeIndex) + ')');
      //004CD10D
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('5' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
          StdItem.Name + #9 +
          IntToStr(UserItem.MakeIndex) + #9 +
          '1' + #9 +
          '0');
    end
    else
    begin                                                   //004CD114
      Dispose(UserItem);
      SysMsg(format(g_sGamecommandMakeItemNameNotFound, [sItemName]), c_Red, t_Hint);
      break;
    end;
  end;
end;

procedure TPlayObject.CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string);
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
  UserItem                                             : pTUserItem;
  DelList                                              : TStringList;
begin
  DelList := nil;
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '人物名称']), c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;

  for I := 0 to PlayObject.m_ItemList.Count - 1 do
  begin
    UserItem := PlayObject.m_ItemList.Items[I];
    if DelList = nil then
      DelList := TStringList.Create;
    DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex),
      TObject(UserItem.MakeIndex));
    Dispose(UserItem);
  end;
  PlayObject.m_ItemList.Clear;
  if DelList <> nil then
  begin
    PlayObject.SendMsg(PlayObject, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
  end;
  // PlayObject.ClientQueryBagItems;
end;

procedure TPlayObject.CmdClearHumanPassword(sCmd: string; nPermission: Integer;
  sHumanName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < nPermission) then
    exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg('清除玩家的仓库密码！！！', c_Red, t_Hint);
    SysMsg(format('命令格式: @%s 人物名称', [sCmd]), c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    exit;
  end;
  PlayObject.m_boPasswordLocked := False;
  PlayObject.m_boUnLockStoragePwd := False;
  PlayObject.m_sStoragePwd := '';
  PlayObject.SysMsg('你的保护密码已被清除！！！', c_Green, t_Hint);
  SysMsg(format('%s的保护密码已被清除！！！', [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName, sItems:
  string);
var
  I, II                                                : Integer;
  MonList                                              : TList;
  Envir                                                : TEnvirnoment;
  nMonCount                                            : Integer;
  boKillAll                                            : Boolean;
  boKillAllMap                                         : Boolean;
  boNotItem                                            : Boolean;
  BaseObject                                           : TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sMapName = '') or (sMonName = '') or (sItems = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 地图号(* 为所有) 怪物名称(* 为所有) 掉物品(0,1)',
      c_Red, t_Hint);
    exit;
  end;
  boKillAll := False;
  boKillAllMap := False;
  boNotItem := True;
  nMonCount := 0;
  Envir := nil;
  if sMonName = '*' then
    boKillAll := True;
  if sMapName = '*' then
    boKillAllMap := True;
  if sItems = '1' then
    boNotItem := False;

  MonList := TList.Create;
  for I := 0 to g_MapManager.Count - 1 do
  begin
    Envir := TEnvirnoment(g_MapManager.Items[I]);
    if (Envir <> nil) and (boKillAllMap or (CompareText(Envir.sMapName, sMapName) = 0))
      then
    begin
      MonList.clear;
      UserEngine.GetMapMonster(Envir, MonList);
      for II := 0 to MonList.Count - 1 do
      begin
        BaseObject := TBaseObject(MonList.Items[II]);
        if boKillAll or (CompareText(sMonName, BaseObject.m_sCharName) = 0) then
        begin
          BaseObject.m_boNoItem := boNotItem;
          // BaseObject.m_WAbil.HP:=0;
          BaseObject.MakeGhost;
          Inc(nMonCount);
        end;
      end;
    end;
  end;
  MonList.Free;
  if Envir = nil then
  begin
    SysMsg('输入的地图不存在！！！', c_Red, t_Hint);
    exit;
  end;

  SysMsg('已清除怪物数: ' + IntTOStr(nMonCount), c_Red, t_Hint);
end;

procedure TPlayObject.CmdClearMission(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称)', c_Red, t_Hint);
    exit;
  end;
  if sHumanName[1] = '?' then
  begin
    SysMsg('此命令用于清除人物的任务标志。', c_Blue, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format('%s不在线，或在其它服务器上！！', [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  FillChar(PlayObject.m_QuestFlag, SizeOf(TQuestFlag), #0);
  SysMsg(format('%s的任务标志已经全部清零。', [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdContestPoint(Cmd: pTGameCmd; sGuildName: string); //004CEF08
var
  I                                                    : Integer;
  Guild                                                : TGuild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then
  begin
    SysMsg('查看行会战的得分数。', c_Red, t_Hint);
    SysMsg(format('命令格式: @%s 行会名称', [Cmd.sCmd]), c_Red, t_Hint);
    exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then
  begin
    SysMsg(format('%s 的得分为: %d', [sGuildName, Guild.nContestPoint]), c_Green,
      t_Hint);
  end
  else
  begin
    SysMsg(format('行会: %s 不存在！！！', [sGuildName]), c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdStartContest(Cmd: pTGameCmd; sParam1: string); //004CF008
var
  I, II                                                : Integer;
  List10, List14                                       : TList;
  PlayObject, PlayObjectA                              : TPlayObject;
  bo19                                                 : Boolean;
  s20                                                  : string;
  Guild                                                : TGuild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg('开始行会争霸赛。', c_Red, t_Hint);
    SysMsg(format('命令格式: @%s', [Cmd.sCmd]), c_Red, t_Hint);
    exit;
  end;

  if not m_PEnvir.m_boFight3Zone then
  begin
    SysMsg('此命令不能在当前地图中使用！！！', c_Red, t_Hint);
    exit;
  end;
  List10 := TList.Create;
  List14 := TList.Create;
  UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
  for I := 0 to List10.Count - 1 do
  begin
    PlayObject := TPlayObject(List10.Items[I]);
    if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then
    begin
      PlayObject.m_nFightZoneDieCount := 0;
      if PlayObject.m_MyGuild = nil then
        Continue;
      bo19 := False;
      for II := 0 to List14.Count - 1 do
      begin
        PlayObjectA := TPlayObject(List14.Items[II]);
        if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then
          bo19 := True;
      end;
      if not bo19 then
      begin
        List14.Add(PlayObject.m_MyGuild);
      end;
    end;
  end;
  SysMsg('行会争霸赛已经开始。', c_Green, t_Hint);
  UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor, '- 行会战争已爆发。');
  s20 := '';
  for I := 0 to List14.Count - 1 do
  begin
    Guild := TGuild(List14.Items[I]);
    Guild.StartTeamFight();
    for II := 0 to List10.Count - 1 do
    begin
      PlayObject := TPlayObject(List10.Items[I]);
      if PlayObject.m_MyGuild = Guild then
      begin
        Guild.AddTeamFightMember(PlayObject.m_sCharName);
      end;
    end;
    s20 := s20 + Guild.sGuildName + ' ';
  end;
  UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000, g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor, ' -参加的门派:' + s20);
  List10.Free;
  List14.Free;
end;

procedure TPlayObject.CmdEndContest(Cmd: pTGameCmd; sParam1: string); //004CF364
var
  I, II                                                : Integer;
  List10, List14                                       : TList;
  PlayObject, PlayObjectA                              : TPlayObject;
  bo19                                                 : Boolean;
  s20                                                  : string;
  Guild                                                : TGuild;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg('结束行会争霸赛。', c_Red, t_Hint);
    SysMsg(format('命令格式: @%s', [Cmd.sCmd]), c_Red, t_Hint);
    exit;
  end;

  if not m_PEnvir.m_boFight3Zone then
  begin
    SysMsg('此命令不能在当前地图中使用！！！', c_Red, t_Hint);
    exit;
  end;
  List10 := TList.Create;
  List14 := TList.Create;
  UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
  for I := 0 to List10.Count - 1 do
  begin
    PlayObject := TPlayObject(List10.Items[I]);
    if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then
    begin
      if PlayObject.m_MyGuild = nil then
        Continue;
      bo19 := False;
      for II := 0 to List14.Count - 1 do
      begin
        PlayObjectA := TPlayObject(List14.Items[II]);
        if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then
          bo19 := True;
      end;
      if not bo19 then
      begin
        List14.Add(PlayObject.m_MyGuild);
      end;
    end;
  end;
  for I := 0 to List14.Count - 1 do
  begin
    Guild := TGuild(List14.Items[I]);
    Guild.EndTeamFight();
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
      g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, format(' - %s 行会争霸赛已结束。',
      [Guild.sGuildName]));
  end;
  List10.Free;
  List14.Free;
end;

procedure TPlayObject.CmdAllowGroupReCall(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('此命令用于允许或禁止编组传送功能。', c_Red, t_Hint);
    exit;
  end;

  m_boAllowGroupReCall := not m_boAllowGroupReCall;
  if m_boAllowGroupReCall then
    SysMsg(g_sEnableGroupRecall {'[允许天地合一]'}, c_Green, t_Hint)
  else
    SysMsg(g_sDisableGroupRecall {'[禁止天地合一]'}, c_Green, t_Hint);
end;

procedure TPlayObject.CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string); //004CF564
var
  I                                                    : Integer;
  Guild                                                : TGuild;
  PlayObject                                           : TPlayObject;
  sHumanName                                           : string;
  nPoint                                               : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then
  begin
    SysMsg('查看行会争霸赛结果。', c_Red, t_Hint);
    SysMsg(format('命令格式: @%s 行会名称', [Cmd.sCmd]), c_Red, t_Hint);
    exit;
  end;

  if not m_PEnvir.m_boFight3Zone then
  begin
    SysMsg('此命令不能在当前地图中使用！！！', c_Red, t_Hint);
    exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then
  begin
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
      g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, format(' - %s 行会争霸赛结果: ',
      [Guild.sGuildName]));
    for I := 0 to Guild.TeamFightDeadList.Count - 1 do
    begin
      nPoint := Integer(Guild.TeamFightDeadList.Objects[I]);
      sHumanName := Guild.TeamFightDeadList.Strings[I];
      UserEngine.CryCry(RM_CRY,
        m_PEnvir,
        m_nCurrX,
        m_nCurrY,
        1000,
        g_Config.btCryMsgFColor,
        g_Config.btCryMsgBColor,
        format(' - %s  : %d 分/死亡%d次。 ', [sHumanName, HiWord(nPoint),
          LoWord(nPoint)]));
    end;
  end;
  UserEngine.CryCry(RM_CRY,
    m_PEnvir,
    m_nCurrX,
    m_nCurrY,
    1000,
    g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor,
    format(' - [%s] : %d 分。', [Guild.sGuildName, Guild.nContestPoint]));
  UserEngine.CryCry(RM_CRY,
    m_PEnvir,
    m_nCurrX,
    m_nCurrY,
    1000,
    g_Config.btCryMsgFColor,
    g_Config.btCryMsgBColor,
    '------------------------------------');
end;

procedure TPlayObject.CmdDearRecall(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('命令格式: @' + sCmd +
      ' (夫妻传送，将对方传送到自己身边，对方必须允许传送。)', c_Green, t_Hint);
    exit;
  end;
  if m_sDearName = '' then
  begin
    SysMsg('你没有结婚！！！', c_Red, t_Hint);
    exit;
  end;
  if m_PEnvir.m_boNODEARRECALL then
  begin
    SysMsg('本地图禁止夫妻传送！！！', c_Red, t_Hint);
    exit;
  end;

  if m_DearHuman = nil then
  begin
    if m_btGender = 0 then
    begin
      SysMsg('你的老婆不在线！！！', c_Red, t_Hint);
    end
    else
    begin
      SysMsg('你的老公不在线！！！', c_Red, t_Hint);
    end;
    exit;
  end;
  if GetTickCount - m_dwDearRecallTick < 10000 then
  begin
    SysMsg('稍等会才能再次使用此功能！！！', c_Red, t_Hint);
    exit;
  end;
  m_dwDearRecallTick := GetTickCount();
  if m_DearHuman.m_boCanDearRecall then
  begin
    RecallHuman(m_DearHuman.m_sCharName);
    SendRefMsg(RM_510, 0, 1, 0, 32, '');
    m_DearHuman.SendRefMsg(RM_510, 0, 1, 0, 32, '');
  end
  else
  begin
    SysMsg(m_DearHuman.m_sCharName + ' 不允许传送！！！', c_Red, t_Hint);
    exit;
  end;

end;

procedure TPlayObject.CmdMasterRecall(sCmd, sParam: string);
var
  I                                                    : Integer;
  MasterHuman                                          : TPlayObject;
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('命令格式: @' + sCmd +
      ' (师徒传送，师父可以将徒弟传送到自己身边，徒弟必须允许传送。)', c_Green, t_Hint);
    exit;
  end;
  if not m_boMaster then
  begin
    SysMsg('只能师父才能使用此功能！！！', c_Red, t_Hint);
    exit;
  end;
  if m_MasterList.Count = 0 then
  begin
    SysMsg('你的徒弟一个都不在线！！！', c_Red, t_Hint);
    exit;
  end;
  if m_PEnvir.m_boNOMASTERRECALL then
  begin
    SysMsg('本地图禁止师徒传送！！！', c_Red, t_Hint);
    exit;
  end;
  if GetTickCount - m_dwMasterRecallTick < 10000 then
  begin
    SysMsg('稍等伙才能再次使用此功能！！！', c_Red, t_Hint);
    exit;
  end;

  for I := 0 to m_MasterList.Count - 1 do
  begin
    MasterHuman := TPlayObject(m_MasterList.Items[I]);
    if MasterHuman.m_boCanMasterRecall then
    begin
      RecallHuman(MasterHuman.m_sCharName);
      MasterHuman.SendRefMsg(RM_510, 0, 1, 0, 31, '');
    end
    else
    begin
      SysMsg(MasterHuman.m_sCharName + ' 不允许传送！！！', c_Red, t_Hint);
    end;
  end;
  SendRefMsg(RM_510, 0, 1, 0, 31, '');
end;

procedure TPlayObject.CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sHumName = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);
    PlayObject.m_nBonusPoint := 0;
    PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    PlayObject.HasLevelUp(0);
    PlayObject.SysMsg('分配点数已清除！！！', c_Red, t_Hint);
    SysMsg(sHumName + ' 的分配点数已清除.', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);
var
  PlayObject                                           : TPlayObject;
  nLevel                                               : Integer;
begin
  if (m_btPermission < 6) then
    exit;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 点数(为空则查看)', c_Red, t_Hint);
    exit;
  end;
  nLevel := Str_ToInt(sLevel, -1);
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    if (nLevel >= 0) and (nLevel <= 255) then
    begin
      PlayObject.m_btReLevel := nLevel;
      PlayObject.RefShowName();
    end;
    SysMsg(sHumanName + ' 的转生等级为 ' + IntToStr(PlayObject.m_btReLevel), c_Green,
      t_Hint);
  end
  else
  begin
    SysMsg(sHumanName + ' 没在线上！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject                                           : TPlayObject;
  nTotleUsePoint                                       : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sHumName = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    nTotleUsePoint := PlayObject.m_BonusAbil.DC +
      PlayObject.m_BonusAbil.MC +
      PlayObject.m_BonusAbil.SC +
      PlayObject.m_BonusAbil.AC +
      PlayObject.m_BonusAbil.MAC +
      PlayObject.m_BonusAbil.HP +
      PlayObject.m_BonusAbil.MP +
      PlayObject.m_BonusAbil.Hit +
      PlayObject.m_BonusAbil.Speed +
      PlayObject.m_BonusAbil.X2;
    FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), #0);

    Inc(PlayObject.m_nBonusPoint, nTotleUsePoint);
    PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    PlayObject.HasLevelUp(0);
    PlayObject.SysMsg('分配点数已复位！！！', c_Red, t_Hint);
    SysMsg(sHumName + ' 的分配点数已复位.', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdSbkDoorControl(sCmd, sParam: string);
begin

end;

procedure TPlayObject.CmdSearchDear(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('此命令用于查询配偶当前所在位置。', c_Red, t_Hint);
    exit;
  end;
  if m_sDearName = '' then
  begin
    SysMsg(g_sYouAreNotMarryedMsg {'你都没结婚查什么？'}, c_Red, t_Hint);
    exit;
  end;
  if m_DearHuman = nil then
  begin
    if m_btGender = 0 then
    begin
      SysMsg(g_sYourWifeNotOnlineMsg {'你的老婆还没有上线！！！'}, c_Red, t_Hint);
    end
    else
    begin
      SysMsg(g_sYourHusbandNotOnlineMsg {'你的老公还没有上线！！！'}, c_Red, t_Hint);
    end;
    exit;
  end;

  if m_btGender = 0 then
  begin
    SysMsg(g_sYourWifeNowLocateMsg {'你的老婆现在位于:'}, c_Green, t_Hint);
    SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.sMapDesc + '(' +
      IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY) + ')', c_Green,
      t_Hint);
    m_DearHuman.SysMsg(g_sYourHusbandSearchLocateMsg {'你的老公正在找你，他现在位于:'},
      c_Green, t_Hint);
    m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) +
      ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(g_sYourHusbandNowLocateMsg {'你的老公现在位于:'}, c_Red, t_Hint);
    SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.sMapDesc + '(' +
      IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY) + ')', c_Green,
      t_Hint);
    m_DearHuman.SysMsg(g_sYourWifeSearchLocateMsg {'你的老婆正在找你，她现在位于:'},
      c_Green, t_Hint);
    m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) +
      ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
  end;

end;

procedure TPlayObject.CmdSearchMaster(sCmd, sParam: string);
var
  I                                                    : Integer;
  Human                                                : TPlayObject;
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('此命令用于查询师徒当前所在位置。', c_Red, t_Hint);
    exit;
  end;
  if m_sMasterName = '' then
  begin
    SysMsg(g_sYouAreNotMasterMsg, c_Red, t_Hint);
    exit;
  end;
  if m_boMaster then
  begin
    if m_MasterList.Count <= 0 then
    begin
      SysMsg(g_sYourMasterListNotOnlineMsg, c_Red, t_Hint);
      exit;
    end;
    SysMsg(g_sYourMasterListNowLocateMsg, c_Green, t_Hint);
    for I := 0 to m_MasterList.Count - 1 do
    begin
      Human := TPlayObject(m_MasterList.Items[I]);
      SysMsg(Human.m_sCharName + ' ' + Human.m_PEnvir.sMapDesc + '(' +
        IntToStr(Human.m_nCurrX) + ':' + IntToStr(Human.m_nCurrY) + ')', c_Green, t_Hint);
      Human.SysMsg(g_sYourMasterSearchLocateMsg, c_Green, t_Hint);
      Human.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX) + ':'
        + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
    end;
  end
  else
  begin
    if m_MasterHuman = nil then
    begin
      SysMsg(g_sYourMasterNotOnlineMsg, c_Red, t_Hint);
      exit;
    end;
    SysMsg(g_sYourMasterNowLocateMsg, c_Red, t_Hint);
    SysMsg(m_MasterHuman.m_sCharName + ' ' + m_MasterHuman.m_PEnvir.sMapDesc + '(' +
      IntToStr(m_MasterHuman.m_nCurrX) + ':' + IntToStr(m_MasterHuman.m_nCurrY) + ')',
      c_Green, t_Hint);
    m_MasterHuman.SysMsg(g_sYourMasterListSearchLocateMsg, c_Green, t_Hint);
    m_MasterHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' + IntToStr(m_nCurrX)
      + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission: string);
var
  nPerission                                           : Integer;
  PlayObject                                           : TPlayObject;
resourcestring
  sOutFormatMsg                                        = '[权限调整] %s (%s %d -> %d)';
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  nPerission := Str_ToInt(sPermission, 0);
  if (sHumanName = '') or not (nPerission in [0..10]) then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 权限等级(0 - 10)', c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  if g_Config.boShowMakeItemMsg then
    MainOutMessage(format(sOutFormatMsg, [m_sCharName, PlayObject.m_sCharName,
      PlayObject.m_btPermission, nPerission]));
  PlayObject.m_btPermission := nPerission;
  SysMsg(sHumanName + ' 当前权限为: ' + IntToStr(PlayObject.m_btPermission), c_Red,
    t_Hint);
end;

procedure TPlayObject.CmdShowHumanFlag(sCmd: string; nPermission: Integer;
  sHumanName, sFlag: string);
var
  PlayObject                                           : TPlayObject;
  nFlag                                                : Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandShowHumanFlagHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  nFlag := Str_ToInt(sFlag, 0);
  if PlayObject.GetQuestFalgStatus(nFlag) = 1 then
  begin
    SysMsg(format(g_sGameCommandShowHumanFlagONMsg, [PlayObject.m_sCharName, nFlag]),
      c_Green, t_Hint);
  end
  else
  begin
    SysMsg(format(g_sGameCommandShowHumanFlagOFFMsg, [PlayObject.m_sCharName, nFlag]),
      c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdShowHumanUnit(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
var
  PlayObject                                           : TPlayObject;
  nUnit                                                : Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandShowHumanUnitHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  nUnit := Str_ToInt(sUnit, 0);
  if PlayObject.GetQuestUnitStatus(nUnit) = 1 then
  begin
    SysMsg(format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName, nUnit]),
      c_Green, t_Hint);
  end
  else
  begin
    SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName, nUnit]),
      c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
var
  PlayObject                                           : TPlayObject;
  nUnit                                                : Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandShowHumanUnitHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  nUnit := Str_ToInt(sUnit, 0);
  if PlayObject.GetQuestUnitOpenStatus(nUnit) = 1 then
  begin
    SysMsg(format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName, nUnit]),
      c_Green, t_Hint);
  end
  else
  begin
    SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName, nUnit]),
      c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandMapInfoMsg, [m_PEnvir.sMapName, m_PEnvir.sMapDesc]),
    c_Green, t_Hint);
  SysMsg(format(g_sGameCommandMapInfoSizeMsg, [m_PEnvir.m_nWidth, m_PEnvir.m_nHeight]),
    c_Green, t_Hint);
end;

procedure TPlayObject.CmdShowMapMode(sCmd, sMapName: string);
var
  Envir                                                : TEnvirnoment;
  sMsg                                                 : string;
begin
  if (m_btPermission < 6) then
    exit;
  if (sMapName = '') then
  begin
    SysMsg('命令格式: @' + sCmd + ' 地图号', c_Red, t_Hint);
    exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then
  begin
    SysMsg(sMapName + ' 不存在！！！', c_Red, t_Hint);
    exit;
  end;
  sMsg := '地图模式: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg, c_Blue, t_Hint);
end;

procedure TPlayObject.CmdSetMapMode(sCmd, sMapName, sMapMode, sParam1,
  sParam2: string);
var
  Envir                                                : TEnvirnoment;
  sMsg                                                 : string;
begin
  if (m_btPermission < 6) then
    exit;
  if (sMapName = '') or (sMapMode = '') then
  begin
    SysMsg('命令格式: @' + sCmd + ' 地图号 模式', c_Red, t_Hint);
    exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then
  begin
    SysMsg(sMapName + ' 不存在！！！', c_Red, t_Hint);
    exit;
  end;
  if CompareText(sMapMode, 'SAFE') = 0 then
  begin
    if (sParam1 <> '') then
    begin
      Envir.m_boSAFE := True;
    end
    else
    begin
      Envir.m_boSAFE := False;
    end;
  end
  else
    if CompareText(sMapMode, 'DARK') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.m_boDARK := True;
      end
      else
      begin
        Envir.m_boDARK := False;
      end;
    end
    else
      if CompareText(sMapMode, 'DARK') = 0 then
      begin
        if (sParam1 <> '') then
        begin
          Envir.m_boDARK := True;
        end
        else
        begin
          Envir.m_boDARK := False;
        end;
      end
      else
        if CompareText(sMapMode, 'FIGHT') = 0 then
        begin
          if (sParam1 <> '') then
          begin
            Envir.m_boFightZone := True;
          end
          else
          begin
            Envir.m_boFightZone := False;
          end;
        end
        else
          if CompareText(sMapMode, 'FIGHT3') = 0 then
          begin
            if (sParam1 <> '') then
            begin
              Envir.m_boFight3Zone := True;
            end
            else
            begin
              Envir.m_boFight3Zone := False;
            end;
          end
          else
            if CompareText(sMapMode, 'DAY') = 0 then
            begin
              if (sParam1 <> '') then
              begin
                Envir.m_boDAY := True;
              end
              else
              begin
                Envir.m_boDAY := False;
              end;
            end
            else
              if CompareText(sMapMode, 'QUIZ') = 0 then
              begin
                if (sParam1 <> '') then
                begin
                  Envir.m_boQUIZ := True;
                end
                else
                begin
                  Envir.m_boQUIZ := False;
                end;
              end
              else
                if CompareText(sMapMode, 'NORECONNECT') = 0 then
                begin
                  if (sParam1 <> '') then
                  begin
                    Envir.m_boNORECONNECT := True;
                    Envir.sNoReconnectMap := sParam1;
                  end
                  else
                  begin
                    Envir.m_boNORECONNECT := False;
                  end;
                end
                else
                  if CompareText(sMapMode, 'MUSIC') = 0 then
                  begin
                    if (sParam1 <> '') then
                    begin
                      Envir.m_boMUSIC := True;
                      Envir.m_nMUSICID := Str_ToInt(sParam1, -1);
                    end
                    else
                    begin
                      Envir.m_boMUSIC := False;
                    end;
                  end
                  else
                    if CompareText(sMapMode, 'EXPRATE') = 0 then
                    begin
                      if (sParam1 <> '') then
                      begin
                        Envir.m_boEXPRATE := True;
                        Envir.m_nEXPRATE := Str_ToInt(sParam1, -1);
                      end
                      else
                      begin
                        Envir.m_boEXPRATE := False;
                      end;
                    end
                    else
                      if CompareText(sMapMode, 'PKWINLEVEL') = 0 then
                      begin
                        if (sParam1 <> '') then
                        begin
                          Envir.m_boPKWINLEVEL := True;
                          Envir.m_nPKWINLEVEL := Str_ToInt(sParam1, -1);
                        end
                        else
                        begin
                          Envir.m_boPKWINLEVEL := False;
                        end;
                      end
                      else
                        if CompareText(sMapMode, 'PKWINEXP') = 0 then
                        begin
                          if (sParam1 <> '') then
                          begin
                            Envir.m_boPKWINEXP := True;
                            Envir.m_nPKWINEXP := Str_ToInt(sParam1, -1);
                          end
                          else
                          begin
                            Envir.m_boPKWINEXP := False;
                          end;
                        end
                        else
                          if CompareText(sMapMode, 'PKLOSTLEVEL') = 0 then
                          begin
                            if (sParam1 <> '') then
                            begin
                              Envir.m_boPKLOSTLEVEL := True;
                              Envir.m_nPKLOSTLEVEL := Str_ToInt(sParam1, -1);
                            end
                            else
                            begin
                              Envir.m_boPKLOSTLEVEL := False;
                            end;
                          end
                          else
                            if CompareText(sMapMode, 'PKLOSTEXP') = 0 then
                            begin
                              if (sParam1 <> '') then
                              begin
                                Envir.m_boPKLOSTEXP := True;
                                Envir.m_nPKLOSTEXP := Str_ToInt(sParam1, -1);
                              end
                              else
                              begin
                                Envir.m_boPKLOSTEXP := False;
                              end;
                            end
                            else
                              if CompareText(sMapMode, 'DECHP') = 0 then
                              begin
                                if (sParam1 <> '') and (sParam2 <> '') then
                                begin
                                  Envir.m_boDECHP := True;
                                  Envir.m_nDECHPTIME := Str_ToInt(sParam1, -1);
                                  Envir.m_nDECHPPOINT := Str_ToInt(sParam2, -1);
                                end
                                else
                                begin
                                  Envir.m_boDECHP := False;
                                end;
                              end
                              else
                                if CompareText(sMapMode, 'DECGAMEGOLD') = 0 then
                                begin
                                  if (sParam1 <> '') and (sParam2 <> '') then
                                  begin
                                    Envir.m_boDECGAMEGOLD := True;
                                    Envir.m_nDECGAMEGOLDTIME := Str_ToInt(sParam1, -1);
                                    Envir.m_nDECGAMEGOLD := Str_ToInt(sParam2, -1);
                                  end
                                  else
                                  begin
                                    Envir.m_boDECGAMEGOLD := False;
                                  end;
                                end
                                else
                                  if CompareText(sMapMode, 'INCGAMEGOLD') = 0 then
                                  begin
                                    if (sParam1 <> '') and (sParam2 <> '') then
                                    begin
                                      Envir.m_boINCGAMEGOLD := True;
                                      Envir.m_nINCGAMEGOLDTIME := Str_ToInt(sParam1, -1);
                                      Envir.m_nINCGAMEGOLD := Str_ToInt(sParam2, -1);
                                    end
                                    else
                                    begin
                                      Envir.m_boINCGAMEGOLD := False;
                                    end;
                                  end
                                  else
                                    if CompareText(sMapMode, 'INCGAMEPOINT') = 0 then
                                    begin
                                      if (sParam1 <> '') and (sParam2 <> '') then
                                      begin
                                        Envir.m_boINCGAMEPOINT := True;
                                        Envir.m_nINCGAMEPOINTTIME := Str_ToInt(sParam1,
                                          -1);
                                        Envir.m_nINCGAMEPOINT := Str_ToInt(sParam2, -1);
                                      end
                                      else
                                      begin
                                        Envir.m_boINCGAMEGOLD := False;
                                      end;
                                    end
                                    else
                                      if CompareText(sMapMode, 'RUNHUMAN') = 0 then
                                      begin
                                        if (sParam1 <> '') then
                                        begin
                                          Envir.m_boRUNHUMAN := True;
                                        end
                                        else
                                        begin
                                          Envir.m_boRUNHUMAN := False;
                                        end;
                                      end
                                      else
                                        if CompareText(sMapMode, 'RUNMON') = 0 then
                                        begin
                                          if (sParam1 <> '') then
                                          begin
                                            Envir.m_boRUNMON := True;
                                          end
                                          else
                                          begin
                                            Envir.m_boRUNMON := False;
                                          end;
                                        end
                                        else
                                          if CompareText(sMapMode, 'NEEDHOLE') = 0 then
                                          begin
                                            if (sParam1 <> '') then
                                            begin
                                              Envir.m_boNEEDHOLE := True;
                                            end
                                            else
                                            begin
                                              Envir.m_boNEEDHOLE := False;
                                            end;
                                          end
                                          else
                                            if CompareText(sMapMode, 'NORECALL') = 0 then
                                            begin
                                              if (sParam1 <> '') then
                                              begin
                                                Envir.m_boNORECALL := True;
                                              end
                                              else
                                              begin
                                                Envir.m_boNORECALL := False;
                                              end;
                                            end
                                            else
                                              if CompareText(sMapMode, 'NOGUILDRECALL') =
                                                0 then
                                              begin
                                                if (sParam1 <> '') then
                                                begin
                                                  Envir.m_boNOGUILDRECALL := True;
                                                end
                                                else
                                                begin
                                                  Envir.m_boNOGUILDRECALL := False;
                                                end;
                                              end
                                              else
                                                if CompareText(sMapMode, 'NODEARRECALL')
                                                  = 0 then
                                                begin
                                                  if (sParam1 <> '') then
                                                  begin
                                                    Envir.m_boNODEARRECALL := True;
                                                  end
                                                  else
                                                  begin
                                                    Envir.m_boNODEARRECALL := False;
                                                  end;
                                                end
                                                else
                                                  if CompareText(sMapMode,
                                                    'NOMASTERRECALL') = 0 then
                                                  begin
                                                    if (sParam1 <> '') then
                                                    begin
                                                      Envir.m_boNOMASTERRECALL := True;
                                                    end
                                                    else
                                                    begin
                                                      Envir.m_boNOMASTERRECALL := False;
                                                    end;
                                                  end
                                                  else
                                                    if CompareText(sMapMode,
                                                      'NORANDOMMOVE') = 0 then
                                                    begin
                                                      if (sParam1 <> '') then
                                                      begin
                                                        Envir.m_boNORANDOMMOVE := True;
                                                      end
                                                      else
                                                      begin
                                                        Envir.m_boNORANDOMMOVE := False;
                                                      end;
                                                    end
                                                    else
                                                      if CompareText(sMapMode, 'NODRUG')
                                                        = 0 then
                                                      begin
                                                        if (sParam1 <> '') then
                                                        begin
                                                          Envir.m_boNODRUG := True;
                                                        end
                                                        else
                                                        begin
                                                          Envir.m_boNODRUG := False;
                                                        end;
                                                      end
                                                      else
                                                        if CompareText(sMapMode, 'MINE')
                                                          = 0 then
                                                        begin
                                                          if (sParam1 <> '') then
                                                          begin
                                                            Envir.m_boMINE := True;
                                                          end
                                                          else
                                                          begin
                                                            Envir.m_boMINE := False;
                                                          end;
                                                        end
                                                        else
                                                          if CompareText(sMapMode,
                                                            'NOPOSITIONMOVE') = 0 then
                                                          begin
                                                            if (sParam1 <> '') then
                                                            begin
                                                              Envir.m_boNOPOSITIONMOVE :=
                                                                True;
                                                            end
                                                            else
                                                            begin
                                                              Envir.m_boNOPOSITIONMOVE :=
                                                                False;
                                                            end;
                                                          end;
  sMsg := '地图模式: ' + Envir.GetEnvirInfo;
  SysMsg(sMsg, c_Blue, t_Hint);
end;

procedure TPlayObject.CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName: string;
  nCount: Integer);                                           //004CDFF8
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
  nItemCount                                           : Integer;
  StdItem                                              : pTStditem;
  UserItem                                             : pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or (sItemName = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 物品名称 数量)', c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  nItemCount := 0;
  for I := PlayObject.m_ItemList.Count - 1 to 0 do
  begin
    UserItem := PlayObject.m_ItemList.Items[I];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then
    begin
      PlayObject.SendDelItems(UserItem);
      Dispose(UserItem);
      PlayObject.m_ItemList.Delete(I);
      Inc(nItemCount);
      if nItemCount >= nCount then
        break;
    end;
  end;
end;

procedure TPlayObject.CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);  //004CD27C
var
  PlayObject                                           : TPlayObject;
  nServerIndex                                         : integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumName = '') or (nCount <= 0) then
    exit;
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    if PlayObject.m_nGold > nCount then
    begin
      Dec(PlayObject.m_nGold, nCount);
    end
    else
    begin
      nCount := PlayObject.m_nGold;
      PlayObject.m_nGold := 0;
    end;
    PlayObject.GoldChanged();
    SysMsg(sHumName + '的金币已减少' + IntToStr(nCount) + '.', c_Green, t_Hint);
    //004CD409
    if g_boGameLogGold then
      AddGameDataLog('13' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nCount) + #9 +
        '1' + #9 +
        sHumName);
  end
  else
  begin
    if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then
    begin
      SysMsg(sHumName + '现在' + IntToStr(nServerIndex) + '号服务器上', c_Green, t_Hint);
    end
    else
    begin
      FrontEngine.AddChangeGoldList(m_sCharName, sHumName, -nCount);
      SysMsg(sHumName + '现在不在线，等其上线时金币将自动减少', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdDelGuild(Cmd: pTGameCmd; sGuildName: string); //004CEDEC
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if nServerIndex <> 0 then
  begin
    SysMsg('只能在主服务器上才可以使用此命令删除行会！！！', c_Red, t_Hint);
    exit;
  end;
  if sGuildName = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 行会名称', c_Red, t_Hint);
    exit;
  end;
  if g_GuildManager.DelGuild(sGuildName) then
  begin
    UserEngine.SendServerGroupMsg(SS_206, nServerIndex, sGuildName);
  end
  else
  begin
    SysMsg('没找到' + sGuildName + '这个行会！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdDelNpc(sCmd: string; nPermission: Integer; sParam1: string);
var
  BaseObject                                           : TBaseObject;
  I                                                    : Integer;
resourcestring
  sDelOK                                               = '删除NPC成功...';
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    exit;
  end;
  BaseObject := GetPoseCreate();
  if BaseObject <> nil then
  begin
    for I := 0 to UserEngine.m_MerchantList.Count - 1 do
    begin
      if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then
      begin
        BaseObject.m_boGhost := True;
        BaseObject.m_dwGhostTick := GetTickCount();
        BaseObject.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
        SysMsg(sDelOK, c_Red, t_Hint);
        exit;
      end;
    end;
    for I := 0 to UserEngine.QuestNPCList.Count - 1 do
    begin
      if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then
      begin
        BaseObject.m_boGhost := True;
        BaseObject.m_dwGhostTick := GetTickCount();
        BaseObject.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
        SysMsg(sDelOK, c_Red, t_Hint);
        exit;
      end;
    end;
  end;
  SysMsg(g_sGameCommandDelNpcMsg, c_Red, t_Hint);
end;

procedure TPlayObject.CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string);
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
  boDelAll                                             : Boolean;
  UserMagic                                            : pTUserMagic;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or (sSkillName = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 技能名称)', c_Red, t_Hint);
    exit;
  end;
  if CompareText(sSkillName, 'All') = 0 then
    boDelAll := True
  else
    boDelAll := False;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;

  for I := PlayObject.m_MagicList.Count - 1 downto 0 do
  begin
    UserMagic := PlayObject.m_MagicList.Items[I];
    if boDelAll then
    begin
      Dispose(UserMagic);
      PlayObject.m_MagicList.Delete(I);
    end
    else
    begin
      if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then
      begin
        PlayObject.SendDelMagic(UserMagic);
        Dispose(UserMagic);
        PlayObject.m_MagicList.Delete(I);
        PlayObject.SysMsg(format('技能%s已删除。', [sSkillName]), c_Green, t_Hint);
        SysMsg(format('%s的技能%s已删除。', [sHumanName, sSkillName]), c_Green, t_Hint);
        break;
      end;
    end;
  end;
end;

procedure TPlayObject.CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sAccount = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 登录帐号 是否永久封(0,1)', c_Red, t_Hint);
    exit;
  end;
  g_DenyAccountList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then
    begin
      g_DenyAccountList.AddObject(sAccount, TObject(1));
      SaveDenyAccountList();
      SysMsg(sAccount + '已加入禁止登录帐号列表', c_Green, t_Hint);
    end
    else
    begin
      g_DenyAccountList.AddObject(sAccount, TObject(0));
      SysMsg(sAccount + '已加入临时禁止登录帐号列表', c_Green, t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sCharName = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 是否永久封(0,1)', c_Red, t_Hint);
    exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then
    begin
      g_DenyChrNameList.AddObject(sCharName, TObject(1));
      SaveDenyChrNameList();
      SysMsg(sCharName + '已加入禁止人物列表', c_Green, t_Hint);
    end
    else
    begin
      g_DenyChrNameList.AddObject(sCharName, TObject(0));
      SysMsg(sCharName + '已加入临时禁止人物列表', c_Green, t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;

procedure TPlayObject.CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sIPaddr = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' IP地址 是否永久封(0,1)', c_Red, t_Hint);
    exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if (sFixDeny <> '') and (sFixDeny[1] = '1') then
    begin
      g_DenyIPAddrList.AddObject(sIPaddr, TObject(1));
      SaveDenyIPAddrList();
      SysMsg(sIPaddr + '已加入禁止登录IP列表', c_Green, t_Hint);
    end
    else
    begin
      g_DenyIPAddrList.AddObject(sIPaddr, TObject(0));
      SysMsg(sIPaddr + '已加入临时禁止登录IP列表', c_Green, t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;

procedure TPlayObject.CmdDisableFilter(sCmd, sParam1: string);
begin
  if (m_btPermission < 6) then
    exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then
  begin
    SysMsg('启用/禁止文字过滤功能。', c_Red, t_Hint);
    exit;
  end;
  boFilterWord := not boFilterWord;
  if boFilterWord then
  begin
    SysMsg('已启用文字过滤。', c_Green, t_Hint);
  end
  else
  begin
    SysMsg('已禁止文字过滤。', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount,
  sFixDeny: string);
var
  I                                                    : Integer;
  boDelete                                             : Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sAccount = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 登录帐号', c_Red, t_Hint);
    exit;
  end;
  boDelete := False;
  g_DenyAccountList.Lock;
  try
    for I := 0 to g_DenyAccountList.Count - 1 do
    begin
      if CompareText(sAccount, g_DenyAccountList.Strings[I]) = 0 then
      begin
        if Integer(g_DenyAccountList.Objects[I]) <> 0 then
          SaveDenyAccountList;
        g_DenyAccountList.Delete(I);
        SysMsg(sAccount + '已从禁止登录帐号列表中删除。', c_Green, t_Hint);
        boDelete := True;
        break;
      end;
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
  if not boDelete then
    SysMsg(sAccount + '没有被禁止登录。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName,
  sFixDeny: string);
var
  I                                                    : Integer;
  boDelete                                             : Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sCharName = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    exit;
  end;
  boDelete := False;
  g_DenyChrNameList.Lock;
  try
    for I := 0 to g_DenyChrNameList.Count - 1 do
    begin
      if CompareText(sCharName, g_DenyChrNameList.Strings[I]) = 0 then
      begin
        if Integer(g_DenyChrNameList.Objects[I]) <> 0 then
          SaveDenyChrNameList;
        g_DenyChrNameList.Delete(I);
        SysMsg(sCharName + '已从禁止登录人物列表中删除。', c_Green, t_Hint);
        boDelete := True;
        break;
      end;
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
  if not boDelete then
    SysMsg(sCharName + '没有被禁止登录。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr,
  sFixDeny: string);
var
  I                                                    : Integer;
  boDelete                                             : Boolean;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sIPaddr = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' IP地址', c_Red, t_Hint);
    exit;
  end;
  boDelete := False;
  g_DenyIPAddrList.Lock;
  try
    for I := 0 to g_DenyIPAddrList.Count - 1 do
    begin
      if CompareText(sIPaddr, g_DenyIPAddrList.Strings[I]) = 0 then
      begin
        if Integer(g_DenyIPAddrList.Objects[I]) <> 0 then
          SaveDenyIPAddrList;
        g_DenyIPAddrList.Delete(I);
        SysMsg(sIPaddr + '已从禁止登录IP列表中删除。', c_Green, t_Hint);
        boDelete := True;
        break;
      end;
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
  if not boDelete then
    SysMsg(sIPaddr + '没有被禁止登录。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount,
  sFixDeny: string);
var
  I                                                    : Integer;
begin
  if (m_btPermission < 6) then
    exit;
  g_DenyAccountList.Lock;
  try
    if g_DenyAccountList.Count <= 0 then
    begin
      SysMsg('禁止登录帐号列表为空。', c_Green, t_Hint);
      exit;
    end;
    for I := 0 to g_DenyAccountList.Count - 1 do
    begin
      SysMsg(g_DenyAccountList.Strings[I], c_Green, t_Hint);
    end;
  finally
    g_DenyAccountList.UnLock;
  end;
end;

procedure TPlayObject.CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName,
  sFixDeny: string);
var
  I                                                    : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  g_DenyChrNameList.Lock;
  try
    if g_DenyChrNameList.Count <= 0 then
    begin
      SysMsg('禁止登录角色列表为空。', c_Green, t_Hint);
      exit;
    end;
    for I := 0 to g_DenyChrNameList.Count - 1 do
    begin
      SysMsg(g_DenyChrNameList.Strings[I], c_Green, t_Hint);
    end;
  finally
    g_DenyChrNameList.UnLock;
  end;
end;

procedure TPlayObject.CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr,
  sFixDeny: string);
var
  I                                                    : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  g_DenyIPAddrList.Lock;
  try
    if g_DenyIPAddrList.Count <= 0 then
    begin
      SysMsg('禁止登录角色列表为空。', c_Green, t_Hint);
      exit;
    end;
    for I := 0 to g_DenyIPAddrList.Count - 1 do
    begin
      SysMsg(g_DenyIPAddrList.Strings[I], c_Green, t_Hint);
    end;
  finally
    g_DenyIPAddrList.UnLock;
  end;
end;

procedure TPlayObject.CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sHumanName = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    PlayObject.m_boFilterSendMsg := True;
  end;
  g_DisableSendMsgList.Add(sHumanName);
  SaveDisableSendMsgList();
  SysMsg(sHumanName + ' 已加入禁言列表。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdDisableSendMsgList(Cmd: pTGameCmd);
var
  I                                                    : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if g_DisableSendMsgList.Count <= 0 then
  begin
    SysMsg('禁言列表为空！！！', c_Red, t_Hint);
    exit;
  end;

  SysMsg('禁言列表:', c_Blue, t_Hint);
  for I := 0 to g_DisableSendMsgList.Count - 1 do
  begin
    SysMsg(g_DisableSendMsgList.Strings[I], c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sHumanName = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
    exit;
  end;
  for I := 0 to g_DisableSendMsgList.Count - 1 do
  begin
    if CompareText(sHumanName, g_DisableSendMsgList.Strings[I]) = 0 then
    begin
      PlayObject := UserEngine.GeTPlayObject(sHumanName);
      if PlayObject <> nil then
      begin
        PlayObject.m_boFilterSendMsg := False;
      end;
      g_DisableSendMsgList.Delete(I);
      SaveDisableSendMsgList();
      SysMsg(sHumanName + ' 已从禁言列表中删除。', c_Green, t_Hint);
      exit;
    end;
  end;
  SysMsg(sHumanName + ' 没有被禁言！！！', c_Red, t_Hint);
end;

procedure TPlayObject.CmdEndGuild;                          //4D1A44
begin
  if (m_MyGuild <> nil) then
  begin
    if (m_nGuildRankNo > 1) then
    begin
      if TGuild(m_MyGuild).IsMember(m_sCharName) and
        TGuild(m_MyGuild).DelMember(m_sCharName) then
      begin
        UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
          TGuild(m_MyGuild).sGuildName);
        m_MyGuild := nil;
        RefRankInfo(0, '');
        RefShowName();                                      //10/31
        SysMsg('你已经退出行会。', c_Green, t_Hint);
      end;
    end
    else
    begin
      SysMsg('行会掌门人不能这样退出行会！！！', c_Red, t_Hint);
    end;
  end
  else
  begin
    SysMsg('你都没加入行会！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdFireBurn(nInt, nTime, nN: Integer);
var
  FireBurnEvent                                        : TFireBurnEvent;
begin
  if (m_btPermission < 6) then
    exit;
  if (nInt = 0) or (nTime = 0) or (nN = 0) then
  begin
    SysMsg('命令格式: @' + g_GameCommand.FIREBURN.sCmd + ' nInt nTime nN', c_Red,
      t_Hint);
    exit;
  end;
  FireBurnEvent := TFireBurnEvent.Create(Self, m_nCurrX, m_nCurrY, nInt, nTime, nN);
  g_EventManager.AddEvent(FireBurnEvent);
end;

procedure TPlayObject.CmdForcedWallconquestWar(Cmd: pTGameCmd; sCastleName: string);
var
  Castle                                               : TUserCastle;
  s20                                                  : string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;

  if sCastleName = '' then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 城堡名称', c_Red, t_Hint);
    exit;
  end;

  Castle := g_CastleManager.Find(sCastleName);
  if Castle <> nil then
  begin
    Castle.m_boUnderWar := not Castle.m_boUnderWar;
    if Castle.m_boUnderWar then
    begin
      Castle.m_dwStartCastleWarTick := GetTickCount();
      Castle.StartWallconquestWar();

      UserEngine.SendServerGroupMsg(SS_212, nServerIndex, '');
      s20 := '[' + Castle.m_sName + '攻城战已经开始]';
      UserEngine.SendBroadCastMsg(s20, t_System);
      UserEngine.SendServerGroupMsg(SS_204, nServerIndex, s20);
      Castle.MainDoorControl(True);
    end
    else
    begin
      Castle.StopWallconquestWar();
    end;
  end
  else
  begin
    SysMsg(format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCastleName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string); //004CC528
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandFreePKHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  PlayObject.m_nPkPoint := 0;
  PlayObject.RefNameColor();
  PlayObject.SysMsg(g_sGameCommandFreePKHumanMsg, c_Green, t_Hint);
  SysMsg(format(g_sGameCommandFreePKMsg, [sHumanName]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdGroupRecall(sCMD: string);
var
  I                                                    : Integer;
  dwValue                                              : LongWord;
  PlayObject                                           : TPlayObject;
begin
  if m_boRecallSuite or (m_btPermission >= 6) then
  begin
    if not m_PEnvir.m_boNORECALL then
    begin
      dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
      m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
      if m_btPermission >= 6 then
        m_wGroupRcallTime := 0;

      if m_wGroupRcallTime > dwValue then
      begin
        Dec(m_wGroupRcallTime, dwValue);
      end
      else
        m_wGroupRcallTime := 0;
      if m_wGroupRcallTime = 0 then
      begin
        if m_GroupOwner = Self then
        begin
          for I := 1 to m_GroupMembers.Count - 1 do
          begin
            PlayObject := TPlayObject(m_GroupMembers.Objects[I]);
            if PlayObject.m_boAllowGroupReCall then
            begin
              if PlayObject.m_PEnvir.m_boNORECALL then
              begin
                SysMsg(format('%s 所在的地图不允许传送。', [PlayObject.m_sCharName]),
                  c_Red, t_Hint);
              end
              else
              begin
                RecallHuman(PlayObject.m_sCharName);
              end;
            end
            else
            begin
              SysMsg(format('%s 不允许天地合一！！！', [PlayObject.m_sCharName]), c_Red,
                t_Hint);
            end;
          end;
          m_dwGroupRcallTick := GetTickCount();
          m_wGroupRcallTime := g_Config.nGroupRecallTime;
        end;
      end
      else
      begin
        SysMsg(format('%d 秒之后才可以再使用此功能！！！', [m_wGroupRcallTime]), c_Red,
          t_Hint);
      end;
    end
    else
    begin
      SysMsg('此地图禁止使用此命令！！！', c_Red, t_Hint);
    end;
  end
  else
  begin
    SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdGuildRecall(sCmd, sParam: string);
var
  I, II                                                : Integer;
  dwValue                                              : LongWord;
  PlayObject                                           : TPlayObject;
  GuildRank                                            : pTGuildRank;
  nRecallCount, nNoRecallCount                         : Integer;
  Castle                                               : TUserCastle;
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('命令功能: 行会传送，行会掌门人可以将整个行会成员全部集中。', c_Red, t_Hint);
    exit;
  end;

  if not m_boGuildMove and (m_btPermission < 6) then
  begin
    SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
    exit;
  end;
  if not IsGuildMaster then
  begin
    SysMsg('行会掌门人才可以使用此功能！！！', c_Red, t_Hint);
    exit;
  end;
  if m_PEnvir.m_boNOGUILDRECALL then
  begin
    SysMsg('本地图不允许使用此功能！！！', c_Red, t_Hint);
    exit;
  end;
  Castle := g_CastleManager.InCastleWarArea(Self);

  //if UserCastle.m_boUnderWar and UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY) then begin
  if (Castle <> nil) and Castle.m_boUnderWar then
  begin
    SysMsg('攻城区域不允许使用此功能！！！', c_Red, t_Hint);
    exit;
  end;
  nRecallCount := 0;
  nNoRecallCount := 0;
  dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
  m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
  if m_btPermission >= 6 then
    m_wGroupRcallTime := 0;
  if m_wGroupRcallTime > dwValue then
  begin
    Dec(m_wGroupRcallTime, dwValue);
  end
  else
    m_wGroupRcallTime := 0;

  if m_wGroupRcallTime > 0 then
  begin
    SysMsg(format('%d 秒之后才可以再使用此功能！！！', [m_wGroupRcallTime]), c_Red,
      t_Hint);
    exit;
  end;

  for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do
  begin
    GuildRank := TGuild(m_MyGuild).m_RankList.Items[I];
    for II := 0 to GuildRank.MemberList.Count - 1 do
    begin
      PlayObject := TPlayObject(GuildRank.MemberList.Objects[II]);
      if PlayObject <> nil then
      begin
        if PlayObject = Self then
        begin
          //          Inc(nNoRecallCount);
          Continue;
        end;
        if PlayObject.m_boAllowGuildReCall then
        begin
          if PlayObject.m_PEnvir.m_boNORECALL then
          begin
            SysMsg(format('%s 所在的地图不允许传送。', [PlayObject.m_sCharName]), c_Red,
              t_Hint);
          end
          else
          begin
            RecallHuman(PlayObject.m_sCharName);
            Inc(nRecallCount);
          end;
        end
        else
        begin
          Inc(nNoRecallCount);
          SysMsg(format('%s 不允许行会合一！！！', [PlayObject.m_sCharName]), c_Red,
            t_Hint);
        end;
      end;
    end;
  end;
  //  SysMsg('已传送' + IntToStr(nRecallCount) + '个成员，' + IntToStr(nNoRecallCount) + '个成员未被传送。',c_Green,t_Hint);
  SysMsg(format('已传送%d个成员，%d个成员未被传送。', [nRecallCount, nNoRecallCount]),
    c_Green, t_Hint);
  m_dwGroupRcallTick := GetTickCount();
  m_wGroupRcallTime := g_Config.nGuildRecallTime;
end;

procedure TPlayObject.CmdGuildWar(sCmd, sGuildName: string); //004CE9F0
begin
  if (m_btPermission < 6) then
    exit;
end;

procedure TPlayObject.CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair: Integer);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or (nHair < 0) then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 类型值', c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    PlayObject.m_btHair := nHair;
    PlayObject.FeatureChanged();
    SysMsg(sHumanName + ' 的头发已改变。', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string); //004CFC98
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandInfoHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  SysMsg(PlayObject.GeTBaseObjectInfo(), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandHumanLocalHelpMsg]), c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandHumanLocalMsg, [sHumanName, m_sIPLocal
    {GetIPLocal(PlayObject.m_sIPaddr)}]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHunger(sCmd, sHumanName: string; nHungerPoint: Integer);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < 6) then
    exit;
  if (sHumanName = '') or (nHungerPoint < 0) then
  begin
    SysMsg('命令格式: @' + sCMD + ' 人物名称 能量值', c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    PlayObject.m_nHungerStatus := nHungerPoint;
    PlayObject.SendMsg(PlayObject, RM_MYSTATUS, 0, 0, 0, 0, '');
    PlayObject.RefMyStatus();
    SysMsg(sHumanName + ' 的能量值已改变。', c_Green, t_Hint);
  end
  else
  begin
    SysMsg(sHumanName + '没有在线！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint: Integer);  //004BF4D4
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandIncPkPointHelpMsg]), c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  Inc(PlayObject.m_nPkPoint, nPoint);
  PlayObject.RefNameColor();
  if nPoint > 0 then
    SysMsg(format(g_sGameCommandIncPkPointAddPointMsg, [sHumanName, nPoint]), c_Green,
      t_Hint)
  else
    SysMsg(format(g_sGameCommandIncPkPointDecPointMsg, [sHumanName, -nPoint]), c_Green,
      t_Hint);
end;

procedure TPlayObject.CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumName = '') or ((sHumName <> '') and (sHumName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandKickHumanHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    PlayObject.m_boKickFlag := True;
    PlayObject.m_boEmergencyClose := True;
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdKill(Cmd: pTGameCmd; sHumanName: string);
var
  BaseObject                                           : TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if sHumanName <> '' then
  begin
    BaseObject := UserEngine.GeTPlayObject(sHumanName);
    if BaseObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
      exit;
    end;
  end
  else
  begin
    BaseObject := GetPoseCreate();
    if BaseObject = nil then
    begin
      SysMsg('命令使用方法不正确，必须与角色面对面站好！！！', c_Red, t_Hint);
      exit;
    end;
  end;
  BaseObject.Die;
end;

procedure TPlayObject.CmdLockLogin(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if not g_Config.boLockHumanLogin then
  begin
    SysMsg('本服务器还没有启用登录锁功能！！！', c_Red, t_Hint);
    exit;
  end;

  if m_boLockLogon and not m_boLockLogoned then
  begin
    SysMsg('您还没有打开登录锁或还没有设置锁密码！！！', c_Red, t_Hint);
    exit;
  end;

  m_boLockLogon := not m_boLockLogon;
  if m_boLockLogon then
  begin
    SysMsg('已开启登录锁', c_Green, t_Hint);
  end
  else
  begin
    SysMsg('已关闭登录锁', c_Green, t_Hint);
  end;

end;

procedure TPlayObject.CmdLotteryTicket(sCmd: string; nPerMission: Integer;
  sParam1: string);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandLotteryTicketMsg, [g_Config.nWinLotteryCount,
    g_Config.nNoWinLotteryCount,
      g_Config.nWinLotteryLevel1,
      g_Config.nWinLotteryLevel2,
      g_Config.nWinLotteryLevel3,
      g_Config.nWinLotteryLevel4,
      g_Config.nWinLotteryLevel5,
      g_Config.nWinLotteryLevel6]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdLuckPoint(sCmd: string; nPerMission: Integer;
  sHumanName, sCtr, sPoint: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandLuckPointHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;

  if sCtr = '' then
  begin
    SysMsg(format(g_sGameCommandLuckPointMsg, [sHumanName, PlayObject.m_nBodyLuckLevel,
      PlayObject.m_dBodyLuck, PlayObject.m_nLuck]), c_Green, t_Hint);
    exit;
  end;

end;

procedure TPlayObject.CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount: Integer);  //004CCE34
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sItemName = '') then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGamecommandMakeHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  if (nCount <= 0) then
    nCount := 1;
  if (nCount > 10) then
    nCount := 10;
  if (m_btPermission < Cmd.nPermissionMax) then
  begin
    if not CanMakeItem(sItemName) then
    begin
      SysMsg(g_sGamecommandMakeItemNameOrPerMissionNot, c_Red, t_Hint);
      exit;
    end;
    //if UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurry) then begin
    if g_CastleManager.InCastleWarArea(Self) <> nil then
    begin
      SysMsg(g_sGamecommandMakeInCastleWarRange, c_Red, t_Hint);
      exit;
    end;
    if not InSafeZone then
    begin
      SysMsg(g_sGamecommandMakeInSafeZoneRange, c_Red, t_Hint);
      exit;
    end;
    nCount := 1;
  end;

  for I := 0 to nCount - 1 do
  begin
    if m_ItemList.Count >= m_bMaxBagitem then
      exit;                                                 //
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
    begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem.Price >= 15000) and not g_Config.boTestServer and (m_btPermission < 5)
        then
      begin
        Dispose(UserItem);
        Continue;
      end
      else
      begin
        if Random(g_Config.nMakeRandomAddValue {10}) = 0 then
          UserEngine.RandomUpgradeItem(UserItem);
      end;
      if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26] then
      begin
        if StdItem.Shape in [130, 131, 132] then
        begin
          UserEngine.GetUnknowItemValue(UserItem);
        end;
      end;
      if m_btPermission >= Cmd.nPermissionMax then
      begin
        UserItem.MakeIndex := GetItemNumberEx();            //制造的物品另行取得物品ID

      end;
      m_ItemList.Add(UserItem);
      SendAddItem(UserItem);
      if g_Config.boShowMakeItemMsg and (m_btPermission >= 6) then
        MainOutMessage('[制造物品] ' + m_sCharName + ' ' + sItemName + '(' +
          IntToStr(UserItem.MakeIndex) + ')');
      //004CD10D
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('5' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
          StdItem.Name + #9 +
          IntToStr(UserItem.MakeIndex) + #9 +
          '1' + #9 +
          '0');
    end
    else
    begin                                                   //004CD114
      Dispose(UserItem);
      SysMsg(format(g_sGamecommandMakeItemNameNotFound, [sItemName]), c_Red, t_Hint);
      break;
    end;
  end;
end;

procedure TPlayObject.CmdMapMove(Cmd: pTGameCmd; sMapName: string);
var
  Envir                                                : TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMoveHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if (Envir = nil) then
  begin
    SysMsg(format(g_sTheMapNotFound, [sMapName]) { + ' 此地图号不存在！！！'}, c_Red,
      t_Hint);
    exit;
  end;
  if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then
  begin
    SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
    MapRandomMove(sMapName, 0);
  end
  else
  begin
    SysMsg(format(g_sTheMapDisableMove, [sMapName, Envir.sMapDesc])
      {'地图 ' + sParam1 + ' 不允许传送！！！'}, c_Red, t_Hint);
  end;
end;
//004CDA38

procedure TPlayObject.CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);
var
  Envir                                                : TEnvirnoment;
  nX, nY                                               : Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sMapName = '') or (sX = '') or (sY = '') or ((sMapName <> '') and (sMapName[1] =
      '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandPositionMoveHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then
    begin
      Envir := g_MapManager.FindMap(sMapName);
      if Envir <> nil then
      begin
        nX := Str_ToInt(sX, 0);
        nY := Str_ToInt(sY, 0);
        if Envir.CanWalk(nX, nY, True) then
        begin
          SpaceMove(sMapName, nX, nY, 0);
        end
        else
        begin
          SysMsg(format(g_sGameCommandPositionMoveCanotMoveToMap, [sMapName, sX, sY]),
            c_Green, t_Hint);
        end;
      end;
    end
    else
    begin
      SysMsg(format(g_sTheMapDisableMove, [sMapName, Envir.sMapDesc]), c_Red, t_Hint);
    end;
  except
    on e: Exception do
    begin
      MainOutMessage('[Exceptioin] TPlayObject.CmdPositionMove');
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

procedure TPlayObject.CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
var
  SrcEnvir, DenEnvir                                   : TEnvirnoment;
  HumanList                                            : TList;
  I                                                    : Integer;
  MoveHuman                                            : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sDenMap = '') or (sSrcMap = '') or ((sSrcMap <> '') and (sSrcMap[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMapMoveHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  SrcEnvir := g_MapManager.FindMap(sSrcMap);
  DenEnvir := g_MapManager.FindMap(sDenMap);
  if (SrcEnvir = nil) then
  begin
    SysMsg(format(g_sGameCommandMapMoveMapNotFound, [sSrcMap]), c_Red, t_Hint);
    exit;
  end;
  if (DenEnvir = nil) then
  begin
    SysMsg(format(g_sGameCommandMapMoveMapNotFound, [sDenMap]), c_Red, t_Hint);
    exit;
  end;

  HumanList := TList.Create;
  UserEngine.GetMapRageHuman(SrcEnvir, SrcEnvir.m_nWidth div 2, SrcEnvir.m_nHeight div 2,
    1000, HumanList);
  for I := 0 to HumanList.Count - 1 do
  begin
    MoveHuman := TPlayObject(HumanList.Items[I]);
    if MoveHuman <> Self then
      MoveHuman.MapRandomMove(sDenMap, 0);
  end;
  HumanList.Free;
end;

procedure TPlayObject.CmdMemberFunctionEx(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('打开会员功能窗口.', c_Red, t_Hint);
    exit;
  end;
  if g_FunctionNPC <> nil then
  begin
    g_FunctionNPC.GotoLable(Self, '@Member', False);
  end;
end;

procedure TPlayObject.CmdMemberFunctionEx1(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('打开会员功能窗口.', c_Red, t_Hint);
    exit;
  end;
  if g_FunctionNPC <> nil then
  begin
    g_FunctionNPC.GotoLable(Self, '@Member1', False);
  end;
end;

procedure TPlayObject.CmdMission(Cmd: pTGameCmd; sX, sY: string); //004CCA08
var
  nX, nY                                               : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sX = '') or (sY = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' X  Y', c_Red, t_Hint);
    exit;
  end;
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  g_boMission := True;
  g_sMissionMap := m_sMapName;
  g_nMissionX := nX;
  g_nMissionY := nY;
  SysMsg('怪物集中目标已设定为: ' + m_sMapName + '(' + IntToStr(g_nMissionX) + ':' +
    IntToStr(g_nMissionY) + ')', c_Green, t_Hint);
end;

procedure TPlayObject.CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel: Integer;
  snewname: string = '');                                     //004CC7F4
var
  I                                                    : Integer;
  nX, nY                                               : Integer;
  Monster                                              : TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMobHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  if nCount <= 0 then
    nCount := 1;
  if not (nLevel in [0..10]) then
    nLevel := 0;

  nCount := _MIN(64, nCount);
  GetFrontPosition(nX, nY);
  for I := 0 to nCount - 1 do
  begin
    Monster := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY, sMonName);
    if Monster <> nil then
    begin
      //  if monster.m_sCharName='元神' then begin
      //   UserEngine.CopyHumData(monster,self);
      //  end;
      if snewname <> '' then
        Monster.m_sNewName := snewname;
      Monster.m_btSlaveMakeLevel := nLevel;
      Monster.m_btSlaveExpLevel := nLevel;
      Monster.RecalcAbilitys;
      Monster.RefNameColor;

      //     monster.m_boMission:=false;            //hint
    end
    else
    begin
      SysMsg(g_sGameCommandMobMsg, c_Red, t_Hint);
      break;
    end;
  end;
end;

procedure TPlayObject.CmdMobCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir                                                : TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandMobCountHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  if (sMapName[1] = '*') then
  begin
    SysMsg(format(g_sGameCommandMobCountMonsterCount, [UserEngine.GetAllMonstercount]),
      c_Green, t_Hint);
    exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then
  begin
    SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
    exit;
  end;

  SysMsg(format(g_sGameCommandMobCountMonsterCount, [UserEngine.GetMapMonster(Envir,
    nil)]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdHumanCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir                                                : TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandHumanCountHelpMsg]), c_Red, t_Hint);
    exit;
  end;
  Envir := g_MapManager.FindMap(sMapName);
  if Envir = nil then
  begin
    SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandMobCountMonsterCount, [UserEngine.GetMapHuman(sMapName)]),
    c_Green, t_Hint);
end;

procedure TPlayObject.CmdMobFireBurn(Cmd: pTGameCmd; sMap, sX, sY, sType,
  sTime, sPoint: string);
var
  nX, nY, nType, nTime, nPoint                         : Integer;
  FireBurnEvent                                        : TFireBurnEvent;
  Envir                                                : TEnvirnoment;
  OldEnvir                                             : TEnvirnoment;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sMap = '') or ((sMap <> '') and (sMap[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMap, sX, sY, sType,
      sTime, sPoint]), c_Red, t_Hint);
    exit;
  end;

  nX := Str_ToInt(sX, -1);
  nY := Str_ToInt(sY, -1);
  nType := Str_ToInt(sType, -1);
  nTime := Str_ToInt(sTime, -1);
  nPoint := Str_ToInt(sPoint, -1);
  if nPoint < 0 then
    nPoint := 1;

  if (sMap = '') or (nX < 0) or (nY < 0) or (nType < 0) or (nTime < 0) or (nPoint < 0)
    then
  begin
    SysMsg(format(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMap, sX, sY, sType,
      sTime, sPoint]), c_Red, t_Hint);
    exit;
  end;
  Envir := g_MapManager.FindMap(sMap);
  if Envir <> nil then
  begin
    OldEnvir := m_PEnvir;
    m_PEnvir := Envir;
    FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime * 1000, nPoint);
    g_EventManager.AddEvent(FireBurnEvent);
    m_PEnvir := OldEnvir;
    exit;
  end;
  SysMsg(format(g_sGameCommandMobFireBurnMapNotFountMsg, [Cmd.sCmd, sMap]), c_Red,
    t_Hint);
end;

procedure TPlayObject.CmdMobLevel(Cmd: pTGameCmd; Param: string); //004CFD5C
var
  I                                                    : Integer;
  BaseObjectList                                       : TList;
  BaseObject                                           : TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((Param <> '') and (Param[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    exit;
  end;

  BaseObjectList := TList.Create;
  m_PEnvir.GetRangeBaseObject(m_nCurrX, m_nCurrY, 2, True, BaseObjectList);
  for I := 0 to BaseObjectList.Count - 1 do
  begin
    BaseObject := TBaseObject(BaseObjectList.Items[i]);
    if BaseObject = nil then
      continue;
    SysMsg(BaseObject.GeTBaseObjectInfo(), c_Green, t_Hint);
  end;
  BaseObjectList.Free;
end;

procedure TPlayObject.CmdMobNpc(sCmd: string; nPermission: Integer; sParam1, sParam2,
  sParam3, sParam4: string);
var
  nAppr                                                : Integer;
  boIsCastle                                           : Boolean;
  Merchant                                             : TMerchant;
  nX, nY                                               : Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sParam1 = '') or (sParam2 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandMobNpcHelpMsg]), c_Red,
      t_Hint);
    exit;
  end;

  nAppr := Str_ToInt(sParam3, 0);
  boIsCastle := (Str_ToInt(sParam4, 0) = 1);
  if sParam1 = '' then
  begin
    SysMsg('命令格式: @' + sCmd + ' NPC名称 脚本文件名 外形(数字) 属沙城(0,1)', c_Red,
      t_Hint);
    exit;
  end;
  Merchant := TMerchant.Create;
  Merchant.m_sCharName := sParam1;
  Merchant.m_sMapName := m_sMapName;
  Merchant.m_PEnvir := m_PEnvir;
  Merchant.m_wAppr := nAppr;
  Merchant.m_nFlag := 0;
  Merchant.m_boCastle := boIsCastle;
  Merchant.m_sScript := sParam2;
  GetFrontPosition(nX, nY);
  Merchant.m_nCurrX := nX;
  Merchant.m_nCurrY := nY;
  Merchant.Initialize();
  UserEngine.AddMerchant(Merchant);
end;

procedure TPlayObject.CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount: string);  //004CCBB4
var
  I                                                    : Integer;
  nCount, nX, nY                                       : Integer;
  MEnvir                                               : TEnvirnoment;
  Mon                                                  : TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  nCount := _MIN(500, Str_ToInt(sCount, 0));
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  MEnvir := g_MapManager.FindMap(g_sMissionMap);
  if (nX <= 0) or (nY <= 0) or (sMonName = '') or (nCount <= 0) then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' X  Y 怪物名称 怪物数量', c_Red, t_Hint);
    exit;
  end;
  if not g_boMission or (MEnvir = nil) then
  begin
    SysMsg('还没有设定怪物集中点！！！', c_Red, t_Hint);
    SysMsg('请先用命令' + g_GameCommand.MISSION.sCmd + '设置怪物的集中点。', c_Red,
      t_Hint);
    exit;
  end;

  for I := 0 to nCount - 1 do
  begin
    Mon := UserEngine.RegenMonsterByName(g_sMissionMap, nX, nY, sMonName);
    if Mon <> nil then
    begin
      Mon.m_boMission := True;
      Mon.m_nMissionX := g_nMissionX;
      Mon.m_nMissionY := g_nMissionY;
    end
    else
      break;
  end;
  SysMsg(IntToStr(nCount) + ' 只 ' + sMonName + ' 已正在往地图 ' + g_sMissionMap + ' ' +
    IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + ' 集中。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdNpcScript(sCmd: string; nPermission: Integer; sParam1, sParam2,
  sParam3: string);
var
  BaseObject                                           : TBaseObject;
  nNPCType                                             : Integer;
  I                                                    : Integer;
  sScriptFileName                                      : string;
  Merchant                                             : TMerchant;
  NormNpc                                              : TNormNpc;
  LoadList                                             : TStringList;
  sScriptLine                                          : string;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandNpcScriptHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  nNPCType := -1;
  BaseObject := GetPoseCreate();
  if BaseObject <> nil then
  begin
    for I := 0 to UserEngine.m_MerchantList.Count - 1 do
    begin
      if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then
      begin
        nNPCType := 0;
        break;
      end;
    end;
    for I := 0 to UserEngine.QuestNPCList.Count - 1 do
    begin
      if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then
      begin
        nNPCType := 1;
        break;
      end;
    end;
  end;
  if nNPCType < 0 then
  begin
    SysMsg('命令使用方法不正确，必须与NPC面对面，才能使用此命令！！！', c_Red, t_Hint);
    exit;
  end;

  if sParam1 = '' then
  begin
    if nNPCType = 0 then
    begin
      Merchant := TMerchant(BaseObject);
      sScriptFileName := g_Config.sEnvirDir + sMarket_Def + Merchant.m_sScript + '-' +
        Merchant.m_sMapName + '.txt';
    end;
    if nNPCType = 1 then
    begin
      NormNpc := TNormNpc(BaseObject);
      sScriptFileName := g_Config.sEnvirDir + sNpc_def + NormNpc.m_sCharName + '-' +
        NormNpc.m_sMapName + '.txt';
    end;
    if FileExists(sScriptFileName) then
    begin
      LoadList := TStringList.Create;
      try
        LoadList.LoadFromFile(sScriptFileName);
      except
        SysMsg('读取脚本文件错误: ' + sScriptFileName, c_Red, t_Hint);
      end;
      for I := 0 to LoadList.Count - 1 do
      begin
        sScriptLine := Trim(LoadList.Strings[I]);
        sScriptLine := ReplaceChar(sScriptLine, ' ', ',');
        SysMsg(IntToStr(I) + ',' + sScriptLine, c_Blue, t_Hint);
      end;
      LoadList.Free;
    end;
  end;
end;

procedure TPlayObject.CmdOPDeleteSkill(sHumanName, sSkillName: string); //004CE938
begin
  if (m_btPermission < 6) then
    exit;
end;

procedure TPlayObject.CmdOPTraining(sHumanName, sSkillName: string;
  nLevel: Integer);                                         //004CC468
begin
  if (m_btPermission < 6) then
    exit;
end;

procedure TPlayObject.CmdPKpoint(Cmd: pTGameCmd; sHumanName: string); //004CC61C
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandPKPointHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  SysMsg(format(g_sGameCommandPKPointMsg, [sHumanName, PlayObject.m_nPkPoint]), c_Green,
    t_Hint);
end;

procedure TPlayObject.CmdPrvMsg(sCmd: string; nPermission: Integer;
  sHumanName: string);
var
  I                                                    : Integer;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandPrvMsgHelpMsg]), c_Red,
      t_Hint);
    exit;
  end;
  for I := 0 to m_BlockWhisperList.Count - 1 do
  begin
    if CompareText(m_BlockWhisperList.Strings[I], sHumanName) = 0 then
    begin
      m_BlockWhisperList.Delete(I);
      SysMsg(format(g_sGameCommandPrvMsgUnLimitMsg, [sHumanName]), c_Green, t_Hint);
      exit;
    end;
  end;
  m_BlockWhisperList.Add(sHumanName);
  SysMsg(format(g_sGameCommandPrvMsgLimitMsg, [sHumanName]), c_Green, t_Hint);

end;

procedure TPlayObject.CmdReAlive(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandReAliveHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  PlayObject.ReAlive;
  PlayObject.m_WAbil.HP := PlayObject.m_WAbil.MaxHP;
  PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');

  SysMsg(format(g_sGameCommandReAliveMsg, [sHumanName]), c_Green, t_Hint);
  SysMsg(sHumanName + ' 已获重生。', c_Green, t_Hint);
end;

procedure TPlayObject.CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string); //004CE250
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  RecallHuman(sHumanName);
end;

procedure TPlayObject.CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel,
  nAutoChangeColor, nFixColor: Integer);                      //004CC8C4
var
  I                                                    : Integer;
  n10, n14                                             : Integer;
  Mon                                                  : TBaseObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandRecallMobHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  if nLevel >= 10 then
    nLevel := 0;
  if nCount <= 0 then
    nCount := 1;
  for I := 0 to nCount - 1 do
  begin
    if m_SlaveList.Count >= 20 then
      break;
    GetFrontPosition(n10, n14);
    Mon := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, n10, n14, sMonName);
    if Mon <> nil then
    begin
      Mon.m_Master := Self;
      Mon.m_dwMasterRoyaltyTick := GetTickCount + 24 * 60 * 60 * 1000;
      Mon.m_btSlaveMakeLevel := 3;
      Mon.m_btSlaveExpLevel := nLevel;
      if nAutoChangeColor = 1 then
      begin
        Mon.m_boAutoChangeColor := True;
      end
      else
        if nFixColor > 0 then
        begin
          Mon.m_boFixColor := True;
          Mon.m_nFixColorIdx := nFixColor - 1;
        end;

      Mon.RecalcAbilitys();
      Mon.RefNameColor();
      m_SlaveList.Add(Mon);
    end;
  end;
end;

procedure TPlayObject.CmdReconnection(sCmd, sIPaddr, sPort: string);
//004CE380
begin
  if (m_btPermission < 6) then
    exit;
  if (sIPaddr <> '') and (sIPaddr[1] = '?') then
  begin
    SysMsg('此命令用于改变客户端连接网关的IP及端口。', c_Blue, t_Hint);
    exit;
  end;

  if (sIPaddr = '') or (sPort = '') then
  begin
    SysMsg('命令格式: @' + sCmd + ' IP地址 端口', c_Red, t_Hint);
    exit;
  end;
  if (sIPaddr <> '') and (sPort <> '') then
  begin
    SendMsg(Self, RM_RECONNECTION, 0, 0, 0, 0, sIPaddr + '/' + sPort);
  end;
end;

procedure TPlayObject.CmdRefineWeapon(Cmd: pTGameCmd; nDC, nMC, nSC, nHit: Integer);  //004CD1C4
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (nDC + nMC + nSC) > 10 then
    exit;
  if m_UseItems[U_WEAPON].wIndex <= 0 then
    exit;
  m_UseItems[U_WEAPON].btValue[0] := nDC;
  m_UseItems[U_WEAPON].btValue[1] := nMC;
  m_UseItems[U_WEAPON].btValue[2] := nSC;
  m_UseItems[U_WEAPON].btValue[5] := nHit;
  SendUpdateItem(@m_UseItems[U_WEAPON]);
  RecalcAbilitys();
  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  MainOutMessage('[武器调整]' + m_sCharName + ' DC:' + IntToStr(nDC) + ' MC' +
    IntToStr(nMC) + ' SC' + IntToStr(nSC) + ' HIT:' + IntToStr(nHit));
end;

procedure TPlayObject.CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandReGotoHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  SpaceMove(PlayObject.m_PEnvir.sMapName, PlayObject.m_nCurrX, PlayObject.m_nCurrY, 0);

end;

procedure TPlayObject.CmdReloadAbuse(sCmd: string; nPerMission: Integer;
  sParam1: string);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    exit;
  end;
end;

procedure TPlayObject.CmdReLoadAdmin(sCmd: string);
begin
  if (m_btPermission < 6) then
    exit;
  FrmDB.LoadAdminList();
  UserEngine.SendServerGroupMsg(213, nServerIndex, '');
  SysMsg('管理员列表重新加载成功...', c_Green, t_Hint);
end;

procedure TPlayObject.CmdReloadGuild(sCmd: string; nPerMission: Integer;
  sParam1: string);
var
  Guild                                                : TGuild;
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, g_sGameCommandReloadGuildHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;
  if nServerIndex <> 0 then
  begin
    SysMsg(g_sGameCommandReloadGuildOnMasterserver, c_Red, t_Hint);
    exit;
  end;

  Guild := g_GuildManager.FindGuild(sParam1);
  if Guild = nil then
  begin
    SysMsg(format(g_sGameCommandReloadGuildNotFoundGuildMsg, [sParam1]), c_Red, t_Hint);
    exit;
  end;
  Guild.LoadGuild();
  SysMsg(format(g_sGameCommandReloadGuildSuccessMsg, [sParam1]), c_Red, t_Hint);
  UserEngine.SendServerGroupMsg(SS_207, nServerIndex, sParam1);
end;

procedure TPlayObject.CmdReloadGuildAll;                    //004CE530
begin
  if (m_btPermission < 6) then
    exit;
end;

procedure TPlayObject.CmdReloadLineNotice(sCmd: string;
  nPerMission: Integer; sParam1: string);
begin
  if (m_btPermission < nPermission) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
    exit;
  end;
  if LoadLineBanner(g_Config.sNoticeDir + 'BannerNotice.TXT') then
  begin
    SysMsg('重新加载广告设置信息完成。', c_Green, t_Hint);
  end
  else
  begin
    SysMsg('重新加载广告设置信息失败。', c_Green, t_Hint);
  end;

  if LoadLineNotice(g_Config.sNoticeDir + 'LineNotice.txt') then
  begin
    SysMsg(g_sGameCommandReloadLineNoticeSuccessMsg, c_Green, t_Hint);
  end
  else
  begin
    SysMsg(g_sGameCommandReloadLineNoticeFailMsg, c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadManage(Cmd: pTGameCmd; sParam: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam <> '') and (sParam[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    exit;
  end;
  if sParam = '' then
  begin
    if g_ManageNPC <> nil then
    begin
      g_ManageNPC.ClearScript();
      g_ManageNPC.LoadNPCScript();
      SysMsg('重新加载登录脚本完成...', c_Green, t_Hint);
    end
    else
    begin
      SysMsg('重新加载登录脚本失败...', c_Green, t_Hint);
    end;
  end
  else
  begin
    if g_FunctionNPC <> nil then
    begin
      g_FunctionNPC.ClearScript();
      g_FunctionNPC.LoadNPCScript();
      g_SHOPNPC.ClearScript();
      g_SHOPNPC.LoadNPCScript();
      SysMsg('重新加载功能脚本和商城脚本完成...', c_Green, t_Hint);
    end
    else
    begin
      SysMsg('重新加载功能脚本失败...', c_Green, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdReloadRobot;
begin
  RobotManage.ReLoadRobot();
  SysMsg('重新加载机器人配置完成...', c_Green, t_Hint);
end;

procedure TPlayObject.CmdReloadRobotManage;
begin
  if (m_btPermission < 6) then
    exit;
  if g_RobotNPC <> nil then
  begin
    g_RobotNPC.ClearScript();
    g_RobotNPC.LoadNPCScript();
    SysMsg('重新加载机器人专用脚本完成...', c_Green, t_Hint);
  end
  else
  begin
    SysMsg('重新加载机器人专用脚本失败...', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadMonItems;                    //
var
  I                                                    : Integer;
  Monster                                              : pTMonInfo;
begin
  if (m_btPermission < 6) then
    exit;
  try
    for I := 0 to UserEngine.MonsterList.Count - 1 do
    begin
      Monster := UserEngine.MonsterList.Items[I];
      FrmDB.LoadMonitems(Monster.sName, Monster.ItemList);
    end;
    SysMsg('怪物爆物品列表重加载完成...', c_Green, t_Hint);
  except
    SysMsg('怪物爆物品列表重加载失败！！！', c_Green, t_Hint);
  end;
end;

procedure TPlayObject.CmdReloadNpc(sParam: string);         //004CFFF8
var
  I                                                    : Integer;
  TmpList                                              : TList;
  Merchant                                             : TMerchant;
  Npc                                                  : TNormNpc;
begin
  if (m_btPermission < 6) then
    exit;
  if CompareText('all', sParam) = 0 then
  begin
    FrmDB.ReLoadMerchants();
    UserEngine.ReloadMerchantList();
    SysMsg('交易NPC重新加载完成！！！', c_Red, t_Hint);
    UserEngine.ReloadNpcList();
    SysMsg('管理NPC重新加载完成！！！', c_Red, t_Hint);
    exit;
  end;                                                      //004D0136
  TmpList := TList.Create;
  if UserEngine.GetMerchantList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0 then
  begin
    for I := 0 to TmpList.Count - 1 do
    begin
      Merchant := TMerchant(TmpList.Items[i]);
      Merchant.ClearScript;
      Merchant.LoadNPCScript;
      SysMsg(Merchant.m_sCharName + '重新加载成功...', c_Green, t_Hint);
    end;                                                    // for
  end
  else
  begin
    SysMsg('附近未发现任何交易NPC！！！', c_Red, t_Hint);
  end;
  TmpList.Clear;
  if UserEngine.GetNpcList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0 then
  begin
    for I := 0 to TmpList.Count - 1 do
    begin
      Npc := TNormNpc(TmpList.Items[i]);
      Npc.ClearScript;
      Npc.LoadNPCScript;
      SysMsg(Npc.m_sCharName + '重新加载成功...', c_Green, t_Hint);
    end;                                                    // for
  end
  else
  begin
    SysMsg('附近未发现任何管理NPC！！！', c_Red, t_Hint);
  end;
  TmpList.Free;
end;

procedure TPlayObject.CmdSearchHuman(sCmd, sHumanName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if m_boProbeNecklace or (m_btPermission >= 6) then
  begin
    if (sHumanName = '') then
    begin
      SysMsg('命令格式: @' + sCmd + ' 人物名称', c_Red, t_Hint);
      exit;
    end;
    if ((GetTickCount - m_dwProbeTick) > 10000) or (m_btPermission >= 3) then
    begin
      m_dwProbeTick := GetTickCount();
      PlayObject := UserEngine.GeTPlayObject(sHumanName);
      if PlayObject <> nil then
      begin
        SysMsg(sHumanName + ' 现在位于 ' + PlayObject.m_PEnvir.sMapDesc + ' ' +
          IntToStr(PlayObject.m_nCurrX) + ':' + IntToStr(PlayObject.m_nCurrY), c_Blue,
          t_Hint);
      end
      else
      begin
        SysMsg(sHumanName + ' 现在不在线，或位于其它服务器上！！！', c_Red, t_Hint);
      end;
    end
    else
    begin
      SysMsg(IntToStr((GetTickCount - m_dwProbeTick) div 1000 - 10) +
        ' 秒之后才可以再使用此功能！！！', c_Red, t_Hint);
    end;
  end
  else
  begin
    SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdShowSbkGold(Cmd: pTGameCmd; sCastleName, sCtr, sGold: string);
var
  I                                                    : Integer;
  Ctr                                                  : Char;
  nGold                                                : Integer;
  Castle                                               : TUserCastle;
  List                                                 : TStringList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sCastleName <> '') and (sCastleName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    exit;
  end;
  if sCastleName = '' then
  begin
    List := TStringList.Create;
    g_CastleManager.GetCastleGoldInfo(List);
    for I := 0 to List.Count - 1 do
    begin
      SysMsg(List.Strings[I], c_Green, t_Hint);
    end;
    List.Free;
    exit;
  end;
  Castle := g_CastleManager.Find(sCastleName);
  if Castle = nil then
  begin
    SysMsg(format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCastleName]), c_Red, t_Hint);
    exit;
  end;

  Ctr := sCtr[1];
  nGold := Str_ToInt(sGold, -1);
  if not (Ctr in ['=', '-', '+']) or (nGold < 0) or (nGold > 100000000) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandSbkGoldHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  case Ctr of
    '=': Castle.m_nTotalGold := nGold;
    '-': Dec(Castle.m_nTotalGold);
    '+': Inc(Castle.m_nTotalGold, nGold);
  end;
  if Castle.m_nTotalGold < 0 then
    Castle.m_nTotalGold := 0;

end;

procedure TPlayObject.CmdShowUseItemInfo(Cmd: pTGameCmd;
  sHumanName: string);
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
  UserItem                                             : pTUserItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandShowUseItemInfoHelpMsg]), c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  for I := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do
  begin
    UserItem := @PlayObject.m_UseItems[I];
    if UserItem.wIndex = 0 then
      Continue;
    SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]',
      [GetUseItemName(I),
      UserEngine.GetStdItemName(UserItem.wIndex),
        UserItem.wIndex,
        UserItem.MakeIndex,
        UserItem.Dura,
        UserItem.DuraMax]),
        c_Blue, t_Hint);
  end;
end;

procedure TPlayObject.CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem,
  sType: string);
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
  UserItem                                             : pTUserItem;
  nItem, nBind                                         : Integer;
  ItemBind                                             : pTItemBind;
  nItemIdx, nMakeIdex                                  : Integer;
  sBindName                                            : string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  nBind := -1;
  nItem := GetUseItemIdx(sItem);
  if CompareText(sType, '帐号') = 0 then
    nBind := 0;
  if CompareText(sType, '人物') = 0 then
    nBind := 1;
  if CompareText(sType, 'IP') = 0 then
    nBind := 2;

  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and
    (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  UserItem := @PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then
  begin
    SysMsg(format(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]), c_Red,
      t_Hint);
    exit;
  end;
  nItemIdx := UserItem.wIndex;
  nMakeIdex := UserItem.MakeIndex;
  case nBind of                                             //
    0:
      begin
        sBindName := PlayObject.m_sUserID;
        g_ItemBindAccount.Lock;
        try
          for I := 0 to g_ItemBindAccount.Count - 1 do
          begin
            ItemBind := g_ItemBindAccount.Items[I];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then
            begin
              SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]),
                c_Red, t_Hint);
              exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindAccount.Insert(0, ItemBind);
        finally
          g_ItemBindAccount.UnLock;
        end;
        SaveItemBindAccount();
        SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    1:
      begin
        sBindName := PlayObject.m_sCharName;
        g_ItemBindCharName.Lock;
        try
          for I := 0 to g_ItemBindCharName.Count - 1 do
          begin
            ItemBind := g_ItemBindCharName.Items[I];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then
            begin
              SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]),
                c_Red, t_Hint);
              exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindCharName.Insert(0, ItemBind);
        finally
          g_ItemBindCharName.UnLock;
        end;
        SaveItemBindCharName();
        SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    2:
      begin
        sBindName := PlayObject.m_sIPaddr;
        g_ItemBindIPaddr.Lock;
        try
          for I := 0 to g_ItemBindIPaddr.Count - 1 do
          begin
            ItemBind := g_ItemBindIPaddr.Items[I];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then
            begin
              SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]),
                c_Red, t_Hint);
              exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindIPaddr.Insert(0, ItemBind);
        finally
          g_ItemBindIPaddr.UnLock;
        end;
        SaveItemBindIPaddr();
        SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
  end;
end;

procedure TPlayObject.CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem,
  sType: string);
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
  UserItem                                             : pTUserItem;
  nItem, nBind                                         : Integer;
  ItemBind                                             : pTItemBind;
  nItemIdx, nMakeIdex                                  : Integer;
  sBindName                                            : string;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  nBind := -1;
  nItem := GetUseItemIdx(sItem);
  if CompareText(sType, '帐号') = 0 then
    nBind := 0;
  if CompareText(sType, '人物') = 0 then
    nBind := 1;
  if CompareText(sType, 'IP') = 0 then
    nBind := 2;

  if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '') and
    (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject = nil then
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
    exit;
  end;
  UserItem := @PlayObject.m_UseItems[nItem];
  if UserItem.wIndex = 0 then
  begin
    SysMsg(format(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]), c_Red,
      t_Hint);
    exit;
  end;
  nItemIdx := UserItem.wIndex;
  nMakeIdex := UserItem.MakeIndex;
  case nBind of                                             //
    0:
      begin
        sBindName := PlayObject.m_sUserID;
        g_ItemBindAccount.Lock;
        try
          for I := 0 to g_ItemBindAccount.Count - 1 do
          begin
            ItemBind := g_ItemBindAccount.Items[I];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then
            begin
              SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]),
                c_Red, t_Hint);
              exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindAccount.Insert(0, ItemBind);
        finally
          g_ItemBindAccount.UnLock;
        end;
        SaveItemBindAccount();
        SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    1:
      begin
        sBindName := PlayObject.m_sCharName;
        g_ItemBindCharName.Lock;
        try
          for I := 0 to g_ItemBindCharName.Count - 1 do
          begin
            ItemBind := g_ItemBindCharName.Items[I];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then
            begin
              SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]),
                c_Red, t_Hint);
              exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindCharName.Insert(0, ItemBind);
        finally
          g_ItemBindCharName.UnLock;
        end;
        SaveItemBindCharName();
        SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
    2:
      begin
        sBindName := PlayObject.m_sIPaddr;
        g_ItemBindIPaddr.Lock;
        try
          for I := 0 to g_ItemBindIPaddr.Count - 1 do
          begin
            ItemBind := g_ItemBindIPaddr.Items[I];
            if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex = nMakeIdex) then
            begin
              SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg, [sHumanName, sItem]),
                c_Red, t_Hint);
              exit;
            end;
          end;
          New(ItemBind);
          ItemBind.nItemIdx := nItemIdx;
          ItemBind.nMakeIdex := nMakeIdex;
          ItemBind.sBindName := sBindName;
          g_ItemBindIPaddr.Insert(0, ItemBind);
        finally
          g_ItemBindIPaddr.UnLock;
        end;
        SaveItemBindIPaddr();
        SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            UserItem.wIndex,
            UserItem.MakeIndex,
            UserItem.Dura,
            UserItem.DuraMax,
            sBindName]),
            c_Blue, t_Hint);
        PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
          [GetUseItemName(nItem),
          UserEngine.GetStdItemName(UserItem.wIndex),
            sType,
            sBindName
            ]), c_Blue, t_Hint);
      end;
  end;
end;

procedure TPlayObject.CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
var
  dwTime                                               : LongWord;
  nIndex                                               : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sTime = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?'))
    then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandShutupHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  dwTime := Str_ToInt(sTime, 5);
  g_DenySayMsgList.Lock;
  try
    nIndex := g_DenySayMsgList.GetIndex(sHumanName);
    if nIndex >= 0 then
    begin
      g_DenySayMsgList.Objects[nIndex] := TObject(GetTickCount + dwTime * 60 * 1000);
    end
    else
    begin
      g_DenySayMsgList.AddRecord(sHumanName, GetTickCount + dwTime * 60 * 1000);
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
  SysMsg(format(g_sGameCommandShutupHumanMsg, [sHumanName, dwTime]), c_Red, t_Hint);
end;

procedure TPlayObject.CmdShutupList(Cmd: pTGameCmd; sParam1: string);
var
  I                                                    : Integer;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if ((sParam1 <> '') and (sParam1[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
    exit;
  end;

  if (m_btPermission < 6) then
    exit;
  g_DenySayMsgList.Lock;
  try
    if g_DenySayMsgList.Count <= 0 then
    begin
      SysMsg(g_sGameCommandShutupListIsNullMsg, c_Green, t_Hint);
      exit;
    end;
    for I := 0 to g_DenySayMsgList.Count - 1 do
    begin
      SysMsg(g_DenySayMsgList.Strings[I] + ' ' +
        IntToStr((LongWord(g_DenySayMsgList.Objects[I]) - GetTickCount) div 60000),
        c_Green, t_Hint);
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
end;

procedure TPlayObject.CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string; boAll:
  Boolean);
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandShutupReleaseHelpMsg]), c_Red, t_Hint);
    exit;
  end;
  g_DenySayMsgList.Lock;
  try
    I := g_DenySayMsgList.GetIndex(sHumanName);
    if I >= 0 then
    begin
      g_DenySayMsgList.Delete(I);
      PlayObject := UserEngine.GeTPlayObject(sHumanName);
      if PlayObject <> nil then
      begin
        PlayObject.SysMsg(g_sGameCommandShutupReleaseCanSendMsg, c_Red, t_Hint);
      end;
      if boAll then
      begin
        UserEngine.SendServerGroupMsg(SS_210, nServerIndex, sHumanName);
      end;
      SysMsg(format(g_sGameCommandShutupReleaseHumanCanSendMsg, [sHumanName]), c_Green,
        t_Hint);
    end;
  finally
    g_DenySayMsgList.UnLock;
  end;
end;

procedure TPlayObject.CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);
var
  sShowMsg                                             : string;
  StdItem                                              : pTStdItem;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;

  if (nWhere in [0..12]) and (nValueType in [0..15]) and (nValue in [0..255]) then
  begin
    if m_UseItems[nWhere].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
      if StdItem = nil then
        exit;

      if nValueType > 13 then
      begin
        nValue := _MIN(65, nValue);
        if nValueType = 14 then
          m_UseItems[nWhere].Dura := nValue * 1000;
        if nValueType = 15 then
          m_UseItems[nWhere].DuraMax := nValue * 1000;
      end
      else
      begin
        m_UseItems[nWhere].btValue[nValueType] := nValue;
      end;
      RecalcAbilitys();
      SendUpdateItem(@m_UseItems[nWhere]);
      sShowMsg := IntToStr(m_UseItems[nWhere].wIndex) + '-' +
        IntToStr(m_UseItems[nWhere].MakeIndex) + ' ' +
        IntToStr(m_UseItems[nWhere].Dura) + '/' + IntToStr(m_UseItems[nWhere].DuraMax) +
          ' ' +
        IntToStr(m_UseItems[nWhere].btValue[0]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[1]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[2]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[3]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[4]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[5]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[6]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[7]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[8]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[9]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[10]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[11]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[12]) + '/' +
        IntToStr(m_UseItems[nWhere].btValue[13]);
      SysMsg(sShowMsg, c_Blue, t_Hint);
      if g_Config.boShowMakeItemMsg then
        MainOutMessage('[物品调整] ' + m_sCharName + '(' + StdItem.Name + ' -> ' +
          sShowMsg + ')');
    end
    else
    begin
      SysMsg(g_sGamecommandSuperMakeHelpMsg, c_Red, t_Hint);
    end;
  end;
end;

procedure TPlayObject.CmdSpirtStart(sCmd, sParam1: string);
var
  nTime                                                : Integer;
  dwTime                                               : LongWord;
begin
  if (m_btPermission < 6) then
    exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then
  begin
    SysMsg('此命令用于开始祈祷生效宝宝叛变。', c_Red, t_Hint);
    exit;
  end;
  nTime := Str_ToInt(sParam1, -1);
  if nTime > 0 then
  begin
    dwTime := LongWord(nTime) * 1000;
  end
  else
  begin
    dwTime := g_Config.dwSpiritMutinyTime;
  end;

  g_dwSpiritMutinyTick := GetTickCount + dwTime;
  SysMsg('祈祷叛变已开始。持续时长 ' + IntToStr(dwTime div 1000) + ' 秒。', c_Green,
    t_Hint);
end;

procedure TPlayObject.CmdSpirtStop(sCmd, sParam1: string);
begin
  if (m_btPermission < 6) then
    exit;
  if (sParam1 <> '') and (sParam1[1] = '?') then
  begin
    SysMsg('此命令用于停止祈祷生效导致宝宝叛变。', c_Red, t_Hint);
    exit;
  end;
  g_dwSpiritMutinyTick := 0;
  SysMsg('祈祷叛变已停止。', c_Green, t_Hint);

end;

procedure TPlayObject.CmdStartQuest(Cmd: pTGameCmd; sQuestName: string);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sQuestName = '') then
  begin
    SysMsg('命令格式: @' + Cmd.sCmd + ' 问答名称', c_Red, t_Hint);
    exit;
  end;
  UserEngine.SendQuestMsg(sQuestName);
end;

procedure TPlayObject.CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
  MoveHuman                                            : TPlayObject;
  nRange                                               : Integer;
  HumanList                                            : TList;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sRange = '') or (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?'))
    then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandSuperTingHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  nRange := _MAX(10, Str_ToInt(sRange, 2));
  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    HumanList := TList.Create;
    UserEngine.GetMapRageHuman(PlayObject.m_PEnvir, PlayObject.m_nCurrX,
      PlayObject.m_nCurrY, nRange, HumanList);
    for I := 0 to HumanList.Count - 1 do
    begin
      MoveHuman := TPlayObject(HumanList.Items[I]);
      if MoveHuman <> Self then
        MoveHuman.MapRandomMove(MoveHuman.m_sHomeMap, 0);
    end;
    HumanList.Free;
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;

end;

procedure TPlayObject.CmdTakeOffHorse(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('下马命令，在骑马状态输入此命令下马。', c_Red, t_Hint);
    SysMsg(format('命令格式: @%s', [sCmd]), c_Red, t_Hint);
    exit;
  end;
  if not m_boOnHorse then
    exit;

  m_boOnHorse := False;
  m_boOnBaozi := False;
  FeatureChanged();
end;

procedure TPlayObject.CmdTakeOnHorse(sCmd, sParam: string);
begin
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg('上马命令，在戴好马牌后输入此命令就可以骑上马。', c_Red, t_Hint);
    SysMsg(format('命令格式: @%s', [sCmd]), c_Red, t_Hint);
    exit;
  end;
  if m_boOnHorse then
    exit;

  if (m_btHorseType = 0) then
  begin
    SysMsg('骑马必须先戴上马牌！！！', c_Red, t_Hint);
    exit;
  end;
  m_boOnHorse := True;
  FeatureChanged();
end;

procedure TPlayObject.CmdTestanying(sCmd: string; nRange, nType, nTime, nPoint: Integer);
var
  nX, nY                                               : Integer;
  anyingEvent                                          : TanyingEvent;
  nMinX, nMaxX, nMinY, nMaxY                           : Integer;
begin
  nMinX := m_nCurrX - nRange;
  nMaxX := m_nCurrX + nRange;
  nMinY := m_nCurrY - nRange;
  nMaxY := m_nCurrY + nRange;
  for nX := nMinX to nMaxX do
  begin
    for nY := nMinY to nMaxY do
    begin
      if ((nX < nMaxX) and (nY = nMinY)) or
        ((nY < nMaxY) and (nX = nMinX)) or
        (nX = nMaxX) or (nY = nMaxY) then
      begin
        anyingEvent := TanyingEvent.Create(self.m_PEnvir, nX, nY, nType, nTime * 1000,
          nPoint);                                            //self
        g_EventManager.AddEvent(anyingEvent);
      end;
    end;
  end;
end;

procedure TPlayObject.CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint: Integer);
var
  nX, nY                                               : Integer;
  FireBurnEvent                                        : TFireBurnEvent;
  nMinX, nMaxX, nMinY, nMaxY                           : Integer;
begin
  nRange := _min(nRange, 100);
  nMinX := m_nCurrX - nRange;
  nMaxX := m_nCurrX + nRange;
  nMinY := m_nCurrY - nRange;
  nMaxY := m_nCurrY + nRange;
  for nX := nMinX to nMaxX do
  begin
    for nY := nMinY to nMaxY do
    begin
      if ((nX < nMaxX) and (nY = nMinY)) or
        ((nY < nMaxY) and (nX = nMinX)) or
        (nX = nMaxX) or (nY = nMaxY) then
      begin
        FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime * 1000,
          nPoint);
        g_EventManager.AddEvent(FireBurnEvent);
      end;
    end;
  end;
end;

procedure TPlayObject.CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
var
  btDc, btSc, btMc, btDura                             : Byte;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sParam <> '') and (sParam[1] = '?') then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandTestGetBagItemsHelpMsg]), c_Red, t_Hint);
    exit;
  end;
  btDc := 0;
  btSc := 0;
  btMc := 0;
  btDura := 0;
  GetBagUseItems(btDc, btSc, btMc, btDura);
  SysMsg(format('DC:%d SC:%d MC:%d DURA:%d', [btDc, btSc, btMc, btDura]), c_Blue,
    t_Hint);
end;

procedure TPlayObject.CmdTestSpeedMode(Cmd: pTGameCmd);
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  m_boTestSpeedMode := not m_boTestSpeedMode;
  if m_boTestSpeedMode then
  begin
    SysMsg('开启速度测试模式', c_Red, t_Hint);
  end
  else
  begin
    SysMsg('关闭速度测试模式', c_Red, t_Hint);
  end;

end;

procedure TPlayObject.CmdTestStatus(sCmd: string; nType, nTime: Integer);
begin
  if (m_btPermission < 6) then
    exit;
  if (not (nType in [Low(TStatusTime)..High(TStatusTime)])) or (nTime < 0) then
  begin
    SysMsg('命令格式: @' + sCmd + ' 类型(0..11) 时长', c_Red, t_Hint);
    exit;
  end;
  m_wStatusTimeArr[nType] := nTime * 1000;
  m_dwStatusArrTick[nType] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  StatusChanged();
  SysMsg(format('状态编号:%d 时间长度: %d 秒', [nType, nTime]), c_Green, t_Hint);
end;

procedure TPlayObject.CmdTing(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, g_sGameCommandTingHelpMsg]),
      c_Red, t_Hint);
    exit;
  end;

  PlayObject := UserEngine.GeTPlayObject(sHumanName);
  if PlayObject <> nil then
  begin
    PlayObject.MapRandomMove(m_sHomeMap, 0);
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdTraining(sSkillName: string; nLevel: Integer); //004CC414
begin
  if (m_btPermission < 6) then
    exit;
end;

procedure TPlayObject.CmdUserMoveXY(sCMD, sX, sY: string);
var
  Envir                                                : TEnvirnoment;
  nX, nY                                               : Integer;
begin
  if m_boTeleport and (not (m_boOnSellItem)) then
  begin
    nX := Str_ToInt(sX, -1);
    nY := Str_ToInt(sY, -1);
    {
    if (nX < 0) or (nY < 0) then begin
      SysMsg('命令格式: @' + sCMD + ' 座标X 座标Y',c_Red,t_Hint);
      exit;
    end;
    }
    if not m_PEnvir.m_boNOPOSITIONMOVE then
    begin
      if m_PEnvir.CanWalkOfItem(nX, nY, g_Config.boUserMoveCanDupObj,
        g_Config.boUserMoveCanOnItem) then
      begin
        if (GetTickCount - m_dwTeleportTick) > g_Config.dwUserMoveTime * 1000 {10000}
          then
        begin
          m_dwTeleportTick := GetTickCount();
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          //BaseObjectMove('',sX,sY);
          SpaceMove(m_sMapName, nX, nY, 0);
        end
        else
        begin
          SysMsg(IntToStr(g_Config.dwUserMoveTime - (GetTickCount - m_dwTeleportTick) div
            1000) + '秒之后才可以再使用此功能！！！', c_Red, t_Hint);
        end;
      end
      else
      begin
        SysMsg(format(g_sGameCommandPositionMoveCanotMoveToMap, [m_sMapName, sX, sY]),
          c_Green, t_Hint);
      end;
    end
    else
    begin
      SysMsg('此地图禁止使用此命令！！！', c_Red, t_Hint);
    end;
  end
  else
  begin
    SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
  end;
end;

procedure TPlayObject.CmdViewDiary(sCMD: string; nFlag: Integer); //004D1B70
begin

end;

procedure TPlayObject.CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2: string);
var
  PlayObject                                           : TPlayObject;
begin
  if (m_btPermission < Cmd.nPermissionMin) then
  begin
    SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
    exit;
  end;
  if (sCharName = '') or ((sCharName <> '') and (sCharName[1] = '?')) then
  begin
    SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
      g_sGameCommandViewWhisperHelpMsg]), c_Red, t_Hint);
    exit;
  end;
  PlayObject := UserEngine.GeTPlayObject(sCharName);
  if PlayObject <> nil then
  begin
    if PlayObject.m_GetWhisperHuman = Self then
    begin
      PlayObject.m_GetWhisperHuman := nil;
      SysMsg(format(g_sGameCommandViewWhisperMsg1, [sCharName]), c_Green, t_Hint);
    end
    else
    begin
      PlayObject.m_GetWhisperHuman := Self;
      SysMsg(format(g_sGameCommandViewWhisperMsg2, [sCharName]), c_Green, t_Hint);
    end;
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sCharName]), c_Red, t_Hint);
  end;
end;

constructor TPlayObject.Create;                             //004C9860
var
  i                                                    : Integer;
begin
  inherited;
  for I := 0 to 99 do
    m_DySval[i] := '';
  DelayCallList := TList.Create;
  m_nItemUnitIndex := -1;
  m_btLingzhuMode := 0;
  m_nRecallEvilCount := 0;
  m_nZMValue := 0;
  FillChar(m_MagicPOwerList, 101, #0);
  m_sLastKillMon := '无';
  m_sLastKillMap := '';
  m_nTimerA := 0;
  m_nBuyItemnum := 1;
  m_nSendValue := 0;
  m_nSendstring := '';
  m_nsendtype := 0;
  m_nsendid := '';
  m_bocheckboxitem := 0;
  m_nboxid := '';
  m_nboxbacktype := 0;
  m_nflagforsell := false;
  m_nflagforsellcolor := 0;
  m_bohasmagicfont := false;
  m_wmagicfont := 0;
  m_wmagicfontcolor := 0;
  m_bomagiccolorchange := false;
  m_nmagiccolor := 0;
  m_bohasMONSTORAGE := false;
  m_PetBaseObject := nil;
  m_monStoragesize := 0;
  M_monstoragelevel := 0;
  M_monstoragehuoli := 0;
  M_monitemmake := 0;
  ///  for delay
  m_nnpcdelay := 0;
  m_dwnnpcdelaytick := 0;
  m_bonpcdelay := false;
  m_nnpc := 0;
  M_Snpcgots := '';
  ///
  m_bohashuanying := false;
  m_bohashuancai := false;

  m_boOnSellItem := false;                                  //正在摆摊中
  m_boHavebeArp := false;                                   //变身标志
  m_nApprNum := 0;
  fillchar(m_Onsellitemarr, sizeof(TClientItem) * 10, #0); //           :array[0..9]of TOClientItem; //摆摊的物品
  m_Sonsellname := '';                                      //摊位的名称
  m_nOnsellcount := 0;                                      //摆摊的物品数量

  m_sSytleName := '';
  m_dwLastModSytelNameTick := 0;

  ///  for 夺宝活动
  m_nArrowtime := 0;
  m_nArrowtick := GetTickCount();
  m_nArrowEattick := GetTickCount();
  m_boArrow := false;
  m_SArrownpcgoto := '';

  m_sofflinegoto := '';

  m_SarrowTimernpc := '';
  m_sArrowitem := '';

  m_dwchecksafearea := GetTickCount();
  m_dwcheckhumitem := GetTickCount();

  m_dwAddmpmodetick := GetTickCount();

  m_dwcheckdelaytick := GetTickCount();

  ////
  m_boAddHpmode := false;
  m_boAddYQMode := false;
  m_nAddYQ := 0;
  m_boAddmpmode := false;
  m_dwtuzhanMoveTick := GetTickCount();

  m_sfenghao := '';
  sYsname := '';
  nyssex := 0;
  sYsnameMaster := '';

  m_boCheckNewYs := false;
  bocanhcall := false;
  m_boStartshow := false;
  m_nYsCallcount := 0;
  m_dwYsCallTick := GetTickCount();
  Ysplayer := nil;
  ysmasterplayer := nil;

  ///  以上我的新加初始化
  m_btRaceServer := RC_PLAYOBJECT;
  m_boEmergencyClose := False;
  m_boSwitchData := False;
  m_boReconnection := False;
  m_boKickFlag := False;
  m_boSoftClose := False;
  m_boReadyRun := False;
  bo698 := False;
  n69C := 0;
  m_dwSaveRcdTick := GetTickCount();
  m_boWantRefMsg := True;
  m_boRcdSaved := False;
  m_boDeathRcdSaved := False;
  m_boDieInFight3Zone := False;
  m_Script := nil;
  m_boTimeRecall := False;
  m_sMoveMap := '';
  m_nMoveX := 0;
  m_nMoveY := 0;
  m_dwRunTick := GetTickCount();
  m_nRunTime := 250;
  m_dwSearchTime := 1000;
  m_dwSearchTick := GetTickCount();
  m_nViewRange := 12;
  m_boNewHuman := False;
  m_boLoginNoticeOK := False;
  bo6AB := False;
  m_boExpire := False;
  m_boSendNotice := False;
  m_dwCheckDupObjTick := GetTickCount();
  dwTick578 := GetTickCount();
  dwTick57C := GetTickCount();
  m_boInSafeArea := False;
  n5F8 := 0;
  n5FC := 0;
  m_dwMagicAttackTick := GetTickCount();
  m_dwMagicAttackInterval := 0;
  m_dwAttackTick := GetTickCount();
  m_dwMoveTick := GetTickCount();
  m_dwTurnTick := GetTickCount();
  m_dwActionTick := GetTickCount();
  m_dwAttackCount := 0;
  m_dwAttackCountA := 0;
  m_dwMagicAttackCount := 0;
  m_dwMoveCount := 0;
  m_dwMoveCountA := 0;
  m_nOverSpeedCount := 0;

  m_sOldSayMsg := '';
  m_dwSayMsgTick := GetTickCount();
  m_boDisableSayMsg := False;
  m_dwDisableSayMsgTick := GetTickCount();
  m_dLogonTime := Now();
  m_dwLogonTick := GetTickCount();
  n584 := 0;
  n588 := 0;
  m_boSwitchData := False;
  m_boSwitchDataSended := False;
  m_nWriteChgDataErrCount := 0;
  m_dwShowLineNoticeTick := GetTickCount();
  m_nShowLineNoticeIdx := 0;

  m_dwShowBannerNoticeTime := GetTickCount();
  //  m_dwHideBannerNoticeTime  :=GetTickCount();
  m_nShowBannerNoticeIdx := 0;
  m_boshowBanner := false;

  m_nSoftVersionDateEx := 0;
  m_CanJmpScriptLableList := TStringList.Create;
  m_CanJmpScriptLableListleft := TStringList.Create;
  m_nKillMonExpMultiple := 1;
  m_nKillMonExpRate := 100;
  m_dwRateTick := GetTickCount();
  m_nPowerRate := 100;

  m_boSetStoragePwd := False;
  m_boReConfigPwd := False;
  m_boCheckOldPwd := False;
  m_boUnLockPwd := False;
  m_boUnLockStoragePwd := False;
  m_boPasswordLocked := False;                              //锁仓库
  m_btPwdFailCount := 0;
  m_sTempPwd := '';
  m_sStoragePwd := '';
  ;
  m_boFilterSendMsg := False;

  m_boCanDeal := True;
  m_boCanDrop := True;
  m_boCanGetBackItem := True;
  m_boCanWalk := True;
  m_boCanRun := True;
  m_boCanHit := True;
  m_boCanSpell := True;
  m_boCanUseItem := True;
  m_nMemberType := 0;
  m_nMemberLevel := 0;

  m_nGameGold := 0;
  m_boDecGameGold := False;
  m_nDecGameGold := 1;
  m_dwDecGameGoldTick := GetTickCount();
  m_dwDecGameGoldTime := 60 * 1000;

  m_boIncGameGold := False;
  m_nIncGameGold := 1;
  m_dwIncGameGoldTick := GetTickCount();
  m_dwIncGameGoldTime := 60 * 1000;

  m_nGamePoint := 0;
  m_nJpPoint := 0;
  wGEMCOUNT[0] := 0;
  wGEMCOUNT[1] := 0;
  wGEMCOUNT[2] := 0;
  m_YSPoint := 0;
  M_YSfenghao := 0;
  wATTACHEPOINT := 0;
  m_dwIncGamePointTick := GetTickCount();

  m_nPayMentPoint := 0;

  m_DearHuman := nil;
  m_MasterHuman := nil;
  m_MasterList := TList.Create;
  m_FrientList := Tgstringlist.Create;
  m_boSendMsgFlag := False;
  m_boChangeItemNameFlag := False;

  m_boCanMasterRecall := False;
  m_boCanDearRecall := False;
  m_dwDearRecallTick := GetTickCount();
  m_dwMasterRecallTick := GetTickCount();
  m_btReColorIdx := 0;
  m_GetWhisperHuman := nil;
  m_boOnHorse := False;
  m_boUsexushou := False;
  m_boOnBaozi := False;
  m_wContribution := 0;
  m_sRankLevelName := g_sRankLevelName;
  m_boFixedHideMode := True;
  m_nStep := 0;
  FillChar(m_nMval, SizeOf(m_nMval), #0);
  m_nClientFlagMode := -1;
  m_dwAutoGetExpTick := GetTickCount;
  m_nAutoGetExpPoint := 0;
  m_AutoGetExpEnvir := nil;
  m_dwHitIntervalTime := g_Config.dwHitIntervalTime;        //攻击间隔
  m_dwMagicHitIntervalTime := g_Config.dwMagicHitIntervalTime; //魔法间隔
  m_dwRunIntervalTime := g_Config.dwRunIntervalTime;        //走路间隔
  m_dwWalkIntervalTime := g_Config.dwWalkIntervalTime;      //走路间隔
  m_dwTurnIntervalTime := g_Config.dwTurnIntervalTime;      //换方向间隔
  m_dwActionIntervalTime := g_Config.dwActionIntervalTime;  //组合操作间隔
  m_dwRunLongHitIntervalTime := g_Config.dwRunLongHitIntervalTime; //组合操作间隔
  m_dwRunHitIntervalTime := g_Config.dwRunHitIntervalTime;  //组合操作间隔
  m_dwWalkHitIntervalTime := g_Config.dwWalkHitIntervalTime; //组合操作间隔
  m_dwRunMagicIntervalTime := g_Config.dwRunMagicIntervalTime; //跑位魔法间隔
  m_DynamicVarList := TList.Create;
  m_SessInfo := nil;
  m_boTestSpeedMode := False;
  m_boLockLogon := True;
  m_boLockLogoned := False;
  //   m_bMaxBagitem           := 46 ;//默认包裹容量为 46

end;

procedure TPlayObject.DealCancel;                           //004DD394
begin
  if not m_boDealing then
    exit;
  m_boDealing := False;
  SendDefMessage(SM_DEALCANCEL, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then
  begin
    TPlayObject(m_DealCreat).DealCancel;
  end;
  m_DealCreat := nil;
  GetBackDealItems();
  SysMsg(g_sDealActionCancelMsg {'交易取消'}, c_Green, t_Hint);
  m_DealLastTick := GetTickCount();
end;

procedure TPlayObject.DealCancelA;
begin
  m_Abil.HP := m_WAbil.HP;
  DealCancel();
end;

function TPlayObject.DecGold(nGold: Integer): Boolean;      //004BF6A8
begin
  Result := False;
  if m_nGold >= nGold then
  begin
    Dec(m_nGold, nGold);
    Result := True;
  end;
end;

destructor TPlayObject.Destroy;                             //004C9B54
var
  I                                                    : Integer;
  pDelayCall                                           : pTDelayCall;
begin
  m_MasterList.Free;
  m_FrientList.Free;
  for I := 0 to DelayCallList.Count - 1 do
  begin
    pDelayCall := pTDelayCall(DelayCallList[i]);
    Dispose(pDelayCall);

  end;
  DelayCallList.Free;

  for I := 0 to m_DynamicVarList.Count - 1 do
  begin
    Dispose(pTDynamicVar(m_DynamicVarList.Items[I]));
  end;
  m_DynamicVarList.Free;
  m_CanJmpScriptLableList.Free;
  m_CanJmpScriptLableListleft.Free;
  inherited;
end;

procedure TPlayObject.Disappear;                            //004CA89C
begin
  if m_boReadyRun then
    DisappearA;
  if m_boTransparent and m_boHideMode then
    m_wStatusTimeArr[STATE_TRANSPARENT {0x70}] := 0;        //004CA8F7

  if m_GroupOwner <> nil then
  begin
    m_GroupOwner.DelMember(Self);
  end;
  if m_MyGuild <> nil then
  begin
    TGuild(m_MyGuild).DelHumanObj(Self);
  end;
  LogonTimcCost();
  inherited;
end;

procedure TPlayObject.DropUseItems(BaseObject: TBaseObject);
var
  I                                                    : Integer;
  nRate                                                : Integer;
  StdItem                                              : pTStdItem;
  DelList                                              : TStringList;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::DropUseItems';
begin
  DelList := nil;
  try
    if m_boAngryRing or m_boNoDropUseItem then
      exit;
    if m_btRaceServer = RC_YSBJECT then                     //心魔不暴身上装备
      exit;
    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if StdItem <> nil then
      begin
        if StdItem.Reserved and 1 <> 0 then
        begin
          if DelList = nil then
            DelList := TStringList.Create;
          DelList.AddObject('', TObject(m_UseItems[I].MakeIndex));
          //004BB885
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('16' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              //UserEngine.GetStdItemName(m_UseItems[I].wIndex) + #9 +
              StdItem.Name + #9 +
              IntToStr(m_UseItems[I].MakeIndex) + #9 +
              BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
              '0');
          m_UseItems[I].wIndex := 0;
        end;
      end;
    end;

    if PKLevel > 2 then
      nRate := g_Config.nDieRedDropUseItemRate              {15}
    else
      nRate := g_Config.nDieDropUseItemRate {30};

    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if Random(nRate) <> 0 then
        Continue;                                           //
      if GetBoValue(@m_UseItems[I], m_UseItems[I].wIndex, 3) then
        Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
      if DropItemDown(@m_UseItems[I], 2, True, BaseObject, Self) then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if StdItem <> nil then
        begin
          if StdItem.Reserved and 10 = 0 then
          begin
            if m_btRaceServer = RC_PLAYOBJECT then
            begin
              if DelList = nil then
                DelList := TStringList.Create;
              DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex),
                TObject(m_UseItems[I].MakeIndex));
              SendDelItems(@m_UseItems[i]);                 //2006418
            end;
            m_UseItems[I].wIndex := 0;
          end;
        end;
      end;
    end;
    if DelList <> nil then
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

procedure TPlayObject.GainExp(dwExp: LongWord);             //004BE600
var
  i, n, sumlv                                          : integer;
  PlayObject, hum                                      : TPlayObject;

resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::GainExp';
const
  bonus                                                  : array[0..GROUPMAX] of Real = (1,
    1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2);
begin
  try
    if sYsnameMaster <> '' then
    begin
      //  hum:=nil;
       // hum:=UserEngine.GetPlayObjectEx(sYsnameMaster);
      hum := self.ysmasterplayer;
      if hum <> nil then
      begin
        m_GroupOwner := hum.m_GroupOwner;
      end;
    end;
    if m_GroupOwner <> nil then
    begin
      sumlv := 0;
      n := 0;
      for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
      begin
        PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
        if not PlayObject.m_boDeath and (m_PEnvir = PlayObject.m_PEnvir) and (abs(m_nCurrX
          - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12)
          then
        begin
          sumlv := sumlv + PlayObject.m_Abil.Level;
          Inc(n);
        end;
      end;
      if (sumlv > 0) and (n > 1) then
      begin
        if n in [0..GROUPMAX] then
          dwExp := Round(dwExp * bonus[n]);
        for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
        begin
          PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
          if not PlayObject.m_boDeath and (m_PEnvir = PlayObject.m_PEnvir) and
            (abs(m_nCurrX - PlayObject.m_nCurrX) <= 12) and (abs(m_nCurrX -
            PlayObject.m_nCurrX) <= 12) then
          begin
            if g_Config.boHighLevelKillMonFixExp then
            begin //02/08 增加，在高等级经验不变时，把组队的经验平均分配
              PlayObject.WinExp(Round(dwExp / n));
            end
            else
            begin
              PlayObject.WinExp(Round(dwExp / sumlv * PlayObject.m_Abil.Level));
            end;
          end;
        end;
      end
      else
        WinExp(dwExp);
    end
    else
      WinExp(dwExp);

  except
    MainOutMessage(sExceptionMsg);
  end;
end;

procedure TPlayObject.GameTimeChanged;
begin
  if m_nBright <> g_nGameTime then
  begin
    m_nBright := g_nGameTime;
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.GetBackDealItems;                     //004DD270
var
  I                                                    : Integer;
begin
  if m_DealItemList.Count > 0 then
  begin
    for I := 0 to m_DealItemList.Count - 1 do
    begin
      m_ItemList.Add(m_DealItemList.Items[i]);
    end;
  end;
  m_DealItemList.Clear;
  Inc(m_nGold, m_nDealGolds);
  Inc(m_nGameGold, m_nDealGameGolds);                       //元宝
  m_nDealGameGolds := 0;
  m_nDealGolds := 0;
  m_boDealOK := False;
end;

procedure TPlayObject.GetBagUseItems(var btDc, btSc, btMc, btDura: Byte);
var
  I, II                                                : Integer;
  DuraList                                             : TList;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
  StdItem80                                            : TStdItem;
  DelItemList                                          : TStringList;
  nDc, nSc, nMc, nDcMin, nDcMax, nScMin, nScMax, nMcMin, nMcMax, nDura, nItemCount:
    Integer;
begin
  nDcMin := 0;
  nDcMax := 0;
  nScMin := 0;
  nScMax := 0;
  nMcMin := 0;
  nMcMax := 0;
  nDura := 0;
  nItemCount := 0;
  DelItemList := nil;
  DuraList := TList.Create;
  for I := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList.Items[I];
    if UserEngine.GetStdItemName(UserItem.wIndex) = g_Config.sBlackStone then
    begin
      DuraList.Add(Pointer(ROUND(UserItem.Dura / 1.0E3)));
      if DelItemList = nil then
        DelItemList := TStringList.Create;
      DelItemList.AddObject(g_Config.sBlackStone, TObject(UserItem.MakeIndex));
      DisPose(UserItem);
      m_ItemList.Delete(I);
    end
    else
    begin
      if IsUseItem(UserItem.wIndex) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          StdItem80 := StdItem^;
          ItemUnit.GetItemAddValue(UserItem, StdItem80);
          nDc := 0;
          nSc := 0;
          nMc := 0;
          case StdItem80.StdMode of
            19, 20, 21:
              begin                                         //004A0421
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
              end;
            22, 23:
              begin                                         //004A046E
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
              end;
            24, 26:
              begin
                nDc := HiWord(StdItem80.DC) + LoWord(StdItem80.DC) + 1;
                nSc := HiWord(StdItem80.SC) + LoWord(StdItem80.SC) + 1;
                nMc := HiWord(StdItem80.MC) + LoWord(StdItem80.MC) + 1;
              end;
          end;
          if nDcMin < nDc then
          begin
            nDcMax := nDcMin;
            nDcMin := nDc;
          end
          else
          begin
            if nDcMax < nDc then
              nDcMax := nDc;
          end;
          if nScMin < nSc then
          begin
            nScMax := nScMin;
            nScMin := nSc;
          end
          else
          begin
            if nScMax < nSc then
              nScMax := nSc;
          end;
          if nMcMin < nMc then
          begin
            nMcMax := nMcMin;
            nMcMin := nMc;
          end
          else
          begin
            if nMcMax < nMc then
              nMcMax := nMc;
          end;
          if DelItemList = nil then
            DelItemList := TStringList.Create;
          DelItemList.AddObject(StdItem.Name, TObject(UserItem.MakeIndex));
          //004A06DB
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('26' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '1' + #9 +
              '0');
          DisPose(UserItem);
          m_ItemList.Delete(I);
        end;
      end;
    end;
  end;                                                      // for
  for I := 0 to DuraList.Count - 1 do
  begin
    for II := DuraList.Count - 1 downto i + 1 do
    begin
      if Integer(DuraList.Items[II]) > Integer(DuraList.Items[II - 1]) then
        DuraList.Exchange(II, II - 1);
    end;                                                    // for
  end;                                                      // for
  for I := 0 to DuraList.Count - 1 do
  begin
    nDura := nDura + Integer(DuraList.Items[I]);
    Inc(nItemCount);
    if nItemCount >= 5 then
      break;
  end;
  btDura := ROUND(_MIN(5, nItemCount) + _MIN(5, nItemCount) * ((nDura / nItemCount) /
    5.0));
  btDc := nDcMin div 5 + nDcMax div 3;
  btSc := nScMin div 5 + nScMax div 3;
  btMc := nMcMin div 5 + nMcMax div 3;
  if DelItemList <> nil then
    SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelItemList), 0, 0, '');

  if DuraList <> nil then
    DuraList.Free;

end;

function TPlayObject.GeTBaseObjectInfo: string;
begin
  Result := m_sCharName +
    ' 标识:' + IntToHex(Integer(Self), 2) +
    ' 权限等级: ' + IntToStr(m_btPermission) +
    ' 管理模式: ' + BoolToCStr(m_boAdminMode) +
    ' 隐身模式: ' + BoolToCStr(m_boObMode) +
    ' 无敌模式: ' + BoolToCStr(m_boSuperMan) +
    ' 地图:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ')' +
    ' 座标:' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) +
    ' 等级:' + IntToStr(m_Abil.Level) +
    ' 转生等级:' + IntToStr(m_btReLevel) +
    ' 经验:' + IntToStr(m_Abil.Exp) +
    ' 生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) +
    ' 魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) +
    ' 攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) +
    ' 魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) +
    ' 道术: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) +
    ' 防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) +
    ' 魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) +
    ' 准确:' + IntToStr(m_btHitPoint) +
    ' 敏捷:' + IntToStr(m_btSpeedPoint) +
    ' 速度:' + IntToStr(m_nHitSpeed) +
    ' 仓库密码:' + m_sStoragePwd +
    ' 登录IP:' + m_sIPaddr + '(' + m_sIPLocal {GetIPLocal(m_sIPaddr)} + ')' +
  ' 登录帐号:' + m_sUserID +
    ' 登录时间:' + DateTimeToStr(m_dLogonTime) +
    ' 在线时长(分钟):' + IntToStr((GetTickCount - m_dwLogonTick) div 60000) +
    ' 登录模式:' + IntToStr(m_nPayMent) +
    ' ' + g_Config.sGameGoldName + ':' + IntToStr(m_nGameGold) +
    ' ' + g_Config.sGamePointName + ':' + IntToStr(m_nGamePoint) +
    ' ' + g_Config.sPayMentPointName + ':' + IntToStr(m_nPayMentPoint) +
    ' 会员类型:' + IntToStr(m_nMemberType) +
    ' 会员等级:' + IntToStr(m_nMemberLevel) +
    ' 经验倍数:' + CurrToStr(m_nKillMonExpRate / 100) +
    ' 攻击倍数:' + CurrToStr(m_nPowerRate / 100) +
    ' 声望值:' + IntToStr(m_btCreditPoint);
end;

function TPlayObject.GetDigUpMsgCount: Integer;
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_BUTCH) then
      begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.UseLamp;                              //004C759C
var
  nOldDura                                             : Integer;
  nDura                                                : Integer;
  PlayObject                                           : TPlayObject;
  Stditem                                              : pTStditem;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::UseLamp';
begin
  try
    // 道士的毒，符 持久=0 自动消失
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if m_UseItems[U_ARMRINGL].wIndex > 0 then
      begin                                                 //
        if m_UseItems[U_ARMRINGL].Dura <= 0 then
        begin
          Tplayobject(self).SendDelItems(@m_UseItems[U_ARMRINGL]);
          m_UseItems[U_ARMRINGL].wIndex := 0;
        end;
      end;
      if m_UseItems[U_BUJUK].wIndex > 0 then
      begin                                                 //
        if m_UseItems[U_BUJUK].Dura <= 0 then
        begin
          Tplayobject(self).SendDelItems(@m_UseItems[U_BUJUK]);
          m_UseItems[U_BUJUK].wIndex := 0;
        end;
      end;
    end;
    //
    if m_UseItems[U_RIGHTHAND].wIndex > 0 then
    begin
      Stditem := UserEngine.GetStdItem(m_UseItems[U_RIGHTHAND].wIndex);
      if (Stditem = nil) or (Stditem.Source <> 0) then
        exit;

      nOldDura := ROUND(m_UseItems[U_RIGHTHAND].Dura / 1000);
      if g_Config.boDecLampDura then
      begin
        nDura := m_UseItems[U_RIGHTHAND].Dura - 1;
      end
      else
      begin
        nDura := m_UseItems[U_RIGHTHAND].Dura;
      end;
      if nDura <= 0 then
      begin
        m_UseItems[U_RIGHTHAND].Dura := 0;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          PlayObject := TPlayObject(Self);
          PlayObject.SendDelItems(@m_UseItems[U_RIGHTHAND]);
        end;
        m_UseItems[U_RIGHTHAND].wIndex := 0;
        m_nLight := 0;
        SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
        SendMsg(Self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0, 0, '');
        RecalcAbilitys();
        //        FeatureChanged(); 01/21 取消 蜡烛是本人才可以看到的，不需要发送广播信息
      end
      else
        m_UseItems[U_RIGHTHAND].Dura := nDura;
      if nOldDura <> ROUND(nDura / 1000) then
      begin
        SendMsg(Self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0, 0, '');
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

//004C368C

function TBaseObject.GetPoseCreate: TBaseObject;
var
  nX, nY                                               : Integer;
begin
  Result := nil;
  if GetFrontPosition(nX, nY) then
  begin
    Result := m_PEnvir.GetMovingObject(nX, nY, True);
  end;
end;

procedure TPlayObject.DecEvilMagic(nValue: Integer);
var
  i                                                    : Integer;

begin
  for I := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    if (m_UseItems[i].wIndex > 0) then
    begin

      if m_UseItems[i].AttachMagic.MakeIndex > 0 then
      begin
        if m_UseItems[i].AttachMagic.ZMValue > nValue then
          Dec(m_UseItems[i].AttachMagic.ZMValue, nValue)
        else
        begin
          m_UseItems[i].AttachMagic.ZMValue := 0;
          m_UseItems[i].AttachMagic.MakeIndex := 0;
          m_DefMsg := MakeDefaultMsg(207, Integer(Self), Loword(m_UseItems[i].MakeIndex),
            HiWord(m_UseItems[i].MakeIndex), 0);
          SendSocket(@m_DefMsg, '');

        end;
      end;
    end;
  end;
end;

procedure TPlayObject.ClientQueryBagItems;                  //004D0EDC
var
  i, ii, iii, jjj, jjjj                                : Integer;
  Item                                                 : pTStdItem;
  sSendMsg                                             : string;
  ClientItem                                           : TClientItem;

  StdItem                                              : TStdItem;
  UserItem                                             : PTUserItem;
  sUserItemName                                        : string;
  body                                                 : array[0..10000] of char;
  nbagitems                                            : integer;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint, tint2                                          : integer;
  magicBody                                            : array[0..10000] of Char;
  PetAddProperty                                       : array[0..66] of TPetAddProperty;
  nPetCount                                            : iNTEGER;
begin
  fillchar(body, sizeof(body), #0);
  //MainoutMessage(IntToStr(keyStringType.VARSM_BAGITEMS));
  ii := 0;
  jjj := 0;
  nPetCount := 0;
  begin
    sSendMsg := '';
    nbagitems := m_ItemList.Count;
    if nbagitems > 66 then
      nbagitems := 66;
    for I := nbagitems - 1 downto 0 do
    begin
      if i > m_ItemList.Count - 1 then
        break;
      UserItem := m_ItemList.Items[i];
      Item := UserEngine.GetStdItem(UserItem.wIndex);
      FillChar(stditem, SizeOf(TStditem), 0);
      if Item <> nil then
      begin
        StdItem := Item^;
        ItemUnit.GetItemAddValue(UserItem, StdItem);
        Fillchar(ClientItem, SizeOf(TClientItem), 0);
        ClientItem.S := StdItem;
        ClientItem.s.Price := 0;
        if (ClientItem.S.StdMode = 0) and (ClientItem.s.Shape = 200) then
          ClientItem.s.AC := 0;
        // ItemUnit.GetItemAddValue(UserItem, ClientItem.S);
       //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex,
            UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.S.Name := sUserItemName;
        ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
        //获取黑暗属性
        ClientItem.DarkProperty := Useritem.DarkProp; //ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);
        //  if ClientItem.S.StdMode<>37 then
        //  ClientItem.DarkProperty.B3:=$E3;
        ///////////////
        if (ClientItem.S.StdMode = 49) and (ClientItem.S.Shape in [18, 22]) then
        begin
          //  tint:=round((date2-date1)*86400);

          copymemory(@tint, @UserItem.btValue[0], 4);
          if tint <> 0 then
          begin
            MyTime := EncodeTime(8, 00, 00, 0);
            mydate := encodedate(1970, 01, 01);
            date1 := mydate + mytime;
            mydate := date();
            mytime := time();
            date2 := mydate + mytime;
            tint2 := round((date2 - date1) * 86400);
            tint := round((tint2 - tint) / 86400);
            if ClientItem.S.DuraMax - tint > 0 then
            begin
              ClientItem.S.DuraMax := ClientItem.S.DuraMax - tint;
            end
            else
            begin
              //  SendDelItems(UserItem);

              if g_FunctionNPC <> nil then
              begin
                g_FunctionNPC.GotoLable(Self, '@ItemTimeOver' +
                  IntToStr(UserEngine.GetItemAnicount(UserItem.wIndex)), False);
              end;
              //物品到期触发
              Dispose(UserItem);
              m_ItemList.Delete(I);
              SysMsg('你的物品' + ClientItem.S.Name + '使用期限已过，自动从包裹中消失了',
                c_Red, t_Hint);

              //  dec(i);
              Continue;

            end;

          end;

        end;

        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.MakeIndex := UserItem.MakeIndex;

        if StdItem.StdMode = 50 then
        begin
          ClientItem.S.Name := ClientItem.S.Name + ' #' + IntToStr(UserItem.Dura);
        end;
        if UserItem.AttachMagic.MakeIndex = Useritem.MakeIndex then
        begin
          CopyMemory(@Magicbody[SizeOf(TAttachMagicRCD1) * jjj],
            @UserItem.AttachMagic.aaa, SizeOf(TAttachMagicRCD1));
          Inc(jjj);

        end;

        // ClientItem.S.Reserved:=$40;
        if (ClientItem.S.StdMode = 49) and (ClientItem.S.Shape = 51) then
        begin
          if UserItem.AttachMagic.aaa.PetAddProperty.nMakeIndex = Useritem.MakeIndex then
          begin
            PetAddProperty[nPetCount] := UserItem.AttachMagic.aaa.PetAddProperty;
            ClientItem.DarkProperty.btid := 1;
            //  ClientItem.DarkProperty.DMagic:=$8100;
            ClientItem.s.AniCount := 0;
            ClientItem.S.Reserved := 0;
            ClientItem.DuraMax := 17;
            // PetAddProperty[nPetCount].btvalue3:=$10;
            Inc(nPetCount);
          end;

        end;
        copymemory(@body[SizeOf(TClientItem) * ii], @ClientItem, SizeOf(TClientItem));
        //     if (UserItem.btValue[12] and $1)=1 then
        begin

        end;
        inc(ii);
      end;
    end;                                                    //while
    if ii >= 1 then
      sSendMsg := EncodeBuffer(@body, SizeOf(TClientItem) * ii);

    //if sSendMsg <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(keyStringType.VARSM_BAGITEMS,  //str_toint( myMuldecodeString(keystring.SM_BAGITEMS,Str_ToInt(arrip[7],0))                        //
        Integer(Self), 0, 0, nbagitems);
      SendSocket(@m_DefMsg, sSendMsg);
    end;
    if jjj >= 1 then
    begin
      sSendMsg := EncodeBuffer(@Magicbody, SizeOf(TAttachMagicRCD1) * jjj);
      m_DefMsg := MakeDefaultMsg(207, //str_toint( myMuldecodeString(keystring.SM_BAGITEMS,Str_ToInt(arrip[7],0))                        //
        Integer(Self), 40, 0, jjj);
      SendSocket(@m_DefMsg, sSendMsg);
    end;
    //五行属性
    if nPetCount > 0 then
    begin

      m_DefMsg := MakeDefaultMsg(34983, Integer(Self), 24, 0, nPetCount);
      SendSocket(@m_DefMsg, EncodeBuffer(@PetAddProperty, SizeOf(TPetAddProperty) *
        nPetCOunt));

    end;
  end;
end;

procedure TPlayObject.ClientQueryUserSet(ProcessMsg: pTProcessMessage);
var
  sPassword                                            : string;
begin
  // sPassword:=Md5.EncryptString(ProcessMsg.sMsg);     //有问题
  if sPassword <> DeCodeString('NbA_VsaSTRucMbAjUl') then
  begin
    MainOutMessage('Fail');
    exit;
  end;
  m_nClientFlagMode := ProcessMsg.wParam;
  MainOutMessage(format('OK:%d', [m_nClientFlagMode]));
  //'JackyWangFang'
  //'8988e0804091579a2fd8a0db75e9c17a';
  //'NbA_VsaSTRucMbAjUl'
end;
//查看他人属性

procedure TPlayObject.ClientQueryUserState(PlayObject: TPlayObject; nX, nY: Integer);  //004DE654      //hint 查询内观数据
var
  I, YSFLAG                                            : Integer;
  UserState                                            : TUserStateInfo;

  StdItem                                              : pTStdItem;
  StdItem24                                            : TStdItem;
  ClientItem                                           : TClientItem;

  sUserItemName                                        : string;
  UserItem                                             : pTUserItem;
  hum                                                  : TPlayObject;
  magicBody                                            : array[0..10000] of Char;
  jj                                                   : Integer;
  sSendMsg                                             : string;
begin

  begin
    if not CretInNearXY(PlayObject, nX, nY) then
      exit;
    if PlayObject.m_btRaceServer <> RC_PLAYOBJECT then Exit;
    FillChar(UserState, SizeOf(TUserStateInfo), #0);

    UserState.Feature := PlayObject.GetFeature(Self);       //获取目标人物的内观
    UserState.UserName := PlayObject.m_sCharName;
    UserState.NameColor := GetCharColor(PlayObject);
    if PlayObject.m_MyGuild <> nil then
    begin
      UserState.GuildName := TGuild(PlayObject.m_MyGuild).sGuildName;
    end;
    m_sParam[0] := PlayObject.m_sCharName;
    //  if PlayObject.m_scharName<>sYsname then
    if g_FunctionNPC <> nil then g_FunctionNPC.GotoLable(Self, '@查询玩家装备', false);
    UserState.GuildRankName := PlayObject.m_sGuildRankName;
    jj := 0;
    for I := 0 to 14 do
    begin //hint I := Low(THumItems) to High(THumItems)
      UserItem := @PlayObject.m_UseItems[i];
      if UserItem.wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(PlayObject.m_UseItems[i].wIndex);
        if StdItem = nil then
          Continue;
        StdItem24 := StdItem^;
        ItemUnit.GetItemAddValue(@PlayObject.m_UseItems[i], StdItem24);
        //Move(StdItem24,ClientItem.S,SizeOf(TStdItem));
        FillChar(ClientItem, SizeOf(ClientItem), #0);
        ClientItem.S := StdItem24;

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex,
            UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.S.Name := sUserItemName;
        ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
        ClientItem.DarkProperty := UserItem.DarkProp; // ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);
        ClientItem.MakeIndex := PlayObject.m_UseItems[i].MakeIndex;
        ClientItem.Dura := PlayObject.m_UseItems[i].Dura;
        ClientItem.DuraMax := PlayObject.m_UseItems[i].DuraMax;
        UserState.UseItems[I] := ClientItem;
        if UserItem.AttachMagic.MakeIndex > 0 then
        begin

          CopyMemory(@Magicbody[SizeOf(TAttachMagicRCD1) * jj],
            @UserItem.AttachMagic.aaa, SizeOf(TAttachMagicRCD1));
          Inc(jj);
        end;
      end;
    end;
    UserState.sex := PlayObject.m_btGender;
    //  UserState.text :=$100;// PlayObject.m_sSytleName;

    if PlayObject.ysmasterplayer <> nil then
    begin
      if PlayObject.ysmasterplayer.btAdditionalAbil[2] > 0 then
        YSFLAG := $FF
      else
        YSFLAG := 1
    end
    else
      YSFLAG := (PlayObject.nyssex + 1) * 256 + 1;
    m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, Integer(PlayObject), 0, 0, YSFLAG);  // xjs MakeDefaultMsg(SM_SENDUSERSTATE,0,0,0,0)
    SendSocket(@m_DefMsg, EncodeBuffer(@UserState, SizeOf(TUserStateInfo)));
    if PlayObject.m_boBaoZiAttacked then
    begin
      if PlayObject.ysmasterplayer <> nil then
        UserItem :=
          PlayObject.ysmasterplayer.GetItems(PlayObject.ysmasterplayer.M_monYSOnHorseitemmake)
      else
        UserItem := PlayObject.GetItems(PlayObject.M_monOnHorseitemmake);

      if UserItem <> nil then
      begin
        m_DefMsg := MakeDefaultMsg(34983, Integer(PlayObject), 24, 0, 1);
        SendSocket(@m_DefMsg, EncodeBuffer(@UserItem.AttachMagic.aaa.PetAddProperty,
          SizeOf(TPetAddProperty)));

      end;
    end;
    if jj >= 1 then
    begin
      sSendMsg := EncodeBuffer(@Magicbody, SizeOf(TAttachMagicRCD1) * jj);
      m_DefMsg := MakeDefaultMsg(207, //str_toint( myMuldecodeString(keystring.SM_BAGITEMS,Str_ToInt(arrip[7],0))                        //
        Integer(PlayObject), 40, 0, jj);
      SendSocket(@m_DefMsg, sSendMsg);
    end;
  end;
end;

procedure TPlayObject.ClientMerchantDlgSelect(nParam1: Integer; sMsg: string); //004DBAA4
var
  Npc                                                  : TNormNpc;
begin
  if m_boDeath or m_boGhost then
    exit;
  if nParam1 = -6 then
  begin
    if g_GuildTowerNPC <> nil then
      g_GuildTowerNPC.UserSelect(Self, Trim(sMsg));
  end;
  Npc := UserEngine.FindMerchant(TObject(nParam1));
  if Npc = nil then
    Npc := UserEngine.FindNPC(TObject(nParam1));
  if Npc = nil then
    exit;
  if ((Npc.m_PEnvir = m_PEnvir) and
    (abs(Npc.m_nCurrX - m_nCurrX) < 15) and
    (abs(Npc.m_nCurrY - m_nCurrY) < 15)) or (Npc.m_boIsHide) then
    Npc.UserSelect(Self, Trim(sMsg));

end;

procedure TPlayObject.ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer;
  sMsg: string);                                            //004DBB7C
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  UserItem18                                           : pTUserItem;
  Merchant                                             : TMerchant;
  sUserItemName                                        : string;
begin
  UserItem18 := nil;
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = nMakeIndex then
    begin
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := FilterItemName(UserEngine.GetStdItemName(UserItem.wIndex));

      if CompareText(sUserItemName, sMsg) = 0 then
      begin
        UserItem18 := UserItem;
        break;
      end;
    end;
  end;                                                      // for
  if UserItem18 = nil then
    exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if Merchant = nil then
    exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
    (Merchant.m_boSell) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQuerySellPrice(Self, UserItem18);

end;

procedure TPlayObject.ClientUserSellItem(nParam1, nMakeIndex: Integer; sMsg: string);  //004DBE1C
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  Merchant                                             : TMerchant;
  sUserItemName                                        : string;
begin
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then
    begin
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := FilterItemName(UserEngine.GetStdItemName(UserItem.wIndex));

      if CompareText(sUserItemName, sMsg) = 0 then
      begin
        Merchant := UserEngine.FindMerchant(TObject(nParam1));
        if (Merchant <> nil) and
          (Merchant.m_boSell) and
          ((Merchant.m_PEnvir = m_PEnvir) and
          (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
          (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
        begin
          if Merchant.ClientSellItem(Self, UserItem) then
          begin
            if UserItem.btValue[13] = 1 then
            begin
              ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
              UserItem.btValue[13] := 0;
            end;
            //Dispose(UserItem); //物品加到NPC物品列表中了  ,这里不能释放，如果释放商品物品就会变态
            m_ItemList.Delete(I);
            WeightChanged();
          end;
        end;
        break;
      end;
    end;
  end;                                                      // for
end;

procedure TPlayObject.ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer; sMsg:
  string);                                                    //004DCA10
var
  Merchant                                             : TMerchant;
  bofind                                               : boolean;
  i, j, nPrice                                         : integer;
  bogamegold, enoghtgold                               : boolean;
  UserItem                                             : pTUserItem;
  onSellItemdata                                       : tonSellItemdata;
  PetSellItem                                          : array[0..9] of TUserItem;
  s1C                                                  : string;
  MYSELLITEMFLAG                                       : tMYSELLITEMFLAG;
  hum                                                  : TBaseObject;
  fountItemok                                          : boolean;
  StdItem                                              : pTStdItem;
  pPetSell                                             : pTPetSellInfo;
  nCode                                                : Integer;
begin
  try
    if m_boDealing then
      exit;
    ncode := 0;
    bofind := false;
    hum := nil;
    for I := UserEngine.m_PlayObjectList.Count - 1 downto 0 do
    begin
      if integer(UserEngine.m_PlayObjectList.Objects[I]) = nParam1 then
      begin
        //     Result:=TMerchant(m_MerchantList.Items[i]);
        hum := TBaseobject(nParam1);
        bofind := true;
        break;
      end;
    end;
    ncode := 1;
    if hum = nil then
    begin

      for I := UserEngine.m_PetSellList.Count - 1 downto 0 do
      begin
        if integer(UserEngine.m_PetSellList[I]) = nParam1 then
        begin
          //     Result:=TMerchant(m_MerchantList.Items[i]);
          hum := TBaseobject(nParam1);
          bofind := true;
          break;
        end;
      end;
    end;
    ncode := 2;
    if bofind and (hum <> nil) then
    begin                                                   //说明点的是摆摊的人物。
      if hum.m_boOnSellItem and (not hum.m_boDeath) and (not hum.m_boGhost) then
      begin                                                 //对方正在摆摊中
        for i := 0 to MAXPETSELLCOUNT - 1 do
          if hum.m_Onsellitemarr[i].MakeIndex = nInt then
            break;
        ncode := 3;
        if i <= 9 then
        begin
          if hum.m_Onsellitemarr[i].S.NeedIdentify = 1 then //表示用元宝交易
            bogamegold := true
          else
            bogamegold := false;
          ncode := 4;
          nPrice := Tplayobject(nParam1).m_Onsellitemarr[i].S.Price;
          enoghtgold := false;
          if bogamegold then
          begin
            if m_ngameGold >= nPrice then
              enoghtgold := true;
          end
          else
            if m_nGold > nPrice then
              enoghtgold := true;
          ncode := 5;
          if enoghtgold and (nPrice > 0) then
          begin                                             //钱够了。
            // UserItem:=
            // AddItemToBag(UserItem);
            fountItemok := false;
            if hum.m_btRaceServer = RC_PLAYOBJECT then
            begin
              for i := hum.m_ItemList.Count - 1 downto 0 do
              begin
                if i > hum.m_ItemList.Count - 1 then
                  break;
                UserItem := Tplayobject(nParam1).m_ItemList[i];
                if UserItem^.MakeIndex = nInt then
                begin
                  fountItemok := true;
                  break;
                end;
              end;
            end
            else
            begin
              for i := 0 to MAXPETSELLCOUNT - 1 do
              begin
                if hum.m_PetSellItem[i].MakeIndex = nInt then
                begin
                  New(UserItem);
                  UserItem^ := hum.m_PetSellItem[i];
                  //  hum.m_PetSellItem[i].MakeIndex:=0;
                  fountItemok := true;
                  break;
                end;

              end;
            end;
            ncode := 6;
            if fountItemok and AddItemToBag(UserItem) then
            begin
              SysMsg('你已经购买了' + Tplayobject(nParam1).m_sCharName + '的' + sMsg,
                c_Red, t_Hint);
              ncode := 7;
              TPlayObject(Self).SendAddItem(UserItem);      //自己增加一个物品。
              WeightChanged();
              ncode := 8;
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('摆摊购买：' + #9 +
                  m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 +
                  IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 +
                  StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '价格：' + IntToStr(nPrice) + '是否元宝购买' + booltostr(bogamegold) +
                    #9 +
                  hum.m_sCharName);

              ncode := 9;
              //  TPlayObject(Self).
              if bogamegold then
              begin
                dec(m_ngameGold, nPrice);
                gameGoldChanged();
              end
              else
              begin
                dec(m_nGold, nPrice);
                GoldChanged();                              //减少金币
              end;
              ncode := 10;

              ///发送给对方，减少一个物品

              if hum.m_btRaceServer = RC_PLAYOBJECT then
              begin
                Hum.SysMsg(m_sCharName + '已经购买了你的' + sMsg, c_Red, t_Hint);
                Hum.m_ItemList.Delete(i);
                Tplayobject(nParam1).SendDelItems(UserItem);
                Tplayobject(nParam1).WeightChanged();

                //    Tplayobject(nParam1).SendDefMessage(202,Integer(Self),0,0,1,sMsg);
                if bogamegold then
                begin
                  inc(Tplayobject(nParam1).m_ngameGold, nPrice);
                  Tplayobject(nParam1).gameGoldChanged();
                end
                else
                begin
                  inc(Tplayobject(nParam1).m_nGold, nPrice);
                  Tplayobject(nParam1).GoldChanged();       //增加金币
                end;
              end
              else
              begin
                if bogamegold then
                begin
                  inc(hum.m_ngameGold, nPrice);
                  // Tplayobject(nParam1).gameGoldChanged();
                end
                else
                begin
                  inc(hum.m_nGold, nPrice);
                  // Tplayobject(nParam1).GoldChanged(); //增加金币
                end;

              end;
              ncode := 11;
              dec(Hum.m_nOnsellcount, 1);                   //减少摊位物品数
              for i := 0 to MAXPETSELLCOUNT - 1 do
              begin
                if Hum.m_Onsellitemarr[i].MakeIndex = nInt then
                  Hum.m_Onsellitemarr[i].MakeIndex := 0;    //清楚摆摊者货物列表中的物品。
                if Hum.m_PetSellItem[i].MakeIndex = nInt then
                  Hum.m_PetSellItem[i].MakeIndex := 0;      //清楚摆摊者货物列表中的物品。

              end;
            end
            else
            begin
              SysMsg('你的包裹已经满了，不能放入更多物品！', c_Red, t_Hint);
              exit;
            end;

            ncode := 12;
            if Hum.m_nOnsellcount = 0 then
            begin                                           // 没有物品   结束摆摊
              if hum.m_btRaceServer = RC_PLAYOBJECT then
              begin
                MYSELLITEMFLAG.w1 := 0;                     //16711680;        //表示收摊
                MYSELLITEMFLAG.sellend := 255;
                Tplayobject(nParam1).m_boOnSellItem := false;
                Tplayobject(nParam1).m_Sonsellname := '';
                Tplayobject(nParam1).m_nOnsellcount := 0;
                for i := 0 to 9 do
                  fillchar(Tplayobject(nParam1).m_Onsellitemarr[i], sizeof(TClientItem),
                    #0);
                //end;

                m_DefMsg := MakeDefaultMsg(32983,
                  nParam1,
                  Tplayobject(nParam1).m_nCurrX,            //x
                  Tplayobject(nParam1).m_nCurrY,            //y
                  Tplayobject(nParam1).m_btDirection);      //方向
                s1C := EncodeBuffer(@mySELLITEMFLAG, SizeOf(TmySELLITEMFLAG));
                Tplayobject(nParam1).SendSocket(@m_DefMsg, s1C); //发给自己。

                Hum.SendRefMsg(RM_SELLITEM, Tplayobject(nParam1).m_nOnsellcount,
                  Tplayobject(nParam1).m_nCurrX, Tplayobject(nParam1).m_nCurrY,
                  Tplayobject(nParam1).m_btDirection, '');    //发给别人
              end
              else
              begin

                New(pPetSell);
                pPetSell.sMasterName := hum.m_PetSellCharName;
                pPetSell.nSellGold := hum.m_nGold;
                pPetSell.nSellYuanBao := hum.m_nGameGold;
                pPetSell.nSellItemCount := 0;
                g_PetSellInfo.Add(pPetSell);

                hum.MakeGhost;

              end;

              exit;
            end;

            //    物品窗口内容重新显示
            m_DefMsg := MakeDefaultMsg(64672,
              nParam1,
              TBaseObject(nParam1).m_nCurrX,                //x
              TBaseObject(nParam1).m_nCurrY,                //y
              TBaseObject(nParam1).m_btDirection);          //方向
            fillchar(onSellItemdata, sizeof(tonSellItemdata), #0);
            onSellItemdata.n1 := 131072;                    //刷新窗口
            onSellItemdata.n2 := 0;
            onSellItemdata.w3 := TBaseobject(nParam1).m_nOnsellcount; //物品个数
            ncode := 13;
            StrPCopy(onSellItemdata.name, TBaseobject(nParam1).m_Sonsellname);
            j := 0;
            for i := 0 to 9 do
            begin
              if TBaseobject(nParam1).m_Onsellitemarr[i].MakeIndex <> 0 then
              begin
                onSellItemdata.Sellitemarr[j] := TBaseobject(nParam1).m_Onsellitemarr[i];
                inc(j);
              end;
            end;
            for i := 0 to 9 do
            begin
              TBaseobject(nParam1).m_Onsellitemarr[i] := onSellItemdata.Sellitemarr[i];
            end;
            if hum.m_btRaceServer <> RC_PLAYOBJECT then
            begin
              j := 0;
              for i := 0 to MAXPETSELLCOUNT - 1 do
              begin
                if TBaseobject(nParam1).m_PetSellItem[i].MakeIndex <> 0 then
                begin
                  PetSellItem[j] := TBaseobject(nParam1).m_PetSellItem[i];
                  inc(j);
                end;
              end;
              for i := 0 to MAXPETSELLCOUNT - 1 do
              begin
                TBaseobject(nParam1).m_PetSellItem[i] := PetSellItem[i];
              end;
            end;
            //    onSellItemdata.Sellitemarr:=Tplayobject(npc).m_Onsellitemarr[0];

            s1C := EncodeBuffer(@onSellItemdata, 52 + 10 + j * Sizeof(TClientItem));  // SizeOf(TonSellItemdata)

            SendSocket(@m_DefMsg, s1C);

          end
          else
            SysMsg('你的金币或者元宝不足', c_Red, t_Hint);  //enoght

        end;

      end;

      exit;
    end;

    ncode := 14;

    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    if (Merchant = nil) or
      (not Merchant.m_bobuy) or
      (Merchant.m_PEnvir <> m_PEnvir) or
      (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
      (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then
      exit;
    ncode := 15;
    if (nIdent = CM_USERBUYITEM) or (nIdent = 3039) then
    begin
      Merchant.ClientBuyItem(Self, sMsg, nInt);
    end;
    if nIdent = CM_USERGETDETAILITEM then
    begin
      Merchant.ClientGetDetailGoodsList(Self, sMsg, nZz);
    end;
    ncode := 16;
  except
    on e: Exception do
    begin
      if bofind then
        MainOutMessage('TUserHumah.ClientUserBuyItem 摆摊人物:' +
          Tplayobject(nParam1).m_sCharName + 'wIdent = ' + IntToStr(nIdent) + ' code = ' +
          Inttostr(nCode))
      else
        MainOutMessage('TUserHumah.ClientUserBuyItem NPC名字' + Merchant.m_sCharName +
          'wIdent = ' + IntToStr(nIdent) + ' code = ' + Inttostr(nCode));
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

function TPlayObject.ClientDropGold(nGold: Integer): Boolean; //004C5BB0
begin
  Result := False;
  if g_Config.boInSafeDisableDrop and InSafeZone then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropInSafeZoneMsg);
    exit;
  end;

  if g_Config.boControlDropItem and (nGold < g_Config.nCanDropGold) then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropGoldMsg);
    exit;
  end;

  if not m_boCanDrop then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    exit;
  end;
  if nGold >= m_nGold then
    exit;
  Dec(m_nGold, nGold);
  if not DropGoldDown(nGold, False, nil, Self) then
    Inc(m_nGold, nGold);
  GoldChanged();
  Result := True;
end;

function TPlayObject.ClientDropItem(sItemName: string;      //004C5A2C
  nItemIdx: Integer): Boolean;
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
  sUserItemName                                        : string;
begin
  Result := False;
  { if not m_boClientFlag then begin
     if m_nStep = 8 then Inc(m_nStep)
     else m_nStep:=0;
   end;}

  if not m_boCanDrop then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotDropItemMsg);
    exit;
  end;

  if Pos(' ', sItemName) > 0 then
  begin //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sItemName, sItemName, [' ']);
  end;
  if (GetTickCount - m_DealLastTick) > 3000 then
  begin
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem = nil then
          Continue;
        //sItem:=UserEngine.GetStdItemName(UserItem.wIndex);
        //取自定义物品名称
        if stditem.StdMode = 52 then
        begin                                               //烟花物品
          SendRefMsg(rm_21295, 0, 0, 0, stditem.Shape, ''); //shape = 类型 1-12
          Dispose(UserItem);
          m_ItemList.Delete(i);
          Result := True;
          break;
        end;
        if g_Config.boInSafeDisableDrop and InSafeZone then
        begin                                               //如果安全区不能丢
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
            g_sCanotDropInSafeZoneMsg);
          exit;
        end;
        //////////////
        if (stditem.Reserved = 11) or (M_monitemmake = UserItem.MakeIndex) then
        begin                                               //   stditem.StdMode =49
          //  SendMsg(g_ManageNPC,RM_MENU_OK,0,Integer(Self),0,0,'该物品不能丢弃');
          SysMsg('该物品不能丢弃', c_Red, t_Hint);

          exit;
        end;
        //////////////

        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex,
            UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          if g_Config.boControlDropItem and (StdItem.Price < g_Config.nCanDropPrice) then
          begin
            Dispose(UserItem);
            m_ItemList.Delete(i);
            Result := True;
            break;
          end;
          if DropItemDown(UserItem, 1, False, nil, Self) then
          begin                                             //物品掉落在地上成功
            Dispose(UserItem);
            m_ItemList.Delete(i);

            Result := True;
            break;
          end;
        end;                                                //004C5B53
      end;
    end;
    if Result then
      WeightChanged();
  end;
end;

procedure TPlayObject.GoldChange(sChrName: string; nGold: Integer); //004CD844
var
  s10, s14                                             : string;
begin
  if nGold > 0 then
  begin
    s10 := '14';
    s14 := '增加完成';
  end
  else
  begin
    s10 := '13';
    s14 := '以删减';
  end;
  SysMsg(sChrName + ' 的金币 ' + IntToStr(nGold) + ' 金币' + s14, c_Green, t_Hint);
  //004CD97C
  if g_boGameLogGold then
    AddGameDataLog(s10 + #9 +
      m_sMapName + #9 +
      IntToStr(m_nCurrX) + #9 +
      IntToStr(m_nCurrY) + #9 +
      m_sCharName + #9 +
      sSTRING_GOLDNAME + #9 +
      IntToStr(nGold) + #9 +
      '1' + #9 +
      sChrName);
end;

//004D6758

//004C9C08

procedure TPlayObject.ClearStatusTime;
begin
  FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
end;

procedure TPlayObject.SendMapDescription;
var
  nMUSICID                                             : Integer;
begin
  nMUSICID := -1;
  if m_PEnvir.m_boMUSIC then
    nMUSICID := m_PEnvir.m_nMUSICID;

  SendDefMessage(SM_MAPDESCRIPTION, nMUSICID, 0, 0, 0, m_PEnvir.sMapDesc);
end;

procedure TPlayObject.SendNotice;                           //004DA490
var
  LoadList                                             : TStringList;
  i                                                    : integer;
  sNoticeMsg                                           : string;
begin
  if g_FunctionNPC <> nil then
    if g_FunctionNPC.GotoLable(self, '@Notice', False) then
      exit;
  LoadList := TStringList.Create;
  NoticeManager.GetNoticeMsg('Notice', LoadList);
  sNoticeMsg := '';
  for I := 0 to LoadList.Count - 1 do
  begin
    sNoticeMsg := sNoticeMsg + LoadList.Strings[i] + #$20#$1B;
  end;
  LoadList.Free;
  //  SendDefMessage(SM_SENDNOTICE,0,0,0,0,sNoticeMsg);
  SendDefMessage(SM_SENDNOTICE, 257, 38, 0, 0, sNoticeMsg);
end;

function TPlayObject.FindPetSell: TBaseObject;
var
  i                                                    : Integer;
  Pet                                                  : TBaseObject;
begin
  Result := nil;
  for i := 0 to UserEngine.m_PetSellList.Count - 1 do
  begin
    Pet := TBaseObject(UserEngine.m_PetSellList[i]);
    if Pet.m_PetSellCharName = m_sCharName then
    begin
      Pet.m_Master := Self;
      M_boPetOnSell := True;
      m_PetBaseObject := Pet;
      m_bohasMONSTORAGE := True;
      // M_MonPetColor:=Pet.M_MonPetColor;
      M_monstoragehuoli := Pet.M_monstoragehuoli;
      M_monstoragelevel := Pet.M_monstoragelevel;
      M_monSellitemmake := Pet.M_monitemmake;
      m_PetSellBaseObject := Pet;
      m_SlaveList.Add(Pet);
      SendPetInfo(M_monSellitemmake, 3);
      Break;
    end;
  end;

end;

procedure TPlayObject.RunNewMapEvent(x, y, nSign: Integer; sItemName: string);
var
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  i, nRate                                             : Integer;
  pNewMapEvent                                         : pTNewMapEvent;
begin
  if g_FunctionNPC = nil then exit;

  if m_PEnvir.GetMapCellInfo(X, Y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then
  begin
    for I := 0 to MapCellInfo.ObjList.Count - 1 do
    begin
      OSObject := MapCellInfo.ObjList.Items[i];
      if OSObject = nil then
        continue;
      if OSObject.btType = OS_NEWMAPEVENT then
      begin
        pNewMapEvent := pTNewMapEvent(OSObject.CellObj);
        if pNewMapEvent.btcondition <> nSign then Continue;
        if pNewMapEvent.boconditionGroup then
        begin
          if m_GroupOwner = nil then
            Continue;

        end;
        if (sItemName = pNewMapEvent.sConditionItem) or (pNewMapEvent.sConditionItem =
          '*') then
        begin

          nRate := Random(pNewmapevent.nRate);
          if (nRate <= pNewmapevent.nRate) then
          begin
            if pNewmapevent.sLabel <> '' then
              g_FunctionNPC.GotoLable(Self, pNewmapevent.sLabel, false);
          end;
        end;
      end;
    end;
  end;
end;

procedure TPlayObject.GetPetSell(ntype: Byte);
var
  I, ii, icount                                        : Integer;
  UserItem                                             : PTUserItem;
  Item                                                 : pTStdItem;
  pPetSell                                             : pTPetSellInfo;
begin
  //检测摆摊豹子
  for i := g_PetSellInfo.Count - 1 downto 0 do
  begin
    pPetSell := pTpetSellInfo(g_PetSellInfo[i]);
    if (pPetSell.sMasterName = m_sCharName) then
    begin
      iCOunt := pPetSell^.nSellItemCount;
      case nType of
        0:                                                  //取回钱物
          begin
            m_nGameGold := m_nGameGold + pPetSell^.nSellYuanBao;
            m_nGold := m_nGold + pPetSell^.nSellGold;
            pPetSell^.nSellGold := 0;
            pPetSell^.nSellYuanBao := 0;
            GoldChanged;
            SendGoldInfo(False);
          end;
        1:                                                  //取回物品
          begin

            if icount > 10 then Continue;
            for ii := pPetSell^.nSellItemCount - 1 downto 0 do
            begin
              if IsEnoughBag then
              begin
                Item := UserEngine.GetStdItem(pPetSell^.nSellItem[ii].wIndex);
                if (Item <> nil) then
                begin
                  New(UserItem);
                  UserItem^ := pPetSell^.nSellItem[ii];
                  m_ItemList.Add(UserItem);
                  SendAddItem(UserItem);
                end;
                Dec(icount);

              end;
            end;

          end;
      end;
      pPetSell^.nSellItemCount := iCOunt;
      if (pPetSell.nSellItemCount = 0) and (pPetSell.nSellGold = 0) and
        (pPetSell.nSellYuanBao = 0) then
      begin
        g_PetSellInfo.Delete(i);
        Dispose(pPetSell);
      end;
      //            Break;
    end;

  end;
end;

procedure TPlayObject.UserLogon;                            //004C9C24
type
  TGetLicense = function(var nDay: Integer; var nM2Crc: Integer): Integer; stdcall;
var
  nDay, fenghaolevel                                   : Integer;
  nM2Crc                                               : Integer;
  nUserCount                                           : Integer;
  I                                                    : Integer;
  II                                                   : Integer;
  UserItem                                             : PTUserItem;
  UserItem1                                            : PTUserItem;
  StdItem                                              : PTStdItem;
  s14                                                  : string;
  sItem                                                : string;
  sIPaddr                                              : string;
  hum                                                  : TplayObject;
  pPetSell                                             : pTPetSellInfo;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::UserLogon';
  sCheckIPaddrFail                                     = '登录IP地址不匹配！！！';
begin
  nUserCount := 0;
  nDay := 0;
  nM2Crc := 0;
  sIPaddr := '';
  try
    if m_nSoftVersionDateEx <> 0 then
      SendDefMessage(38289, Integer(Self), 0, 0, 0, '1, 9, 7, 9')
    else
      SendDefMessage(38289, Integer(Self), 0, 0, 0, '1, 9, 7, 9');
    //   SendDefMessage(38289, Integer(Self), 0, 0, 0, '1, 9, 6, 5');

    begin
      if g_Config.boTestServer then
      begin
        if m_Abil.Level < g_Config.nTestLevel then
          m_Abil.Level := g_Config.nTestLevel;
        if m_nGold < g_Config.nTestGold then
          m_nGold := g_Config.nTestGold;
      end;                                                  //004C9C99
    end;

    if g_Config.boTestServer or (g_Config.boServiceMode) then
      m_nPayMent := 3;
    m_dwMapMoveTick := GetTickCount();
    m_dLogonTime := Now();
    m_dwLogonTick := GetTickCount();
    Initialize();                                           //004C9CE8
    // SendMsg(Self,RM_LOGON,0,0,0,0,'');   //登陆消息
    if m_Abil.Level <= 7 then
    begin
      if GetRangeHumanCount >= 80 then
      begin
        MapRandomMove(m_PEnvir.sMapName, 0);
      end;
    end;                                                    //004C9D32

    if m_boDieInFight3Zone then
    begin
      MapRandomMove(m_PEnvir.sMapName, 0);
    end;

    if UserEngine.GetHumPermission(m_sCharName, sIPaddr, m_btPermission) then
    begin

      if not CompareIPaddr(m_sIPaddr, sIPaddr) then
      begin
        SysMsg(sCheckIPaddrFail, c_Red, t_Hint);
        m_boEmergencyClose := True;
      end;

    end;

    GetStartPoint();

    for i := 0 to m_MagicList.Count - 1 do
    begin
      sub_4C713C(pTUserMagic(m_MagicList.Items[i]));
    end;

    if m_boNewHuman then
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sCandle, UserItem) then
      begin
        m_ItemList.Add(UserItem);
      end
      else
        Dispose(UserItem);
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sBasicDrug, UserItem) then
      begin
        m_ItemList.Add(UserItem);
      end
      else
        Dispose(UserItem);
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sWoodenSword, UserItem) then
      begin
        m_ItemList.Add(UserItem);
      end
      else
        Dispose(UserItem);

      New(UserItem);
      if m_btGender = 0 then
        sItem := g_Config.sClothsMan
      else
        sItem := g_Config.sClothsWoman;

      if UserEngine.CopyToUserItemFromName(sItem, UserItem) then
      begin
        m_ItemList.Add(UserItem);
      end
      else
        Dispose(UserItem);
    end;                                                    //004C9F44

    //检查背包中的物品是否合法

    for I := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := pTuserItem(m_ItemList.Items[I]);
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);    //要带上的物品

      if (StdItem = nil) or ((StdItem.Reserved and 8) <> 0) then //上线必需消失
      begin
        Dispose(PTUserItem(m_ItemList.Items[I]));
        m_ItemList.Delete(I);
      end;
    end;

    //004C9FB8

    if btLXBHCount > 0 then
    begin
      SendLXBHInfo();
    end;
    if btLXBHItemCount > 0 then
    begin
      SendLXBHInfo(1);
    end;
    //  if btAdditionalAbil[2]>0 then
    SendYuanYingInfo;
    //004C9FBD
    //检查人物身上的物品是否符合使用规则
    if g_Config.boCheckUserItemPlace then
    begin
      for I := Low(THumanUseItems) to High(THumanUseItems) do
      begin
        if m_UseItems[I].wIndex > 0 then
        begin
          StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
          if StdItem <> nil then
          begin
            if not CheckUserItems(I, StdItem) then
            begin
              New(UserItem);
              UserItem^ := m_UseItems[I];
              if not AddItemToBag(UserItem) then
              begin
                m_ItemList.Insert(0, UserItem);
              end;
              m_UseItems[I].wIndex := 0;
            end;
          end
          else
            m_UseItems[I].wIndex := 0;
        end;
      end;                                                  //004CA06D
    end;

    //检查背包中是否有复制品
    for I := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[I];
      s14 := UserEngine.GetStdItemName(UserItem.wIndex);
      {  if UserItem.Dura=0 then
        begin
          Dispose(PTUserItem(m_ItemList.Items[i]));
           m_ItemList.Delete(i);
           Continue;
        end;   }
      for ii := I - 1 downto 0 do
      begin
        UserItem1 := m_ItemList.Items[ii];
        if ((UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
          (UserItem.MakeIndex = UserItem1.MakeIndex)) then
        begin
          Dispose(PTUserItem(m_ItemList.Items[ii]));        //hint 内存释放问题
          m_ItemList.Delete(ii);
          break;
        end;
      end;
    end;
    m_nItemUnitIndex := GetItemUnitIndex;
    //004CA149
    for i := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do
    begin
      if m_wStatusTimeArr[i] > 0 then
        m_dwStatusArrTick[i] := GetTickCount();
    end;
    //004CA177
    m_nCharStatus := GetCharStatus();
    RecalcLevelAbilitys();
    RecalcAbilitys();
    m_Abil.MaxExp := GetLevelExp(m_Abil.Level);

    //GetPetSell ;
    FindPetSell;
    SendDefMessage(816, 0, 29, 0, 0, '');
    if (m_nGold > g_Config.nHumanMaxGold * 2) and (g_Config.nHumanMaxGold > 0) then
      m_nGold := g_Config.nHumanMaxGold * 2;
    if not bo6AB then
    begin
      if (m_nSoftVersionDate < g_Config.nSoftVersionDate) then
      begin
        SysMsg(sClientSoftVersionError, c_Red, t_Hint);
        SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
        SysMsg(sForceDisConnect, c_Red, t_Hint);
        m_boEmergencyClose := True;
        exit;
      end;
      if sYsnameMaster = '' then
      begin                                                 //如果是人物
        if m_btRaceServer = RC_PLAYOBJECT then
          SaveToPlayList(self);                             //处理人物到 TOPPLAYLIST
        case m_btAttatckMode of
          HAM_ALL: SysMsg(sAttackModeOfAll, c_Green, t_Hint); //[攻击模式: 全体攻击]
          HAM_PEACE: SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint);  //[攻击模式: 和平攻击]
          HAM_DEAR: SysMsg(sAttackModeOfDear, c_Green, t_Hint); //[攻击模式: 和平攻击]
          HAM_MASTER: SysMsg(sAttackModeOfMaster, c_Green, t_Hint); //[攻击模式: 和平攻击]
          HAM_GROUP: SysMsg(sAttackModeOfGroup, c_Green, t_Hint); //[攻击模式: 编组攻击]
          HAM_GUILD: SysMsg(sAttackModeOfGuild, c_Green, t_Hint); //[攻击模式: 行会攻击]
          HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint);  //[攻击模式: 红名攻击]
        end;

        SysMsg(sStartChangeAttackModeHelp, c_Green, t_Hint);  //使用组合快捷键 CTRL-H 更改攻击...
        if g_Config.boTestServer then
          SysMsg(sStartNoticeMsg, c_Green, t_Hint);         //欢迎进入本服务器进行游戏...
        if UserEngine.PlayObjectCount > g_Config.nTestUserLimit then
        begin
          if m_btPermission < 2 then
          begin
            SysMsg(sOnlineUserFull, c_Red, t_Hint);
            SysMsg(sForceDisConnect, c_Red, t_Hint);
            m_boEmergencyClose := True;
          end;
        end;
      end;                                                  //如果是人物
      //004CA344

    end;
    m_nBright := g_nGameTime;
    m_Abil.MaxExp := GetLevelExp(m_Abil.Level); //jacky 2004/09/15 登录重新取得升级所需经验值

    SendMsg(Self, RM_LOGON, 0, 0, 0, 0, m_sMapName);        // ''  显示地图

    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SENDUSEITEMS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');

    //  ClientQueryBagItems();      //hint 增加发送背包
    FeatureChanged();                                       //增加，广播人物骑马信息
    if sYsnameMaster <> '' then
      SendMsg(Self, RM_YSStart, 0, 0, 0, 0, '');

    m_MyGuild := g_GuildManager.MemberOfGuild(m_sCharName);
    if m_MyGuild <> nil then
    begin
      m_sGuildRankName := TGuild(m_MyGuild).GetRankName(Self, m_nGuildRankNo);
      for I := 0 to TGuild(m_MyGuild).GuildWarList.Count - 1 do
      begin
        SysMsg(TGuild(m_MyGuild).GuildWarList.Strings[i] + ' 正在与本行会进行行会战。',
          c_Green, t_Hint);
      end;
    end;
    RefShowName();

    if sYsnameMaster = '' then
    begin                                                   //如果不是元神。
      if (m_nPayMent = 1) then
      begin
        if not bo6AB then
          SysMsg(sYouNowIsTryPlayMode, c_Red, t_Hint);
        //    m_nGoldMax:=100000;
        m_nGoldMax := g_Config.nHumanTryModeMaxGold;
        if m_Abil.Level > g_Config.nTryModeLevel then
        begin
          SysMsg('测试状态可以使用到第 ' + IntToStr(g_Config.nTryModeLevel) + ' 级。',
            c_Red, t_Hint);
          SysMsg('链接中断，请冲值！', c_Red, t_Hint); //请到以下地址获得收费相关信息。(http://www.gameofmir.com)
          m_boEmergencyClose := True;
        end;
      end;                                                  //004CA4FA
      if (m_nPayMent = 3) and not bo6AB then
      begin
        //  SysMsg(g_sNowIsFreePlayMode{'当前服务器运行于测试模式.'},c_Green,t_Hint);
      end;
      if g_Config.boVentureServer then
        SysMsg('当前服务器运行于Venture Mode.', c_Green, t_Hint);
    end;

    if (m_MagicErgumSkill <> nil) and (not m_boUseThrusting) then
    begin
      m_boUseThrusting := True;
      SendSocket(nil, '+LNG');
    end;
    if m_PEnvir.m_boNORECONNECT then
      MapRandomMove(m_PEnvir.sNoReconnectMap, 0);

    if CheckDenyLogon() then
      exit; //如果人物在禁止登录列表里则直接掉线而不执行下面内容
    if sYsnameMaster = '' then
    begin                                                   //如果不是元神。
      if g_ManageNPC <> nil then
      begin
        g_ManageNPC.GotoLable(Self, '@Initialize', False);
        g_ManageNPC.GotoLable(Self, '@Login', False);
      end;
    end
    else
    begin
      if g_ManageNPC <> nil then
      begin
        bocanhcall := True;
        g_ManageNPC.GotoLable(Self, '@Initialize', False);

        g_ManageNPC.GotoLable(Self, '@Login', False);
        bocanhcall := False;
        m_sfenghao := '九千九百九十九界';
      end;
      fenghaolevel := makeword(8, m_nfenghaolevel);
      SendMsg(Self, RM_MAGADDABILTY, 0, fenghaolevel, 0, 0, #$A1#$A1);  //  //显示封号   和翅膀
    end;
    //  Tbaseobject(ProcessMsg.BaseObject).SendRefMsg(RM_MAGADDABILTY,0,$108,0,0, Tbaseobject(ProcessMsg.BaseObject).m_sRankLevelName);
    //  format(m_sRankLevelName,[m_sCharName])
    if m_sfenghao <> '' then
    begin
      fenghaolevel := makeword(8, m_nfenghaolevel);
      SendMsg(Self, RM_MAGADDABILTY, 0, fenghaolevel, 0, 0, m_sfenghao);  //  //显示封号   和翅膀
    end;

    m_boFixedHideMode := False;                             //01/21 增加

    m_boFilterSendMsg := GetDisableSendMsgList(m_sCharName);

    //密码保护系统
    if sYsnameMaster = '' then
    begin                                                   //如果不是元神。
      if g_Config.boPasswordLockSystem then
      begin
        if m_boPasswordLocked then
        begin
          m_boCanGetBackItem := not g_Config.boLockGetBackItemAction;
        end;

        if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked then
        begin
          m_boCanDeal := not g_Config.boLockDealAction;
          m_boCanDrop := not g_Config.boLockDropAction;
          m_boCanUseItem := not g_Config.boLockUserItemAction;
          m_boCanWalk := not g_Config.boLockWalkAction;
          m_boCanRun := not g_Config.boLockRunAction;
          m_boCanHit := not g_Config.boLockHitAction;
          m_boCanSpell := not g_Config.boLockSpellAction;
          m_boCanSendMsg := not g_Config.boLockSendMsgAction;
          m_boObMode := g_Config.boLockInObModeAction;
          m_boAdminMode := g_Config.boLockInObModeAction;

          SysMsg(g_sActionIsLockedMsg + ' 开锁命令: @' + g_GameCommand.LOCKLOGON.sCmd,
            c_Red, t_Hint);
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sActionIsLockedMsg +
            #13#10
            + '密码命令: @' + g_GameCommand.PASSWORDLOCK.sCmd);
        end;
        if not m_boPasswordLocked then
        begin
          //    SysMsg(format(g_sPasswordNotSetMsg,[g_GameCommand.PASSWORDLOCK.sCmd]) ,c_Red,t_Hint);
        end;
        if not m_boLockLogon and m_boPasswordLocked then
        begin
          SysMsg(format(g_sNotPasswordProtectMode, [g_GameCommand.LOCKLOGON.sCmd]),
            c_Red, t_Hint);
        end;

      end;
    end;                                                    //不是元神

    nUserCount := 2000;                                     //允许人数

    if sYsnameMaster <> '' then
    begin                                                   //如果是元神
      // hum:=nil;
     //  hum:=UserEngine.GetPlayObjectEx(sYsnameMaster);
      hum := self.ysmasterplayer;
      if hum <> nil then
      begin
        m_btAttatckMode := hum.m_btAttatckMode;
        m_MyGuild := hum.m_MyGuild;
        m_GroupOwner := hum.m_GroupOwner;
      end;
    end;
    if (m_PEnvir <> nil) and (m_boReOnLine) then
      SpaceMove(m_PEnvir.sMapName, m_nCurrX, m_nCurrY, 1);

    if UserEngine.PlayObjectCount > nUserCount then
    begin
      if m_btPermission < 10 then
      begin
        SysMsg(sOnlineUserFull, c_Red, t_Hint);
        SysMsg(sForceDisConnect, c_Red, t_Hint);
        m_boEmergencyClose := True;
      end;
    end;
    //重置泡点方面计时
    m_dwIncGamePointTick := GetTickCount();
    m_dwIncGameGoldTick := GetTickCount();
    m_dwAutoGetExpTick := GetTickCount();

  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg);
      MainOutMessage(E.Message);

    end;

  end;

end;

procedure TPlayObject.ReadAllBook();
var
  I                                                    : Integer;
  Magic                                                : pTMagic;
  UserMagic                                            : pTUserMagic;
begin
  UserMagic := nil;
  Magic := nil;
  for I := 0 to UserEngine.m_MagicList.Count - 1 do
  begin
    Magic := UserEngine.m_MagicList.Items[I];
    New(UserMagic);
    UserMagic.MagicInfo := Magic;
    UserMagic.wMagIdx := Magic.wMagicId;
    UserMagic.btLevel := 2;
    UserMagic.btKey := 0;
    UserMagic.btLevel := 0;
    UserMagic.nTranPoint := 100000;
    m_MagicList.Add(UserMagic);
    SendAddMagic(UserMagic);
  end;
end;

procedure TPlayObject.SendGoldInfo(boSendName: Boolean);
var
  sMsg                                                 : string;
begin

  if boSendName then
    sMsg := g_Config.sGameGoldName + #13 + g_Config.sGamePointName;

  SendDefMessage(keyStringType.VARSM_GAMEGOLDNAME, //str_toint(myMuldecodeString(keystring.SM_GAMEGOLDNAME,Str_ToInt(arrip[10],0)),0),             //
    m_nGameGold,
    LoWord(m_nGamePoint),
    HiWord(m_nGamePoint),
    0,
    sMsg);

end;

procedure TPlayObject.SendLogon;                            //004D677C
var
  MessageBodyWL                                        : TMessageBodyWL;
  nRecog, ndreshape                                    : Integer;
  StdItem                                              : pTStdItem;
  horsename, smapname, susername                       : string;
  mobhorse                                             : Tbaseobject;
  msgcode                                              : Integer;
begin
  if not m_boLoginNoticeOK then
  begin
    m_DefMsg := MakeDefaultMsg(SM_NEWMAP, Integer(Self), m_nCurrX, m_nCurrY, 0);
    if m_PEnvir.mirrorname = '' then
      smapname := m_PEnvir.sMapName
    else
      smapname := m_PEnvir.mirrorname;                      //地图镜像
    SendSocket(@m_DefMsg, EncodeString(smapname));          // m_sMapName
    SendDefMessage(3032, 0, 0, 0, 30, 'u]evuASl@vfmvvTEzpUrlqYqplUtrq@urqfzvvfu', True);
    m_DefMsg := MakeDefaultMsg(keyStringType.VARSM_LOGON, //str_toint( myMuldecodeString( keystring.SM_LOGON,Str_ToInt(arrip[5],0))
      Integer(Self), m_nCurrX, m_nCurrY, MakeWord(m_btDirection, m_btGender));  //hint  m_btGender 性别

    ClientOpenSHOP(1, '');

    MessageBodyWL.lParam1 := GetFeatureToLong();
    MessageBodyWL.lParam2 := m_nCharStatus;
    if m_boAllowGroup then
      MessageBodyWL.lTag1 := MakeLong(MakeWord(1, 0), GetFeatureEx)
    else
      MessageBodyWL.lTag1 := 0;
    MessageBodyWL.lTag2 := 0;                               //hint
    SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));

    susername := GetShowName;
    if sYsnameMaster <> '' then
      SendDefMessage(SM_USERNAME,
        Integer(self),
        GetCharColor(self),
        0,
        0,
        EncodeString(susername))

    else
      SendDefMessage(SM_USERNAME,
        Integer(self),
        GetCharColor(self),
        0,
        0,
        susername);                                         // EncodeString (susername)

    nRecog := GetFeatureToLong();

    ndreshape := GetDress;

    m_DefMsg := MakeDefaultMsg(keyStringType.varSM_FEATURECHANGED,
      Integer(Self),
      LoWord(nRecog),
      HiWord(nRecog),
      GetFeatureEx);
    SendSocket(@m_DefMsg, encodebuffer(@ndreshape, 4));

    { SendDefMessage(SM_FEATURECHANGED,
                                Integer(Self),
                                LoWord(nRecog),
                                HiWord(nRecog),
                                GetFeatureEx,
                                encodebuffer(@ndreshape,4));   }
    exit;
  end;                                                      // if not m_boLoginNoticeOK
  CheckHorse;
  m_boHavebeArp := false;
  m_boAllowfriend := true;

  if not (m_bMaxBagitem in [46, 66]) then
    m_bMaxBagitem := 46;
  if sYsnameMaster <> '' then
    m_bMaxBagitem := 40;                                    //如果是元神

  SendDefMessage(38292, Integer(Self), 0, m_bMaxBagitem, 0, ''); //包裹容量
  //  SendDefMessage(3040, Integer(Self), 0, 0, 0, ''); //1.950新增加
  SendDefMessage(38291, Integer(Self), 1, 0, 0, '');        //1.950新增加
  SendDefMessage(38291, Integer(Self), 2, 0, 0, '');        //1.950新增加
  //    SendDefMessage(38291, Integer(Self),4, 0, 0, ''); //1.950新增加
  if Checkhuanying then
  begin
    if not m_bohashuanying then
      SendRefMsg(RM_21292, 0, 16, 2, 0,
        '你已拥有幻影全套，内蕴的仙灵之力将提升你的反应能力……');
    m_bohashuanying := true;
    m_btSpeedPoint := m_btSpeedPoint + 3
  end;                                                      //幻影效果开始

  if Checkhuancai then
  begin
    if not m_bohashuancai then
      SendRefMsg(RM_21292, 0, 16, 1, 0,
        '你已拥有幻彩全套，内蕴的仙灵之力将提升你的生命上限……');
    m_bohashuancai := true;
    m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_WAbil.Level + 10);
  end;                                                      //幻彩效果开始

  SendDefMessage(38291, Integer(Self), 4, 0, 0, m_sSytleName); //个性化签名

  //  SendDefMessage(510,Integer(Self),1, 0, 32, '');
   //  SendRefMsg(RM_510,0, 1 ,0,32,'');

  //  SendDefMessage(38289,Integer(Self),0, 0, 0, '1,8,0,8');       //解决4格显示问题

  ClientQueryBagItems();                                    //hint 增加发送背包
  SendBagPos();
  msgcode := 38000;
  if sYsnameMaster = '' then
  begin
    SendDefMessage(100, 0, msgcode + 656, 10, 768, '本服务器端采用夕阳引擎V2.0'); //广告
    sendTaskInfo();
  end;
  if m_wStatusTimeArr[STATE_14] > 0 then
  begin
    m_boAbilMagzqDefence := true;
    SendRefMsg(RM_29, 0, m_wStatusTimeArr[STATE_14], 100, 154, ''); //广播护身真气状态
  end;

end;

procedure TPlayObject.SendServerConfig;
var
  nRecog, nParam                                       : Integer;
  nRunHuman, nRunMon, nRunNpc, nWarRunAll              : Integer;
  ClientConf                                           : TClientConf;
  sMsg                                                 : string;
begin
  //  if m_nSoftVersionDateEx = 0 then
  exit;

  nRunHuman := 0;
  nRunMon := 0;
  nRunNpc := 0;
  nWarRunAll := 0;

  if g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) then
  begin
    nRunHuman := 1;
    nRunMon := 1;
    nRunNpc := 1;
    nWarRunAll := 1;
  end
  else
  begin
    if g_Config.boRunHuman or m_PEnvir.m_boRUNHUMAN then
      nRunHuman := 1;
    if g_Config.boRunMon or m_PEnvir.m_boRUNMON then
      nRunMon := 1;
    if g_Config.boRunNpc then
      nRunNpc := 1;
    if g_Config.boWarDisHumRun then
      nWarRunAll := 1;

  end;
  ClientConf := g_Config.ClientConf;

  ClientConf.boRunHuman := nRunHuman = 1;
  ClientConf.boRunMon := nRunMon = 1;
  ClientConf.boRunNpc := nRunNpc = 1;
  ClientConf.boWarRunAll := nWarRunAll = 1;
  ClientConf.wSpellTime := g_Config.dwMagicHitIntervalTime + 300;
  ClientConf.wHitIime := g_Config.dwHitIntervalTime + 500;

  sMsg := EncodeBuffer(@ClientConf, SizeOf(ClientConf));
  nRecog := MakeLong(MakeWord(nRunHuman, nRunMon), MakeWord(nRunNpc, nWarRunAll));
  nParam := MakeWord(5, 0);
  SendDefMessage(SM_SERVERCONFIG, nRecog, nParam, 0, 0, sMsg);
end;

procedure TPlayObject.SendServerStatus;
begin
  if m_btPermission < 10 then
    exit;
  SysMsg(IntToStr(CalcFileCRC(Application.ExeName)), c_Red, t_Hint);
end;
//检查角色的座标是否在指定误差范围以内
//TargeTBaseObject 为要检查的角色，nX,nY 为比较的座标
//检查角色是否在指定座标的1x1 范围以内，如果在则返回True 否则返回 False

function TPlayObject.CretInNearXY(TargeTBaseObject: TBaseObject; nX,
  nY: Integer): Boolean;                                    //004C36CC
var
  I                                                    : Integer;
  nCX, nCY                                             : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  BaseObject                                           : TBaseObject;
begin
  Result := False;
  if m_PEnvir = nil then
  begin
    MainOutMessage('CretInNearXY nil PEnvir');
    exit;
  end;

  for nCX := nX - 2 to nX + 2 do
  begin
    for nCY := nY - 2 to nY + 2 do
    begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil)
        then
      begin
        for I := 0 to MapCellInfo.ObjList.Count - 1 do
        begin
          OSObject := MapCellInfo.ObjList.Items[i];
          if OSObject = nil then
            continue;
          if OSObject.btType = OS_MOVINGOBJECT then
          begin
            BaseObject := TBaseObject(OSObject.CellObj);
            if BaseObject <> nil then
            begin
              if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject) then
              begin
                Result := True;
                exit;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

function TPlayObject.CretInNearhum(TargeTBaseObject: TBaseObject; nX,
  nY: Integer): Boolean;                                    //004C36CC
var
  I                                                    : Integer;
  nCX, nCY                                             : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  BaseObject                                           : TBaseObject;
begin
  Result := False;
  if m_PEnvir = nil then
  begin
    MainOutMessage('CretInNearXY nil PEnvir');
    exit;
  end;

  for nCX := nX - 10 to nX + 10 do
  begin
    for nCY := nY - 10 to nY + 10 do
    begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil)
        then
      begin
        for I := 0 to MapCellInfo.ObjList.Count - 1 do
        begin
          OSObject := MapCellInfo.ObjList.Items[i];
          if OSObject = nil then
            continue;
          if OSObject.btType = OS_MOVINGOBJECT then
          begin
            BaseObject := TBaseObject(OSObject.CellObj);
            if BaseObject <> nil then
            begin
              if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject) then
              begin
                Result := True;
                exit;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

function TPlayObject.ISsomeOneInNearXY(nX, nY: Integer): Boolean; //004C36CC
var
  I                                                    : Integer;
  nCX, nCY                                             : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  BaseObject                                           : TBaseObject;
begin
  Result := False;
  if m_PEnvir = nil then
  begin
    MainOutMessage('CretInNearXY nil PEnvir');
    exit;
  end;

  for nCX := nX - 1 to nX + 1 do
  begin
    for nCY := nY - 1 to nY + 1 do
    begin
      if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and (MapCellInfo.ObjList <> nil)
        then
      begin
        for I := 0 to MapCellInfo.ObjList.Count - 1 do
        begin
          OSObject := MapCellInfo.ObjList.Items[i];
          if OSObject = nil then
            continue;
          if OSObject.btType = OS_MOVINGOBJECT then
          begin
            BaseObject := TBaseObject(OSObject.CellObj);
            if (BaseObject <> nil) and (BaseObject <> TBaseObject(self)) and
              (BaseObject.m_master <> Self) then
            begin
              if not BaseObject.m_boGhost then
              begin
                Result := True;
                exit;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

//004D112C

procedure TPlayObject.SendUseitems;
var
  i, ii, jj                                            : Integer;
  Item                                                 : pTStdItem;
  sSendMsg                                             : string;
  ClientItem                                           : TClientItem;

  StdItem                                              : TStdItem;
  sUserItemName                                        : string;
  csitem                                               : TcsClientItem;

  body                                                 : array[0..10000] of char;
  magicBody                                            : array[0..10000] of Char;

begin

  begin
    sSendMsg := '';
    ii := 0;
    jj := 0;
    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin //hint     I := Low(THumItems) to High(THumItems)
      if m_UseItems[i].wIndex > 0 then
      begin
        Item := UserEngine.GetStdItem(m_UseItems[i].wIndex);
        if Item <> nil then
        begin
          StdItem := Item^;
          ItemUnit.GetItemAddValue(@m_UseItems[i], StdItem);
          ClientItem.S := StdItem;

          //取自定义物品名称
          sUserItemName := '';
          if m_UseItems[i].btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[i].MakeIndex,
              m_UseItems[i].wIndex);
          ClientItem.DarkProperty := m_UseItems[i].DarkProp;  // ItemUnit.GetItemDarkProperty(m_UseItems[i].MakeIndex, m_UseItems[i].wIndex);
          if sUserItemName <> '' then
            ClientItem.S.Name := sUserItemName;
          ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
          ClientItem.Dura := m_UseItems[i].Dura;
          ClientItem.DuraMax := m_UseItems[i].DuraMax;
          ClientItem.MakeIndex := m_UseItems[i].MakeIndex;

          csitem.id := i;                                   //makeword(i,0) ;
          csitem.item := ClientItem;
          //附魔
          if m_UseItems[i].AttachMagic.MakeIndex > 0 then
          begin

            CopyMemory(@Magicbody[SizeOf(TAttachMagicRCD1) * jj],
              @m_UseItems[i].AttachMagic.aaa, SizeOf(TAttachMagicRCD1));
            Inc(jj);
          end;
          //   sSendMsg := sSendMsg + EncodeBuffer(@csitem, SizeOf(TcsClientItem)); //hint 发送身上装备
          copymemory(@body[SizeOf(TcsClientItem) * ii], @csitem, SizeOf(TcsClientItem));
          Inc(ii);

        end;
      end;
    end;
    if ii >= 1 then
      sSendMsg := EncodeBuffer(@body, SizeOf(TcsClientItem) * ii);

    if sSendMsg <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(SM_SENDUSEITEMS, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSendMsg);
    end;
    if jj >= 1 then
    begin
      sSendMsg := EncodeBuffer(@Magicbody, SizeOf(TAttachMagicRCD1) * jj);
      m_DefMsg := MakeDefaultMsg(207, //str_toint( myMuldecodeString(keystring.SM_BAGITEMS,Str_ToInt(arrip[7],0))                        //
        Integer(Self), 40, 0, jj);
      SendSocket(@m_DefMsg, sSendMsg);
    end;

  end;
end;

procedure TPlayObject.SendUseMagic;                         //004D1418
var
  I, II                                                : Integer;
  sSendMsg                                             : string;
  UserMagic                                            : pTUserMagic;
  ClientMagic                                          : TClientMagic;
  body                                                 : array[0..10000] of char;
begin
  fillchar(body, sizeof(body), #0);
  sSendMsg := '';
  II := 0;
  for I := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[I];
    ClientMagic.Key := Chr(UserMagic.btKey);
    ClientMagic.bt1 := $28;
    ClientMagic.bt2 := $01;
    ClientMagic.Level := UserMagic.btLevel;
    ClientMagic.CurTrain := UserMagic.nTranPoint;
    ClientMagic.Def := UserMagic.MagicInfo^;
    if ClientMagic.Level >= 3 then
    begin
      ClientMagic.CurTrain := ClientMagic.Def.MaxTrain[3];
      ClientMagic.Def.TrainLevel[4] := $44;
      ClientMagic.Def.TrainLevel[5] := $65;

    end;
    ClientMagic.Def.btDesc[3] := 1;
    ClientMagic.Def.btDesc[7] := $1D;
    ClientMagic.Def.btDesc[9] := 2;
    ClientMagic.Def.btLenvel := UserMagic.btLevel;
    //  sSendMsg:=sSendMsg + EncodeBuffer(@ClientMagic,SizeOf(TClientMagic)) + '/';      //hint
    copymemory(@body[SizeOf(TClientMagic) * II], @ClientMagic, SizeOf(TClientMagic));
    INC(II);
  end;
  if II >= 1 then
    sSendMsg := EncodeBuffer(@body, SizeOf(TClientMagic) * II);

  if sSendMsg <> '' then
  begin
    m_DefMsg := MakeDefaultMsg(keyStringType.VARSM_SENDMYMAGIC,  //  str_toint(myMuldecodeString( keystring.SM_SENDMYMAGIC,Str_ToInt(arrip[9],0)),0)
      0, 0, 0, m_MagicList.Count);                          //hint
    SendSocket(@m_DefMsg, sSendMsg);
  end;
end;

function TPlayObject.ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var
  dwDelayTime: LongWord): Boolean;                            //4CAEB8
var
  dwCheckTime                                          : LongWord;
begin
  Result := False;
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) then
    exit;                                                   //防麻
  if not CheckActionStatus(wIdent, dwDelayTime) then
  begin
    m_boFilterAction := False;
    exit;
  end;
  m_boFilterAction := True;
  dwCheckTime := GetTickCount - m_dwTurnTick;
  if dwCheckTime < g_Config.dwTurnIntervalTime then
  begin
    dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
    {
    if dwCheckTime <= g_Config.dwTurnIntervalTime div 2 then begin
      SysMsg('ClientChangeDir ' + IntToStr(dwCheckTime);
      m_boEmergencyClose:=True;
      Result:=True;
    end;
    }
    exit;
  end;

  if (nX = m_nCurrX) and (nY = m_nCurrY) then
  begin
    m_btDirection := nDir;
    if Walk(RM_TURN) then
    begin
      m_dwTurnTick := GetTickCount();
      Result := True;
    end;
  end;
end;

function TPlayObject.ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime: LongWord):
  Boolean;                                                    //004CC248
var
  dwCheckTime                                          : LongWord;
begin
  //SetProcessName('TPlayObject.ClientSitDownHit');
  Result := False;
  if m_boDeath or (m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) then
    exit;                                                   //防麻

  dwCheckTime := GetTickCount - m_dwTurnTick;

  if dwCheckTime < g_Config.dwTurnIntervalTime then
  begin
    dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
    exit;
  end;
  m_dwTurnTick := GetTickCount;
  SendRefMsg(RM_POWERHIT, 0, 0, 0, 0, '');
  Result := True;
end;

procedure TPlayObject.ClientOpenDoor(nX, nY: Integer);      //004DABD4
var
  Door                                                 : pTDoorInfo;
  Castle                                               : TUserCastle;
begin
  Door := m_PEnvir.GetDoor(nX, nY);
  if Door = nil then
    exit;
  Castle := g_CastleManager.IsCastleEnvir(m_PEnvir);
  if (Castle = nil) or
    (Castle.m_DoorStatus <> Door.Status) or
    (m_btRaceServer <> RC_PLAYOBJECT) or
    Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then
  begin

    UserEngine.OpenDoor(m_PEnvir, nX, nY);
  end;
  {
  if (UserCastle.m_MapCastle <> m_PEnvir) or
     (UserCastle.m_DoorStatus <> Door.Status) or
     (m_btRaceServer <> RC_PLAYOBJECT) or
     UserCastle.CheckInPalace(m_nCurrX,m_nCurrY,Self) then begin

    UserEngine.OpenDoor(m_PEnvir,nX,nY);
  end;
  }
end;

procedure TPlayObject.ClientTakeOnItems(btWhere: Byte; nItemIdx: integer; sItemName:
  string; boNpc: Boolean = false);                            //004DAC70
var
  I, n14, n18                                          : Integer;
  UserItem, TakeOffItem                                : pTUserItem;
  StdItem, Takeoffstditem, StdItem20                   : pTStdItem;
  StdItem58                                            : TStdItem;
  sUserItemName                                        : string;
  horsename                                            : string;
  baseobject                                           : TBaseobject;
  ntype                                                : integer;
  nhashousepai                                         : integer;
  foundItem                                            : boolean;
  pUnit_Item                                           : pTUnit_Item;
  //  horseitem:pTStdItem;
label
  FailExit;

begin
  StdItem := nil;
  UserItem := nil;
  n14 := -1;
  foundItem := false;
  sItemName := FilterItemName(sItemName);
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
    begin
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := FilterItemName(UserEngine.GetStdItemName(UserItem.wIndex));

      StdItem := UserEngine.GetStdItem(UserItem.wIndex);    //要带上的物品
      if StdItem <> nil then
      begin
        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          n14 := i;
          foundItem := true;
          break;
        end;
      end;
    end;
    UserItem := nil;
  end;

  if not foundItem then
  begin
    SysMsg('穿戴失败！！', c_Red, t_Hint);
    n18 := -4;
    goto FailExit;
  end;

  if (StdItem <> nil) and (UserItem <> nil) then
  begin
    if sYsnameMaster <> '' then
    begin                                                   //如果是盛大
      if GetBoValue(UserItem, UserItem.wIndex, 11) then
      begin
        SysMsg('此物品元神禁止穿戴！！', c_Red, t_Hint);
        n18 := -4;
        goto FailExit;
      end;
    end
    else
    begin
      if GetBoValue(UserItem, UserItem.wIndex, 10) then
      begin
        SysMsg('此物品人物禁止穿戴！！', c_Red, t_Hint);
        n18 := -4;
        goto FailExit;
      end;
      if (PKLevel >= 2) and (GetBoValue(UserItem, Useritem.wIndex, 12)) then
      begin
        SysMsg('此物品红名人物禁止穿戴！！', c_Red, t_Hint);
        n18 := -4;
        goto FailExit;
      end;

    end;
  end;

  nhashousepai := CheckHorsepos;
  if (nhashousepai in [U_RIGHTHAND, U_BUJUK]) and (StdItem.StdMode in [33]) and
    (nhashousepai <> btWhere) then
  begin
    SysMsg('您已经带有马牌！', c_Red, t_Hint);
    n18 := -4;
    goto FailExit;
  end;

  ///
  n18 := 0;
  if (StdItem <> nil) and (UserItem <> nil) then
  begin
    if CheckUserItems(btWhere, StdItem) then
    begin                                                   //带物品位置
      StdItem58 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem58);
      if CheckTakeOnItems(btWhere, StdItem58) and CheckItemBindUse(UserItem) then
      begin
        TakeOffItem := nil;
        if btWhere in [0..14] then
        begin

          if m_UseItems[btWhere].wIndex > 0 then
          begin
            StdItem20 := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);  //身上待卸下的物品

            if (StdItem20 <> nil) and
              (StdItem20.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) then
            begin
              if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0) then
              begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
                n18 := -4;
                goto FailExit;
              end;
            end;

            if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0) then
            begin
              SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              n18 := -4;
              goto FailExit;
            end;                                            //004DAE78
            if (StdItem20.Reserved and 4) <> 0 then
            begin
              SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              n18 := -4;
              goto FailExit;
            end;
            if GetBoValue(@m_UseItems[btWhere], m_UseItems[btWhere].wIndex, 3) then
            begin
              SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
              goto FailExit;
            end;
            //物品取小成功

            New(TakeOffItem);
            TakeOffItem^ := m_UseItems[btWhere];

          end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

          if (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) and //004DAEC7
          (UserItem.btValue[8] <> 0) then
            UserItem.btValue[8] := 0;

          m_UseItems[btWhere] := UserItem^;
          if boNpc then
            SendDelItems(Useritem);
          DelBagItem(n14);
          if TakeOffItem <> nil then
          begin
            if m_btRaceServer = RC_PLAYOBJECT then
            begin                                           //
              if g_FunctionNPC <> nil then
              begin
                if sYsnameMaster <> '' then
                  g_FunctionNPC.GotoLable(Tplayobject(Self), '@YSTakeOff' +
                    IntToStr(btWhere), False)
                else
                  g_FunctionNPC.GotoLable(Tplayobject(Self), '@TakeOff' +
                    IntToStr(btWhere), False)
              end;
            end;
          end;

          //带上物品
         ///
          if m_btRaceServer = RC_PLAYOBJECT then
          begin                                             //如果是人物
            if g_FunctionNPC <> nil then
            begin
              if sYsnameMaster <> '' then
                g_FunctionNPC.GotoLable(Tplayobject(Self), '@YSTakeOn' +
                  IntToStr(btWhere), False)
              else
                g_FunctionNPC.GotoLable(Tplayobject(Self), '@TakeOn' + IntToStr(btWhere),
                  False);
              g_FunctionNPC.GotoLable(Tplayobject(Self), '@TakeOnALL', False);

            end;

          end;

          ////

          if TakeOffItem <> nil then
          begin
            Takeoffstditem := UserEngine.GetStdItem(TakeOffItem.wIndex);
            if (Takeoffstditem.StdMode in [33]) then
            begin
              m_boOnHorse := false;
              ArrestStringEx(Takeoffstditem.Name, '(', ')', horsename);

              for i := m_SlaveList.Count - 1 downto 0 do
              begin
                if TBaseObject(m_SlaveList.Items[i]).m_sCharName = horsename then
                begin
                  TBaseObject(m_SlaveList.Items[i]).MakeGhost;
                  m_SlaveList.Delete(i);
                  SendDefMessage(34977, 0, 612, 0, 0, '');
                  SysMsg('你的' + horsename + '已经收回', c_Red, t_Hint);
                  break;
                end;
              end;

            end;

            AddItemToBag(TakeOffItem);
            SendAddItem(TakeOffItem);
          end;

          if (StdItem.StdMode in [33]) then
          begin

            if (m_PEnvir.m_boCANHORSE) then
            begin

              //TBaseObject.MakeSlave(sMonName:String;nMakeLevel,nExpLevel,nMaxMob:Integer;dwRoyaltySec:LongWord)
              ArrestStringEx(stditem.Name, '(', ')', horsename);
              BaseObject := MakeSlave(horsename, 0, 0, 10, 10 * 24 * 60 * 60);  // stditem.Name
              if BaseObject <> nil then
              begin
                SendDefMessage(34977, stditem.Shape + 110, 612, 1, 0, '');
                BaseObject.m_bohorse := true;
                SysMsg('你的' + horsename + '已经放出', c_Red, t_Hint);
                m_boOnHorse := false;                       //还不在马上
              end;
            end
            else
              SysMsg('这里不能骑马', c_Red, t_Hint);

          end;
          RecalcAbilitys();
          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
          SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
          /////////////
          ///
          m_nItemUnitIndex := GetItemUnitIndex;
          if (m_nItemUnitIndex >= 0) and (m_nItemUnitIndex < g_Item_UnitList.Count) then
          begin
            pUnit_Item := pTunit_Item(g_Item_UnitList.Objects[m_nItemUnitIndex]);
            if pUnit_Item <> nil then
            begin
              if pUnit_Item.sTakeOn <> '' then
              begin
                if g_FunctionNPC <> nil then
                  g_FunctionNPC.GotoLable(Self, pUnit_Item.sTakeOn, false);
              end;
              if pUnit_Item.sTakeOnHint <> '' then
                SysMsg(pUnit_Item.sTakeOnHint, c_Red, t_Hint);
            end;
          end;
          if (StdItem.StdMode in [10, 11]) then
            if m_UseItems[btWhere].btValue[12] = 0 then
            begin
              m_UseItems[btWhere].btValue[11] := Random(15);  // UserItem.btValue[11] 衣服颜色 [0。。15 ]
              m_UseItems[btWhere].btValue[12] := 1;
            end;
          if Checkhuanying then
          begin                                             //幻影套装
            if not m_bohashuanying then
              SendRefMsg(RM_21292, 0, 16, 2, 0,
                '你已拥有幻影全套，内蕴的仙灵之力将提升你的反应能力……');
            m_bohashuanying := true;
            m_btSpeedPoint := m_btSpeedPoint + 3;
          end
          else
          begin
            if m_bohashuanying then
              SendRefMsg(RM_21292, 0, 16, 0, 0, '');
            m_bohashuanying := false;
            RecalcAbilitys;
          end;

          if Checkhuancai then
          begin                                             //幻彩套装
            if not m_bohashuancai then
              SendRefMsg(RM_21292, 0, 16, 1, 0,
                '你已拥有幻彩全套，内蕴的仙灵之力将提升你的生命上限……');
            m_bohashuancai := true;
            m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_WAbil.Level + 10);
          end
          else
          begin
            if m_bohashuancai then
              SendRefMsg(RM_21292, 0, 16, 0, 0, '');
            m_bohashuancai := false;
            RecalcAbilitys;
            //   dec(m_WAbil.MaxHP,m_WAbil.Level+10);
          end;

          ////////////////
          SendDefMessage(SM_TAKEON_OK, GetFeatureToLong, GetFeatureEx, 0, 0, ''); //
          //   if  m_boOnHorse then SendRefMsg(RM_TAKEHORSE,m_btDirection,m_nCurrX,m_nCurrY,0,'')
          //   else FeatureChanged();
          FeatureChanged();
          n18 := 1;
        end;
      end
      else
        n18 := -1;                                          //004DAFA0
    end
    else
      n18 := -1;                                            //004DAFA9
  end;                                                      //004DAFB0
  FailExit:
  if n18 <= 0 then
    SendDefMessage(SM_TAKEON_FAIL, n18, 0, 0, 0, '');

end;

procedure TPlayObject.ClientTakeOffItems(btWhere: Byte; nItemIdx: integer; sItemName:
  string);                                                    //004DB01C
var
  n10, i                                               : Integer;
  StdItem                                              : pTStdItem;
  UserItem                                             : pTUserItem;
  sUserItemName, horsename                             : string;
  pUnit_Item                                           : pTUnit_Item;
label
  FailExit;
begin
  n10 := 0;
  if not m_boDealing and (btWhere < 15) then
  begin
    if m_UseItems[btWhere].wIndex > 0 then
    begin
      if m_UseItems[btWhere].MakeIndex = nItemIdx then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
        if (StdItem <> nil) and
          (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) then
        begin
          if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0) then
          begin
            SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
            n10 := -4;
            goto FailExit;
          end;
        end;
        if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) then
        begin
          SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;
        if (StdItem.Reserved and 4) <> 0 then
        begin
          SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          n10 := -4;
          goto FailExit;
        end;
        if GetBoValue(@m_UseItems[btWhere], m_UseItems[btWhere].wIndex, 3) then
        begin
          SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red, t_Hint);
          goto FailExit;
        end;
        //取自定义物品名称
        sUserItemName := '';
        if m_UseItems[btWhere].btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(m_UseItems[btWhere].MakeIndex,
            m_UseItems[btWhere].wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(m_UseItems[btWhere].wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          New(UserItem);
          UserItem^ := m_UseItems[btWhere];
          m_sParam[30] := sUserItemName;
          if AddItemToBag(UserItem) then
          begin
            m_UseItems[btWhere].wIndex := 0;
            //这里放回包裹成功。
           ////
          //   if TakeOffItem<>nil then begin
            if m_btRaceServer = RC_PLAYOBJECT then
            begin                                           //如果是人物掉物品
              if g_FunctionNPC <> nil then
              begin
                if sYsnameMaster <> '' then
                  g_FunctionNPC.GotoLable(Tplayobject(Self), '@YSTakeOff' +
                    IntToStr(btWhere), False)
                else
                  g_FunctionNPC.GotoLable(Tplayobject(Self), '@TakeOff' +
                    IntToStr(btWhere), False);
                g_FunctionNPC.GotoLable(Tplayobject(Self), '@TakeOffALL' +
                  IntToStr(btWhere), False)
              end;
            end;
            //   end;
             ////
            if (StdItem.StdMode in [33]) then
            begin
              m_boOnHorse := false;
              ArrestStringEx(stditem.Name, '(', ')', horsename);

              for i := m_SlaveList.Count - 1 downto 0 do
              begin
                if TBaseObject(m_SlaveList.Items[i]).m_sCharName = horsename then
                begin
                  TBaseObject(m_SlaveList.Items[i]).MakeGhost;
                  m_SlaveList.Delete(i);
                  SysMsg('你的' + horsename + '已经收回', c_Red, t_Hint);
                  break;
                end;
              end;
            end;
            //////////////////////////////////
            if not Checkhuanying then
            begin                                           //幻影套装
              if m_bohashuanying then
                SendRefMsg(RM_21292, 0, 16, 0, 0, '');
              m_bohashuanying := false;
            end;
            if not Checkhuancai then
            begin                                           //幻彩套装
              if m_bohashuancai then
                SendRefMsg(RM_21292, 0, 16, 0, 0, '');
              m_bohashuancai := false;
              RecalcAbilitys;
              // dec(m_WAbil.MaxHP,m_WAbil.Level+10);
            end;
            if m_nItemUnitIndex >= 0 then
            begin
              //  n10:=GetItemUnitIndex;
              if (m_nItemUnitIndex >= 0) and (m_nItemUnitIndex < g_Item_UnitList.Count)
                then
              begin
                pUnit_Item := pTunit_Item(g_Item_UnitList.Objects[m_nItemUnitIndex]);
                if pUnit_Item <> nil then
                begin
                  if pUnit_Item.ItemName[btWhere] = sItemName then
                  begin
                    if pUnit_Item.sTakeOff <> '' then
                    begin
                      if g_FunctionNPC <> nil then
                        g_FunctionNPC.GotoLable(Self, pUnit_Item.sTakeOff, false);
                    end;

                    m_nItemUnitIndex := -1;
                  end;
                end;
              end;

            end;
            SendAddItem(UserItem);
            RecalcAbilitys();
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
            SendDefMessage(SM_TAKEOFF_OK, GetFeatureToLong, GetDress, 0, 0, '');  //GetFeatureEx
            // if  m_boOnHorse then SendRefMsg(RM_TAKEHORSE,m_btDirection,m_nCurrX,m_nCurrY,0,'')
            //     else FeatureChanged();

            FeatureChanged();
          end
          else
          begin
            Dispose(UserItem);
            n10 := -3;
          end;
        end;
      end;                                                  //004DB26F
    end
    else
      n10 := -2;                                            //004DB25F

  end
  else
    n10 := -1;                                              //004DB268

  FailExit:                                                 //004DB26F
  if n10 <= 0 then
    SendDefMessage(SM_TAKEOFF_FAIL, n10, 0, 0, 0, '');
end;

procedure TPlayObject.ClientAddZM(ntype, nItemIdx: Integer);
var
  UserItem                                             : pTUserItem;
  StdItem, StdItem2                                    : pTStdItem;
  i                                                    : Integer;
  BaseObjectList                                       : Tlist;
  Targe                                                : TBaseObject;
begin
  case ntype of

    5:                                                      //镇魔
      begin
        for I := 0 to m_ItemList.Count - 1 do
        begin
          UserItem := nil;
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
          begin
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItem <> nil) and (StdItem.StdMode = 3) and (StdItem.Shape = 27) then
            begin
              SendDelItems(UserItem);
              Dispose(UserItem);
              m_ItemList.Delete(I);
              WeightChanged();
              Inc(m_nZMValue, StdItem.DuraMax);
              SendDefMessage(34968, Integer(Self), 3, m_nZMValue * 1000, 0, '');
              break;
            end;
          end;
        end;
      end;

    4:                                                      //绝杀
      begin
        if (m_nZMValue >= g_Config.CallEvilConf.nEvilUniQueSkillDecPower) then
        begin
          Dec(m_nZMValue, g_Config.CallEvilConf.nEvilUniQueSkillDecPower);
          BaseObjectList := Tlist.Create;
          GetMapBaseObjects(m_PEnvir, m_nCurrX, m_nCurrY, 2, BaseObjectList);
          SendDefMessage(34968, Integer(Self), 260, m_nZMValue * 1000, 0, '');
          for I := 0 to BaseObjectList.Count - 1 do
          begin
            Targe := TBaseObject(BaseObjectList.Items[i]);
            if Targe = nil then
              continue;
            if IsProperTarget(Targe) then
            begin
              Targe.MakePosion(3, g_Config.CallEvilConf.nEvilUniQueSkillDontMoveTime, 0);
              Targe.MakePosion(5, g_Config.CallEvilConf.nEvilUniQueSkillDontMoveTime, 0);
              Targe.SendRefMsg(RM_MAGADDABILTY, 0, 32, 0, 0, ''); //
            end;
          end;
          BaseObjectList.Free;
          for I := 0 to m_SlaveList.Count - 1 do
          begin
            Targe := TBaseObject(m_SlaveList.Items[i]);
            Targe.m_wPowerRate[2] := g_Config.CallEvilConf.nEvilUniQueSkillDecPower - 1;
            Targe.m_wPowerRateTick[2] := GetTickCount +
              LongWord(g_Config.CallEvilConf.nUseEvilUniQueSkillTick * 1000);
            Targe.MakePosion(14, g_Config.CallEvilConf.nEvilUniQueSkillDontMoveTime, 0);
          end;
        end
        else
          SysMsg('镇魔值不够', c_Red, t_Hint);
      end;
  end;

end;

procedure TPlayObject.ClientUseItems(nItemIdx, monid: Integer; sItemName: string);  //004DB3B0
  function GetUnbindItemName(nShape: Integer): string;      //004E4214
  var
    I                                                  : Integer;
  begin
    Result := '';
    for I := 0 to g_UnbindList.Count - 1 do
    begin
      if Integer(g_UnbindList.Objects[I]) = nShape then
      begin
        Result := g_UnbindList.Strings[I];
        break;
      end;
    end;
  end;

  function GetbindItemName(nShape: Integer; sItemName: string): string; //004E4214
  var
    I                                                  : Integer;
    stdItem                                            : pTStdItem;

  begin
    Result := '';
    for I := 0 to g_bindList.Count - 1 do
    begin
      if Integer(g_bindList.Objects[I]) = nShape then
      begin
        Result := g_bindList.Strings[I];
        break;
      end;
    end;
    if Result = '' then
    begin
      for I := 0 to g_UnbindList.Count - 1 do
      begin
        if g_UnbindList.Strings[I] = sItemName then
        begin
          stdItem := UserEngine.GetStdItem(31, Integer(g_UnbindList.Objects[I]));
          if stdItem <> nil then
          begin
            Result := Stditem.Name;
          end;
          break;
        end;
      end;
    end;
  end;

  function GetUnBindItems(sItemName: string; nCount: Integer): Boolean; //004DB2DC
  var
    I                                                  : Integer;
    UserItem                                           : pTUserItem;
  begin
    Result := False;
    for I := 0 to nCount - 1 do
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
      begin
        m_ItemList.Add(UserItem);
        if m_btRaceServer = RC_PLAYOBJECT then
          SendAddItem(UserItem);
        Result := True;
      end
      else
      begin
        Dispose(UserItem);
        break;
      end;
    end;
  end;
var
  I, ii, iii, rt1, rt2, rt3                            : Integer;
  boEatOK                                              : Boolean;
  UserItem, UserItem1, UserItem2                       : pTUserItem;
  StdItem, StdItem2                                    : pTStdItem;
  UserItem34                                           : TUserItem;
  t                                                    : word;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint, tint2                                          : integer;
  wint, x, y, wname                                    : word;
  nCheck30                                             : INTEGER;
  StdItemname                                          : string;
  uselingfurec                                         : Tuselingfurec;
  horsename                                            : string;
  monhorse                                             : TBaseObject;
  EvilKillDate                                         : TEvilKillDate;
  human                                                : Tplayobject;
begin
  boEatOK := False;
  StdItem := nil;
  try
    if m_boCanUseItem then
    begin
      if not m_boDeath then
      begin
        for I := 0 to m_ItemList.Count - 1 do
        begin
          UserItem := nil;
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
          begin
            UserItem34 := UserItem^;
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem <> nil then
            begin
              m_sParam[0] := IntToStr(UserItem.MakeIndex);
              m_sParam[2] := StdItem.Name;
              if (pos(StdItem.Name, m_PEnvir.m_sNotAllowUseItem) > 0) then
              begin
                SysMsg('本地图禁止使用该物品', c_Red, t_Hint);
                break;
              end;
              case StdItem.StdMode of                       //
                0, 2, 3:
                  begin                                     //药     =3表示卷轴    1
                    if (StdItem.StdMode = 3) and m_boOnSellItem then
                    begin
                      SysMsg('正在摆摊中，不能使用该物品', c_Red, t_Hint);
                      break;
                    end;
                    nCheck30 := 0;
                    if (StdItem.StdMode = 3) and (StdItem.Shape = 16) then
                    begin
                      if UserItem.Dura <= 0 then
                      begin
                        SendDelItems(UserItem);
                        Dispose(UserItem);
                        m_ItemList.Delete(I);
                        WeightChanged();
                        exit;
                      end;
                      m_nFlagType := Stditem.AC;
                      dec(UserItem.Dura, 1);
                      SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                      SendUpdateItem(UserItem);
                      if UserItem.Dura <= 0 then
                      begin
                        SendDelItems(UserItem);
                        Dispose(UserItem);
                        m_ItemList.Delete(I);
                        WeightChanged();
                      end;
                      SysMsg('您改变了摊位类型', c_Red, t_Hint);
                      exit;

                    end;
                    if (StdItem.StdMode = 3) and (StdItem.Shape = 17) then
                    begin
                      //回城神石
                      if StdItem.Looks <> 502 then
                      begin
                        if UserItem.Dura <= 0 then
                        begin
                          SendDelItems(UserItem);
                          Dispose(UserItem);
                          m_ItemList.Delete(I);
                          WeightChanged();
                          exit;
                        end;
                        if (UserItem.btValue[1] = 0) and (UserItem.btValue[2] = 0) and
                          (UserItem.btValue[4] = 0) then
                        begin
                          SysMsg('请先纪录回城石', c_red, t_Hint);
                          break;
                        end;
                        x := makeword(UserItem.btValue[0], UserItem.btValue[1]); //x
                        y := makeword(UserItem.btValue[2], UserItem.btValue[3]); //y
                        wName := makeword(UserItem.btValue[4], UserItem.btValue[5]);  // 回城地图
                        SpaceMove(inttostr(wName - $30), x, y, 0);

                        dec(UserItem.Dura, 1);
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        SendUpdateItem(UserItem);
                        if UserItem.Dura <= 0 then
                        begin
                          SendDelItems(UserItem);
                          Dispose(UserItem);
                          m_ItemList.Delete(I);
                          WeightChanged();

                        end;

                        exit;
                      end                                   //回城石结束
                      else                                  //摆摊旗帜颜色
                      begin
                        if UserItem.Dura <= 0 then
                        begin
                          SendDelItems(UserItem);
                          Dispose(UserItem);
                          m_ItemList.Delete(I);
                          WeightChanged();
                          exit;
                        end;
                        m_nflagforsell := True;
                        m_nflagforsellcolor := MakeLong(stditem.MAC, stditem.DC);
                        dec(UserItem.Dura, 1);
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        SendUpdateItem(UserItem);
                        if UserItem.Dura <= 0 then
                        begin
                          SendDelItems(UserItem);
                          Dispose(UserItem);
                          m_ItemList.Delete(I);
                          WeightChanged();
                        end;
                        exit;

                      end;                                  //旗帜颜色结束

                    end;
                    nCheck30 := 1;
                    //// 使用灵符打怪物
                    if (StdItem.StdMode = 3) and ((StdItem.Shape = 202) or (sTditem.Shape
                      = 203)) then
                    begin
                      if CretInNearhum(Tbaseobject(monid), self.m_nCurrX, m_nCurrY) then
                      begin
                        if (pos(StdItem.Name, m_PEnvir.m_sCanUserItem) > 0) and (monid <>
                          0) and (Tbaseobject(monid) <> self) and (not
                          Tbaseobject(monid).m_boDeath) and (not
                          Tbaseobject(monid).m_boGhost) then
                        begin
                          if IsProperTarget(Tbaseobject(monid)) and
                            (Tbaseobject(monid).m_btRaceServer <> RC_PLAYOBJECT) then
                          begin
                            uselingfurec.monid := monid;
                            uselingfurec.nx := Tbaseobject(monid).m_nCurrX;
                            uselingfurec.ny := Tbaseobject(monid).m_nCurry;
                            uselingfurec.ntype := $0D;
                            TurnTo(GetNextDirection(m_nCurrX, m_nCurrY,
                              Tbaseobject(monid).m_nCurrX, Tbaseobject(monid).m_nCurrY));
                            m_DefMsg := MakeDefaultMsg(625, Integer(Self), 0, 0,
                              m_btDirection);
                            SendSocket(@m_DefMsg, EncodeBuffer(@uselingfurec,
                              SizeOf(tuselingfurec)));
                            Tbaseobject(monid).SetTargetCreat(self);
                            Tbaseobject(monid).SetLastHiter(self);
                            Tbaseobject(monid).die;
                            m_bouself := True;
                            if StdItem.Shape = 203 then     //灵符捆
                            begin
                              if UserItem.Dura > 0 then
                                Dec(UserItem.Dura);
                              if UserItem.Dura = 0 then
                              begin
                                Dispose(UserItem);
                                m_ItemList.Delete(I);
                                SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
                              end
                              else
                              begin
                                SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                                SendUpdateItem(UserItem);
                              end;
                            end
                            else
                            begin
                              Dispose(UserItem);
                              m_ItemList.Delete(I);
                              SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
                            end;
                            WeightChanged();
                            g_FunctionNPC.GotoLable(tplayobject(Self), '@灵符杀怪',
                              False);
                            exit;
                          end;
                        end;
                      end;
                    end;
                    //镇魔符   2009-2-20 20:43:58

                    if (StdItem.StdMode = 3) and (StdItem.Shape = 27) and
                      (m_PEnvir.m_boCANRECALLEVIL) then
                    begin
                      if CretInNearhum(Tbaseobject(monid), self.m_nCurrX, m_nCurrY) then
                      begin
                        if (monid <> 0) and (Tbaseobject(monid) <> self) and (not
                          Tbaseobject(monid).m_boDeath) and (not
                          Tbaseobject(monid).m_boGhost) then
                        begin
                          //判断是否为心魔
                          Randomize;
                          t := Random(100);
                          if (Tbaseobject(monid).m_btRaceServer >= 254) and
                            (g_Config.CallEvilConf.boCanRecallEvil) and (m_nCallEvilCount <
                            g_Config.CallEvilConf.nMaxRecallEvilCount) and (t <
                            g_Config.CallEvilConf.nRecallEvilRate) then
                          begin
                            FillChar(EvilKillDate, SizeOf(TEvilKillDate), #0);
                            EvilKillDate.nMonID := Monid;

                            m_dwCheckEvilCtrl10SecDecPowerTick := GetTickCount;
                            EvilKillDate.nZMValueMax :=
                              g_Config.CallEvilConf.nEvilCtrlMaxPower * 1000;
                            EvilKillDate.nValue2 := $DAC;
                            SendDefMessage(34968, 0, 257, 1000, 0,
                              EncodeBuffer(@EvilKillDate, SizeOf(EvilKillDate)), True);
                            m_nZMValue := Stditem.DuraMax;
                            Inc(m_nCallEvilCount);
                            SendDefMessage(34968, Integer(Self), 3, m_nZMValue * 1000, 0,
                              '');
                            uselingfurec.monid := monid;
                            uselingfurec.nx := Tbaseobject(monid).m_nCurrX;
                            uselingfurec.ny := Tbaseobject(monid).m_nCurry;
                            uselingfurec.ntype := $0D;
                            TurnTo(GetNextDirection(m_nCurrX, m_nCurrY,
                              Tbaseobject(monid).m_nCurrX, Tbaseobject(monid).m_nCurrY));
                            m_DefMsg := MakeDefaultMsg(625, Integer(Self), 0, 0,
                              m_btDirection);
                            SendSocket(@m_DefMsg, EncodeBuffer(@uselingfurec,
                              SizeOf(tuselingfurec)));
                            Tbaseobject(monid).m_master := Self;
                            m_SlaveList.Add(Tbaseobject(monid));
                            TBaseObject(MonID).m_dwMasterRoyaltyTick := GetTickCount + 240
                              * 60 * 60 * 1000;
                            Tbaseobject(monid).RefShowName;
                            SendDefMessage(SM_510, MonId, 1, 0, 72, '');
                            Dispose(UserItem);
                            m_ItemList.Delete(I);
                            SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
                            WeightChanged();
                            exit;
                          end;
                        end;
                      end;

                    end;
                    //// 使用灵兽项圈
                    if (StdItem.StdMode = 3) and (StdItem.Shape = 206) then
                    begin
                      if CretInNearhum(Tbaseobject(monid), self.m_nCurrX, m_nCurrY) then
                      begin
                        if (pos(StdItem.Name, m_PEnvir.m_sCanUserItem) > 0) and (monid <>
                          0) and (Tbaseobject(monid) <> self) and (not
                          Tbaseobject(monid).m_boDeath) and (not
                          Tbaseobject(monid).m_boGhost) then
                        begin
                          //判断是否为灵兽
                          if (Tbaseobject(monid).m_nNewLevel >= 0) then
                          begin
                            uselingfurec.monid := monid;
                            uselingfurec.nx := Tbaseobject(monid).m_nCurrX;
                            uselingfurec.ny := Tbaseobject(monid).m_nCurry;
                            TurnTo(GetNextDirection(m_nCurrX, m_nCurrY,
                              Tbaseobject(monid).m_nCurrX, Tbaseobject(monid).m_nCurrY));

                            Randomize;
                            x := Random(3);
                            //成功
                            if x = 0 then
                            begin
                              uselingfurec.ntype := $123F;
                              m_DefMsg := MakeDefaultMsg(625, Integer(Self), 1, 0,
                                m_btDirection);
                              m_sEatName :=
                                FilterItemName(Tbaseobject(monid).m_sCharName);
                              m_neatLevel := Tbaseobject(monid).m_nNewLevel;
                              SendSocket(@m_DefMsg, EncodeBuffer(@uselingfurec,
                                SizeOf(tuselingfurec)));
                              Tbaseobject(monid).DisappearA;
                              Tbaseobject(monid).MakeGhost;
                              m_sParam[0] := Tbaseobject(monid).m_sCharName;
                              m_sParam[1] := IntToStr(Tbaseobject(monid).m_wappr);
                              m_sParam[2] := IntToStr(m_neatLevel);
                              g_FunctionNPC.GotoLable(tplayobject(Self), '@捕捉灵兽',
                                False);
                            end
                            else
                              //失败
                            begin
                              uselingfurec.ntype := $123E;
                              Tbaseobject(monid).DamageHealth(30, 1);
                              Tbaseobject(monid).HealthSpellChanged;
                              m_DefMsg := MakeDefaultMsg(625, Integer(Self), 0, 0,
                                m_btDirection);
                              SendSocket(@m_DefMsg, EncodeBuffer(@uselingfurec,
                                SizeOf(tuselingfurec)));
                            end;

                            Dispose(UserItem);
                            m_ItemList.Delete(I);
                            SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
                            WeightChanged();
                            exit;
                          end;
                        end;
                      end;
                    end;
                    /////
                    if (StdItem.StdMode = 3) and (StdItem.Shape = 201) then
                    begin                                   //使用次数限制物品
                      if UserItem.Dura > 0 then
                      begin
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        UsesTimeItem := UserItem;

                        UseStdmodeFunItem(StdItem);
                        Dec(UserItem.Dura);
                        if UserItem.Dura = 0 then
                        begin
                          SendDelItems(UserItem);
                          Dispose(UserItem);
                          m_ItemList.Delete(I);
                          WeightChanged();
                        end
                        else
                          SendUpdateItem(UserItem);

                        exit;
                      end
                      else
                      begin
                        SendDelItems(UserItem);
                        Dispose(UserItem);
                        m_ItemList.Delete(I);
                        WeightChanged();
                      end;
                    end;
                    nCheck30 := 2;
                    ////////////////
                    if (StdItem.StdMode = 0) and (StdItem.Shape in [201, 200]) then
                    begin                                   //使用次数限制药品
                      if UserItem.Dura > 0 then
                      begin
                        EatItems(StdItem);
                        dec(UserItem.Dura, 1);
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        if UserItem.Dura <= 0 then
                        begin
                          SendDelItems(UserItem);
                          Dispose(UserItem);
                          m_ItemList.Delete(I);
                          WeightChanged();

                        end
                        else
                          SendUpdateItem(UserItem);

                        exit;
                      end;
                    end;
                    //////////////
                    nCheck30 := 3;
                    if EatItems(StdItem) then
                    begin
                      Dispose(UserItem);
                      m_ItemList.Delete(I);
                      boEatOK := True;
                    end;
                    break;
                  end;
                4:
                  begin                                     //人物书
                    nCheck30 := 4;
                    if ((stditem.Looks = 887) and (sYsnameMaster <> '')) or
                      ((sYsnameMaster = '') and (stditem.Looks = 197)) then
                    begin
                      if ReadBook(StdItem) then
                      begin //只有人物能使用 stemode=4的技能书 (sYsnameMaster='') and
                        Dispose(UserItem);
                        m_ItemList.Delete(I);
                        boEatOK := True;
                        if (m_MagicErgumSkill <> nil) and (not m_boUseThrusting) then
                        begin
                          ThrustingOnOff(True);
                          SendSocket(nil, '+LNG');
                        end;
                        if (m_MagicBanwolSkill <> nil) and (not m_boUseHalfMoon) then
                        begin
                          HalfMoonOnOff(True);
                          SendSocket(nil, '+WID');
                        end;
                      end;
                    end;
                    //骑战技能
                    if (StdItem.Looks = 1222) and (m_boBaoZiAttacked) then
                    begin

                      if ReadBook(StdItem) then
                      begin //只有人物能使用 stemode=4的技能书 (sYsnameMaster='') and
                        Dispose(UserItem);
                        m_ItemList.Delete(I);
                        boEatOK := True;
                      end;
                    end;
                  end;
                59:
                  begin
                    if m_boOnSellItem then
                    begin
                      SysMsg('正在摆摊中，不能使用该物品', c_Red, t_Hint);
                      break;
                    end;
                    if (StdItem.Shape >= 10) and (StdItem.Shape <= 17) then
                    begin
                      // SendDelItems(UserItem);
                     //   Dispose(UserItem);
                     //   m_ItemList.Delete(I);
                      boEatOK := false;
                      UseStdmodeFunItem(StdItem);
                    end;
                  end;
                49:
                  begin //  StdItem.StdMode =49的物品  使用触发脚本同时包裹里面不消失
                    nCheck30 := 6;
                    if StdItem.Shape = 52 then              //豹粮
                    begin
                      if FEEDMON(stditem.DuraMax) then
                      begin
                        Dispose(UserItem);
                        m_ItemList.Delete(I);
                        SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
                      end
                      else
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                      Exit;
                    end;
                    if StdItem.Shape = 53 then
                    begin
                      m_sEatName := StdItem.Name;
                    end;
                    if m_boOnSellItem then
                    begin
                      SysMsg('正在摆摊中，不能使用该物品', c_Red, t_Hint);
                      break;
                    end;
                    //修改物品的 开始使用时间  //修改后更新物品
                    if StdItem.Shape = 18 then
                    begin                                   //包月物品
                      copymemory(@tint, @UserItem.btValue[0], 4);
                      if tint = 0 then
                      begin

                        MyTime := EncodeTime(8, 00, 00, 0);
                        mydate := encodedate(1970, 01, 01);
                        date1 := mydate + mytime;
                        mydate := date();
                        mytime := time();
                        date2 := mydate + mytime;
                        tint := round((date2 - date1) * 86400);
                        copymemory(@UserItem.btValue[0], @tint, 4);
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        SendUpdateItem(UserItem);
                        UseStdmodeFunItem(StdItem);
                        SysMsg('您开启了该物品的功能，使用期限：开启后' +
                          inttostr(UserItem.Dura) + '天。', c_Red, t_Hint);

                      end;                                  //tint=0
                      //披风
                      if m_boOnHorse or m_boOnBaozi then
                      begin
                        SysMsg(' 不能使用', c_Red, t_Hint);
                        exit;
                      end;

                      // arp := STDITEM.MC;
                      if (m_boHavebeArp) and (m_nApprNum = STDITEM.MC) then
                      begin
                        // PlayObject.SendDefMessage(21292,Integer(Self),64, 0,0, ''); //恢复

                        SendRefMsg(RM_21292, 0, 64, 0, 0, '');
                        m_boHavebeArp := false;
                      end
                      else
                      begin
                        // PlayObject.SendDefMessage(21292,Integer(Self),64, 19,arp, ''); //变身披风
                        if m_boHavebeArp then
                          SendRefMsg(RM_21292, 0, 64, 0, 0, '');
                        SendRefMsg(RM_21292, Integer(Self), 64, 19, STDITEM.MC, '');
                        m_boHavebeArp := true;
                        m_nApprNum := STDITEM.MC;
                      end;
                      SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');

                      exit;
                    end;                                    //tdItem.Shape=18

                    if StdItem.Shape = 22 then
                    begin                                   //御兽天衣

                      if StdItem.AniCount <> m_btGender then
                      begin
                        SysMsg('性别不符，不能使用', c_Red, t_Hint);
                        break;
                      end;
                      copymemory(@tint, @UserItem.btValue[0], 4);
                      if tint = 0 then
                      begin

                        MyTime := EncodeTime(8, 00, 00, 0);
                        mydate := encodedate(1970, 01, 01);
                        date1 := mydate + mytime;
                        mydate := date();
                        mytime := time();
                        date2 := mydate + mytime;
                        tint := round((date2 - date1) * 86400);
                        copymemory(@UserItem.btValue[0], @tint, 4);

                        if not m_boUsexushou then
                          m_boUsexushou := true;
                        SendDefMessage(SM_TAKEON_OK, GetFeatureToLong, 200, 0, 0, '');  //  穿上衣服
                        FeatureChanged();

                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        SendUpdateItem(UserItem);
                        SysMsg('您开启了该物品的功能，使用期限：开启后' +
                          inttostr(UserItem.Dura) + '天。', c_Red, t_Hint);
                        exit;
                      end                                   //tint=0
                      else
                      begin
                        if m_boUsexushou then
                        begin
                          m_boUsexushou := false;
                          SendDefMessage(SM_TAKEOFF_OK, GetFeatureToLong, GetDress, 0, 0,
                            '');
                          if m_boOnBaozi then
                          begin                             //如果在豹上
                            m_boOnBaozi := false;
                            horsename := GetPetName(M_MonItemMake);
                            m_boBaoZiAttacked := False;
                            m_boOnBaozi := false;
                            // MONSTORAGE(self);
                            monhorse := MakeSlave(horsename, M_monstoragehuoli,
                              M_monstoragelevel, 10, 10 * 24 * 60 * 60);
                            if monhorse <> nil then
                            begin
                              m_PetBaseObject := monhorse;
                              monhorse.m_btGender := hibyte(M_monstoragelevel) and $3;
                              m_boOnBaozi := false;
                              m_nCharStatus := m_ncharstatus and $FFFFFFFE;
                              SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY,
                                0, '');
                              SendDefMessage(205, 0, 0, 0, 0, '');
                              Sendpetinfo(M_MonItemMake, 1);
                            end;
                          end;
                          FeatureChanged();

                        end
                        else
                        begin
                          m_boUsexushou := true;
                          SendDefMessage(SM_TAKEON_OK, GetFeatureToLong, GetDress, 0, 0,
                            '');                              //  穿上衣服
                          FeatureChanged();
                        end;
                        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                        exit;
                      end;

                    end;                                    // =22
                    nCheck30 := 7;
                    if StdItem.Shape = 51 then
                    begin                                   //豹魔石
                      if (M_monitemmake <> 0) and (M_monitemmake <> UserItem.MakeIndex)
                        then
                      begin
                        if (UserItem.MakeIndex <> M_monYSOnHorseitemmake) and
                          (UserItem.MakeIndex <> M_monOnHorseitemmake) and
                          (UserItem.MakeIndex <> M_monSellitemmake) then
                        begin
                          SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                          SysMsg('您已经带有灵兽', c_Red, t_Hint);
                          exit;
                        end;
                      end;
                      if sYsnameMaster <> '' then
                      begin                                 //元神
                        SysMsg('不能使用', c_Red, t_Hint);
                        exit;
                      end;

                      SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                      SendUpdateItem(UserItem); //这个命令必须先使用 SM_EAT_FAIL 命令
                      // UseStdmodeFunItem(StdItem);
                      MONSTORAGE(UserItem.MakeIndex);
                      exit;

                    end;

                    SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                    UseStdmodeFunItem(StdItem);
                    exit;

                  end;
                36:
                  begin
                    if StdItem.AniCount > 0 then
                    begin
                      SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                      UseStdmodeFunItem(StdItem);
                      exit;
                    end
                    else
                    begin                                   //天气卷轴
                      m_PEnvir.m_weatherEffect := Stditem.AC;
                      m_PEnvir.m_WindSpeed := StdItem.MAC;
                      m_PEnvir.m_WinsColor := MakeLong(Stditem.DC, StdItem.mc);
                      for Ii := 0 to UserEngine.m_PlayObjectList.Count - 1 do
                      begin
                        human := TPlayObject(UserEngine.m_PlayObjectList.Objects[Ii]);
                        if not human.m_boDeath and not human.m_boGhost and
                          (m_PEnvir = human.m_PEnvir) then
                        begin
                          human.SendMsg(self, RM_DAYCHANGING, 0, 0, 0, 0, '');
                        end;

                      end;
                    end;
                  end;
                37:
                  begin
                    if (StdItem.Shape > 0) and (StdItem.Shape <> 202) then
                    begin
                      boEatOK := false;
                      if monid > 0 then
                      begin
                        //圣灵精华
                        if StdItem.Shape = 212 then
                        begin
                          UserItem1 := GetItems(monid);
                          if UserItem1 <> nil then
                          begin
                            UserItem1.Dura := Useritem1.Dura + Useritem.Dura;
                            SendDelItems(UserItem);
                            Dispose(UserItem);
                            m_ItemList.Delete(I);
                            SendUpdateItem(UserItem1);
                            WeightChanged();
                            exit;
                          end
                          else
                            UseStdmodeFunItem(StdItem);
                        end;
                        //神秘符石
                        if StdItem.Shape = 214 then
                        begin
                          UserItem1 := GetItems(monid);
                          StdItem2 := UserEngine.GetStdItem(UserItem1.wIndex);
                          if UserItem1 <> nil then
                          begin
                            StdItem2 := UserEngine.GetStdItem(UserItem1.wIndex);
                            m_sParam[0] := IntToStr(UserItem.MakeIndex);
                            m_sParam[1] := IntToStr(Useritem1.MakeIndex);
                            m_sParam[3] := StdItem.Name;
                            if StdItem2 <> nil then
                              m_sParam[4] := Stditem2.Name;

                            UserItem1.btValue[0] := UserItem1.btValue[0] +
                              UserItem.btValue[0] + stditem.DuraMax;
                            SendDelItems(UserItem);
                            Dispose(UserItem);
                            m_ItemList.Delete(I);
                            SendUpdateItem(UserItem1);
                            WeightChanged();
                            exit;
                          end
                          else
                            UseStdmodeFunItem(StdItem);
                        end;
                      end
                      else
                      begin
                        case StdItem.Shape of
                          3:                                //爱情树种
                            begin
                              if PlantTree(StdItem) then
                                boEatOK := True;
                            end;
                          4:                                //爱情之水
                            begin
                              WaterPlantTree(StdItem);
                              dec(UserItem.Dura, 1);
                              SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                              if UserItem.Dura <= 0 then
                              begin
                                SendDelItems(UserItem);
                                Dispose(UserItem);
                                m_ItemList.Delete(I);
                                WeightChanged();

                              end
                              else
                                SendUpdateItem(UserItem);
                              Exit;
                            end
                        else
                          UseStdmodeFunItem(StdItem);

                        end;
                      end;
                    end
                    else
                    begin
                      for iii := m_ItemList.Count - 1 downto 0 do
                      begin
                        UserItem2 := m_ItemList.Items[iii];
                        if UserItem2.MakeIndex = monid then
                        begin
                          //
                          if UserItem.Dura > 0 then
                          begin
                            StdItem2 := UserEngine.GetStdItem(UserItem2.wIndex);
                            if StdItem2 <> nil then
                            begin
                              QuestCheckItem(StdItem2.Name, rt1, rt2, rt3);
                              if rt1 >= 6 then
                              begin                         //这个物品有6个以上
                                New(UserItem1);
                                if
                                  UserEngine.CopyToUserItemFromName(GetbindItemName(StdItem2.Shape, stditem2.Name), UserItem1) then
                                begin
                                  m_ItemList.Add(UserItem1);
                                  SendAddItem(UserItem1);
                                  TakeItem(StdItem2.Name, 6);

                                  dec(UserItem.Dura, 1);
                                  SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                                  SendUpdateItem(UserItem);
                                  if UserItem.Dura <= 0 then
                                  begin

                                    SendDelItems(UserItem);
                                    Dispose(UserItem);
                                    m_ItemList.Delete(I);
                                    WeightChanged();

                                  end;

                                end
                                else
                                begin
                                  SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                                  dispose(UserItem1);
                                end;

                              end
                              else
                              begin
                                //不到6个
                                SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
                                SysMsg('您的' + StdItem2.Name + '不足6个，无法捆袋',
                                  c_Red, t_Hint);
                              end;                          // >=6
                            end;                            //<>nil

                            exit;
                          end;                              //>0

                          //

                          break;
                          //
                        end;                                //UserItem2.MakeIndex=monid

                      end;                                  //for

                    end;
                  end;
                31:
                  begin                                     //解包物品
                    nCheck30 := 8;
                    if StdItem.AniCount = 0 then
                    begin
                      if (m_ItemList.Count + 6 - 1) <= m_bMaxBagitem then
                      begin                                 // MAXBAGITEM
                        Dispose(UserItem);
                        m_ItemList.Delete(I);
                        GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                        boEatOK := True;
                      end;
                    end
                    else
                    begin
                      Dispose(UserItem);
                      m_ItemList.Delete(I);
                      boEatOK := True;
                      UseStdmodeFunItem(StdItem);
                    end;
                  end;
              end;
            end;
            break;
          end;
        end;
      end;
    end
    else
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotUseItemMsg);
    end;
    if boEatOK then
    begin
      WeightChanged();
      SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
      nCheck30 := 9;
      //004DB73F
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('11' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          //UserEngine.GetStdItemName(UserItem34.wIndex) + #9 +
          StdItem.Name + #9 +
          IntToStr(UserItem34.MakeIndex) + #9 +
          '1' + #9 +
          '0');
    end
    else
    begin
      SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
    end;

  except
    on e: Exception do
    begin
      StdItemname := '';
      if StdItem <> nil then
        StdItemname := StdItem.Name;
      MainOutMessage(format('CM_Eat Error Check=%d ItemName=%s', [nCheck30,
        StdItemname]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;                                                      //TRY

end;

function TPlayObject.WaterPlantTree(StdItem: pTStdItem): Boolean;
var
  MonList                                              : TList;
  Mon                                                  : TBaseObject;
  i                                                    : Integer;
  function UpdateToList(SMon: string; sDate: string): Boolean;
  var
    sList                                              : TStringList;
    sFileName                                          : string;
    i                                                  : Integer;
  begin
    sList := TStringList.Create;
    sFileName := g_Config.sEnvirDir + '\MonLifeSpan.TXT';
    if FileExists(sFileName) then
      sList.LoadFromFile(sFileName);
    for i := 0 to sList.Count - 1 do
    begin
      if Pos(SMon, sList[i]) > 0 then
      begin
        sList[i] := sDate;
        sList.SaveToFile(sFileName);
        Break;
      end;
    end;

  end;
begin
  if StdItem = nil then Exit;
  try
    MonList := TList.Create;
    UserEngine.GetMapRangeMonster(m_PEnvir, m_nCurrX, m_nCurrY, 5, MonList);
    for I := 0 to MonList.Count - 1 do
    begin
      if Pos(m_sCharName, TBaseObject(MonList[i]).m_sCharName) = 1 then
      begin
        Mon := TBaseObject(MonList[i]);
        if Mon.m_boGhost or Mon.m_boDeath then
          Mon := nil;
        Break;
      end;

    end;

    if Mon = nil then
      SysMsg('在附近范围内没有发现' + m_scharName + '的爱情之树,请在五格范围内使用',
        c_Red, t_Hint)
    else
    begin
      Mon.m_nDieDay := Mon.m_nDieDay + StdItem.AC;
      UpdateToList(Format('%s %s %s %d %d', [Mon.m_sOldName, Mon.m_sCharName,
        Mon.m_PEnvir.sMapName, Mon.m_nCurrX, Mon.m_nCurrY]),
        Format('%s %s %s %d %d %d %d %s', [Mon.m_sOldName, Mon.m_sCharName,
        Mon.m_PEnvir.sMapName, Mon.m_nCurrX, Mon.m_nCurrY, Mon.m_btDirection,
        Mon.m_nDieDay, FormatDateTime('yyyy-mm-dd hh:mm:ss', Mon.m_nDieTime)]));
      SysMsg(m_scharName + '的爱情之树成功延长寿命' + Inttostr(StdItem.AC) +
        '天,死亡时间推迟到' + FormatDateTime('yyyy-mm-dd hh:mm:dd', Mon.m_nDieTime +
        Mon.m_ndieDay), c_Red, t_Hint)

    end;
  finally
    MonList.Free;

  end;

end;

function TPlayObject.PlantTree(StdItem: pTStdItem): Boolean;
var
  pPlantPoint                                          : pTPlantPoint;
  i                                                    : Integer;
  nx, ny                                               : Integer;
  Mon                                                  : TBaseObject;
  function AddToList(SMon: string): Boolean;
  var
    sList                                              : TStringList;
    sFileName                                          : string;
  begin
    sList := TStringList.Create;
    sFileName := g_Config.sEnvirDir + '\MonLifeSpan.TXT';
    if FileExists(sFileName) then
      sList.LoadFromFile(sFileName);
    if sList.IndexOf(sMon) < 0 then
    begin
      sList.Add(SMon);
      sList.SaveToFile(sFileName);
    end;

  end;

begin
  Result := False;
  g_PlantPointList.lock;
  try
    for I := 0 to g_PlantPointList.Count - 1 do
    begin
      pPlantPoint := pTPlantPoint(g_PlantPointList.Objects[i]);
      if pPlantPoint.sMap = m_PEnvir.sMapName then
      begin
        if (Abs(m_nCurrX - pPlantPoint.x) < pPlantPoint.nRand) and (Abs(m_nCurrY -
          pPlantPoint.Y) < pPlantPoint.nRand) then
        begin
          GetFrontPosition(nX, nY);
          Mon := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY, '爱情之树');
          if Mon <> nil then
          begin
            Mon.m_sOldName := Mon.m_sCharName;

            if m_sDearName <> '' then
              Mon.m_sCharName := Format('%s与%s的爱情之树', [m_scharName, m_sDearName])
            else
              Mon.m_sCharName := Format('%s的爱情之树', [m_scharName]);
            Mon.m_nDieTime := Now;
            Mon.m_nDieDay := 3;
            SysMsg('恭喜您，爱情之树种植成功，您的爱情之树现在的寿命是3天。', c_Red,
              t_Hint);
            AddToList(Format('%s %s %s %d %d %d %d %s', [Mon.m_sOldName, Mon.m_sCharName,
              Mon.m_PEnvir.sMapName, Mon.m_nCurrX, Mon.m_nCurrY, Mon.m_btDirection, 3,
              FormatDateTime('yyyy-mm-dd hh:mm:ss', Now)]));
            Result := True;
            Break;
          end;
        end;
      end;

    end;
  finally
    g_plantPointList.unlock;
  end;

end;

function TPlayObject.UseStdmodeFunItem(StdItem: pTStdItem): Boolean;
begin
  Result := False;
  if g_FunctionNPC <> nil then
  begin
    case StdItem.StdMode of
      59: g_FunctionNPC.GotoLable(Self, '@圣灵宝石' + IntToStr(StdItem.Shape), False);
      36: g_FunctionNPC.GotoLable(Self, '@NewStdModeFunc' +
        IntToStr(UserEngine.GetItemAnicount(StdItem.name)), False);
    else
      g_FunctionNPC.GotoLable(Self, '@StdModeFunc' +
        IntToStr(UserEngine.GetItemAnicount(StdItem.name)), False);
    end;
    Result := True;
  end;
end;

function TPlayObject.FEEDMON(nValue: Integer): Boolean;
var
  i                                                    : integer;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint                                                 : integer;
  wint                                                 : word;
  sPetname                                             : string;
  montype                                              : Integer;
  UserItem                                             : pTUserItem;
begin
  tint := 0;
  wint := 0;
  Result := False;
  if M_monitemmake = 0 then
  begin
    SysMsg('您还没有放出宠物，不能喂食。', c_Red, t_Hint);
    exit;
  end;
  // addvalue:=Str_ToInt(QuestActionInfo.sParam1,200);
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if (UserItem <> nil) and (UserItem.MakeIndex = M_monitemmake) then
    begin
      MyTime := EncodeTime(8, 00, 00, 0);
      mydate := encodedate(1970, 01, 01);
      date1 := mydate + mytime;
      mydate := date();
      mytime := time();
      date2 := mydate + mytime;
      tint := round((date2 - date1) * 86400); //一天的秒数      //开始使用时间
      copymemory(@UserItem.btValue[0], @tint, 4);
      //
      copymemory(@wint, @UserItem.btValue[6], 2);
      if UserItem.btvalue[4] < 200 then
        inc(wint, nValue);

      UserItem.btvalue[6] := lobyte(wint);                  //经验值
      UserItem.btvalue[7] := hibyte(wint);

      UserItem.btvalue[4] := wint div g_Config.ClbLevelUpTrains;
      if UserItem.btvalue[4] > 200 then
        UserItem.btvalue[4] := 200;                         //等级

      //
      SendUpdateItem(UserItem);
      montype := hibyte(M_monstoragelevel);
      case montype of
        0: sPetname := '丛林豹';
        1:
          begin

            sPetname := '踏云豹';
          end;
        2: sPetname := '狮魔兽';
        3: sPetname := '震天狮';
      else
        sPetname := '丛林豹';
      end;
      SysMsg('您的' + sPetname + '已经精神饱满，充满了活力。', c_Red, t_Hint);
      Result := True;
      break;
    end;

  end;

end;

procedure TPlayObject.DelItem(UserItem: PTUserItem);
var
  j                                                    : Integer;
  u                                                    : PTUserItem;
begin

  for j := m_Itemlist.Count - 1 downto 0 do
  begin
    U := m_Itemlist.Items[j];
    if UserItem.MakeIndex = U.MakeIndex then
    begin
      m_Itemlist.Delete(j);
      SendDelItems(UserItem);
      Dispose(UserItem);
      Break;
    end;

  end;
end;

procedure TPlayObject.SendPetInfo(ItemMake: Integer; btStatu: Byte);
var
  sSendMsg                                             : string;
  monlevel, montype                                    : integer;
  smonname                                             : string;
  PetInfo                                              : TPetInfo;
  UserItem                                             : pTUserItem;
  TmpStr                                               : string;
  StdItem                                              : pTStdItem;
begin

  UserItem := GetItems(itemmake);
  if UserItem = nil then Exit;
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  monlevel := UserItem.btvalue[4];
  montype := UserItem.btvalue[9] + StdItem.AniCount * 8;
  smonname := GetPetName(ItemMake);
  //        if btStatu=1 then
  //        Begin
  //        //  SendDefMessage(38401, integer(Self), 0, 0, 0, '');
  //          SendDefMessage(38402, integer(Self), 0, 0, 0, '');
  //        End;
  Fillchar(PetInfo, SizeOf(TPetInfo), #0);
  PetInfo.nMakeIndex := ItemMake;
  StrPCopy(PetInfo.Name, (smonname));
  if UserItem <> nil then
  begin
    copymemory(@PetInfo.time, @UserItem.btValue[0], 4);

    //        PetInfo.AC := makeword(UserItem.btvalue[0], UserItem.btvalue[1]); //饥饿程度的量化值
    //        PetInfo.mAC := makeword(UserItem.btvalue[2], UserItem.btvalue[3]); //饥饿程度
    case UserItem.btvalue[8] of
      0: PetInfo.btColor := 0;
      1: PetInfo.btColor := 2;
      2: PetInfo.btColor := 1;
    end;
    // PetInfo.btColor:=2;
    PetInfo.btZSLevel := montype;
    PetInfo.btLevel := monlevel;
    PetInfo.nMemo1 := 7;
    PetInfo.wAttack := btStatu;
    PetInfo.nMemo1 := $94357707;
    PetInfo.nMemo2 := $0;
    PetInfo.aMemo[0] := $2D000000;
    PetInfo.aMemo[1] := $0400C0C6;
    PetInfo.aMemo[2] := $0300C045;
    PetInfo.wMemo1 := 0;
  end;
  PetInfo.Hp := 100;
  // m_monStoragesize:=5;
  if btStatu = 1 then
  begin
    SendDefMessage(38401, integer(Self), 0, 15, m_monStoragesize, '');
    //  SendDefMessage(38402, integer(Self), 0, 0, 0, '');

    tmpstr := 'vvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuv' +
      'vfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvY]tdvtEsMksPu=MwvfmvvvEf]' +
      'fv>fI]vZ^E^vV=f]fvV;trvuef]vaye]fvHs=UwPekMwF[fKkpqkf\v^bfKwboudfqvvfuv^beKwZ_' +
      'sdfmYud_vHcuMu]]vvfucvfqvM`c]vvYF^fk`cfgv`ac]vJY;xfyLdI\vPesMwfkvvfu;dIdv;`c]vt' +
      'IsMksPu=MwvfmvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvHEbefSfVChgv>BxvnEkWReBp_A`Q[nvv`' +
      'uQ[L>;jw=DxfwvvRU??O@zvfuvHcuMwLKuMksFGe`vvacKwMokffqve?Pwvaldvfuvvfuve?Lwb[ndvqUu' +
      'dfmHs=UwvfmvvfuvvfuPYGbvvfuvvfuvvfufLGdwrwU_w>]\YYeevfmvcftvvLUuMksvvfuv>Sf]vBI_]fvv' +
      'vfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvfuvvcuvvf' +
      'uvveuMwj;>xfm`hIdvFhuvveuvvfuvu=UwvemMw^k<xfmJfk_vz<Dxv>edgfkbdkcvB@DxvhEv^swuJP=F>' +
      'W@>?;>quyvsvfuvsfuvv>u;xfmELuH_zHguyczvvfun=tsvl=CxvhuvvfuVWp`v^;Cxv>ELIWan=twvsfuvv' +
      'CuvofupvGuxefmvvBe=xfmGlf`v^=Dxv`Uiffun??rsBXVgv_ar\frgrHhvbPExvFEEcfuvvfuvvfuvvqUudfm' +
      'z>ttvnWDksfqvvfuG\a`vB@devZQgPdwv[ahvJaD^vBm?kex';
    SendDefMessage(34983, integer(Self), 24, 0, 29, TmpStr, True);
  end;
  sSendMsg := EncodeBuffer(@PetInfo, SizeOf(TPetInfo));
  m_DefMsg := MakeDefaultMsg(34977, 0, 356, 1, 0);
  SendSocket(@m_DefMsg, sSendMsg);

end;

procedure TPlayObject.MONSTORAGE(ItemMake: Integer);
var
  baseobject                                           : tbaseobject;
  i                                                    : integer;
  UserItem                                             : pTUserItem;
  pStdItem                                             : pTStdItem;
  StdItem                                              : TStdItem;

  ClientItem                                           : TClientItem;
  DefMsg                                               : TDefaultMessage;
  body                                                 : array[0..10000] of char;
  sSendMsg                                             : string;
  MonLevel, monType                                    : Integer;

  smonname                                             : string;
  PetInfo                                              : TPetInfo;
  nCheck                                               : Integer;
  t                                                    : word;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint, tint2                                          : integer;
  wint, x, y, wname                                    : word;
begin

  try
    UserItem := GetItems(ItemMake);
    if UserItem = nil then exit;
    nCheck := 0;
    pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if pStdItem = nil then exit;
    monlevel := UserItem.btvalue[4];
    montype := UserItem.btvalue[9] + pStdItem.AniCount * 8;
    smonname := GetPetName(ItemMake);

    MyTime := EncodeTime(8, 00, 00, 0);
    mydate := encodedate(1970, 01, 01);
    date1 := mydate + mytime;
    mydate := date();
    mytime := time();
    date2 := mydate + mytime;

    copymemory(@tint, @UserItem.btValue[0], 4);
    if tint = 0 then
    begin
      tint := round((date2 - date1) * 86400); //一天的秒数      //开始使用时间
      copymemory(@UserItem.btValue[0], @tint, 4);
    end;
    tint2 := round((date2 - date1) * 86400);
    tint := round((tint2 - tint) / 86400);

    //    UserItem.btvalue[4] := wint div g_Config.ClbLevelUpTrains;
     //   UserItem.btvalue[4]:=2;
    if UserItem.btvalue[4] > 200 then
      UserItem.btvalue[4] := 200;
    if StdItem.AniCount > 2 then StdItem.AniCount := 0;

    //表示此时有跟随的豹子
   // if (M_monitemmake<>0) and (ItemMake<>M_monitemmake ) then
    begin
      if ItemMake = M_monOnHorseitemmake then
      begin
        m_boOnBaozi := false;
        m_boOnBaozi := false;
        m_boBaoZiAttacked := False;
        SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, ''); //如果在骑豹中
        M_monOnHorseitemmake := 0;
        m_nCharStatus := m_ncharstatus and $FFFFFFFE;
        SendDefMessage(205, 0, 0, 0, 0, '');
        Sendpetinfo(ItemMake, 0);
        RecalcAbilitys();
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        Exit;
      end;
      if ItemMake = M_monSellitemmake then
      begin
        SysMsg('灵兽正在摆摊中，请先停止摆摊!', c_Red, t_Hint);
        exit;
      end;
      if ItemMake = M_monYSOnHorseitemmake then
      begin
        if Ysplayer <> nil then
        begin

          Ysplayer.m_boOnBaozi := false;
          Ysplayer.m_boOnBaozi := false;
          Ysplayer.m_boBaoZiAttacked := False;
          Ysplayer.SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');  //如果在骑豹中
          M_monYSOnHorseitemmake := 0;
          m_nCharStatus := m_ncharstatus and $FFFFFFFE;
          SendDefMessage(205, 0, 0, 0, 0, '');
          Sendpetinfo(ItemMake, 0);
          Exit;
        end;
      end;
    end;

    nCheck := 1;
    if M_monitemmake = 0 then
    begin                                                   //如果还没有 丛林豹
      M_monstoragehuoli := 4 - tint;
      if M_monstoragehuoli <= 0 then
      begin
        SysMsg('您的' + smonname + '已经死亡。', c_Red, t_Hint);
        SendDefMessage(38401, integer(Self), 0, 0, 0, '');
        M_monitemmake := 0;
        m_PetBaseObject := nil;
        exit;
      end;
      nCheck := 2;

      M_monstoragelevel := makeword(UserItem.btvalue[4], UserItem.btvalue[9] +
        pStdItem.AniCount * 8);
      // M_MonPetColor:=UserItem.btValue[8];
      M_monsterZSD := UserItem.btValue[7];
      M_monsterExp := wint;
      // M_monstoragelevel:=1;
      M_monitemmake := UserItem.MakeIndex;
      case UserItem.btvalue[4] of
        0: m_monStoragesize := 0;
        1, 2: m_monStoragesize := 5;
        3, 4: m_monStoragesize := 10;
        5, 6, 7: m_monStoragesize := 10;                    //20
      end;
      if UserItem.btvalue[9] > 0 then                       //表示踏云豹
        m_monStoragesize := 10;

      BaseObject := MakeSlave(smonname, M_monstoragehuoli, M_monstoragelevel, 10, 10 * 24
        * 60 * 60);
      if BaseObject <> nil then
      begin
        //当玩家放出灵兽时触发此标签
        if g_FunctionNPC <> nil then
          g_FunctionNPC.GotoLable(Self, '@ReleasePet', False);
        baseobject.m_btGender := montype and $3;
        Baseobject.m_PetSellCharName := m_sCharName;
        Baseobject.M_monstoragehuoli := M_monstoragehuoli;
        Baseobject.M_monitemmake := M_monItemMake;
        Baseobject.M_monstoragelevel := M_monstoragelevel;
        //     Baseobject.M_MonPetColor:=M_MonPetColor;
        m_PetBaseObject := baseobject;
        Fillchar(PetInfo, SizeOf(TPetInfo), #0);
        //   PetInfo.nMakeIndex:=M_monitemmake;
        StrPCopy(PetInfo.Name, FilterShowName(smonname));
        UserItem := GetItems(M_monitemmake);
        SendDefMessage(38416, integer(self), 0, 0, 1, encodebuffer(@M_monitemmake, 4));
        SendDefMessage(38416, integer(self), 0, 0, 1, encodebuffer(@M_monitemmake, 4),
          True);
        nCheck := 3;

        SendPetInfo(M_monitemmake, 1);
        if M_monstoragehuoli > 2 then
          SysMsg('您的' + FilterShowName(smonname) + '精神饱满。红袖处有豹粮出售。',
            c_Red, t_Hint)
        else
          SysMsg('您的' + FilterShowName(smonname) + '精神不足。红袖处有豹粮出售。',
            c_Red, t_Hint);

        fillchar(body, sizeof(body), 0);
        nCheck := 4;
        begin
          nCheck := 11;
          for i := 0 to m_monStoragelist.Count - 1 do
          begin
            nCheck := 12;
            fillchar(ClientItem, SizeOf(TClientItem), 0);
            UserItem := m_monStoragelist.Items[I];
            pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
            StdItem := pStdItem^;
            ItemUnit.GetItemAddValue(UserItem, StdItem);
            ClientItem.S := StdItem;
            ClientItem.MakeIndex := UserItem.MakeIndex;
            ClientItem.Dura := UserItem.Dura;
            ClientItem.DuraMax := UserItem.DuraMax;
            ClientItem.DarkProperty := Useritem.DarkProp; // ItemUnit.GetItemDarkProperty(UserItem.MakeIndex,Useritem.wIndex);
            copymemory(@body[SizeOf(TClientItem) * i], @ClientItem, SizeOf(TClientItem));
            nCheck := 13;
          end;
          if m_monStoragelist.Count > 0 then
          begin
            sSendMsg := EncodeBuffer(@body, SizeOf(TClientItem) *
              m_monStoragelist.Count);
            DefMsg := MakeDefaultMsg(38402, integer(Self), 0, 0, m_monStoragelist.Count);
            SendSocket(@DefMsg, sSendMsg);
          end
          else
            SendDefMessage(38402, integer(self), 0, 0, 0, ''); //发送宠物背包数据

        end;
      end;

    end
    else
    begin                                                   //如果有丛林豹

      //      if Ysplayer<>nil then
      //      begin
      //
      //          Ysplayer.m_boOnBaozi := false;
      //          Ysplayer.m_boOnBaozi:=false;
      //          Ysplayer.m_boBaoZiAttacked:=False;
      //          Ysplayer.SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, ''); //如果在骑豹中
      //          Ysplayer.m_nCharStatus:=Ysplayer.m_ncharstatus and $FFFFFFFE;
      //          Ysplayer.SendDefMessage(205, 0, 0, 0, 0, '');
      //      end;
      nCheck := 15;

      MakeSlaveghost(GetPetName(M_MonItemMake));
      nCheck := 151;
      i := M_monitemmake;
      M_monitemmake := 0;
      m_PetBaseObject := nil;
      nCheck := 152;
      SendDefMessage(38401, integer(Self), 0, 0, 0, '');
      nCheck := 153;
      //  SendDefMessage(34977, integer(PlayObject), 100, 0, 0, '');

      sSendMsg := EncodeBuffer(@i, 4);
      m_DefMsg := MakeDefaultMsg(34977, Integer(Self), 100, 0, 0);
      nCheck := 154;
      SendSocket(@m_DefMsg, sSendMsg);
      nCheck := 155;
      if m_boOnBaozi then
      begin
        m_boOnBaozi := false;
        m_boOnBaozi := false;
        m_boBaoZiAttacked := False;
        SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, ''); //如果在骑豹中

        m_nCharStatus := m_ncharstatus and $FFFFFFFE;
        SendDefMessage(205, 0, 0, 0, 0, '');
        Sendpetinfo(M_MonItemMake, 0);
        RecalcAbilitys();
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
      nCheck := 16;
    end;
    nCheck := 17;
    m_bohasMONSTORAGE := not m_bohasMONSTORAGE;
  except
    on e: Exception do
    begin

      MainOutMessage(format('Pet Error Check=%d ', [nCheck]));

    end;

  end;                                                      //TRY
end;

procedure TPlayObject.ClientCHECKITEMBOXCF(ItemIDx: Integer; nCount: Integer; nType:
  Integer);
var
  StdItem                                              : pTStdItem;
  UserItem                                             : pTUserItem;
begin
  m_sParam[0] := IntToStr(ItemIDx);
  UserItem := GetItems(ItemIDx);
  if UserItem = nil then exit;
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem <> nil then
  begin
    m_sParam[1] := Stditem.Name;
    m_sParam[2] := IntToStr(nCount);
    if m_npc1 <> nil then
    begin
      TMerchant(m_NPC1).GotoLable(Self, m_nboxid, False);

    end;
  end;
end;

procedure TPlayObject.ClientGetScriptPic(sMsg: string; nParam: Integer);
var
  ClientItem                                           : TClientItem;
  StdItem                                              : pTStdItem;
  sItemName                                            : string;
  StdItem80                                            : TStdItem;
begin
  sItemName := DecodeString(sMsg);
  StdItem := UserEngine.GetStdItem(sItemName);
  if StdItem <> nil then
  begin
    StdItem80 := StdItem^;
    FillChar(ClientItem, SizeOf(TClientItem), 0);
    ClientItem.S := StdItem80;
    ClientItem.MakeIndex := 1;
    ClientItem.Dura := StdItem80.DuraMax;
    ClientItem.DuraMax := StdItem80.DuraMax;
    ClientItem.S.Price := 0;
    m_DefMsg := MakeDefaultMsg(199, Integer(Self), nParam, 0, 0);
    SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
  end;
end;

function TPlayObject.ClientGetButchItem(BaseObject: TBaseObject; nX, nY: Integer; btDir:
  Byte; var dwDelayTime: LongWord): Boolean;                  //004DB7E0
var
  n10, n14                                             : Integer;
  dwCheckTime                                          : LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  dwCheckTime := GetTickCount - m_dwTurnTick;
  if dwCheckTime < g_Config.dwTurnIntervalTime then
  begin
    dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
    exit;
  end;
  m_dwTurnTick := GetTickCount;
  if (abs(nX - m_nCurrX) <= 2) and (abs(nY - m_nCurrY) <= 2) then
  begin
    if m_PEnvir.IsValidObject(nX, nY, 2, BaseObject) then
    begin
      if BaseObject.m_boDeath and (not BaseObject.m_boSkeleton) and
        (BaseObject.m_boAnimal) then
      begin
        n10 := Random(16) + 5;
        n14 := Random(201) + 100;
        Dec(BaseObject.m_nBodyLeathery, n10);
        Dec(BaseObject.m_nMeatQuality, n14);
        if BaseObject.m_nMeatQuality < 0 then
          BaseObject.m_nMeatQuality := 0;
        if BaseObject.m_nBodyLeathery <= 0 then
        begin
          if (BaseObject.m_btRaceServer >= RC_ANIMAL) and (BaseObject.m_btRaceServer <
            RC_MONSTER) then
          begin
            BaseObject.m_boSkeleton := True;
            ApplyMeatQuality();
            BaseObject.SendRefMsg(RM_SKELETON, BaseObject.m_btDirection,
              BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
          end;
          if not TakeBagItems(BaseObject) then
          begin
            SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red, t_Hint);
          end;
          BaseObject.m_nBodyLeathery := 50;
        end;                                                //004DB945
        m_dwDeathTick := GetTickCount();
      end;

    end;                                                    //004DB953
    m_btDirection := btDir;
  end;
  SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TPlayObject.ClientChangeMagicKey(nSkillIdx, nKey: integer); //004DB9A4
var
  I                                                    : Integer;
  UserMagic                                            : pTUserMagic;
begin
  for I := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[i];
    if UserMagic.MagicInfo.wMagicId = nSkillIdx then
    begin
      UserMagic.btKey := nKey;
      break;
    end;
  end;
end;

procedure TPlayObject.ClientGropuClose;                     //004C3C10
begin
  if m_GroupOwner = nil then
  begin
    m_boAllowGroup := False;
    exit;
  end;
  if m_GroupOwner <> Self then
  begin
    m_GroupOwner.DelMember(Self);
    m_boAllowGroup := False;
  end
  else
  begin
    SysMsg('如果你想退出，使用编组功能（删除按钮）', c_Red, t_Hint);
  end;

end;

procedure TPlayObject.ClientCreateGroup(sHumName: string);  //004DCCB4
var
  PlayObject                                           : TPlayObject;
begin
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if m_GroupOwner <> nil then
  begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -1, 0, 0, 0, '');
    exit;
  end;
  if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or
    PlayObject.m_boGhost then
  begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
    exit;
  end;
  if (PlayObject.m_GroupOwner <> nil) then
  begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -3, 0, 0, 0, '');
    exit;
  end;
  if (not PlayObject.m_boAllowGroup) then
  begin
    SendDefMessage(SM_CREATEGROUP_FAIL, -4, 0, 0, 0, '');
    exit;
  end;
  m_GroupMembers.Clear;
  m_GroupMembers.AddObject(m_sCharName, Self);
  m_GroupMembers.AddObject(sHumName, PlayObject);
  JoinGroup(Self);
  PlayObject.JoinGroup(Self);
  m_boAllowGroup := True;
  SendDefMessage(SM_CREATEGROUP_OK, 0, 0, 0, 0, '');
  SendGroupMembers();
end;

procedure TPlayObject.ClientAddGroupMember(sHumName: string); //004DCE48
var
  PlayObject                                           : TPlayObject;
begin
  PlayObject := UserEngine.GeTPlayObject(sHumName);

  if m_GroupOwner <> Self then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -1, 0, 0, 0, '');
    exit;
  end;
  if m_GroupMembers.Count > g_Config.nGroupMembersMax then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -5, 0, 0, 0, '');
    exit;
  end;
  if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or
    PlayObject.m_boGhost then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, '');
    exit;
  end;
  if (PlayObject.m_GroupOwner <> nil) then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, '');
    exit;
  end;
  if (not PlayObject.m_boAllowGroup) then
  begin
    SendDefMessage(SM_GROUPADDMEM_FAIL, -4, 0, 0, 0, '');
    exit;
  end;

  m_GroupMembers.AddObject(sHumName, PlayObject);
  PlayObject.JoinGroup(Self);
  SendDefMessage(SM_GROUPADDMEM_OK, 0, 0, 0, 0, '');
  SendGroupMembers();
end;

procedure TPlayObject.ClientDelGroupMember(sHumName: string); //004DCFB8
var
  PlayObject                                           : TPlayObject;
begin
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if m_GroupOwner <> Self then
  begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -1, 0, 0, 0, '');
    exit;
  end;
  if PlayObject = nil then
  begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -2, 0, 0, 0, '');
    exit;
  end;
  if not IsGroupMember(PlayObject) then
  begin
    SendDefMessage(SM_GROUPDELMEM_FAIL, -3, 0, 0, 0, '');
    exit;
  end;
  DelMember(PlayObject);
  SendDefMessage(SM_GROUPDELMEM_OK, 0, 0, 0, 0, sHumName);
end;

procedure TPlayObject.ClientgetGroupMemberxy;               //004DCBA4
var
  I, j, r                                              : Integer;
  PlayObject, PlayObject1                              : TPlayObject;
  Sendbuf                                              : array[0..50] of integer;
begin

  if m_GroupMembers.Count <= 0 then
    exit;

  m_DefMsg := MakeDefaultMsg(736, 0, 0, 0, 0);

  for I := 0 to m_GroupMembers.Count - 1 do
  begin
    PlayObject := TPlayObject(m_GroupMembers.Objects[i]);
    fillchar(Sendbuf, sizeof(Sendbuf), #0);
    r := 0;
    for j := 0 to m_GroupMembers.Count - 1 do
    begin
      PlayObject1 := TPlayObject(m_GroupMembers.Objects[j]);
      if (PlayObject <> PlayObject1) and (PlayObject.m_PEnvir = PlayObject1.m_PEnvir)
        then
      begin
        Sendbuf[r] := makelong(PlayObject1.m_nCurrX, PlayObject1.m_nCurrY);
        inc(r);
      end;
    end;
    PlayObject.SendSocket(@m_DefMsg, EncodeBuffer(@Sendbuf, (m_GroupMembers.Count - 1) *
      4));
  end;
  // SendSocket(@m_DefMsg,EncodeBuffer(@Sendbuf,m_GroupMembers.Count*4));
end;

procedure TPlayObject.ClientDealTry(sHumName: string);      //004DD0A8
var
  BaseObject                                           : TBaseObject;
begin
  if g_Config.boDisableDeal then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDisableDealItemsMsg);
    exit;
  end;
  if m_boDealing then
    exit;
  if m_btAttatckMode <> HAM_PEACE then
  begin
    SysMsg('对不起无法交易，只有和平攻击模式才能交易', c_Green, t_Hint);  //[攻击模式: 和平攻击]
    exit;
  end;

  if m_boArrow then
  begin
    SysMsg('现在不能交易', c_Green, t_Hint);
    exit;
  end;

  if GetTickCount - m_DealLastTick < g_Config.dwTryDealTime {3000} then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sPleaseTryDealLaterMsg);  //请稍候再交易
    exit;
  end;

  if not m_boCanDeal then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sCanotTryDealMsg);
    exit;
  end;
  BaseObject := GetPoseCreate();                            //对面的人物

  if (BaseObject <> nil) and (BaseObject <> self) then
  begin
    if (BaseObject.GetPoseCreate = Self) and (not BaseObject.m_boDealing) then
    begin
      if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
      begin

        if (BaseObject.m_boAllowDeal and TPlayObject(BaseObject).m_boCanDeal) and (not
          (TPlayObject(BaseObject).m_boArrow)) then
        begin
          BaseObject.SysMsg(m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);  //对方客户端显示开始交易
          SysMsg(BaseObject.m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);  //自己也现实开始交易
          TPlayObject(Self).OpenDealDlg(BaseObject);        //打开交易框。
          TPlayObject(BaseObject).OpenDealDlg(Self);
        end
        else
        begin                                               //004DD1CC
          SysMsg(g_sPoseDisableDealMsg {'对方禁止进入交易'}, c_Red, t_Hint);
        end;
      end;

    end
    else
    begin                                                   //004DD1E0
      SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
    end;

  end
  else
  begin                                                     //004DD1F9
    SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
  end;

end;

procedure TPlayObject.ClientAddDealItem(nItemIdx: integer; sItemName: string); //004DD79C
var
  I                                                    : Integer;
  bo11                                                 : Boolean;
  UserItem                                             : pTUserItem;
  sUserItemName                                        : string;
  stditem                                              : TStdItem;
  Item                                                 : pTStdItem;
begin
  if (m_DealCreat = nil) or (not m_boDealing) then
    exit;
  if Pos(' ', sItemName) >= 0 then
  begin //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sItemName, sItemName, [' ']);
  end;
  bo11 := False;
  if not m_DealCreat.m_boDealOK then
  begin
    for I := 0 to m_Itemlist.Count - 1 do
    begin
      UserItem := m_Itemlist.Items[i];
      if UserItem.MakeIndex = nItemIdx then
      begin
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex,
            UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);
        /////////////      包月物品禁止交易
        item := UserEngine.GetStdItem(UserItem.wIndex);
        stditem := item^;
        ItemUnit.GetItemAddValue(UserItem, StdItem);
        if stditem.Reserved = 11 then
        begin                                               //stditem.StdMode =49
          SysMsg('此物品禁止交易', c_red, t_Hint);
          bo11 := false;
          break;
        end;
        if GetBoValue(UserItem, UserItem.wIndex, 0) then
        begin
          SysMsg('此物品禁止交易', c_red, t_Hint);
          bo11 := false;
          break;

        end;
        /////////

        if (CompareText(sUserItemName, sItemName) = 0) and
          (m_DealItemList.Count < 12) then
        begin
          m_DealItemList.Add(UserItem);
          TPlayObject(Self).SendAddDealItem(UserItem);
          m_Itemlist.Delete(i);
          bo11 := True;
          break;
        end;
      end;
    end;
  end;                                                      //004DDAA7
  if not bo11 then
    SendDefMessage(SM_DEALADDITEM_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientDelDealItem(nItemIdx: integer; sItemName: string); //004DD958
var
  I                                                    : Integer;
  bo11                                                 : Boolean;
  UserItem                                             : pTUserItem;
  sUserItemName                                        : string;
begin

  if g_Config.boCanNotGetBackDeal then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
    exit;
  end;

  if (m_DealCreat = nil) or (not m_boDealing) then
    exit;

  if Pos(' ', sItemName) >= 0 then
  begin //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sItemName, sItemName, [' ']);
  end;

  bo11 := False;
  if not m_DealCreat.m_boDealOK then
  begin                                                     //如果主动方还没有确认
    for I := 0 to m_DealItemList.Count - 1 do
    begin
      UserItem := m_DealItemList.Items[i];
      if UserItem.MakeIndex = nItemIdx then
      begin

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex,
            UserItem.wIndex);
        if sUserItemName = '' then
          sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

        if CompareText(sUserItemName, sItemName) = 0 then
        begin
          m_Itemlist.Add(UserItem);
          TPlayObject(Self).SendDelDealItem(UserItem);
          m_DealItemList.Delete(i);
          bo11 := True;
          break;
        end;
      end;
    end;
  end;                                                      //004DDAA7
  if not bo11 then
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.ClientCancelDeal;                     //004DD450
begin
  DealCancel();
end;

procedure TPlayObject.ClientChangeDealGold(nGold: Integer; nType: Integer); //004DDB04
var
  bo09                                                 : Boolean;
begin

  //禁止取回放入交易栏内的金币
  if (m_nDealGolds > 0) and g_Config.boCanNotGetBackDeal and (ntype = 0) then
  begin
    SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sDealItemsDenyGetBackMsg);
    SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
    exit;
  end;

  if nGold < 0 then
  begin
    SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0,
      '');
    exit;
  end;
  bo09 := False;

  if (m_DealCreat <> nil) and (GetPoseCreate = m_DealCreat) then
  begin
    if not m_DealCreat.m_boDealOK then
    begin
      if nType = 0 then                                     //放金币
        if (m_nGold + m_nDealGolds) >= nGold then
        begin
          m_nGold := (m_nGold + m_nDealGolds) - nGold;
          m_nDealGolds := nGold;
          SendDefMessage(SM_DEALCHGGOLD_OK, m_nDealGolds, LoWord(m_nGold),
            HiWord(m_nGold), 0, '');
          TPlayObject(m_DealCreat).SendDefMessage(SM_DEALREMOTECHGGOLD, m_nDealGolds, 0,
            0, 0, '');
          m_DealCreat.m_DealLastTick := GetTickCount();
          bo09 := True;
          m_DealLastTick := GetTickCount();
        end;                                                //004DDC50
      if nType = 1 then                                     //放元宝
        if (m_nGameGold + m_nDealGameGolds) >= nGold then
        begin
          m_nGameGold := (m_nGameGold + m_nDealGameGolds) - nGold;
          m_nDealGameGolds := nGold;
          SendDefMessage(SM_DEALCHGGOLD_OK, m_nDealGameGolds, LoWord(m_nGameGold),
            HiWord(m_nGameGold), 1, '');
          TPlayObject(m_DealCreat).SendDefMessage(SM_DEALREMOTECHGGOLD, m_nDealGameGolds,
            0, 0, 1, '');
          m_DealCreat.m_DealLastTick := GetTickCount();
          bo09 := True;
          m_DealLastTick := GetTickCount();
        end;                                                //004DDC50

    end;
  end;
  if not bo09 then
  begin
    SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold), HiWord(m_nGold), 0,
      '');
  end;

end;

procedure TPlayObject.ClientDealEnd;                        //004DDC8C
var
  I                                                    : Integer;
  bo11                                                 : Boolean;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
  PlayObject                                           : TPlayObject;
begin
  m_boDealOK := True;
  if m_DealCreat = nil then
    exit;
  if ((GetTickcount - m_DealLastTick) < g_Config.dwDealOKTime {1000}) or ((GetTickcount -
    m_DealCreat.m_DealLastTick) < g_Config.dwDealOKTime {1000}) then
  begin
    SysMsg(g_sDealOKTooFast, c_Red, t_Hint);
    DealCancel();
    exit;
  end;
  if m_DealCreat.m_boDealOK then
  begin
    bo11 := True;
    if (m_bMaxBagitem - m_ItemList.Count) < m_DealCreat.m_DealItemList.Count then
    begin                                                   //MAXBAGITEM
      bo11 := False;
      SysMsg(g_sYourBagSizeTooSmall, c_Red, t_Hint);
    end;
    if (m_nGoldMax - m_nGold) < m_DealCreat.m_nDealGolds then
    begin
      SysMsg(g_sYourGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;
    if (m_DealCreat.m_bMaxBagitem - m_DealCreat.m_ItemList.Count) < m_DealItemList.Count
      then
    begin                                                   //  MAXBAGITEM
      SysMsg(g_sDealHumanBagSizeTooSmall, c_Red, t_Hint);
      bo11 := False;
    end;
    if (m_DealCreat.m_nGoldMax - m_DealCreat.m_nGold) < m_nDealGolds then
    begin
      SysMsg(g_sDealHumanGoldLargeThenLimit, c_Red, t_Hint);
      bo11 := False;
    end;
    if bo11 then
    begin
      for I := 0 to m_DealItemList.Count - 1 do
      begin
        UserItem := m_DealItemList.Items[i];
        m_DealCreat.AddItemToBag(UserItem);
        TPlayObject(m_DealCreat).SendAddItem(UserItem);
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          if not IsCheapStuff(StdItem.StdMode) then
          begin
            //004DDF49
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('8' + #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '1' + #9 +
                m_DealCreat.m_sCharName);
          end;
        end;
      end;                                                  //004DDF5A
      if m_nDealGolds > 0 then
      begin
        Inc(m_DealCreat.m_nGold, m_nDealGolds);
        m_DealCreat.GoldChanged();
        //004DE05E
        if g_boGameLogGold then
          AddGameDataLog('8' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(m_nGold) + #9 +
            '1' + #9 +
            m_DealCreat.m_sCharName);
      end;
      if m_nDealgameGolds > 0 then
      begin
        Inc(m_DealCreat.m_ngameGold, m_nDealgameGolds);
        m_DealCreat.gameGoldChanged();
        //004DE05E
        if g_boGameLogGold then
          AddGameDataLog('8' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            '元宝' + #9 +
            IntToStr(m_ngameGold) + #9 +
            '1' + #9 +
            m_DealCreat.m_sCharName);
      end;

      for I := 0 to m_DealCreat.m_DealItemList.Count - 1 do
      begin
        UserItem := m_DealCreat.m_DealItemList.Items[i];
        AddItemToBag(UserItem);
        TPlayObject(Self).SendAddItem(UserItem);
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          if not IsCheapStuff(StdItem.StdMode) then
          begin
            //004DE217
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('8' + #9 +
                m_DealCreat.m_sMapName + #9 +
                IntToStr(m_DealCreat.m_nCurrX) + #9 +
                IntToStr(m_DealCreat.m_nCurrY) + #9 +
                m_DealCreat.m_sCharName + #9 +
                //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '1' + #9 +
                m_sCharName);
          end;
        end;
      end;                                                  //004DDF5A
      if m_DealCreat.m_nDealGolds > 0 then
      begin
        Inc(m_nGold, m_DealCreat.m_nDealGolds);
        GoldChanged();
        //004DE36E
        if g_boGameLogGold then
          AddGameDataLog('8' + #9 +
            m_DealCreat.m_sMapName + #9 +
            IntToStr(m_DealCreat.m_nCurrX) + #9 +
            IntToStr(m_DealCreat.m_nCurrY) + #9 +
            m_DealCreat.m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(m_DealCreat.m_nGold) + #9 +
            '1' + #9 +
            m_sCharName);
      end;
      if m_DealCreat.m_nDealgameGolds > 0 then
      begin
        Inc(m_ngameGold, m_DealCreat.m_nDealgameGolds);
        gameGoldChanged();
        //004DE36E
        if g_boGameLogGold then
          AddGameDataLog('8' + #9 +
            m_DealCreat.m_sMapName + #9 +
            IntToStr(m_DealCreat.m_nCurrX) + #9 +
            IntToStr(m_DealCreat.m_nCurrY) + #9 +
            m_DealCreat.m_sCharName + #9 +
            '元宝' + #9 +
            IntToStr(m_DealCreat.m_ngameGold) + #9 +
            '1' + #9 +
            m_sCharName);
      end;

      //004DE37
      PlayObject := TPlayObject(m_DealCreat);
      PlayObject.SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
      PlayObject.SysMsg(g_sDealSuccessMsg {'交易成功...'}, c_Green, t_Hint);
      PlayObject.m_DealCreat := nil;
      PlayObject.m_boDealing := False;
      PlayObject.m_DealItemList.Clear;
      PlayObject.m_nDealGolds := 0;
      PlayObject.m_nDealGameGolds := 0;
      PlayObject.m_boDealOK := False;                       //Jacky 增加

      SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
      SysMsg(g_sDealSuccessMsg {'交易成功...'}, c_Green, t_Hint);
      m_DealCreat := nil;
      m_boDealing := False;
      m_DealItemList.Clear;
      m_nDealGolds := 0;
      m_nDealGameGolds := 0;
      m_boDealOK := False;                                  //Jacky 增加
    end
    else
    begin                                                   //004DE42F
      DealCancel();
    end;
  end
  else
  begin                                                     //004DE439
    SysMsg(g_sYouDealOKMsg {'你已经确认交易了'}, c_Green, t_Hint);
    m_DealCreat.SysMsg(g_sPoseDealOKMsg {'对方已经确认交易了'}, c_Green, t_Hint);
  end;
end;

procedure TPlayObject.ClientGetMinMap;                      //004DE550
var
  nMinMap                                              : integer;
begin
  nMinMap := m_PEnvir.nMinMap;
  if nMinMap > 0 then
  begin
    SendDefMessage(SM_READMINIMAP_OK, 0, nMinMap, 0, 0, '');
  end
  else
  begin
    SendDefMessage(SM_READMINIMAP_FAIL, 0, 0, 0, 0, '');
  end;

end;

procedure TPlayObject.ClientMakeDrugItem(NPC: TObject; nItemName: string); //004DCAF8
var
  Merchant                                             : TMerchant;
begin
  Merchant := UserEngine.FindMerchant(NPC);
  if (Merchant = nil) or (not Merchant.m_boMakeDrug) then
    exit;
  if ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientMakeDrugItem(Self, nItemName);

end;

procedure TPlayObject.ClientOpenGuildDlg;                   //004DE8E0
var
  I                                                    : Integer;
  sC                                                   : string;
begin
  if m_MyGuild <> nil then
  begin
    sC := TGuild(m_MyGuild).sGuildName + #13 + ' ' + #13;
    if m_nGuildRankNo = 1 then
    begin
      sC := sC + '1' + #13;
    end
    else
    begin
      sC := sC + '0' + #13;
    end;
    sC := sC + '<Notice>' + #13;
    for I := 0 to TGuild(m_MyGuild).NoticeList.Count - 1 do
    begin
      if length(sC) > 5000 then
        break;
      sC := sC + TGuild(m_MyGuild).NoticeList.Strings[I] + #13;
    end;                                                    // for
    sC := sC + '<KillGuilds>' + #13;
    for I := 0 to TGuild(m_MyGuild).GuildWarList.Count - 1 do
    begin
      if length(sC) > 5000 then
        break;
      sC := sC + TGuild(m_MyGuild).GuildWarList.Strings[I] + #13;
    end;                                                    // for
    sC := sC + '<AllyGuilds>' + #13;
    for I := 0 to TGuild(m_MyGuild).GuildAllList.Count - 1 do
    begin
      if length(sC) > 5000 then
        break;
      sC := sC + TGuild(m_MyGuild).GuildAllList.Strings[I] + #13;
    end;                                                    // for
    m_DefMsg := MakeDefaultMsg(SM_OPENGUILDDLG, 0, 0, 0, 1);
    SendSocket(@m_DefMsg, EncodeString(sC));
  end
  else
  begin
    SendDefMessage(SM_OPENGUILDDLG_FAIL, 0, 0, 0, 0, '');
  end;

end;

procedure TPlayObject.ClientGuildHome;                      //004DEBDC
begin
  ClientOpenGuildDlg();
end;

procedure TPlayObject.ClientGuildMemberList(nVer: Integer); //004DEBF0
var
  GuildRank                                            : pTGuildRank;
  I, II                                                : Integer;
  sSendMsg                                             : string;
begin
  if m_MyGuild = nil then
    exit;
  for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do
  begin
    GuildRank := TGuild(m_MyGuild).m_RankList.Items[I];

    sSendMsg := sSendMsg + '#' + IntToStr(GuildRank.nRankNo) + '/*' + GuildRank.sRankName
      + '/';
    for II := 0 to GuildRank.MemberList.Count - 1 do
    begin
      if length(sSendMsg) > 5000 then
        break;
      if m_nSoftVersionDateEx <> 0 then
        sSendMsg := sSendMsg + GuildRank.MemberList.Strings[II] + '/'
      else
        sSendMsg := sSendMsg + '10' + GuildRank.MemberList.Strings[II] + '/';
    end;

  end;
  if nVer = 837 then
    m_DefMsg := MakeDefaultMsg(837, 0, 0, 0, 1)
  else
    m_DefMsg := MakeDefaultMsg(SM_SENDGUILDMEMBERLIST, 0, 0, 0, 0);
  SendSocket(@m_DefMsg, EncodeString(sSendMsg));
end;

procedure TPlayObject.ClientGuildAddMember(sHumName: string); //004DEDB4
var
  nC                                                   : integer;
  PlayObject                                           : TPlayObject;
begin
  nC := 1;                                                  //'你没有权利使用这个命令。'
  if IsGuildMaster then
  begin
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then
    begin
      if PlayObject.GetPoseCreate = Self then
      begin
        if PlayObject.m_boAllowGuild then
        begin
          if not TGuild(m_MyGuild).IsMember(sHumName) then
          begin
            if (PlayObject.m_MyGuild = nil) and (TGuild(m_MyGuild).m_RankList.Count <
              TGuild(m_MyGuild).nMemberMaxCount) then
            begin
              TGuild(m_MyGuild).AddMember(PlayObject);
              UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
                TGuild(m_MyGuild).sGuildName);
              PlayObject.m_MyGuild := m_MyGuild;
              PlayObject.m_sGuildRankName := TGuild(m_MyGuild).GetRankName(PlayObject,
                PlayObject.m_nGuildRankNo);
              PlayObject.RefShowName();
              PlayObject.SysMsg('你已加入行会: ' + TGuild(m_MyGuild).sGuildName +
                ' 当前封号为: ' + PlayObject.m_sGuildRankName, c_Green, t_Hint);
              nC := 0;
            end
            else
              nC := 4;                                      //'对方已经加入其他行会。'
          end
          else
            nC := 3; //004DEEF4 '对方已经加入我们的行会。'
        end
        else
        begin                                               //004DEEFD
          nC := 5;                                          //'对方不允许加入行会。'
          PlayObject.SysMsg('你拒绝加入行会。 [允许命令为 @' + g_GameCommand.LETGUILD.sCmd
            + ']', c_Red, t_Hint);
        end;
      end
      else
        nC := 2; //004DEF15 '想加入进来的成员应该来面对掌门人。'
    end
    else
      nC := 2;                                              //004DEF1E
  end;                                                      //004DEF25
  if nC = 0 then
  begin
    SendDefMessage(SM_GUILDADDMEMBER_OK, 0, 0, 0, 0, '');
  end
  else
  begin
    SendDefMessage(SM_GUILDADDMEMBER_FAIL, nC, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.ClientGuildDelMember(sHumName: string); //004DEFB8
var
  nC                                                   : integer;
  s14                                                  : string;
  PlayObject                                           : TPlayObject;
begin
  nC := 1;
  if IsGuildMaster then
  begin
    if TGuild(m_MyGuild).IsMember(sHumName) then
    begin
      if m_sCharName <> sHumName then
      begin
        if TGuild(m_MyGuild).DelMember(sHumName) then
        begin
          PlayObject := UserEngine.GeTPlayObject(sHumName);
          if PlayObject <> nil then
          begin
            PlayObject.m_MyGuild := nil;
            PlayObject.RefRankInfo(0, '');
            PlayObject.RefShowName();                       //10/31
          end;                                              //004DF078
          UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
            TGuild(m_MyGuild).sGuildName);
          nC := 0;
        end
        else
          nC := 4;                                          //004DF0A8
      end
      else
      begin                                                 //004DF0B4
        nC := 3;
        s14 := TGuild(m_MyGuild).sGuildName;
        if TGuild(m_MyGuild).CancelGuld(sHumName) then
        begin
          g_GuildManager.DelGuild(s14);
          UserEngine.SendServerGroupMsg(SS_206, nServerIndex, s14);
          m_MyGuild := nil;
          RefRankInfo(0, '');
          RefShowName();                                    //10/31
          SysMsg('行会' + s14 + '已被取消！！！', c_Red, t_Hint);
          nC := 0;
        end
      end;
    end
    else
      nC := 2;
  end;                                                      //004DF15C

  if nC = 0 then
  begin
    SendDefMessage(SM_GUILDDELMEMBER_OK, 0, 0, 0, 0, '');
  end
  else
  begin
    SendDefMessage(SM_GUILDDELMEMBER_FAIL, nC, 0, 0, 0, '');
  end;

end;

procedure TPlayObject.ClientGuildUpdateNotice(sNotict: string); //004DF1EC
var
  sC                                                   : string;
begin
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) or (length(sNotict) > 5000) then
    exit;
  TGuild(m_MyGuild).NoticeList.Clear;
  while (sNotict <> '') do
  begin
    sNotict := GetValidStr3(sNotict, sC, [#$D]);
    TGuild(m_MyGuild).NoticeList.Add(sC);
  end;                                                      // while
  TGuild(m_MyGuild).SaveGuildInfoFile();
  UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGuild(m_MyGuild).sGuildName);
  ClientOpenGuildDlg();
end;

procedure TPlayObject.ClientGuildUpdateRankInfo(sRankInfo: string); //004DF2E8
var
  nC                                                   : Integer;
begin
  if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then
    exit;
  nC := TGuild(m_MyGuild).UpdateRank(sRankInfo);
  if nC = 0 then
  begin
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGuild(m_MyGuild).sGuildName);
    ClientGuildMemberList(837);
  end
  else
  begin
    if nC <= -2 then
    begin
      SendDefMessage(SM_GUILDRANKUPDATE_FAIL, nC, 0, 0, 0, '');
    end;

  end;

end;

procedure TPlayObject.ClientGuildAlly;                      //004DF3AC
var
  n8                                                   : Integer;
  BaseObjectC                                          : TBaseObject;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::ClientGuildAlly';
begin
  try
    n8 := -1;
    BaseObjectC := GetPoseCreate();
    if (BaseObjectC <> nil) and
      (BaseObjectC.m_MyGuild <> nil) and
      (BaseObjectC.m_btRaceServer = RC_PLAYOBJECT) and
      (BaseObjectC.GetPoseCreate = Self) then
    begin
      if TGuild(BaseObjectC.m_MyGuild).m_boEnableAuthAlly then
      begin
        if BaseObjectC.IsGuildMaster and IsGuildMaster then
        begin
          if TGuild(m_MyGuild).IsNotWarGuild(TGuild(BaseObjectC.m_MyGuild)) and
            TGuild(BaseObjectC.m_MyGuild).IsNotWarGuild(TGuild(m_MyGuild)) then
          begin

            TGuild(m_MyGuild).AllyGuild(TGuild(BaseObjectC.m_MyGuild));
            TGuild(BaseObjectC.m_MyGuild).AllyGuild(TGuild(m_MyGuild));

            TGuild(m_MyGuild).SendGuildMsg(TGuild(BaseObjectC.m_MyGuild).sGuildName +
              '行会已经和您的行会联盟成功。');
            TGuild(BaseObjectC.m_MyGuild).SendGuildMsg(TGuild(m_MyGuild).sGuildName +
              '行会已经和您的行会联盟成功。');
            TGuild(m_MyGuild).RefMemberName;
            TGuild(BaseObjectC.m_MyGuild).RefMemberName;
            UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
              TGuild(m_MyGuild).sGuildName);
            UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
              TGuild(BaseObjectC.m_MyGuild).sGuildName);
            n8 := 0;
          end
          else
            n8 := -2;
        end
        else
          n8 := -3;
      end
      else
        n8 := -4;                                           //004DF57C
    end;
    if n8 = 0 then
    begin
      SendDefMessage(SM_GUILDMAKEALLY_OK, 0, 0, 0, 0, '');
    end
    else
    begin
      SendDefMessage(SM_GUILDMAKEALLY_FAIL, n8, 0, 0, 0, '');
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg);
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

procedure TPlayObject.ClientGuildBreakAlly(sGuildName: string); //004DF604
var
  n10                                                  : Integer;
  Guild                                                : TGuild;
begin
  n10 := -1;
  if not IsGuildMaster() then
    exit;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild <> nil then
  begin
    if TGuild(m_MyGuild).IsAllyGuild(Guild) then
    begin
      TGuild(m_MyGuild).DelAllyGuild(Guild);
      Guild.DelAllyGuild(TGuild(m_MyGuild));
      TGuild(m_MyGuild).SendGuildMsg(Guild.sGuildName +
        ' 行会与您的行会解除联盟成功！！！');
      Guild.SendGuildMsg(TGuild(m_MyGuild).sGuildName +
        ' 行会解除了与您行会的联盟！！！');
      TGuild(m_MyGuild).RefMemberName();
      Guild.RefMemberName();
      UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGuild(m_MyGuild).sGuildName);
      UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);
      n10 := 0;
    end
    else
      n10 := -2;
  end
  else
    n10 := -3;                                              //004DF750
  if n10 = 0 then
  begin
    SendDefMessage(SM_GUILDBREAKALLY_OK, 0, 0, 0, 0, '');
  end
  else
  begin
    SendDefMessage(SM_GUILDMAKEALLY_FAIL, 0, 0, 0, 0, '');
  end;

end;

function TPlayObject.SetPetAddInfo(UserItem: PTUserItem; nPos: Integer; nValue: Integer):
  Integer;
var
  btValue                                              : byte;
begin
  Result := 0;
  btValue := nValue;
  case npos of
    0: ;                                                    //积累经验
    1: Useritem.AttachMagic.aaa.PetAddProperty.wCount := nValue; //幻化次数
    2:
      begin
        Useritem.AttachMagic.aaa.PetAddProperty.btZizhi := nValue; //资质
        UserItem.DuraMax := nValue;
      end;
    3: Useritem.AttachMagic.aaa.PetAddProperty.wHp := nValue; //生命
    4: Useritem.AttachMagic.aaa.PetAddProperty.btMagic := btValue; //魔法值
    5: Useritem.AttachMagic.aaa.PetAddProperty.btANTIPOISON := btValue; //中毒躲避
    6: Useritem.AttachMagic.aaa.PetAddProperty.btMAC1 :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btMAC1 and $E0) + (btValue and $1F);  //魔御下限
    7: Useritem.AttachMagic.aaa.PetAddProperty.btMAC2 :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btMAC2 and $E0) + (btValue and $1F);  //魔御上限
    8: Useritem.AttachMagic.aaa.PetAddProperty.btMAGICNICETY :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btMAGICNICETY and $E0) + (btValue and $1F);  //魔法命中
    9: Useritem.AttachMagic.aaa.PetAddProperty.btEVADET :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btEVADET and $E0) + (btValue and $1F); //躲避
    10: Useritem.AttachMagic.aaa.PetAddProperty.btAC1 :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btAC1 and $E0) + (btValue and $1F);  // 防御下限
    11: Useritem.AttachMagic.aaa.PetAddProperty.btAC2 :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btAC2 and $E0) + (btValue and $1F);  // 防御上限
    12: Useritem.AttachMagic.aaa.PetAddProperty.btANTIMAGIC :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btANTIPOISON and $E0) + (btValue and $1F);  //魔法躲避
    13: Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY and $E0) + (btValue and $1F);  //中毒命中
    14: Useritem.AttachMagic.aaa.PetAddProperty.btSAVVY := btValue; // 顿悟
    15: Useritem.AttachMagic.aaa.PetAddProperty.btvalue1 := btValue;  // 五行属性1(0: 金、1:木、2:土、3:水)
    16: Useritem.AttachMagic.aaa.PetAddProperty.btvalue2 := btValue;  // 五行属性2(0: 火、1:木、2:土、3:水)
    17: ;                                                   //灵兽经验
    18: ;                                                   // 保留
    19: Useritem.AttachMagic.aaa.PetAddProperty.btMAC1 :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btMAC1 and $1F) + ((btValue and $7) shl 5);  // 魔法攻击下限 最高：7
    20: Useritem.AttachMagic.aaa.PetAddProperty.btMAC2 :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btMAC2 and $1F) + ((btValue and $7) shl 5);  // 魔法攻击上限 最高：7
    21: Useritem.AttachMagic.aaa.PetAddProperty.btMAGICNICETY :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btMAGICNICETY and $1F) + ((btValue and $7)
      shl 5);                                                 // 道术攻击下限 最高：7
    22: Useritem.AttachMagic.aaa.PetAddProperty.btANTIMAGIC :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btANTIMAGIC and $1F) + ((btValue and $7) shl
      5);                                                     // 道术攻击上限 最高：7
    23: Useritem.AttachMagic.aaa.PetAddProperty.btAC1 :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btAC1 and $1F) + ((btValue and $7) shl 5);  // 攻击下限  最高：7
    24: Useritem.AttachMagic.aaa.PetAddProperty.btAC2 :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btAC2 and $1F) + ((btValue and $7) shl 5);  // 攻击上限  最高：7
    25: Useritem.AttachMagic.aaa.PetAddProperty.btEVADET :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btevadet and $1F) + ((btValue and $7) shl 5);  // 命中  最高：7
    26: Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY and $9F) + ((btValue and $3)
      shl 5);                                                 // 幸运  最高：3
    27: Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY :=
      (Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY and $7F) + ((btValue and $1)
      shl 7);                                                 //骑战速度  最高：1
  end;
end;

function TPlayObject.GetEvilId: Integer;
var
  i                                                    : Integer;
  BaseObject                                           : TBaseObject;
  EvilKillDate                                         : TEvilKillDate;
begin
  for I := m_SlaveList.Count - 1 downto 0 do
  begin
    BaseObject := TBaseObject(m_SlaveList.Items[i]);
    if BaseObject.m_btRaceServer >= 254 then                //是心魔
    begin
      Result := Integer(BaseObject);
      break;
    end;
  end;

end;

procedure TPlayObject.EvilRoyalty;
var
  i                                                    : Integer;
  BaseObject                                           : TBaseObject;
  EvilKillDate                                         : TEvilKillDate;
begin
  for I := m_SlaveList.Count - 1 downto 0 do
  begin
    BaseObject := TBaseObject(m_SlaveList.Items[i]);
    if BaseObject.m_btRaceServer >= 254 then                //是心魔
    begin
      m_SlaveList.Delete(i);
      BaseObject.m_master := nil;
      BaseObject.RefShowName;
      break;
    end;
  end;
  FillChar(EvilKillDate, SizeOf(TEvilKillDate), #0);
  EvilKillDate.nZMValueMax := g_Config.CallEvilConf.nEvilCtrlMaxPower * 1000;
  EvilKillDate.nValue2 := $DAC;
  SendDefMessage(34968, 0, 1, 0, 0, EncodeBuffer(@EvilKillDate, SizeOf(EvilKillDate)),
    True);
  m_nCallEvilCount := 0;
end;

function TPlayObject.GetItemInfoStr(UserItem: PTUserItem; sPos: string): string;
var
  stditem                                              : pTStdItem;
  n14                                                  : Integer;
  s14                                                  : string;
begin
  Result := '';
  if UserItem = nil then Exit;
  stditem := UserEngine.GetStdItem(Useritem.wIndex);
  if stditem = nil then exit;
  sPos := UpperCase(sPos);

  if sPos = 'NAME' then
    Result := StdItem.Name
  else
    if sPos = 'STDMODE' then
      Result := IntToStr(StdItem.StdMode)
    else
      if sPos = 'SHAPE' then
        Result := IntToStr(StdItem.Shape)
      else
        if sPos = 'WEIGHT' then
          Result := IntToStr(StdItem.Weight)
        else
          if sPos = 'ANICOUNT' then
            Result := IntToStr(StdItem.AniCount)
          else
            if sPos = 'SOURCE' then
              Result := IntToStr(StdItem.Source)
            else
              if sPos = 'RESERVED' then
                Result := IntToStr(StdItem.Reserved)
              else
                if sPos = 'LOOKS' then
                  Result := IntToStr(StdItem.Looks)
                else
                  if sPos = 'AC1' then
                    Result := IntToStr(Lobyte(StdItem.AC))
                  else
                    if sPos = 'AC2' then
                      Result := IntToStr(Hibyte(StdItem.AC))
                    else
                      if sPos = 'MAC1' then
                        Result := IntToStr(Lobyte(StdItem.MAC))
                      else
                        if sPos = 'MAC2' then
                          Result := IntToStr(Hibyte(StdItem.MAC))
                        else
                          if sPos = 'DC1' then
                            Result := IntToStr(Lobyte(StdItem.DC))
                          else
                            if sPos = 'DC2' then
                              Result := IntToStr(Hibyte(StdItem.DC))
                            else
                              if sPos = 'MC1' then
                                Result := IntToStr(Lobyte(StdItem.MC))
                              else
                                if sPos = 'MC2' then
                                  Result := IntToStr(Hibyte(StdItem.MAC))
                                else
                                  if sPos = 'SC1' then
                                    Result := IntToStr(Lobyte(StdItem.SC))
                                  else
                                    if sPos = 'SC2' then
                                      Result := IntToStr(Hibyte(StdItem.SC))
                                    else
                                      if sPos = 'NEED' then
                                        Result := IntToStr(StdItem.Need)
                                      else
                                        if sPos = 'NEEDLEVEL' then
                                          Result := IntToStr(StdItem.NeedLevel)
                                        else
                                          if sPos = 'NEEDREALM' then
                                            Result := IntToStr(StdItem.Looks)
                                          else
                                            if sPos = 'DURA' then
                                              Result := IntToStr(UserItem.Dura)
                                            else
                                              if sPos = 'DURAMAX' then
                                                Result := IntToStr(UserItem.DuraMax)
                                              else
                                                if sPos = 'OVERLAP' then
                                                  Result := Inttostr(USERItem.btValue[0]
                                                    + Stditem.DuraMax)
                                                else
                                                  if sPos = 'GLOOMPOINT' then
                                                    Result :=
                                                      IntToStr(UserItem.DarkProp.DMagic)
                                                  else
                                                    if CompareLStr(spos, 'LOGLOOM(', 8)
                                                      then
                                                    begin
                                                      ArrestStringEx(sPos, '(', ')',
                                                        s14);
                                                      n14 := Str_ToInt(s14, 0);

                                                      case n14 of
                                                        6: n14 := 20;
                                                        7: n14 := 22;
                                                        8: n14 := 24;
                                                        9: n14 := 26;
                                                        10: n14 := 28;
                                                      end;
                                                      Result :=
                                                        IntToStr(GetItemInfo(UserItem,
                                                        n14));
                                                    end
                                                    else
                                                      if CompareLStr(sPos, 'ITEMEXT(',
                                                        Length('ITEMEXT(')) then
                                                      begin
                                                        ArrestStringEx(sPos, '(', ')',
                                                          s14);
                                                        n14 := Str_ToInt(s14, 0);
                                                        Result :=
                                                          IntToStr(GetItemInfo(UserItem,
                                                          n14));
                                                      end
                                                      else
                                                        if CompareLStr(spos, 'HIGLOOM(',
                                                          8) then
                                                        begin
                                                          ArrestStringEx(sPos, '(', ')',
                                                            s14);
                                                          n14 := Str_ToInt(s14, 0);

                                                          case n14 of
                                                            6: n14 := 20;
                                                            7: n14 := 22;
                                                            8: n14 := 24;
                                                            9: n14 := 26;
                                                            10: n14 := 28;
                                                          end;
                                                          Result :=
                                                            IntToStr(GetItemInfo(UserItem,
                                                            n14 + 1));
                                                        end
                                                        else
                                                          if CompareLStr(spos, 'VALUE(',
                                                            6) then
                                                          begin
                                                            ArrestStringEx(sPos, '(',
                                                              ')', s14);
                                                            n14 := Str_ToInt(s14, 0);
                                                            n14 := n14 mod 14;
                                                            Result :=
                                                              IntToStr(Useritem.btValue[n14]);
                                                          end
                                                          else
                                                            if CompareLStr(spos,
                                                              'DARKPOINT(', 10) then
                                                            begin
                                                              ArrestStringEx(sPos, '(',
                                                                ')', s14);
                                                              n14 := Str_ToInt(s14, 0);
                                                              n14 := n14 mod 12;
                                                              Result :=
                                                                IntToStr(GetItemInfo(UserItem, n14 + 19));

                                                            end
                                                            else
                                                              if sPos = 'EVILNAME' then
                                                                Result :=
                                                                  UserItem.AttachMagic.MercenaryName
                                                              else
                                                                if sPos = 'EVILJOB' then
                                                                  Result :=
                                                                    IntToStr(UserItem.AttachMagic.MercenaryJob)
                                                                else
                                                                  if sPos = 'EVILREALM'
                                                                    then
                                                                    Result :=
                                                                      IntToStr(UserItem.AttachMagic.MercenaryState)
                                                                  else
                                                                    if sPos = 'EVILDC'
                                                                      then
                                                                      Result :=
                                                                        IntToStr(Lobyte(UserItem.AttachMagic.DC))
                                                                    else
                                                                      if sPos = 'EVILDC2'
                                                                        then
                                                                        Result :=
                                                                          IntToStr(Hibyte(UserItem.AttachMagic.DC))
                                                                      else
                                                                        if sPos = 'EVILMC'
                                                                          then
                                                                          Result :=
                                                                            IntToStr(Lobyte(UserItem.AttachMagic.MC))
                                                                        else
                                                                          if sPos =
                                                                            'EVILMC2' then
                                                                            Result :=
                                                                              IntToStr(Hibyte(UserItem.AttachMagic.MC))
                                                                          else
                                                                            if sPos =
                                                                              'EVILSC' then
                                                                              Result :=
                                                                                IntToStr(Lobyte(UserItem.AttachMagic.SC))
                                                                            else
                                                                              if sPos =
                                                                                'EVILSC2' then
                                                                                Result :=
                                                                                  IntToStr(Hibyte(UserItem.AttachMagic.SC))
                                                                              else
                                                                                if sPos =
                                                                                  'EVILAC' then
                                                                                  Result :=
                                                                                    IntToStr(Lobyte(UserItem.AttachMagic.AC))
                                                                                else
                                                                                  if sPos =
                                                                                    'EVILAC2' then
                                                                                    Result :=
                                                                                      IntToStr(Hibyte(UserItem.AttachMagic.AC))
                                                                                  else
                                                                                    if sPos =
                                                                                      'EVILMAC' then
                                                                                      Result :=
                                                                                        IntToStr(Lobyte(UserItem.AttachMagic.MAC))
                                                                                    else
                                                                                      if sPos =
                                                                                        'EVILMAC2' then
                                                                                        Result :=
                                                                                          IntToStr(Hibyte(UserItem.AttachMagic.MAC))
                                                                                      else
                                                                                        if sPos =
                                                                                          'EVILPOINT' then
                                                                                          Result :=
                                                                                            IntToStr(UserItem.AttachMagic.ZMValue)
                                                                                        else
                                                                                          if
                                                                                            CompareLStr(spos, 'PET.', 4) then
                                                                                          begin
                                                                                            Delete(sPos, 1, 4);
                                                                                            if sPos = 'EVOLUTION' then
                                                                                              Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.wCount)
                                                                                            else
                                                                                              if sPos = 'APTITUDE' then
                                                                                                Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btZizhi)
                                                                                              else
                                                                                                if sPos = 'HP' then
                                                                                                  Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.wHp)
                                                                                                else
                                                                                                  if sPos = 'MP' then
                                                                                                    Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btMagic)
                                                                                                  else
                                                                                                    if sPos = 'ANTIPOISON' then
                                                                                                      Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btANTIPOISON)
                                                                                                    else
                                                                                                      if sPos = 'MAC1' then
                                                                                                        Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btMAC1 and $1F)
                                                                                                      else
                                                                                                        if sPos = 'MAC2' then
                                                                                                          Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btMAC2 and $1F)
                                                                                                        else
                                                                                                          if sPos = 'MAGICNICETY' then
                                                                                                            Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btMAGICNICETY and $7)
                                                                                                          else
                                                                                                            if sPos = 'EVADET' then
                                                                                                              Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btEVADET)
                                                                                                            else
                                                                                                              if sPos = 'AC1' then
                                                                                                                Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btAC1 and $1F)
                                                                                                              else
                                                                                                                if sPos = 'AC2' then
                                                                                                                  Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btAC2 and $1F)
                                                                                                                else
                                                                                                                  if sPos = 'ANTIMAGIC' then
                                                                                                                    Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btANTIMAGIC and $7)
                                                                                                                  else
                                                                                                                    if sPos = 'POISONNICETY' then
                                                                                                                      Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY)
                                                                                                                    else
                                                                                                                      if sPos = 'SAVVY' then
                                                                                                                        Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btSAVVY)
                                                                                                                      else
                                                                                                                        if sPos = 'FELEMENT1' then
                                                                                                                        begin
                                                                                                                          n14 := GetPetAddInfo(UserItem, 28);
                                                                                                                          case n14 of
                                                                                                                            0: Result := '金';
                                                                                                                            1: Result := '木';
                                                                                                                            2: Result := '土';
                                                                                                                            3: Result := '水';
                                                                                                                          end;

                                                                                                                        end
                                                                                                                        else
                                                                                                                          if sPos = 'FELEMENT2' then
                                                                                                                          begin
                                                                                                                            n14 := GetPetAddInfo(UserItem, 29);
                                                                                                                            case n14 of
                                                                                                                              0: Result := '金';
                                                                                                                              1: Result := '木';
                                                                                                                              2: Result := '土';
                                                                                                                              3: Result := '水';
                                                                                                                            end;

                                                                                                                          end
                                                                                                                          else
                                                                                                                            if sPos = 'FELEMENTPOINT1' then
                                                                                                                              Result := IntToStr(Useritem.AttachMagic.aaa.PetAddProperty.btZizhi)
                                                                                                                            else
                                                                                                                              if sPos = 'MC1' then
                                                                                                                                Result := IntToStr((Useritem.AttachMagic.aaa.PetAddProperty.btMAC1 shr 5) and $7)
                                                                                                                              else
                                                                                                                                if sPos = 'MC2' then
                                                                                                                                  Result := IntToStr((Useritem.AttachMagic.aaa.PetAddProperty.btMAC2 shr 5) and $7)
                                                                                                                                else
                                                                                                                                  if sPos = 'SC1' then
                                                                                                                                    Result := IntToStr((Useritem.AttachMagic.aaa.PetAddProperty.btMAGICNICETY shr 5) and $7)
                                                                                                                                  else
                                                                                                                                    if sPos = 'SC2' then
                                                                                                                                      Result := IntToStr((Useritem.AttachMagic.aaa.PetAddProperty.btANTIMAGIC shr 5) and $7)
                                                                                                                                    else
                                                                                                                                      if sPos = 'DC1' then
                                                                                                                                        Result := IntToStr((Useritem.AttachMagic.aaa.PetAddProperty.btAC1 shr 5) and $7)
                                                                                                                                      else
                                                                                                                                        if sPos = 'DAC2' then
                                                                                                                                          Result := IntToStr((Useritem.AttachMagic.aaa.PetAddProperty.btAC2 shr 5) and $7)
                                                                                                                                        else
                                                                                                                                          if sPos = 'NICETY' then
                                                                                                                                            Result := IntToStr((Useritem.AttachMagic.aaa.PetAddProperty.btEVADET shr 5) and $7)
                                                                                          end;

end;

function TPlayObject.SetItemInfo(UserItem: PTUserItem; nPos: Integer; nvalue: Integer):
  Integer;
var
  btValue                                              : Byte;
begin

  btvalue := nvalue and $F;
  case npos of
    0..12:
      begin
        UserItem.btValue[npos] := nvalue;
      end;

    19: UserItem.DarkProp.DMagic := nvalue;
    20: UserItem.DarkProp.DDC := (UserItem.DarkProp.DDC and $F0) + btvalue;
    21: UserItem.DarkProp.DDC := (UserItem.DarkProp.DDC and $0F) + btValue shl 4;
    22: UserItem.DarkProp.DMC := (UserItem.DarkProp.DMC and $F0) + btvalue;
    23: UserItem.DarkProp.DMC := (UserItem.DarkProp.DMC and $0F) + btValue shl 4;
    24: UserItem.DarkProp.DSC := (UserItem.DarkProp.DSC and $F0) + btvalue;
    25: UserItem.DarkProp.DSC := (UserItem.DarkProp.DSC and $0F) + btValue shl 4;
    26: UserItem.DarkProp.DAC := (UserItem.DarkProp.DAC and $F0) + btvalue;
    27: UserItem.DarkProp.DAC := (UserItem.DarkProp.DAC and $0F) + btValue shl 4;
    28: UserItem.DarkProp.DMAC := (UserItem.DarkProp.DMAC and $F0) + btvalue;
    29: UserItem.DarkProp.DMAC := (UserItem.DarkProp.DMAC and $0F) + btValue shl 4;
    30: UserItem.DarkProp.DNEEDLEVEL := nvalue;
    59: UserItem.DarkProp.btid := nvalue;
    69:
      begin
        UserItem.DarkProp.btMagicID := nvalue;
        //2008-11-18
        //  修正圣灵武器在游戏端显示失效的bug
        //  DarkProp.btid:=2;
      end;
    70: UserItem.DarkProp.btMagicPower := nvalue;
    71: UserItem.btValue[0] := nvalue;

    32:
      UserItem.AttachMagic.MercenaryJob := nValue;
    33:
      UserItem.AttachMagic.MercenaryState := nValue;
    34:
      UserItem.AttachMagic.DC := (UserItem.AttachMagic.DC and $F0) + btValue;
    35:
      UserItem.AttachMagic.DC := (UserItem.AttachMagic.DC and $F) + btValue shl 4;
    36:
      UserItem.AttachMagic.MC := (UserItem.AttachMagic.MC and $F0) + btValue;
    37:
      UserItem.AttachMagic.MC := (UserItem.AttachMagic.MC and $F) + btValue shl 4;
    38:
      UserItem.AttachMagic.SC := (UserItem.AttachMagic.SC and $F0) + btValue;
    39:
      UserItem.AttachMagic.SC := (UserItem.AttachMagic.SC and $F) + btValue shl 4;
    40:
      UserItem.AttachMagic.AC := (UserItem.AttachMagic.AC and $F0) + btValue;
    41:
      UserItem.AttachMagic.AC := (UserItem.AttachMagic.AC and $F) + btValue shl 4;
    42:
      UserItem.AttachMagic.MAC := (UserItem.AttachMagic.MAC and $F0) + btValue;
    43:
      UserItem.AttachMagic.MAC := (UserItem.AttachMagic.MAC and $F) + btValue shl 4;
    44:
      UserItem.AttachMagic.ZMValue := btValue;

  end;

end;

function TPlayObject.GetItemInfo(UserItem: PTUserItem; nPos: Integer): Integer;
begin
  Result := 0;
  if UserItem = nil then exit;

  case nPos of
    0..12:
      begin
        Result := UserItem.btValue[nPos];
      end;
    13:
      Result := UserItem.Dura;
    14:
      Result := UserItem.DuraMax;
    19: Result := UserItem.DarkProp.DMagic;
    20: Result := UserItem.DarkProp.DDC and $0F;
    21: Result := (UserItem.DarkProp.DDC and$F0) shr 4;
    22: Result := UserItem.DarkProp.DMC and $0F;
    23: Result := (UserItem.DarkProp.DMC and$F0) shr 4;
    24: Result := UserItem.DarkProp.DSC and $0F;
    25: Result := (UserItem.DarkProp.DSC and$F0) shr 4;
    26: Result := UserItem.DarkProp.DAC and $0F;
    27: Result := (UserItem.DarkProp.DAC and$F0) shr 4;
    28: Result := UserItem.DarkProp.DMAC and $0F;
    29: Result := (UserItem.DarkProp.DMAC and$F0) shr 4;
    30: Result := UserItem.DarkProp.DNEEDLEVEL;
    59: Result := UserItem.DarkProp.btid;
    69:
      begin
        Result := UserItem.DarkProp.btMagicID;

      end;
    70: Result := UserItem.DarkProp.btMagicPower;
    71: Result := UserItem.btValue[0];
    31..44:
      begin

        begin
          case nPos of
            31:
              begin

              end;
            32:
              Result := Useritem.AttachMagic.MercenaryJob;
            33:
              Result := Useritem.AttachMagic.MercenaryState;
            34:
              Result := LoByte(Useritem.AttachMagic.DC);
            35:
              Result := HiByte(Useritem.AttachMagic.DC);
            36:
              Result := LoByte(Useritem.AttachMagic.MC);
            37:
              Result := HiByte(Useritem.AttachMagic.MC);
            38:
              Result := LoByte(Useritem.AttachMagic.SC);
            39:
              Result := HiByte(Useritem.AttachMagic.SC);
            40:
              Result := LoByte(Useritem.AttachMagic.AC);
            41:
              Result := HiByte(Useritem.AttachMagic.AC);
            42:
              Result := LoByte(Useritem.AttachMagic.MAC);
            43:
              Result := HiByte(Useritem.AttachMagic.MAC);
            44:
              Result := Useritem.AttachMagic.ZMValue;
          end;
        end;
      end;
  end;

end;

function TPlayObject.GetPetAddInfo(UserItem: PTUserItem; nPos: Integer): Integer;
begin
  Result := 0;
  if UserItem = nil then exit;
  case npos of
    0: ;                                                    //积累经验
    1: Result := Useritem.AttachMagic.aaa.PetAddProperty.wCount; //幻化次数
    2: Result := Useritem.AttachMagic.aaa.PetAddProperty.btZizhi; //资质
    3: Result := Useritem.AttachMagic.aaa.PetAddProperty.wHp; //生命
    4: Result := Useritem.AttachMagic.aaa.PetAddProperty.btMagic; //魔法值
    5: Result := Useritem.AttachMagic.aaa.PetAddProperty.btANTIPOISON; //中毒躲避
    6: Result := Useritem.AttachMagic.aaa.PetAddProperty.btMAC1 and $1F; //魔御下限
    7: Result := Useritem.AttachMagic.aaa.PetAddProperty.btMAC2 and $1F; //魔御上限
    8: Result := Useritem.AttachMagic.aaa.PetAddProperty.btMAGICNICETY and $1F; //魔法命中
    9: Result := Useritem.AttachMagic.aaa.PetAddProperty.btEVADET and $1F; //躲避
    10: Result := Useritem.AttachMagic.aaa.PetAddProperty.btAC1 and $1F; // 防御下限
    11: Result := Useritem.AttachMagic.aaa.PetAddProperty.btAC2 and $1F; // 防御上限
    12: Result := Useritem.AttachMagic.aaa.PetAddProperty.btANTIMAGIC and $1F; //魔法躲避
    13: Result := Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY and $1F;  //中毒命中
    14: Result := Useritem.AttachMagic.aaa.PetAddProperty.btSAVVY; // 顿悟
    15: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btvalue1) and $3F;  // 五行属性1(0: 金、1:木、2:土、3:水)
    16: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btvalue2) and $3F;  // 五行属性2(0: 火、1:木、2:土、3:水)
    17: Result := 0;                                        //灵兽经验
    18: ;                                                   // 保留
    19: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btMAC1 shr 5) and $7;  // 魔法攻击下限 最高：7
    20: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btMAC2 shr 5) and $7;  // 魔法攻击上限 最高：7
    21: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btMAGICNICETY shr 5) and $7;  // 道术攻击下限 最高：7
    22: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btANTIMAGIC shr 5) and $7;  // 道术攻击上限 最高：7
    23: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btAC1 shr 5) and $7;  // 攻击下限  最高：7
    24: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btAC2 shr 5) and $7;  // 攻击上限  最高：7
    25: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btEVADET shr 5) and $7;  // 命中  最高：7
    26: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY shr 5) and $3;  // 幸运  最高：3
    27: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btPOISONNICETY shr 7) and $1;  //骑战速度  最高：1
    28: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btvalue1 shr 6) and $3;  //骑战速度  最高：1
    29: Result := (Useritem.AttachMagic.aaa.PetAddProperty.btvalue2 shr 6) and $3;  //骑战速度  最高：1

  end;
end;

procedure TPlayObject.RecalcAdjusBonus();
var
  BonusTick                                            : pTNakedAbility;
  NakedAbil                                            : pTNakedAbility;
  l, m, adc, amc, asc, aac, amac                       : integer;
  ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac   : Word;
  UserItem                                             : PTUserItem;
  procedure AdjustAb(abil: byte; val: word; var lov, hiv: Word);
  var
    lo, hi                                             : byte;
    i                                                  : integer;
  begin
    lo := Lobyte(abil);
    hi := Hibyte(abil);
    lov := 0;
    hiv := 0;
    for i := 1 to val do
    begin
      if lo + 1 < hi then
      begin
        Inc(lo);
        Inc(lov);
      end
      else
      begin
        Inc(hi);
        Inc(hiv);
      end;
    end;
  end;

begin
  BonusTick := nil;
  NakedAbil := nil;
  case m_btJob of
    0:
      begin
        BonusTick := @g_Config.BonusAbilofWarr;
        NakedAbil := @g_Config.NakedAbilofWarr;
      end;
    1:
      begin
        BonusTick := @g_Config.BonusAbilofWizard;
        NakedAbil := @g_Config.NakedAbilofWizard;
      end;
    2:
      begin
        BonusTick := @g_Config.BonusAbilofTaos;
        NakedAbil := @g_Config.NakedAbilofTaos;
      end;
    3:
      begin
        BonusTick := @g_Config.BonusAbilofTaos;
        NakedAbil := @g_Config.NakedAbilofTaos;
      end;
  end;

  adc := m_BonusAbil.DC div BonusTick.DC;
  amc := m_BonusAbil.MC div BonusTick.MC;
  asc := m_BonusAbil.SC div BonusTick.SC;
  aac := m_BonusAbil.AC div BonusTick.AC;
  amac := m_BonusAbil.MAC div BonusTick.MAC;

  AdjustAb(NakedAbil.DC, adc, ldc, hdc);
  AdjustAb(NakedAbil.MC, amc, lmc, hmc);
  AdjustAb(NakedAbil.SC, asc, lsc, hsc);
  AdjustAb(NakedAbil.AC, aac, lac, hac);
  AdjustAb(NakedAbil.MAC, amac, lmac, hmac);
  //lac  := 0;  hac := aac;
  //lmac := 0;  hmac := amac;

  m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + ldc, HiWord(m_WAbil.DC) + hdc);
  m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + lmc, HiWord(m_WAbil.MC) + hmc);
  m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + lsc, HiWord(m_WAbil.SC) + hsc);
  m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + lac, HiWord(m_WAbil.AC) + hac);
  m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + lmac, HiWord(m_WAbil.MAC) + hmac);

  m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_BonusAbil.HP div BonusTick.HP);
  m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + m_BonusAbil.MP div BonusTick.MP);

  //骑战加成
  if m_boBaoZiAttacked then
  begin
    if ysmasterplayer <> nil then
      UserItem := ysmasterplayer.GetItems(ysmasterplayer.M_monYSOnHorseitemmake)
    else
      UserItem := GetItems(M_monOnHorseitemmake);
    if (UserItem <> nil) and (UserItem.AttachMagic.aaa.PetAddProperty.nMakeIndex =
      Useritem.MakeIndex) then
    begin
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + GetPetAddInfo(UserItem, 23),
        HiWord(m_WAbil.DC) + GetPetAddInfo(UserItem, 24));
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + GetPetAddInfo(UserItem, 19),
        HiWord(m_WAbil.MC) + GetPetAddInfo(UserItem, 20));
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + GetPetAddInfo(UserItem, 21),
        HiWord(m_WAbil.SC) + GetPetAddInfo(UserItem, 22));
      m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + GetPetAddInfo(UserItem, 10),
        HiWord(m_WAbil.AC) + GetPetAddInfo(UserItem, 11));
      m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + GetPetAddInfo(UserItem, 6),
        HiWord(m_WAbil.MAC) + GetPetAddInfo(UserItem, 7));
      m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + GetPetAddInfo(UserItem, 3));
      m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + GetPetAddInfo(UserItem, 4));
      Inc(m_btHitPoint, GetPetAddInfo(UserItem, 25));       //命中
      Inc(m_btAntiPoison, GetPetAddInfo(UserItem, 5));      //中毒躲避
      Inc(m_nAntiMagic, GetPetAddInfo(UserItem, 12));       //魔法躲避
      Inc(m_btSpeedPoint, GetPetAddInfo(UserItem, 9));
      Inc(m_btMagicPoint, GetPetAddInfo(UserItem, 8));
      Inc(m_btPoisonPoint, GetPetAddInfo(UserItem, 13));
    end;

  end;
  //元婴加成
  if (btAdditionalAbil[2] > 0) and (sYsnameMaster = '') then
  begin
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + GetADDITIONALABIL(8), HiWord(m_WAbil.DC)
      + GetADDITIONALABIL(9));
    m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + GetADDITIONALABIL(10), HiWord(m_WAbil.MC)
      + GetADDITIONALABIL(11));
    m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + GetADDITIONALABIL(12), HiWord(m_WAbil.SC)
      + GetADDITIONALABIL(13));
    m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + GetADDITIONALABIL(14), HiWord(m_WAbil.AC)
      + GetADDITIONALABIL(15));
    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + GetADDITIONALABIL(16),
      HiWord(m_WAbil.MAC) + GetADDITIONALABIL(17));

  end;
  if sYsnameMaster <> '' then                               //第二元神加成
  begin
    if ysmasterplayer <> nil then
    begin
      m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP +
        ysmasterplayer.GetADDITIONALABIL(18));
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + ysmasterplayer.GetADDITIONALABIL(19),
        HiWord(m_WAbil.DC) + ysmasterplayer.GetADDITIONALABIL(20));
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + ysmasterplayer.GetADDITIONALABIL(19),
        HiWord(m_WAbil.MC) + ysmasterplayer.GetADDITIONALABIL(20));
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + ysmasterplayer.GetADDITIONALABIL(19),
        HiWord(m_WAbil.SC) + ysmasterplayer.GetADDITIONALABIL(20));
    end;

  end;

end;

procedure TPlayObject.ClientAdjustBonus(nPoint: Integer; sMsg: string); //004DF804
var
  BonusAbil                                            : TNakedAbility;
  nTotleUsePoint                                       : Integer;
begin
  FillChar(BonusAbil, SizeOf(TNakedAbility), #0);
  DecodeBuffer(sMsg, @BonusAbil, SizeOf(TNakedAbility));

  nTotleUsePoint := BonusAbil.DC +
    BonusAbil.MC +
    BonusAbil.SC +
    BonusAbil.AC +
    BonusAbil.MAC +
    BonusAbil.HP +
    BonusAbil.MP +
    BonusAbil.Hit +
    BonusAbil.Speed +
    BonusAbil.X2;

  if (nPoint + nTotleUsePoint) = m_nBonusPoint then
  begin
    m_nBonusPoint := nPoint;
    Inc(m_BonusAbil.DC, BonusAbil.DC);
    Inc(m_BonusAbil.MC, BonusAbil.MC);
    Inc(m_BonusAbil.SC, BonusAbil.SC);
    Inc(m_BonusAbil.AC, BonusAbil.AC);
    Inc(m_BonusAbil.MAC, BonusAbil.MAC);
    Inc(m_BonusAbil.HP, BonusAbil.HP);
    Inc(m_BonusAbil.MP, BonusAbil.MP);
    Inc(m_BonusAbil.Hit, BonusAbil.Hit);
    Inc(m_BonusAbil.Speed, BonusAbil.Speed);
    Inc(m_BonusAbil.X2, BonusAbil.X2);

    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
  end
  else
  begin
    SysMsg('非法数据调整！！！', c_Red, t_Hint);
  end;
end;

function TPlayObject.GetMyStatus: Integer;                  //004C145C
begin
  Result := m_nHungerStatus div 1000;
  if Result > 4 then
    Result := 4;
end;

procedure TPlayObject.SendAdjustBonus;                      //004DA9E4
var
  sSendMsg                                             : string;
  //NakedAbil:TNakedAbility;
begin
  m_DefMsg := MakeDefaultMsg(SM_ADJUST_BONUS, m_nBonusPoint, 0, 0, 0);
  sSendMsg := '';
  //NakedAbil:=m_BonusAbil;
  //FillChar(NakedAbil,SizeOf(TNakedAbility),#0);
  case m_btjob of                                           //
    0: sSendMsg := EncodeBuffer(@g_Config.BonusAbilofWarr, SizeOf(TNakedAbility)) + '/' +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofWarr, SizeOf(TNakedAbility));
    1: sSendMsg := EncodeBuffer(@g_Config.BonusAbilofWizard, SizeOf(TNakedAbility)) + '/'
      +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofWizard, SizeOf(TNakedAbility));
    2: sSendMsg := EncodeBuffer(@g_Config.BonusAbilofTaos, SizeOf(TNakedAbility)) + '/' +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofTaos, SizeOf(TNakedAbility));
    3: sSendMsg := EncodeBuffer(@g_Config.BonusAbilofTaos, SizeOf(TNakedAbility)) + '/' +
      EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@g_Config.NakedAbilofTaos, SizeOf(TNakedAbility));
  end;                                                      // case
  SendSocket(@m_DefMsg, sSendMsg);
end;

function TBaseObject.GetAttackDir(BaseObject: TBaseObject; var btDir: Byte): Boolean;  //004C3CA0
begin
  Result := False;
  if (m_nCurrX - 1 <= BaseObject.m_nCurrX) and
    (m_nCurrX + 1 >= BaseObject.m_nCurrX) and
    (m_nCurrY - 1 <= BaseObject.m_nCurrY) and
    (m_nCurrY + 1 >= BaseObject.m_nCurrY) and
    ((m_nCurrX <> BaseObject.m_nCurrX) or
    (m_nCurrY <> BaseObject.m_nCurrY)) then
  begin
    Result := True;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
    begin
      btDir := DR_LEFT;
      exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY) then
    begin
      btDir := DR_RIGHT;
      exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_UP;
      exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY) then
    begin
      btDir := DR_DOWN;
      exit;
    end;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY)
      then
    begin
      btDir := DR_UPLEFT;
      exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and ((m_nCurrY - 1) = BaseObject.m_nCurrY)
      then
    begin
      btDir := DR_UPRIGHT;
      exit;
    end;
    if ((m_nCurrX - 1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY)
      then
    begin
      btDir := DR_DOWNLEFT;
      exit;
    end;
    if ((m_nCurrX + 1) = BaseObject.m_nCurrX) and ((m_nCurrY + 1) = BaseObject.m_nCurrY)
      then
    begin
      btDir := DR_DOWNRIGHT;
      exit;
    end;
    btDir := 0;
  end;
end;

function TBaseObject.GetAttackDirx(BaseObject: TBaseObject; ragen: integer; var btDir:
  Byte): Boolean;                                             //004C3CA0
begin
  Result := False;
  if (m_nCurrX - ragen <= BaseObject.m_nCurrX) and
    (m_nCurrX + ragen >= BaseObject.m_nCurrX) and
    (m_nCurrY - ragen <= BaseObject.m_nCurrY) and
    (m_nCurrY + ragen >= BaseObject.m_nCurrY) and
    ((m_nCurrX <> BaseObject.m_nCurrX) or
    (m_nCurrY <> BaseObject.m_nCurrY)) then
  begin
    Result := True;
    if ((m_nCurrX - ragen) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY)
      then
    begin
      btDir := DR_LEFT;
      exit;
    end;
    if ((m_nCurrX + ragen) = BaseObject.m_nCurrX) and (m_nCurrY = BaseObject.m_nCurrY)
      then
    begin
      btDir := DR_RIGHT;
      exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - ragen) = BaseObject.m_nCurrY)
      then
    begin
      btDir := DR_UP;
      exit;
    end;
    if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + ragen) = BaseObject.m_nCurrY)
      then
    begin
      btDir := DR_DOWN;
      exit;
    end;
    if ((m_nCurrX - ragen) = BaseObject.m_nCurrX) and ((m_nCurrY - ragen) =
      BaseObject.m_nCurrY) then
    begin
      btDir := DR_UPLEFT;
      exit;
    end;
    if ((m_nCurrX + ragen) = BaseObject.m_nCurrX) and ((m_nCurrY - ragen) =
      BaseObject.m_nCurrY) then
    begin
      btDir := DR_UPRIGHT;
      exit;
    end;
    if ((m_nCurrX - ragen) = BaseObject.m_nCurrX) and ((m_nCurrY + ragen) =
      BaseObject.m_nCurrY) then
    begin
      btDir := DR_DOWNLEFT;
      exit;
    end;
    if ((m_nCurrX + ragen) = BaseObject.m_nCurrX) and ((m_nCurrY + ragen) =
      BaseObject.m_nCurrY) then
    begin
      btDir := DR_DOWNRIGHT;
      exit;
    end;
    btDir := 0;
  end;
end;

function TBaseObject.TargetInSpitRange(BaseObject: TBaseObject; var btDir: Byte): Boolean;  //004C3E68
var
  n14, n18                                             : Integer;
begin
  Result := False;
  if (abs(BaseObject.m_nCurrX - m_nCurrX) <= 2) and (abs(BaseObject.m_nCurrY - m_nCurrY)
    <= 2) then
  begin
    n14 := BaseObject.m_nCurrX - m_nCurrX;
    n18 := BaseObject.m_nCurrY - m_nCurrY;
    if (abs(n14) <= 1) and (abs(n18) <= 1) then
    begin
      GetAttackDir(BaseObject, btDir);
      Result := True;
      exit;
    end;
    Inc(n14, 2);
    Inc(n18, 2);
    if ((n14 >= 0) and (n14 <= 4)) and ((n18 >= 0) and (n18 <= 4)) then
    begin
      btDir := GetNextDirection(m_nCurrX, m_nCurrY, BaseObject.m_nCurrX,
        BaseObject.m_nCurrY);
      if g_Config.SpitMap[btDir, n18, n14] = 1 then
        Result := True;
    end;

  end;

end;

//004BF6F0

function TBaseObject.RecalcBagWeight: Integer;
var
  I                                                    : Integer;
  UserItem                                             : PTUserItem;
  StdItem                                              : PTStdItem;
begin
  Result := 0;
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
    begin
      Inc(Result, StdItem.Weight);
    end;
  end;
end;
//004BFD50

procedure TBaseObject.RecalcHitSpeed;
var
  I                                                    : Integer;
  UserMagic                                            : pTUserMagic;
  BonusTick                                            : pTNakedAbility;
begin
  BonusTick := nil;
  case m_btJob of
    0: BonusTick := @g_Config.BonusAbilofWarr;
    1: BonusTick := @g_Config.BonusAbilofWizard;
    2: BonusTick := @g_Config.BonusAbilofTaos;
    3: BonusTick := @g_Config.BonusAbilofTaos;  //妖士
  end;
  m_btHitPoint := DEFHIT + m_BonusAbil.Hit div BonusTick.Hit;

  case m_btJob of
    TAOS: m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed + 3;  //档荤绰 扁夯 刮酶捞 臭促.
  else
    m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed;
  end;

  m_nHitPlus := 0;
  m_nHitDouble := 0;
  m_nHitpj := 0;
  m_nHitpd := 0;
  m_btMagicPoint := 0;
  m_btPoisonPoint := 0;
  m_MagicOneSwordSkill := nil;
  m_MagicPowerHitSkill := nil;
  m_MagicErgumSkill := nil;
  m_MagicBanwolSkill := nil;
  m_MagicFireSwordSkill := nil;
  m_MagicCrsSkill := nil;
  m_Magic41Skill := nil;
  m_Magic59Skill := nil;
  m_Magic60Skill := nil;
  m_Magic586368skill := nil;
  m_Magic76skill := nil;
  m_Magic69skill := nil;
  for I := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[i];
    case UserMagic.wMagIdx of
      SKILL_ONESWORD:
        begin                                               //内功心法
          m_MagicOneSwordSkill := UserMagic;
          if UserMagic.btLevel > 0 then
          begin
            m_btHitPoint := m_btHitPoint + ROUND(9 / 3 * UserMagic.btLevel);
          end;
        end;
      74:
        begin                                               //	擒龙手
          //  m_MagicOneSwordSkill:=UserMagic;
          if UserMagic.btLevel > 0 then
          begin
            m_btHitPoint := m_btHitPoint + UserMagic.btLevel;
          end;
        end;
      SKILL_88:
        begin                                               //强化攻杀
          m_Magic88Skill := UserMagic;
          m_MagicPowerHitSkill := UserMagic;
          if UserMagic.btLevel > 0 then
          begin
            m_btHitPoint := m_btHitPoint + ROUND(3 / 3 * UserMagic.btLevel);
          end;
          m_nHitPlus := DEFHIT + UserMagic.btLevel;
          m_btAttackSkillCount := 7 - UserMagic.btLevel;
          m_btAttackSkillPointCount := Random(m_btAttackSkillCount);

          m_MagicPowerHitType := UserMagic.wMagIdx;
        end;
      SKILL_YEDO, SKILL_40, SKILL_41:
        begin                                               //攻杀剑法
          m_MagicPowerHitSkill := UserMagic;
          if UserMagic.btLevel > 0 then
          begin
            m_btHitPoint := m_btHitPoint + ROUND(3 / 3 * UserMagic.btLevel);
          end;
          m_nHitPlus := DEFHIT + UserMagic.btLevel;
          m_btAttackSkillCount := 7 - UserMagic.btLevel;
          m_btAttackSkillPointCount := Random(m_btAttackSkillCount);

          m_MagicPowerHitType := UserMagic.wMagIdx;
        end;
      SKILL_ERGUM:
        begin                                               //刺杀剑法
          m_MagicErgumSkill := UserMagic;
        end;
      SKILL_BANWOL:
        begin                                               //半月弯刀
          m_MagicBanwolSkill := UserMagic;
        end;
      SKILL_43:
        begin                                               //抱月刀
          m_Magic43Skill := UserMagic;
        end;

      SKILL_FIRESWORD, SKILL_44:
        begin                                               //烈火剑法
          m_MagicFireSwordSkill := UserMagic;
          m_nFireHitSkillType := UserMagic.wMagIdx;
          m_nHitDouble := 5 + UserMagic.btLevel * 5;
        end;
      SKILL_ILKWANG:
        begin                                               //基本剑法
          m_MagicOneSwordSkill := UserMagic;
          if UserMagic.btLevel > 0 then
          begin
            m_btHitPoint := m_btHitPoint + ROUND(8 / 3 * UserMagic.btLevel);
          end;
        end;
      {  40: begin
          m_MagicCrsSkill:=UserMagic;
        end;
        41: begin
          m_Magic41Skill:=UserMagic;
        end; }
      59:
        begin
          m_Magic59Skill := UserMagic;
          if UserMagic.btLevel > 0 then
          begin
            m_nHitpj := ROUND(UserMagic.MagicInfo.btDefPower /
              (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) +
              (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower -
              UserMagic.MagicInfo.btDefPower));
          end;
          if UserMagic.btLevel > 0 then
          begin
            m_btHitPoint := m_btHitPoint + UserMagic.btLevel;
          end;
        end;
      60:
        begin
          m_Magic60Skill := UserMagic;
          if UserMagic.btLevel > 0 then
          begin
            m_nHitpd := ROUND(UserMagic.MagicInfo.btDefPower /
              (UserMagic.MagicInfo.btTrainLv + 1) * (UserMagic.btLevel + 1)) +
              (UserMagic.MagicInfo.btDefPower + Random(UserMagic.MagicInfo.btDefMaxPower -
              UserMagic.MagicInfo.btDefPower));
          end;
          if UserMagic.btLevel > 0 then
          begin
            m_btHitPoint := m_btHitPoint + UserMagic.btLevel;
          end;

        end;
      62:
        begin                                               //突站
          m_nHittz := ROUND(UserMagic.MagicInfo.wPower / (UserMagic.MagicInfo.btTrainLv +
            1) * (UserMagic.btLevel + 1)) + (UserMagic.MagicInfo.wPower +
            Random(UserMagic.MagicInfo.wMaxPower - UserMagic.MagicInfo.wPower));
        end;
      58, 63, 68:
        begin                                               // 战魂真悟 道心清明   法之魄
          m_Magic586368skill := UserMagic;
        end;
      76: m_Magic76skill := UserMagic;
      69: m_Magic69skill := UserMagic;                      //兽灵术

    end;
  end;
end;
//004BFFD0

procedure TBaseObject.AddItemSkill(nIndex: Integer);
var
  Magic                                                : pTMagic;
  UserMagic                                            : pTUserMagic;
  PlayObject                                           : TPlayObject;
begin
  Magic := nil;
  case nIndex of
    1: Magic := UserEngine.FindMagic(g_Config.sFireBallSkill);
    2: Magic := UserEngine.FindMagic(g_Config.sHealSkill);
  end;
  if Magic <> nil then
  begin
    if not IsTrainingSkill(Magic.wMagicId) then
    begin
      New(UserMagic);
      UserMagic.MagicInfo := Magic;
      UserMagic.wMagIdx := Magic.wMagicId;
      UserMagic.btKey := 0;
      UserMagic.btLevel := 1;
      UserMagic.nTranPoint := 0;
      m_MagicList.Add(UserMagic);
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        {
        PlayObject:=TPlayObject(Self);
        PlayObject.SendAddMagic(UserMagic);
        }
        TPlayObject(Self).SendAddMagic(UserMagic);
      end;
    end;
  end;
end;

function TBaseObject.AddToMap: Boolean;                     //004BA5E4
var
  Point                                                : Pointer;
begin
  Point := m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
  if Point <> nil then
    Result := True
  else
    Result := False;
  if not m_boFixedHideMode then
    SendRefMsg(RM_TURN, m_btDirection, m_nCurrX, m_nCurrY, 0, '');

end;

procedure TBaseObject.AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word;
  nDir: Integer);                                           //004C2C50
  function GetMagicSpell(UserMagic: pTUserMagic): Integer;
  begin
    Result := ROUND(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv + 1) *
      (UserMagic.btLevel + 1));
  end;
  //武器升级设置
  procedure CheckWeaponUpgradeStatus(UserItem: pTUserItem); //004C27C0
  begin
    //if (UserItem.btValue[0] + UserItem.btValue[1] + UserItem.btValue[2]) < 20 then begin
    if (UserItem.btValue[0] + UserItem.btValue[1] + UserItem.btValue[2]) <
      g_Config.nUpgradeWeaponMaxPoint then
    begin
      case UserItem.btValue[10] of
        1: UserItem.wIndex := 0;
        10..13: UserItem.btValue[0] := UserItem.btValue[0] + UserItem.btValue[10] - 9;
        20..23: UserItem.btValue[1] := UserItem.btValue[1] + UserItem.btValue[10] - 19;
        30..33: UserItem.btValue[2] := UserItem.btValue[2] + UserItem.btValue[10] - 29;
      end;
    end
    else
      UserItem.wIndex := 0;
    UserItem.btValue[10] := 0;
  end;
  procedure CheckWeaponUpgrade();                           //004C2854
  var
    UseItems                                           : TUserItem;
    PlayObject                                         : TPlayObject;
    StdItem                                            : pTStdItem;
  begin
    if m_UseItems[U_WEAPON].btValue[10] > 0 then
    begin
      UseItems := m_UseItems[U_WEAPON];
      CheckWeaponUpgradeStatus(@m_UseItems[U_WEAPON]);
      if m_UseItems[U_WEAPON].wIndex = 0 then
      begin
        SysMsg(g_sTheWeaponBroke, c_Red, t_Hint);
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelItems(@UseItems);
        //PlayObject.StatusChanged;
        SendRefMsg(RM_BREAKWEAPON, 0, 0, 0, 0, '');
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        //004C29E0
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('21' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            //UserEngine.GetStdItemName(UseItems.wIndex) + #9 +
            StdItem.Name + #9 +
            IntToStr(UseItems.MakeIndex) + #9 +
            '1' + #9 +
            '0');
        FeatureChanged();
      end
      else
      begin
        SysMsg(sTheWeaponRefineSuccessfull, c_Red, t_Hint);
        PlayObject := TPlayObject(Self);
        PlayObject.SendUpdateItem(@m_UseItems[U_WEAPON]);
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        //004C2B14
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('20' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            //UserEngine.GetStdItemName(UseItems.wIndex) + #9 +
            StdItem.Name + #9 +
            IntToStr(UseItems.MakeIndex) + #9 +
            '1' + #9 +
            '0');
        RecalcAbilitys();
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
    end;
  end;
var
  AttackTarget                                         : TBaseObject;
  boPowerHit                                           : Boolean;
  boFireHit                                            : Boolean;
  boCrsHit                                             : Boolean;
  bo41                                                 : Boolean;
  bo59                                                 : Boolean;
  bo60                                                 : Boolean;
  wIdent                                               : Word;
  nCheckCode, nSpellPoint                              : Integer;
  Attackok                                             : boolean;
  MagicId                                              : Integer;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::AttackDir Code: %d';
begin                                                       //004C2C50
  nCheckCode := 0;
  try
    nSpellPoint := 0;
    if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) then
    begin                                                   //半月
      if m_WAbil.MP > 0 then
      begin
        nCheckCode := 1;
        DamageSpell(m_MagicBanwolSkill.MagicInfo.btDefSpell +
          GetMagicSpell(m_MagicBanwolSkill));
        nCheckCode := 2;
        HealthSpellChanged();
        nCheckCode := 3;
      end
      else
        wHitMode := RM_HIT;
    end;
    if (wHitMode = 10) and (m_Magic59Skill <> nil) and (m_Magic59Skill.MagicInfo <> nil)
      then
    begin                                                   //
      if m_WAbil.MP > 0 then
      begin
        nCheckCode := 591;
        DamageSpell(m_Magic59Skill.MagicInfo.btDefSpell + GetMagicSpell(m_Magic59Skill));
        nCheckCode := 592;
        HealthSpellChanged();
        nCheckCode := 593;
      end
      else
        wHitMode := RM_HIT;
    end;

    if (wHitMode = 88) and (m_Magic88Skill <> nil) then
    begin                                                   //
      if m_WAbil.MP > 0 then
      begin
        nCheckCode := 601;
        DamageSpell(m_Magic88Skill.MagicInfo.btDefSpell + GetMagicSpell(m_Magic88Skill));
        nCheckCode := 602;
        HealthSpellChanged();
        nCheckCode := 603;
      end
      else
        wHitMode := RM_HIT;
    end;
    if (wHitMode = 11) and (m_Magic60Skill <> nil) then
    begin                                                   //
      if m_WAbil.MP > 0 then
      begin
        nCheckCode := 601;
        DamageSpell(m_Magic60Skill.MagicInfo.btDefSpell + GetMagicSpell(m_Magic60Skill));
        nCheckCode := 602;
        HealthSpellChanged();
        nCheckCode := 603;
      end
      else
        wHitMode := RM_HIT;
    end;

    if (m_btRaceServer = RC_YSBJECT) and (m_Master <> nil) then
    begin                                                   //如果是原身
      if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) then
      begin                                                 //半月
        if m_Master.m_WAbil.MP > 0 then
        begin
          nCheckCode := 1;
          m_Master.DamageSpell(m_MagicBanwolSkill.MagicInfo.btDefSpell +
            GetMagicSpell(m_MagicBanwolSkill));
          nCheckCode := 2;
          m_Master.HealthSpellChanged();
          nCheckCode := 3;
        end
        else
          wHitMode := RM_HIT;
      end;
      if (wHitMode = 10) and (m_Magic59Skill <> nil) then
      begin                                                 //
        if m_Master.m_WAbil.MP > 0 then
        begin
          nCheckCode := 1591;
          m_Master.DamageSpell(m_Magic59Skill.MagicInfo.btDefSpell +
            GetMagicSpell(m_Magic59Skill));
          nCheckCode := 1592;
          m_Master.HealthSpellChanged();
          nCheckCode := 1593;
        end
        else
          wHitMode := RM_HIT;
      end;
      if (wHitMode = 11) and (m_Magic60Skill <> nil) then
      begin                                                 //
        if m_Master.m_WAbil.MP > 0 then
        begin
          nCheckCode := 1601;
          m_Master.DamageSpell(m_Magic60Skill.MagicInfo.btDefSpell +
            GetMagicSpell(m_Magic60Skill));
          nCheckCode := 1602;
          m_Master.HealthSpellChanged();
          nCheckCode := 1603;
        end
        else
          wHitMode := RM_HIT;
      end;
    end; //   if( m_btRaceServer = RC_YSBJECT) and (m_Master<>nil)

    nCheckCode := 4;
    m_btDirection := nDir;
    if TargeTBaseObject = nil then
    begin
      nCheckCode := 41;
      AttackTarget := GetPoseCreate();
    end
    else
      AttackTarget := TargeTBaseObject;
    if (AttackTarget <> nil) and (m_UseItems[U_WEAPON].wIndex > 0) then
    begin
      nCheckCode := 42;
      CheckWeaponUpgrade();
    end;
    nCheckCode := 5;
    if (m_btRaceServer = RC_YSBJECT) and (wHitMode in [3, 7]) then
    begin                                                   //元身的技能使用概率
      if random(10) < 5 then
      begin

        if (wHitMode = 7) and (m_MagicFireSwordSkill <> nil) then
        begin
          nSpellPoint := m_MagicFireSwordSkill.MagicInfo.btDefSpell +
            GetMagicSpell(m_MagicFireSwordSkill);
          m_boFireHitSkill := true;
        end;
        if (wHitMode in [3, 12, 13]) and (m_MagicPowerHitSkill <> nil) then
        begin
          nSpellPoint := m_MagicPowerHitSkill.MagicInfo.btDefSpell +
            GetMagicSpell(m_MagicPowerHitSkill);
          m_boPowerHit := true;
        end;

        if (nSpellPoint > 0) and (m_Master <> nil) then
        begin
          if m_Master.m_WAbil.MP > 0 then
          begin
            m_Master.DamageSpell(nSpellPoint);              //减少蓝血
            m_Master.HealthSpellChanged();
          end
          else
            wHitMode := RM_HIT;
        end;

      end;
    end;

    boPowerHit := m_boPowerHit;
    boFireHit := m_boFireHitSkill;
    boCrsHit := m_boCrsHitkill;
    bo41 := m_bo41kill;
    bo59 := m_bo59kill;
    bo60 := m_bo60kill;

    Attackok := false;
    if _Attack(wHitMode, AttackTarget) then
    begin
      nCheckCode := 6;
      SetTargetCreat(AttackTarget);                         //$FFF2
      nCheckCode := 7;
      Attackok := true;
    end;
    wIdent := RM_HIT;

    if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_YSBJECT) then
    begin
      case wHitMode of
        0: wIdent := RM_HIT;
        1: wIdent := RM_HEAVYHIT;
        2: wIdent := RM_BIGHIT;
        3:
          if boPowerHit then
            wIdent := RM_SPELL2;
        4:
          if m_MagicErgumSkill <> nil then
            wIdent := RM_LONGHIT;
        5:
          if m_MagicBanwolSkill <> nil then
            wIdent := RM_WIDEHIT;
        7:
          if boFireHit then
            wIdent := RM_FIREHIT;
        8:
          if m_MagicCrsSkill <> nil then
            wIdent := RM_CRSHIT;
        9:
          if m_Magic41Skill <> nil then
          begin
            wIdent := RM_41;
            MagicId := 41;
          end;
        10:
          if m_Magic59Skill <> nil then
          begin
            wIdent := RM_25;
            MagicId := 59;
          end;
        11:
          if m_Magic60Skill <> nil then
          begin
            wIdent := RM_25;
            MagicId := 60;
          end;

        12:
          if boPowerHit then
          begin
            wIdent := RM_25;
            MagicId := 40;
          end;                                              //残影
        13:
          if boPowerHit then
          begin
            wIdent := RM_25;
            MagicId := 41;
          end;                                              //血影
        15:
          if m_Magic43Skill <> nil then
          begin
            wIdent := RM_25;
            MagicId := 43;
          end;                                              //抱月
        16:
          if boFireHit then
          begin
            wIdent := RM_25;
            MagicId := 44;
          end;                                              //雷霆
        88:
          begin
            if (m_Magic88Skill <> nil) then
            begin
              wIdent := RM_25;
              MagicId := 88;
            end;                                            //抱月
          end;
      end;
    end;
    nCheckCode := 8;
    {   if wHitMode in[10,11] then begin    //AttackTarget
       // AttackTarget.SendRefMsg(RM_47,1536,m_btDirection,0,integer(self),'');
       AttackTarget.StruckDamage(17);  // 393216    458752
       if wHitMode=10 then
       AttackTarget.SendRefMsg(RM_47,17,393216,0,integer(self),'');

       if wHitMode=11 then
       AttackTarget.SendRefMsg(RM_47,17,458752,0,integer(self),'');
     }

     //  AttackTarget.SendMsg(AttackTarget,RM_STRUCK,nPower,AttackTarget.m_WAbil.HP,AttackTarget.m_WAbil.MaxHP,Integer(Self),'');

       //   SendRefMsg(wIdent,integer(AttackTarget),0,0,0,'');
       //   SendRefMsg(wIdent,m_btDirection,m_nCurrX,m_nCurrY,integer(AttackTarget),'');
     //   end ;
     //   else begin
    SendAttackMsg(wIdent, m_btDirection, m_nCurrX, m_nCurrY, MagicId);
    if (wIdent = RM_FIREHIT) and (wHitMode = 7) and Attackok and (m_MagicFireSwordSkill
      <> nil) then
    begin                                                   //如果是烈火
      AttackTarget.SendRefMsg(RM_47, 0, $10000, 0, integer(self), '');
      //骑战状态下，烈火剑法地面效果
      if m_boBaoZiAttacked then
        AttackTarget.SendRefMsg(RM_510, 0, 1, 0, 96, '');

    end;

    nCheckCode := 9;
    // end;
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg, [nCheckCode]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

procedure TBaseObject.CheckPKStatus;                        //004BC83C
begin
  if m_boPKFlag and ((GetTickCount - m_dwPKTick) > g_Config.dwPKFlagTime {60 * 1000})
    then
  begin
    m_boPKFlag := False;
    RefNameColor();
  end;
end;

procedure TBaseObject.DamageSpell(nSpellPoint: Integer);    //004BE50C
begin
  if nSpellPoint > 0 then
  begin
    if (m_WAbil.MP - nSpellPoint) > 0 then
      Dec(m_WAbil.MP, nSpellPoint)
    else
      m_WAbil.MP := 0;
  end
  else
  begin
    if (m_WAbil.MP - nSpellPoint) < m_WAbil.MaxMP then
      Dec(m_WAbil.MP, nSpellPoint)
    else
      m_WAbil.MP := m_WAbil.MaxMP;
  end;
end;

//004BF520

procedure TBaseObject.DecPKPoint(nPoint: Integer);
var
  nC                                                   : Integer;
begin
  nC := PKLevel();
  Dec(m_nPkPoint, nPoint);
  if m_nPkPoint < 0 then
    m_nPkPoint := 0;
  if (PKLevel <> nC) and (nC > 0) and (nC <= 2) then
  begin
    RefNameColor();
  end;
end;

//004C01B8

procedure TBaseObject.DelItemSkill(nIndex: Integer);
  procedure DeleteSkill(sSkillName: string);                //004C00B8
  var
    I                                                  : Integer;
    UserMagic                                          : pTUserMagic;
    PlayObject                                         : TPlayObject;
  begin
    for I := 0 to m_MagicList.Count - 1 do
    begin
      UserMagic := m_MagicList.Items[i];
      if UserMagic.MagicInfo.sMagicName = sSkillName then
      begin
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelMagic(UserMagic);
        Dispose(UserMagic);
        m_MagicList.Delete(i);
        break;
      end;
    end;
  end;
begin
  if m_btRaceServer <> RC_PLAYOBJECT then
    exit;
  case nIndex of
    1:
      if m_btJob <> 1 then
        DeleteSkill(g_Config.sFireBallSkill);
    2:
      if m_btJob <> 2 then
        DeleteSkill(g_Config.sHealSkill)
  end;
end;

//004C39E8

procedure TBaseObject.DelMember(BaseObject: TBaseObject);
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
begin
  if m_GroupOwner <> BaseObject then
  begin
    for I := 0 to m_GroupMembers.Count - 1 do
    begin
      if m_GroupMembers.Objects[i] = BaseObject then
      begin
        BaseObject.LeaveGroup();
        m_GroupMembers.Delete(i);
        break;
      end;
    end;
  end
  else
  begin                                                     //004C3A65
    for I := m_GroupMembers.Count - 1 downto 0 do
    begin
      TBaseObject(m_GroupMembers.Objects[i]).LeaveGroup;
      m_GroupMembers.Delete(i);
    end;
  end;
  PlayObject := TPlayObject(Self);
  if not PlayObject.CancelGroup then
  begin
    PlayObject.SendDefMessage(SM_GROUPCANCEL, 0, 0, 0, 0, '');
  end
  else
    PlayObject.SendGroupMembers();
end;

procedure TBaseObject.DoDamageWeapon(nWeaponDamage: Integer); //004C17B4
var
  nDura, nDuraPoint                                    : Integer;
  PlayObject                                           : TPlayObject;
  StdItem                                              : pTStdItem;
begin
  if m_UseItems[U_WEAPON].wIndex <= 0 then
    exit;
  if m_boSuperMan then
    exit;
  nDura := m_UseItems[U_WEAPON].Dura;
  nDuraPoint := Round(nDura / 1.03);
  Dec(nDura, nWeaponDamage);
  if nDura <= 0 then
  begin
    nDura := 0;
    m_UseItems[U_WEAPON].Dura := nDura;
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      PlayObject := TPlayObject(Self);
      PlayObject.SendDelItems(@m_UseItems[U_WEAPON]);
      StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      //004C195A
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('3' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          //UserEngine.GetStdItemName(m_UseItems[U_WEAPON].wIndex) + #9 +
          StdItem.Name + #9 +
          IntToStr(m_UseItems[U_WEAPON].MakeIndex) + #9 +
          BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
          '0');
    end;
    m_UseItems[U_WEAPON].wIndex := 0;
    SendMsg(Self, RM_DURACHANGE, U_WEAPON, nDura, m_UseItems[U_WEAPON].DuraMax, 0, '');
  end
  else
  begin                                                     //004C199D
    m_UseItems[U_WEAPON].Dura := nDura;
  end;
  if (nDura / 1.03) <> nDuraPoint then
  begin
    SendMsg(Self, RM_DURACHANGE, U_WEAPON, m_UseItems[U_WEAPON].Dura,
      m_UseItems[U_WEAPON].DuraMax, 0, '');
  end;
end;

procedure TBaseObject.GetAccessory(Item: TUserItem; var AddAbility: TAddAbility);  //004C0EBC
var
  StdItem                                              : PTStdItem;
  StdItemA                                             : TStdItem;
  DarkProperty                                         : TDarkProperty;

begin
  StdItem := UserEngine.GetStdItem(Item.wIndex);
  if StdItem = nil then
    exit;
  StdItemA := StdItem^;
  ItemUnit.GetItemAddValue(@Item, StdItemA);
  case StdItem.StdMode of
    5, 6:
      begin                                                 //004C0F63
        Inc(AddAbility.wHitPoint, HiByte(StdItemA.AC));
        if HiByte(StdItemA.MAC) > 10 then
        begin
          Inc(AddAbility.nHitSpeed, HiByte(StdItemA.MAC) - 10);
        end
        else
        begin
          Dec(AddAbility.nHitSpeed, HiByte(StdItemA.MAC));
        end;
        Inc(AddAbility.btLuck, LoByte(StdItemA.AC));
        Inc(AddAbility.btUnLuck, LoByte(StdItemA.MAC));
      end;
    19:
      begin                                                 //004C0FBE
        Inc(AddAbility.wAntiMagic, HiByte(StdItemA.AC));
        Inc(AddAbility.btUnLuck, LoByte(StdItemA.MAC));
        Inc(AddAbility.btLuck, HiByte(StdItemA.MAC));
      end;
    53:
      begin                                                 //新加物品属性
        if not g_Config.boAddUserItemNewValue then
        begin
          Inc(AddAbility.wAntiMagic, HiByte(StdItemA.AC));
          Inc(AddAbility.btUnLuck, LoByte(StdItemA.MAC));
          Inc(AddAbility.btLuck, HiByte(StdItemA.MAC));
        end
        else
        begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoByte(StdItemA.AC),
            HiWord(AddAbility.wAC) + HiByte(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoByte(StdItemA.MAC),
            HiWord(AddAbility.wMAC) + HiByte(StdItemA.MAC));
        end;
      end;
    20, 24:
      begin                                                 //004C0FF0
        Inc(AddAbility.wHitPoint, HiByte(StdItemA.AC));
        Inc(AddAbility.wSpeedPoint, HiByte(StdItemA.MAC));
      end;
    52:
      begin //原本与 20,24 一个属性，现在分开单独进行设置
        if not g_Config.boAddUserItemNewValue then
        begin
          Inc(AddAbility.wHitPoint, HiByte(StdItemA.AC));
          Inc(AddAbility.wSpeedPoint, HiByte(StdItemA.MAC));
        end
        else
        begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoByte(StdItemA.AC),
            HiWord(AddAbility.wAC) + HiByte(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoByte(StdItemA.MAC),
            HiWord(AddAbility.wMAC) + HiByte(StdItemA.MAC));
        end;
      end;
    21:
      begin
        Inc(AddAbility.wHealthRecover, HiByte(StdItemA.AC));
        Inc(AddAbility.wSpellRecover, HiByte(StdItemA.MAC));
        Inc(AddAbility.nHitSpeed, LoByte(StdItemA.AC));
        Dec(AddAbility.nHitSpeed, LoByte(StdItemA.MAC));
      end;
    54:
      begin
        if not g_Config.boAddUserItemNewValue then
        begin
          Inc(AddAbility.wHealthRecover, HiByte(StdItemA.AC));
          Inc(AddAbility.wSpellRecover, HiByte(StdItemA.MAC));
          Inc(AddAbility.nHitSpeed, LoByte(StdItemA.AC));
          Dec(AddAbility.nHitSpeed, LoByte(StdItemA.MAC));
        end
        else
        begin
          AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoByte(StdItemA.AC),
            HiWord(AddAbility.wAC) + HiByte(StdItemA.AC));
          AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoByte(StdItemA.MAC),
            HiWord(AddAbility.wMAC) + HiByte(StdItemA.MAC));
        end;
      end;
    23:
      begin
        Inc(AddAbility.wAntiPoison, HiByte(StdItemA.AC));
        Inc(AddAbility.wPoisonRecover, HiByte(StdItemA.MAC));
        Inc(AddAbility.nHitSpeed, LoByte(StdItemA.AC));
        Dec(AddAbility.nHitSpeed, LoByte(StdItemA.MAC));
      end;
    59:
      begin
        if StdItemA.Shape = 5 then
          Inc(m_AddAbil.wHP, StdItemA.AniCount);
        if StdItemA.Shape = 6 then
          Inc(m_AddAbil.WMP, StdItemA.AniCount);
        AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoByte(StdItemA.AC),
          HiWord(AddAbility.wAC) + HiByte(StdItemA.AC));
        AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoByte(StdItemA.MAC),
          HiWord(AddAbility.wMAC) + HiByte(StdItemA.MAC));

      end
  else
    begin
      AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + LoByte(StdItemA.AC),
        HiWord(AddAbility.wAC) + HiByte(StdItemA.AC));
      AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + LoByte(StdItemA.MAC),
        HiWord(AddAbility.wMAC) + HiByte(StdItemA.MAC));
    end;
  end;
  AddAbility.wDC := MakeLong(LoWord(AddAbility.wDC) + LoByte(StdItemA.DC),
    HiWord(AddAbility.wDC) + HiByte(StdItemA.DC));
  AddAbility.wMC := MakeLong(LoWord(AddAbility.wMC) + LoByte(StdItemA.MC),
    HiWord(AddAbility.wMC) + HiByte(StdItemA.MC));
  AddAbility.wSC := MakeLong(LoWord(AddAbility.wSC) + LoByte(StdItemA.SC),
    HiWord(AddAbility.wSC) + HiByte(StdItemA.SC));
  DarkProperty := item.DarkProp; //ItemUnit.GetItemDarkProperty(Item.MakeIndex, Item.wIndex);

  AddAbility.wDC := MakeLong(LoWord(AddAbility.wDC) + GetLow(DarkProperty.DDC),
    HiWord(AddAbility.wDC) + GetHigh(DarkProperty.DDC));
  AddAbility.wMC := MakeLong(LoWord(AddAbility.wMC) + GetLow(DarkProperty.DMC),
    HiWord(AddAbility.wMC) + GetHigh(DarkProperty.DMC));
  AddAbility.wSC := MakeLong(LoWord(AddAbility.wSC) + GetLow(DarkProperty.DSC),
    HiWord(AddAbility.wSC) + GetHigh(DarkProperty.DSC));
  AddAbility.wMAC := MakeLong(LoWord(AddAbility.wMAC) + GetLow(DarkProperty.DMAC),
    HiWord(AddAbility.wMAC) + GetHigh(DarkProperty.DMAC));
  AddAbility.wAC := MakeLong(LoWord(AddAbility.wAC) + GetLow(DarkProperty.DAC),
    HiWord(AddAbility.wAC) + GetHigh(DarkProperty.DAC));
  //心魔属性
end;

//004BF180
{
function TBaseObject.GetCharColor(BaseObject:TBaseObject): Byte;
var
  n10:Integer;
  nCheckCode:Integer;
begin
  nCheckCode:=0;
try
  Result:=BaseObject.GetNamecolor();
  nCheckCode:=1;
  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
    if BaseObject.PKLevel < 2 then begin
      if BaseObject.m_boPKFlag then Result:=g_Config.btPKFlagNameColor;//$2F
      nCheckCode:=2;
      n10:=GetGuildRelation(Self,BaseObject);
      nCheckCode:=3;
      case n10 of
        1,3: Result:=g_Config.btAllyAndGuildNameColor;//$B4;
        2: Result:=g_Config.btWarGuildNameColor;//$45;
      end;
      if BaseObject.m_PEnvir.m_boFight3Zone then begin
        if m_MyGuild = BaseObject.m_MyGuild then Result:=g_Config.btAllyAndGuildNameColor//$B4
        else Result:=g_Config.btWarGuildNameColor//$45;
      end;
    end; //004BF218
    nCheckCode:=4;
    if UserCastle.m_boUnderWar and m_boInFreePKArea and BaseObject.m_boInFreePKArea then begin
      nCheckCode:=5;
      Result:=g_Config.btInFreePKAreaNameColor;//$DD;
      m_boGuildWarArea:=True;
      nCheckCode:=6;
      if (m_MyGuild = nil) then exit;
      if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
        nCheckCode:=7;
        if (m_MyGuild = BaseObject.m_MyGuild) or
           (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then begin
          nCheckCode:=8;
          Result:=g_Config.btAllyAndGuildNameColor//$B4;
        end else begin //004BF2A8
          nCheckCode:=9;
          if UserCastle.IsAttackGuild(TGuild(BaseObject.m_MyGuild)) then begin
            nCheckCode:=10;
            Result:=g_Config.btWarGuildNameColor//$45;
          end;
        end;
      end else begin //004BF2CE
        nCheckCode:=11;
        if UserCastle.IsAttackGuild(TGuild(m_MyGuild)) then begin
          nCheckCode:=12;
          if (m_MyGuild = BaseObject.m_MyGuild) or
             (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then begin
            nCheckCode:=13;
            Result:=g_Config.btAllyAndGuildNameColor//$B4;
          end else begin
            nCheckCode:=14;
            if UserCastle.IsMember(BaseObject) then begin
              nCheckCode:=15;
              Result:=g_Config.btWarGuildNameColor//$45;
            end;
          end;
        end; //004BF379
      end;
    end;
  end else begin //004BF339
    //if (BaseObject.m_btSlaveExpLevel - 8) < 0 then begin
    if (BaseObject.m_btSlaveExpLevel < SLAVEMAXLEVEL) then begin
      Result:=g_Config.SlaveColor[BaseObject.m_btSlaveExpLevel];
    end;
    if BaseObject.m_boCrazyMode then Result:=$F9;
    if BaseObject.m_boHolySeize then Result:=$7D;
  end;
except
  on e: Exception do begin
    MainOutMessage('[Exception] TBaseObject.GetCharColor Code: ' + IntToStr(nCheckCode));
    MainOutMessage(E.Message);
  end;
end;
end;
}

function TBaseObject.GetCharColor(BaseObject: TBaseObject): Byte;
var
  n10                                                  : Integer;
  nCheckCode                                           : Integer;
  Castle                                               : TUserCastle;
begin
  nCheckCode := 0;
  Result := BaseObject.GetNamecolor();
  nCheckCode := 1;
  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
  begin
    if BaseObject.PKLevel < 2 then
    begin
      if BaseObject.m_boPKFlag then
        Result := g_Config.btPKFlagNameColor;               //$2F
      nCheckCode := 2;
      n10 := GetGuildRelation(Self, BaseObject);
      nCheckCode := 3;
      case n10 of
        1, 3: Result := g_Config.btAllyAndGuildNameColor;   //$B4;
        2: Result := g_Config.btWarGuildNameColor;          //$45;
      end;
      if BaseObject.m_PEnvir.m_boFight3Zone then
      begin
        if m_MyGuild = BaseObject.m_MyGuild then
          Result := g_Config.btAllyAndGuildNameColor        //$B4
        else
          Result := g_Config.btWarGuildNameColor            //$45;
      end;
    end;                                                    //004BF218
    nCheckCode := 4;
    Castle := g_CastleManager.InCastleWarArea(BaseObject);
    //    if  UserCastle.m_boUnderWar and m_boInFreePKArea and BaseObject.m_boInFreePKArea then begin
    if (Castle <> nil) and Castle.m_boUnderWar and m_boInFreePKArea and
      BaseObject.m_boInFreePKArea then
    begin
      nCheckCode := 5;
      Result := g_Config.btInFreePKAreaNameColor;           //$DD;
      m_boGuildWarArea := True;
      nCheckCode := 6;
      if (m_MyGuild = nil) then
        exit;
      //      if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
      if Castle.IsMasterGuild(TGuild(m_MyGuild)) then
      begin
        nCheckCode := 7;
        if (m_MyGuild = BaseObject.m_MyGuild) or
          (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then
        begin
          nCheckCode := 8;
          Result := g_Config.btAllyAndGuildNameColor        //$B4;
        end
        else
        begin                                               //004BF2A8
          nCheckCode := 9;
          //if UserCastle.IsAttackGuild(TGuild(BaseObject.m_MyGuild)) then begin
          if Castle.IsAttackGuild(TGuild(BaseObject.m_MyGuild)) then
          begin
            nCheckCode := 10;
            Result := g_Config.btWarGuildNameColor          //$45;
          end;
        end;
      end
      else
      begin                                                 //004BF2CE
        nCheckCode := 11;
        //        if UserCastle.IsAttackGuild(TGuild(m_MyGuild)) then begin
        if Castle.IsAttackGuild(TGuild(m_MyGuild)) then
        begin
          nCheckCode := 12;
          if (m_MyGuild = BaseObject.m_MyGuild) or
            (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then
          begin
            nCheckCode := 13;
            Result := g_Config.btAllyAndGuildNameColor      //$B4;
          end
          else
          begin
            nCheckCode := 14;
            //            if UserCastle.IsMember(BaseObject) then begin
            if Castle.IsMember(BaseObject) then
            begin
              nCheckCode := 15;
              Result := g_Config.btWarGuildNameColor        //$45;
            end;
          end;
        end;                                                //004BF379
      end;
    end;
  end
  else
  begin                                                     //004BF339
    //if (BaseObject.m_btSlaveExpLevel - 8) < 0 then begin
    if (BaseObject.m_btSlaveExpLevel < SLAVEMAXLEVEL) then
    begin
      Result := g_Config.SlaveColor[BaseObject.m_btSlaveExpLevel];

      //这里修改 宝宝的 等级显示
  //    if not BaseObject.m_bohorse  then
  //    BaseObject.m_sCharName:=inttostr(BaseObject.m_btSlaveExpLevel)+'级'+ BaseObject.m_sCharName;
    end;
    if BaseObject.m_boCrazyMode then
      Result := $F9;
    if BaseObject.m_boHolySeize then
      Result := $7D;
  end;
end;

function TBaseObject.GetLevelExp(nLevel: Integer): LongWord; //004BEDC8
begin
  if nLevel <= 500 {51} then
  begin
    Result := g_Config.dwNeedExps[nLevel]
  end
  else
  begin
    Result := g_Config.dwNeedExps[High(g_Config.dwNeedExps)];
    //Result:=$FFFFFFFF;
  end;

end;

//004BF144

function TBaseObject.GetNamecolor(): Byte;
begin
  Result := m_btNameColor; //  g_Config.ReNewNameColor[0];
  if PKLevel = 1 then
    Result := g_Config.btPKLevel1NameColor;                 //$FB;
  if PKLevel >= 2 then
    Result := g_Config.btPKLevel2NameColor;                 //$F9;
end;

procedure TBaseObject.HearMsg(sMsg: string);                //004BB2A0
begin
  if sMsg <> '' then
    SendMsg(nil, RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, 0,
      sMsg);
end;

function TBaseObject.InSafeArea(): Boolean;                 //004BEF8C
var
  I                                                    : Integer;
  sC                                                   : string;
  n14, n18, n1C                                        : Integer;
begin
  if m_PEnvir = nil then
    exit;
  Result := m_PEnvir.m_boSAFE;
  if Result then
    exit;
  try
    g_StartPointList.Lock;
    for I := 0 to g_StartPointList.Count - 1 do
    begin
      sC := g_StartPointList.Strings[i];
      if sC = m_PEnvir.sMapName then
      begin
        n1C := Integer(g_StartPointList.Objects[i]);
        n14 := LoWord(n1C);
        n18 := HiWord(n1C);
        if (abs(m_nCurrX - n14) <= 60) and (abs(m_nCurrY - n18) <= 60) then
        begin
          Result := True;
          break;
        end;
      end;
    end;
  finally
    g_StartPointList.UnLock;
  end;
end;

procedure TBaseObject.MonsterRecalcAbilitys;                //004BE934
var
  n8                                                   : Integer;
begin
  m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_Abil.DC));
  n8 := 0;
  if (m_btRaceServer = 100) or
    (m_btRaceServer = 113) or
    (m_btRaceServer = 114) then
  begin

    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), ROUND((m_btSlaveExpLevel * {1.0e-1} 0.1 +
      {3.0000000000000000001e-1} 0.3) * {3.0} 3.0 * m_btSlaveExpLevel +
      HiWord(m_WAbil.DC)));
    n8 := n8 + ROUND((m_btSlaveExpLevel * {1.0e-1} 0.1 + {3.0000000000000000001e-1} 0.3)
      * m_Abil.MaxHP) * m_btSlaveExpLevel;
    n8 := n8 + m_Abil.MaxHP;
    if m_btSlaveExpLevel > 0 then
      m_WAbil.MaxHP := n8
    else
      m_WAbil.MaxHP := m_Abil.MaxHP;
  end
  else
  begin                                                     //004BEA85
    n8 := m_Abil.MaxHP;
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), ROUND(m_btSlaveExpLevel * 2 +
      HiWord(m_WAbil.DC)));
    n8 := n8 + ROUND(m_Abil.MaxHP * {1.5000000000000000001e-1} 0.15) * m_btSlaveExpLevel;
    m_WAbil.MaxHP := _MIN(ROUND(m_Abil.MaxHP + m_btSlaveExpLevel * 60), n8);
    //m_WAbil.MAC:=0; 01/20 取消此行，防止怪物升级后魔防变0
  end;
  //m_btHitPoint:=15; 01/20 取消此行，防止怪物升级后准确率变15
end;

procedure TPlayObject.ShowMapInfo(sMap, sX, sY: string);
var
  Map                                                  : TEnvirnoment;
  nX, nY                                               : Integer;
  MapCellInfo                                          : pTMapCellinfo;
begin
  nX := Str_ToInt(sX, 0);
  nY := Str_ToInt(sY, 0);
  if (sMap <> '') and (nX >= 0) and (nY >= 0) then
  begin
    Map := g_MapManager.FindMap(sMap);
    if Map <> nil then
    begin
      if Map.GetMapCellInfo(nX, nY, MapCellInfo) then
      begin
        SysMsg('标志: ' + IntToStr(MapCellInfo.chFlag), c_Green, t_Hint);
        if MapCellInfo.ObjList <> nil then
        begin
          SysMsg('对象数: ' + IntToStr(MapCellInfo.ObjList.Count), c_Green, t_Hint);
        end;
      end
      else
      begin
        SysMsg('取地图单元信息失败: ' + sMap, c_Red, t_Hint);
      end;
    end;
  end
  else
  begin
    SysMsg('请按正确格式输入: ' + g_GameCommand.MAPINFO.sCmd + ' 地图号 X Y', c_Green,
      t_Hint);
  end;
end;

procedure TBaseObject.SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);        //004B84FC
var
  SendMessage                                          : pTSendMessage;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if not m_boGhost then
    begin
      New(SendMessage);
      SendMessage.wIdent := wIdent;
      SendMessage.wParam := wParam;
      SendMessage.nParam1 := lParam1;
      SendMessage.nParam2 := lParam2;
      SendMessage.nParam3 := lParam3;
      SendMessage.dwDeliveryTime := 0;
      SendMessage.BaseObject := BaseObject;
      if sMsg <> '' then
      begin
        try
          GetMem(SendMessage.Buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
        except
          SendMessage.Buff := nil;
        end;
      end
      else
      begin
        SendMessage.Buff := nil;
      end;
      m_MsgList.Insert(0, SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1,
  nParam2, nParam3: Integer; sMsg: string);                   //004B865C
var
  SendMessage                                          : pTSendMessage;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    // if not m_boGhost then
    begin
      New(SendMessage);
      SendMessage.wIdent := wIdent;
      SendMessage.wParam := wParam;
      SendMessage.nParam1 := nParam1;
      SendMessage.nParam2 := nParam2;
      SendMessage.nParam3 := nParam3;
      SendMessage.dwDeliveryTime := 0;
      SendMessage.BaseObject := BaseObject;
      SendMessage.boLateDelivery := False;
      if sMsg <> '' then
      begin
        try
          GetMem(SendMessage.Buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
        except
          SendMessage.Buff := nil;
        end;
      end
      else
      begin
        SendMessage.Buff := nil;
      end;
      m_MsgList.Add(SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string;
  dwDelay: LongWord);                                       //004B87C4
var
  SendMessage                                          : pTSendMessage;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    if not m_boGhost then
    begin
      New(SendMessage);
      SendMessage.wIdent := wIdent;
      SendMessage.wParam := wParam;
      SendMessage.nParam1 := lParam1;
      SendMessage.nParam2 := lParam2;
      SendMessage.nParam3 := lParam3;
      SendMessage.dwDeliveryTime := GetTickCount + dwDelay;
      SendMessage.BaseObject := BaseObject;
      SendMessage.boLateDelivery := True;
      if sMsg <> '' then
      begin
        try
          GetMem(SendMessage.Buff, Length(sMsg) + 1);
          Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
        except
          SendMessage.Buff := nil;
        end;
      end
      else
      begin
        SendMessage.Buff := nil;
      end;
      m_MsgList.Add(SendMessage);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string;
  dwDelay: LongWord);                                       //004B8930
var
  SendMessage                                          : pTSendMessage;
  i                                                    : integer;
begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    i := 0;
    while (True) do
    begin
      if m_MsgList.Count <= i then
        break;
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = wIdent) and (SendMessage.nParam1 = lParam1) then
      begin
        m_MsgList.Delete(i);
        if SendMessage.Buff <> nil then
          FreeMem(SendMessage.Buff);
        Dispose(SendMessage);
        Continue;
      end;
      Inc(i);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendDelayMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg, dwDelay);
end;

procedure TBaseObject.SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);        //004B8A7C
var
  SendMessage                                          : pTSendMessage;
  i                                                    : Integer;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    i := 0;
    while (True) do
    begin
      if m_MsgList.Count <= i then
        break;
      SendMessage := m_MsgList.Items[i];
      if SendMessage.wIdent = wIdent then
      begin
        m_MsgList.Delete(i);
        if SendMessage.Buff <> nil then
          FreeMem(SendMessage.Buff);
        Dispose(SendMessage);
        Continue;
      end;
      Inc(i);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);
end;

procedure TBaseObject.SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string);        //004B8A7C
var
  SendMessage                                          : pTSendMessage;
  i, checktime                                         : Integer;

begin
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    i := 0;
    while (True) do
    begin
      if m_MsgList.Count <= i then
        break;
      SendMessage := m_MsgList.Items[i];
      if (SendMessage.wIdent = CM_TURN) or
        (SendMessage.wIdent = CM_WALK) or
        (SendMessage.wIdent = CM_SITDOWN) or
        (SendMessage.wIdent = CM_HORSERUN) or
        (SendMessage.wIdent = CM_RUN) or
        (SendMessage.wIdent = CM_HIT) or
        (SendMessage.wIdent = CM_HEAVYHIT) or
        (SendMessage.wIdent = CM_BIGHIT) or
        (SendMessage.wIdent = CM_POWERHIT) or
        (SendMessage.wIdent = CM_LONGHIT) or
        (SendMessage.wIdent = CM_WIDEHIT) or
        (SendMessage.wIdent = CM_FIREHIT) or
        (SendMessage.wIdent = CM_3026HIT)
        then
      begin
        m_MsgList.Delete(i);
        if SendMessage.Buff <> nil then
          FreeMem(SendMessage.Buff);
        Dispose(SendMessage);
        Continue;
      end;
      Inc(i);
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
  SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);

end;

function TBaseObject.GetMessage(Msg: pTProcessMessage): Boolean; //004B8BA4($FFFF)
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
begin
  Result := False;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    I := 0;
    Msg.wIdent := 0;
    while m_MsgList.Count > I do
    begin
      SendMessage := m_MsgList.Items[I];
      if (SendMessage.dwDeliveryTime <> 0) and (GetTickCount < SendMessage.dwDeliveryTime)
        then
      begin
        Inc(I);
        Continue;
      end;
      m_MsgList.Delete(I);
      Msg.wIdent := SendMessage.wIdent;
      Msg.wParam := SendMessage.wParam;
      Msg.nParam1 := SendMessage.nParam1;
      Msg.nParam2 := SendMessage.nParam2;
      Msg.nParam3 := SendMessage.nParam3;
      Msg.BaseObject := SendMessage.BaseObject;
      Msg.dwDeliveryTime := SendMessage.dwDeliveryTime;
      Msg.boLateDelivery := SendMessage.boLateDelivery;
      if SendMessage.Buff <> nil then
      begin
        Msg.sMsg := StrPas(SendMessage.Buff);
        FreeMem(SendMessage.Buff);
      end
      else
      begin
        Msg.sMsg := '';
      end;
      Dispose(SendMessage);
      Result := True;
      break;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TBaseObject.GetMapBaseObjects(tEnvir: TEnvirnoment; nX, nY, nRage: Integer;
  rList: TList): Boolean;                                     //004B8D2C
var
  III                                                  : Integer;
  x, y                                                 : Integer;
  nStartX, nStartY, nEndX, nEndY                       : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  BaseObject                                           : TBaseObject;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::GetMapBaseObjects';
begin
  Result := False;
  if rList = nil then
    exit;
  try
    nStartX := nX - nRage;
    nEndX := nX + nRage;
    nStartY := nY - nRage;
    nEndY := nY + nRage;
    for x := nStartX to nEndX do
    begin
      for y := nStartY to nEndY do
      begin
        if tEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList <> nil) then
        begin
          for III := 0 to MapCellInfo.ObjList.Count - 1 do
          begin
            OSObject := MapCellInfo.ObjList.Items[III];

            if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then
            begin
              BaseObject := TBaseObject(OSObject.CellObj);
              if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not
                BaseObject.m_boGhost) then
              begin
                rList.Add(BaseObject);
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
  Result := True;
end;

procedure TBaseObject.SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3:
  Integer; sMsg: string);                                     //004B8EBC
var
  II, nC                                               : Integer;
  nCX, nCY, nLX, nLY, nHX, nHY                         : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  BaseObject                                           : TBaseObject;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::SendRefMsg Name = %s';
begin
  if m_PEnvir = nil then
  begin
    MainOutMessage(m_sCharName + ' SendRefMsg nil PEnvir ');
    exit;
  end;
  //if m_boObMode or m_boFixedHideMode then exit;
  //01/21 增加，原来直接不发信息，如果隐身模式则只发送信息给自己
  if m_boObMode or m_boFixedHideMode then
  begin
    SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
    exit;
  end;

  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    if ((GetTickCount - m_SendRefMsgTick) >= 500) or (m_VisibleHumanList.Count = 0) then
    begin
      m_SendRefMsgTick := GetTickCount();
      m_VisibleHumanList.Clear;
      nLX := m_nCurrX - g_Config.nSendRefMsgRange {12};
      nHX := m_nCurrX + g_Config.nSendRefMsgRange {12};
      nLY := m_nCurrY - g_Config.nSendRefMsgRange {12};
      nHY := m_nCurrY + g_Config.nSendRefMsgRange {12};
      for nCX := nLX to nHX do
      begin
        for nCY := nLY to nHY do
        begin
          if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) then
          begin
            if MapCellInfo.ObjList <> nil then
            begin
              for II := MapCellInfo.ObjList.Count - 1 downto 0 do
              begin
                OSObject := MapCellInfo.ObjList.Items[II];
                //////////  2006，8，3 处理抱错
                if OSObject = nil then
                begin
                  MapCellInfo.ObjList.Delete(ii);
                  if MapCellInfo.ObjList.Count > 0 then
                    Continue;
                  MapCellInfo.ObjList.Free;
                  MapCellInfo.ObjList := nil;
                  break;
                end;
                ///////////

                if OSObject <> nil then
                begin
                  if OSObject.btType = OS_MOVINGOBJECT then
                  begin
                    if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then
                    begin
                      DisPose(OSObject);
                      MapCellInfo.ObjList.Delete(II);
                      if MapCellInfo.ObjList.Count <= 0 then
                      begin
                        MapCellInfo.ObjList.Free;
                        MapCellInfo.ObjList := nil;
                        break;
                      end;
                    end
                    else
                    begin                                   //004B90A4
                      try
                        BaseObject := TBaseObject(OSObject.CellObj);
                        if (BaseObject <> nil) {and not BaseObject.m_boGhost} then
                        begin
                          if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
                          begin
                            BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2,
                              nParam3, sMsg);
                            m_VisibleHumanList.Add(BaseObject);
                          end
                          else                              //004B9125
                            if BaseObject.m_boWantRefMsg then
                            begin
                              if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent =
                                RM_DEATH) then
                              begin
                                BaseObject.SendMsg(Self, wIdent, wParam, nParam1,
                                  nParam2, nParam3, sMsg);
                                m_VisibleHumanList.Add(BaseObject);
                              end;
                            end;
                        end;
                      except
                        on e: Exception do
                        begin
                          MapCellInfo.ObjList.Delete(II);
                          if MapCellInfo.ObjList.Count <= 0 then
                          begin
                            MapCellInfo.ObjList.Free;
                            MapCellInfo.ObjList := nil;
                          end;
                          MainOutMessage(format(sExceptionMsg, [m_sCharName]));
                          MainOutMessage(E.Message);
                          raise;
                        end;

                      end;
                    end;
                  end;
                end;
              end; //for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
            end; //if MapCellInfo.ObjList <> nil then begin
          end; //if PEnvir.GetMapCellInfo(nC,n10,MapCellInfo) then begin
        end;
      end;

    end
    else
    begin
      for nC := 0 to m_VisibleHumanList.Count - 1 do
      begin
        BaseObject := TBaseObject(m_VisibleHumanList.Items[nC]);
        if BaseObject.m_boGhost then
          Continue;
        if (BaseObject.m_PEnvir = m_PEnvir) and
          (abs(BaseObject.m_nCurrX - m_nCurrX) < 11) and
          (abs(BaseObject.m_nCurrY - m_nCurrY) < 11) then
        begin
          if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
          begin
            BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
          end
          else
            if BaseObject.m_boWantRefMsg then
            begin
              if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent = RM_DEATH) then
              begin
                BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3,
                  sMsg);
              end;
            end; //if BaseObject.m_boWantRefMsg then begin
        end; //if (BaseObject.m_PEnvir = m_PEnvir) and
      end; //for nC:= 0 to m_VisibleHumanList.Count - 1 do begin
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TBaseObject.UpdateVisibleGay(BaseObject: TBaseObject); //004B939C
var
  I                                                    : Integer;
  boIsVisible                                          : Boolean;
  VisibleBaseObject                                    : pTVisibleBaseObject;
begin
  boIsVisible := False;

  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_Master <> nil) then
    m_boIsVisibleActive := True;                            //如果是人物或宝宝则置TRUE
  for I := 0 to m_VisibleActors.Count - 1 do
  begin
    VisibleBaseObject := m_VisibleActors.Items[i];
    if VisibleBaseObject.BaseObject = BaseObject then
    begin
      VisibleBaseObject.nVisibleFlag := 1;
      boIsVisible := True;
      break;
    end;
  end;
  if boIsVisible then
    exit;
  New(VisibleBaseObject);
  VisibleBaseObject.nVisibleFlag := 2;
  VisibleBaseObject.BaseObject := BaseObject;
  m_VisibleActors.Add(VisibleBaseObject);
end;

procedure TBaseObject.UpdateVisibleItem(wX, wY: Integer; MapItem: PTMapItem); //004B94FC
var
  I                                                    : Integer;
  boIsVisible                                          : Boolean;
  VisibleMapItem                                       : pTVisibleMapItem;
begin
  boIsVisible := False;
  for I := 0 to m_VisibleItems.Count - 1 do
  begin
    VisibleMapItem := m_VisibleItems.Items[i];
    if VisibleMapItem.MapItem = MapItem then
    begin
      VisibleMapItem.nVisibleFlag := 1;
      boIsVisible := True;
      break;
    end;
  end;
  if boIsVisible then
    exit;
  New(VisibleMapItem);
  VisibleMapItem.nVisibleFlag := 2;
  VisibleMapItem.nX := wX;
  VisibleMapItem.nY := wY;
  VisibleMapItem.MapItem := MapItem;
  VisibleMapItem.sName := MapItem.Name;
  VisibleMapItem.wLooks := MapItem.Looks;
  m_VisibleItems.Add(VisibleMapItem);
end;

procedure TBaseObject.UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject); //004B95D0
var
  I                                                    : Integer;
  boIsVisible                                          : Boolean;
  Event                                                : TEvent;
begin
  boIsVisible := False;
  for I := 0 to m_VisibleEvents.Count - 1 do
  begin
    Event := m_VisibleEvents.Items[i];
    if Event = MapEvent then
    begin
      Event.nVisibleFlag := 1;
      boIsVisible := True;
      break;
    end;
  end;
  if boIsVisible then
    exit;
  TEvent(MapEvent).nVisibleFlag := 2;
  TEvent(MapEvent).m_nX := wX;
  TEvent(MapEvent).m_nY := wY;
  m_VisibleEvents.Add(MapEvent);
end;

function TBaseObject.IsVisibleHuman: Boolean;
var
  I                                                    : Integer;
  VisibleBaseObject                                    : pTVisibleBaseObject;
begin
  Result := False;
  for I := 0 to m_VisibleActors.Count - 1 do
  begin
    VisibleBaseObject := m_VisibleActors.Items[i];
    if (TBaseObject(VisibleBaseObject.BaseObject).m_btRaceServer = RC_PLAYOBJECT) or
      (TBaseObject(VisibleBaseObject.BaseObject).m_Master <> nil) then
    begin
      Result := True;
      break;
    end;
  end;
end;

procedure TBaseObject.SearchViewRange;                      //004B966C
var
  I                                                    : Integer;
  nStartX                                              : Integer;
  nEndX                                                : Integer;
  nStartY                                              : Integer;
  nEndY                                                : Integer;
  n18                                                  : Integer;
  n1C                                                  : Integer;
  nIdx                                                 : Integer;
  n24                                                  : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  BaseObject                                           : TBaseObject;
  MapItem                                              : PTMapItem;
  MapEvent                                             : TEvent;
  VisibleBaseObject                                    : pTVisibleBaseObject;
  nCheckCode                                           : Integer;
resourcestring
  sExceptionMsg1                                         =
    '[Exception] TBaseObject::SearchViewRange Code:%d';
  sExceptionMsg2                                         =
    '[Exception] TBaseObject::SearchViewRange 1-%d %s %s %d %d %d';

begin
  nCheckCode := 0;
  if m_PEnvir = nil then
  begin
    MainOutMessage('SearchViewRange nil PEnvir');
    exit;
  end;
  nCheckCode := 1;
  n24 := 0;
  m_boIsVisibleActive := False;                             //先置为FALSE
  try
    nCheckCode := 4;
    for I := 0 to m_VisibleActors.Count - 1 do
    begin
      pTVisibleBaseObject(m_VisibleActors.Items[I]).nVisibleFlag := 0;
    end;
    nCheckCode := 5;
  except
    MainOutMessage(format(sExceptionMsg1, [nCheckCode]));
    KickException();
  end;
  nCheckCode := 6;

  nStartX := m_nCurrX - m_nViewRange;
  nEndX := m_nCurrX + m_nViewRange;
  nStartY := m_nCurrY - m_nViewRange;
  nEndY := m_nCurrY + m_nViewRange;
  try
    nCheckCode := 7;
    for n18 := nStartX to nEndX do
    begin
      nCheckCode := 8;
      for n1C := nStartY to nEndY do
      begin
        nCheckCode := 9;
        if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo) and (MapCellInfo.ObjList <> nil)
          then
        begin
          nCheckCode := 10;
          n24 := 1;
          nIdx := 0;
          while (True) do
          begin
            nCheckCode := 11;
            if MapCellInfo.ObjList.Count <= nIdx then
              break;                                        //004B9858
            OSObject := MapCellInfo.ObjList.Items[nIdx];
            nCheckCode := 12;
            //////////  2006，8，3 处理抱错
            if OSObject = nil then
            begin
              MapCellInfo.ObjList.Delete(nIdx);
              if MapCellInfo.ObjList.Count > 0 then
                Continue;
              MapCellInfo.ObjList.Free;
              MapCellInfo.ObjList := nil;
              break;
            end;
            ///////////

            if OSObject <> nil then
            begin
              nCheckCode := 13;
              if OSObject.btType = OS_MOVINGOBJECT then
              begin
                nCheckCode := 14;
                if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then
                begin
                  Dispose(OSObject);
                  MapCellInfo.ObjList.Delete(nIdx);
                  if MapCellInfo.ObjList.Count > 0 then
                    Continue;
                  MapCellInfo.ObjList.Free;
                  MapCellInfo.ObjList := nil;
                  break;
                end;                                        //004B9907
                nCheckCode := 15;
                BaseObject := TBaseObject(OSObject.CellObj);
                if BaseObject <> nil then
                begin
                  nCheckCode := 16;
                  if not BaseObject.m_boGhost and not BaseObject.m_boFixedHideMode and not
                    BaseObject.m_boObMode then
                  begin
                    nCheckCode := 17;
                    if (m_btRaceServer < RC_ANIMAL) or
                      (m_Master <> nil) or
                      m_boCrazyMode or
                      m_boWantRefMsg or
                      ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX -
                        m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) or
                      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
                    begin
                      nCheckCode := 18;
                      UpdateVisibleGay(BaseObject);
                      nCheckCode := 19;
                    end;
                  end;
                end;
              end;
            end;
            Inc(nIdx);
          end;
        end;
      end;
    end;
  except
    on e: Exception do
    begin

      MainOutMessage(format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX,
        m_nCurrY, nCheckCode]));

      MainOutMessage(E.Message);
      raise;
      KickException();
    end;

  end;
  nCheckCode := 40;
  n24 := 2;
  try
    n18 := 0;
    while (True) do
    begin
      if m_VisibleActors.Count <= n18 then
        break;
      nCheckCode := 41;
      VisibleBaseObject := m_VisibleActors.Items[n18];
      nCheckCode := 42;
      if VisibleBaseObject.nVisibleFlag = 0 then
      begin
        nCheckCode := 43;
        m_VisibleActors.Delete(n18);
        nCheckCode := 48;
        Dispose(VisibleBaseObject);
        nCheckCode := 49;
        Continue;
      end;
      nCheckCode := 50;
      Inc(n18);
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX,
        m_nCurrY, nCheckCode]));
      {MainOutMessage(m_sCharName + ',' +
                     m_sMapName + ',' +
                     IntToStr(m_nCurrX) + ',' +
                     IntToStr(m_nCurrY) + ',' +
                     ' SearchViewRange 2');}
      KickException();
    end;
  end;
end;

function TBaseObject.GetFeatureToLong: Integer;             //004BA23C
begin
  Result := GetFeature(nil);
end;

function TBaseObject.GetFeatureEx(): Word;
begin
  if m_boOnHorse then
  begin
    Result := MakeWord(m_btHorseType, m_btGender);          // m_btDressEffType
  end
  else
  begin
    Result := MakeWord(0, m_btGender);                      //hint  m_btDressEffType
  end;
end;

function TBaseObject.GetYSfenghao(nfegnhao: Integer): Integer;

begin
  result := 0;
  case nfegnhao of
    0: result := 256 * 0 + 0;
    1: result := 256 * 0 + 1;
    2: result := 256 * 1 + 1;
    3: result := 256 * 2 + 1;
    4: result := 256 * 0 + 2;
    5: result := 256 * 1 + 2;
    6: result := 256 * 2 + 2;
    7: result := 256 * 0 + 3;
    8: result := 256 * 1 + 3;
    9: result := 256 * 2 + 3;
    10: result := 256 * 0 + 4;
    11: result := 256 * 1 + 4;
    12: result := 256 * 2 + 4;

  end;
end;

function TBaseObject.GetDress(): Integer;                   //004BA25C
var

  StdItem                                              : PTStdItem;
  value                                                : TIntRec;
begin
  Result := 0;
  if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_YSBJECT) then
  begin

    Value.Value := 0;
    value.btValue[3] := 0;
    if m_UseItems[U_DRESS].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
      if StdItem <> nil then
      begin
        value.btValue[0] := StdItem.Shape;
        //  result := StdItem.Shape; //makeword(StdItem.Shape,m_UseItems[U_DRESS].btValue[11])  ;//m_btDressEffType;                   //  xjs  每种衣服15种颜色。
      end;
    end;
    if m_boUsexushou then
    begin
      value.btValue[0] := 200;
      // exit;
    end;
    if m_UseItems[U_Shield].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_Shield].wIndex);
      if StdItem <> nil then
      begin
        value.btValue[2] := StdItem.Shape;
        //        result := StdItem.Shape; //makeword(StdItem.Shape,m_UseItems[U_DRESS].btValue[11])  ;//m_btDressEffType;                   //  xjs  每种衣服15种颜色。
      end;
    end;
    Result := Value.Value;

  end;
end;

function TBaseObject.GetFeature(BaseObject: TBaseObject): Integer; //004BA25C
var
  nDress, nWeapon, nHair, nRaceImg, nAppr              : Integer;
  StdItem                                              : PTStdItem;
  bo25                                                 : Boolean;
  MonInfo                                              : TMonPetInfo;
  UserItem                                             : PTUserItem;
begin
  if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_YSBJECT) then
  begin
    nDress := 0;
    //衣服
    if m_UseItems[U_DRESS].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
      if StdItem <> nil then
      begin
        nDress := StdItem.Shape * 16 + m_UseItems[U_DRESS].btValue[11];  //m_btDressEffType;                   //  xjs  每种衣服15种颜色。
      end;
    end;
    // Inc(nDress,m_btGender);               //hint 衣服是奇数是男性。传世没有要求
    nWeapon := 0;
    //武器
    if m_UseItems[U_WEAPON].wIndex > 0 then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
      if StdItem <> nil then
      begin
        nWeapon := StdItem.Shape;                           //* 2;                  //hint
        if nWeapon = 19 then
          nWeapon := 25;
      end;
    end;
    //   Inc(nWeapon,m_btGender);             //hint 武器是奇数是男性。传世没有要求
    nHair := m_btHair; //* 2 ;      //+ m_btGender;    //头发   传世没有要求

    if (m_btRaceServer = RC_YSBJECT) then
      Result := MakeHumanFeature(m_btRaceImg, nDress, nWeapon, nHair)
        //   Result := MakeHumanFeature(m_btRaceImg, $e0, $2c, $03)
    else
      Result := MakeHumanFeature(0, nDress, nWeapon, nHair);
    if m_boOnBaozi then
    begin
      if (m_btRaceServer = RC_PLAYOBJECT) and (TPlayObject(Self).ysmasterplayer <> nil)
        then
        MonInfo :=
          TPlayObject(Self).ysmasterplayer.GetpetLevel(TPlayObject(Self).ysmasterplayer.M_monYSOnHorseitemmake)
      else
        MonInfo := TPlayObject(Self).GetpetLevel(TPlayObject(Self).M_monOnHorseitemmake);

      case MonInfo.montype of
        1:
          begin
            case MonInfo.MonColor of
              0: Result := result + 230;
              1: Result := result + 232;
              2: Result := result + 231;
            end;
          end;
        2:
          begin
            case MonInfo.MonColor of
              0: Result := result + $E9;
              1: Result := result + $EB;
              2: Result := result + $EA;
            end;
          end;
        9, 10:                                              //狮子
          begin
            case MonInfo.MonColor of
              0: Result := result + $FC;                    //黄颜色
              1: Result := result + $F8;                    //黑颜色
              2: Result := result + $FD;                    //白颜色
            end;

          end;
        16, 17, 18:
          begin
            case MonInfo.MonColor of
              0: Result := result + $F1;
              1: Result := result + $F3;
              2: Result := result + $EE;
            end;
          end;
      end;
      exit;
    end;
    if m_boOnHorse and m_PEnvir.m_boCANHORSE then
    begin
      Result := Result + m_btHorseType + 174;
    end;
    exit;
  end;                                                      //004BA32F

  { bo25 := False;
   if (BaseObject <> nil) and (BaseObject.bo245) then
     bo25 := True;
   if bo25 then
   begin
     nRaceImg := m_btRaceImg;
     nAppr := m_wAppr;
     case nAppr of
       0:
         begin
           nRaceImg := 12;
           nAppr := 5;
         end;
       1:
         begin
           nRaceImg := 11;
           nAppr := 9;
         end;
       160:
         begin
           nRaceImg := 10;
           nAppr := 0;
         end;
       161:
         begin
           nRaceImg := 10;
           nAppr := 1;
         end;
       162:
         begin
           nRaceImg := 11;
           nAppr := 6;
         end;
       163:
         begin
           nRaceImg := 11;
           nAppr := 3;
         end;
     end;
     Result := MakeMonsterFeature(nRaceImg, m_btMonsterWeapon, nAppr);
     exit;
   end; //004BA40E }
  Result := MakeMonsterFeature(m_btRaceImg, m_btMonsterWeapon, m_wAppr);
end;

function TBaseObject.GetCharStatus(): Integer;              //004BA43C
var
  I                                                    : Integer;
  nStatus                                              : Integer;
begin
  nStatus := 0;
  for I := Low(TStatusTime) to High(TStatusTime) do
  begin
    if m_wStatusTimeArr[I] > 0 then
    begin
      nStatus := ($80000000 shr I) or nStatus;
    end;
  end;
  Result := (m_nCharStatusEx and $FFFFF) or nStatus;
end;

procedure TBaseObject.AbilCopyToWAbil;                      //004BA494
begin
  m_WAbil := m_Abil;
end;

procedure TBaseObject.Initialize;                           //4BA4B8
var
  I                                                    : Integer;
  UserMagic                                            : pTUserMagic;
begin
  AbilCopyToWAbil();
  for I := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[i];
    if UserMagic.btLevel > 5 then
      UserMagic.btLevel := 0;
  end;
  m_boAddtoMapSuccess := True;
  if m_PEnvir.CanWalk(m_nCurrX, m_nCurrY, True) and AddToMap() then
    m_boAddtoMapSuccess := False;
  m_nCharStatus := GetCharStatus();
  AddBodyLuck(0);
  LoadSayMsg();
  if g_Config.boMonSayMsg then
    MonsterSayMsg(nil, s_MonGen);
end;
//==============================
//取得怪物说话信息列表

procedure TBaseObject.LoadSayMsg();
var
  I                                                    : Integer;
begin
  for I := 0 to g_MonSayMsgList.Count - 1 do
  begin
    if CompareText(g_MonSayMsgList.Strings[I], m_sCharName) = 0 then
    begin
      m_SayMsgList := TList(g_MonSayMsgList.Objects[I]);
      break;
    end;
  end;
end;

procedure TBaseObject.Disappear();                          //004BA580
begin

end;

procedure TBaseObject.FeatureChanged;                       //004BA58C
var
  f                                                    : integer; //
begin
  if (m_btRaceServer = RC_PLAYOBJECT) or (m_btRaceServer = RC_YSBJECT) then
  begin
    f := GetDress;
    SendRefMsg(RM_FEATURECHANGED, GetFeatureEx, GetFeatureToLong, 0, 0, encodebuffer(@f,
      4))                                                     // ''
  end
  else
  begin
    //f:=$0f;
    SendRefMsg(RM_FEATURECHANGED, GetFeatureEx, GetFeatureToLong, 0, 0, ''); // '';
    //SendRefMsg(RM_FEATURECHANGED, 0,MakeLong( 14591,61440), 0, 0, encodebuffer(@f, 4)); // '';
  end;
end;

procedure TBaseObject.StatusChanged();                      //004BA5B4
begin
  m_nCharStatus := GetCharStatus();
  SendRefMsg(RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '')
end;

procedure TBaseObject.DisappearA();                         //004BA65C
begin
  if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self) = 1 then
    SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
end;

procedure TBaseObject.KickException;                        //004BA6A8
var
  PlayObject                                           : TPlayObject;
begin
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    m_sMapName := g_Config.sHomeMap;
    m_nCurrX := g_Config.nHomeX;
    m_nCurrY := g_Config.nHomeY;
    PlayObject := TPlayObject(self);
    PlayObject.m_boEmergencyClose := TRUE;
  end
  else
  begin                                                     //
    m_boDeath := True;
    m_dwDeathTick := GetTickCount;
    MakeGhost;
  end;
end;

function TBaseObject.Walk(nIdent: Integer): Boolean;        //004BA724
var
  I                                                    : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  GateObj                                              : pTGateObj;
  bo1D                                                 : Boolean;
  Event                                                : TEvent;
  PlayObject                                           : TPlayObject;
  nCheckCode                                           : Integer;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::Walk  CheckCode:%d %s %s %d:%d';
begin
  Result := True;
  nCheckCode := -1;
  if m_PEnvir = nil then
  begin
    MainOutMessage('Walk nil PEnvir');
    exit;
  end;
  try
    nCheckCode := 1;
    bo1D := m_PEnvir.GetMapCellInfo(m_nCurrX, m_nCurrY, MapCellInfo);
    GateObj := nil;
    Event := nil;
    nCheckCode := 2;
    if bo1D and (MapCellInfo <> nil) and (MapCellInfo.ObjList <> nil) then
    begin
      for I := MapCellInfo.ObjList.Count - 1 downto 0 do
      begin
        OSObject := MapCellInfo.ObjList.Items[i];
        if OSObject.btType = OS_GATEOBJECT then
        begin
          GateObj := pTGateObj(OSObject.CellObj);
        end;
        if OSObject.btType = OS_EVENTOBJECT then
        begin
          if TEvent(OSObject.CellObj).m_OwnBaseObject <> nil then
            Event := TEvent(OSObject.CellObj);
        end;
        if OSObject.btType = OS_MAPEVENT then
        begin

        end;
        if OSObject.btType = OS_DOOR then
        begin

        end;
        if OSObject.btType = OS_ROON then
        begin

        end;
      end;
    end;
    nCheckCode := 3;
    if Event <> nil then
    begin
      if Event.m_OwnBaseObject.IsProperTarget(Self) then    //FFF4
        SendMsg(Event.m_OwnBaseObject, RM_MAGSTRUCK_MINE, 0, Event.m_nDamage, 0, 0, '');
    end;
    nCheckCode := 4;
    if Result and (GateObj <> nil) then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if m_PEnvir.ArroundDoorOpened(m_nCurrX, m_nCurrY) and (not
          (Tplayobject(self).m_boArrow)) then
        begin                                               //夺宝中不能转换地图
          //004BA89E
          if (not TEnvirnoment(GateObj.DEnvir).m_boNEEDHOLE) or
            (g_EventManager.GetEvent(m_PEnvir, m_nCurrX, m_nCurrY, ET_DIGOUTZOMBI) <> nil)
            then
          begin
            if nServerIndex = TEnvirnoment(GateObj.DEnvir).nServerIndex then
            begin
              if not EnterAnotherMap(TEnvirnoment(GateObj.DEnvir), GateObj.nDMapX,
                GateObj.nDMapY) then
              begin
                Result := False;
              end;
            end
            else
            begin                                           //004BA914
              DisappearA();
              m_bo316 := True;
              PlayObject := TPlayObject(Self);
              PlayObject.m_sSwitchMapName := TEnvirnoment(GateObj.DEnvir).sMapName;
              PlayObject.m_nSwitchMapX := GateObj.nDMapX;
              PlayObject.m_nSwitchMapY := GateObj.nDMapY;
              PlayObject.m_boSwitchData := True;
              PlayObject.m_nServerIndex := TEnvirnoment(GateObj.DEnvir).nServerIndex;
              PlayObject.m_boEmergencyClose := True;
              PlayObject.m_boReconnection := True;
            end;
          end;
        end;
      end
      else
        Result := False;
    end
    else
    begin                                                   //004BA998
      nCheckCode := 5;
      if Result then
      begin
        nCheckCode := 6;
        SendRefMsg(nIdent, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
      end;
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg, [nCheckCode, m_sCharname, m_sMapName,
        m_nCurrX, m_nCurrY]));
      {MainOutMessage('[Exception] TBaseObject.Walk  CheckCode: ' + IntToStr(nCheckCode) + ' ' +
                    m_sCharname + ' ' +
                    m_sMapName + ' ' +
                    IntToStr(m_nCurrX) + ':' +
                    IntToStr(m_nCurrY));}
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

function TBaseObject.EnterAnotherMap(Envir: TEnvirnoment; nDMapX,
  nDMapY: Integer): Boolean;                                //004BAADC
var
  I                                                    : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OldEnvir                                             : TEnvirnoment;
  nOldX                                                : Integer;
  nOldY                                                : Integer;
  Castle                                               : TUserCastle;
resourcestring
  sExceptionMsg1                                         =
    '[Exception] TBaseObject::EnterAnotherMap -> MsgTargetList Clear';
  sExceptionMsg2                                         =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleItems Dispose';
  sExceptionMsg3                                         =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleItems Clear';
  sExceptionMsg4                                         =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleEvents Clear';
  sExceptionMsg5                                         =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleActors Dispose';
  sExceptionMsg6                                         =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleActors Clear';
  sExceptionMsg7                                         =
    '[Exception] TBaseObject::EnterAnotherMap';
begin
  Result := False;

  try
    if m_Abil.Level < Envir.nRequestLevel then
      exit;
    if (Envir.QuestNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
      TMerchant(Envir.QuestNPC).Click(TPlayObject(Self));
    if Envir.nNEEDSETONFlag >= 0 then
    begin
      if GetQuestFalgStatus(Envir.nNEEDSETONFlag) <> Envir.nNeedONOFF then
        exit;
    end;
    if not Envir.GetMapCellInfo(nDMapX, nDMapY, MapCellInfo) then
      exit;
    Castle := g_CastleManager.IsCastlePalaceEnvir(Envir);
    if (Castle <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
    begin
      if not Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then
        exit;
    end;
    {
    if (UserCastle.m_MapPalace = Envir) and (m_btRaceServer = RC_PLAYOBJECT) then begin
      if not UserCastle.CheckInPalace(m_nCurrX,m_nCurrY,Self) then exit;
    end;
    }
    OldEnvir := m_PEnvir;
    nOldX := m_nCurrX;
    nOldY := m_nCurrY;
    DisappearA();
    try
      m_VisibleHumanList.Clear;
    except
      MainOutMessage(sExceptionMsg1);
    end;
    try
      for I := 0 to m_VisibleItems.Count - 1 do
      begin
        Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
      end;
    except
      MainOutMessage(sExceptionMsg2);
    end;
    try
      m_VisibleItems.Clear;
    except
      MainOutMessage(sExceptionMsg3);
    end;

    try
      m_VisibleEvents.Clear;
    except
      MainOutMessage(sExceptionMsg4);
    end;
    try
      for I := 0 to m_VisibleActors.Count - 1 do
      begin
        Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
      end;
    except
      MainOutMessage(sExceptionMsg5);
    end;
    try
      m_VisibleActors.Clear;
    except
      MainOutMessage(sExceptionMsg6);
    end;
    SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
    m_PEnvir := Envir;
    m_sMapName := Envir.sMapName;
    m_nCurrX := nDMapX;
    m_nCurrY := nDMapY;
    SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, Envir.sMapName);
    if AddToMap() then
    begin
      m_dwMapMoveTick := GetTickCount();
      m_bo316 := True;
      Result := True;
    end
    else
    begin
      m_PEnvir := OldEnvir;
      m_nCurrX := nOldX;
      m_nCurrY := nOldY;
      m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
    end;
    if m_btRaceServer = RC_PLAYOBJECT then
    begin                                                   //复位泡点，及金币，时间
      TPlayObject(Self).m_dwIncGamePointTick := GetTickCount();
      TPlayObject(Self).m_dwIncGameGoldTick := GetTickCount();
      TPlayObject(Self).m_dwAutoGetExpTick := GetTickCount();
    end;

    if m_PEnvir.m_boFight3Zone and (m_PEnvir.m_boFight3Zone <> OldEnvir.m_boFight3Zone)
      then
      RefShowName();
  except
    MainOutMessage(sExceptionMsg7);
  end;
end;

procedure TBaseObject.TurnTo(nDir: integer);                //004BB048
begin
  m_btDirection := nDir;
  SendRefMsg(RM_TURN, nDir, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TBaseObject.ProcessSayMsg(sMsg: string);          //004BB084
var
  sCharName                                            : string;
begin
  if m_btRaceServer = RC_PLAYOBJECT then
    sCharName := m_sCharName
  else
    sCharName := FilterShowName(m_sCharName);
  SendRefMsg(RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor, 0, sCharName
    + ':' + sMsg);
end;

procedure TBaseObject.SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType);  //004BB124
var
  m_DefMsg                                             : TDefaultMessage;
begin
  if g_Config.boShowPreFixMsg then
  begin
    case MsgType of
      t_Mon: sMsg := g_Config.sMonSayMsgpreFix + sMsg;
      t_Hint: sMsg := g_Config.sHintMsgPreFix + sMsg;
      {
      s_GroupMsg: sMsg:=g_Config.sGroupMsgPreFix + sMsg;
      s_GuildMsg: sMsg:=g_Config.sGuildMsgPreFix + sMsg;
      }
      t_GM: sMsg := g_Config.sGMRedMsgpreFix + sMsg;
      t_System: sMsg := g_Config.sSysMsgPreFix + sMsg;
      t_Notice: sMsg := g_Config.sLineNoticePreFix + sMsg;
      t_Cust: sMsg := g_Config.sCustMsgpreFix + sMsg;
      t_Castle: sMsg := g_Config.sCastleMsgpreFix + sMsg;
      t_hSystem: sMsg := g_Config.sSysMsgPreFix + sMsg;
      t_rSystem: sMsg := g_Config.sSysMsgPreFix + sMsg;
      t_tSystem: sMsg := g_Config.sSysMsgPreFix + sMsg;
    end;
  end;
  {
  case MsgColor of
    c_Green: SendMsg(Self,RM_SYSMESSAGE2,0,0,0,0,sMsg);
    c_Blue: SendMsg(Self,RM_SYSMESSAGE3,0,0,0,0,sMsg);
    else SendMsg(Self,RM_SYSMESSAGE,0,0,0,0,sMsg);
  end;
  }
  if MsgType = t_topSystem then
  begin
    case MsgColor of
      c_Green: SendMsg(self, rm_8942, 0, g_Config.btGreenMsgBColor, 0, 1, sMsg);
      c_Blue: SendMsg(self, rm_8942, 0, g_Config.btBlueMsgBColor, 0, 1, sMsg);
      c_fengs: SendMsg(self, rm_8942, 0, g_Config.btRedMsgBColor, 0, 1, sMsg);
      c_Red: SendMsg(self, rm_8942, 0, g_Config.btredMsgBColor, 0, 1, sMsg);
      c_Yellow: SendMsg(self, rm_8942, 0, g_Config.btYellowMsgBColor, 0, 1, sMsg);
    else

      SendMsg(self, rm_8942, 0, g_Config.btRedMsgBColor, 0, 1, sMsg);
    end;
    exit;                                                   //  g_Config.btRedMsgFColor
  end;
  if MsgType = t_hSystem then
  begin
    SendMsg(self, rm_8941, 0, g_Config.btRedMsgBColor, 0, 1, sMsg);
    exit;                                                   //  g_Config.btRedMsgFColor
  end;
  if MsgType = t_rSystem then
  begin
    SendMsg(self, rm_8941, 0, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor, 512,
      sMsg);
    exit;
  end;
  if MsgType = t_tSystem then
  begin
    SendMsg(self, rm_8941, 0, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor, 256,
      sMsg);
    exit;
  end;
  case MsgColor of
    c_Green: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btGreenMsgFColor,
      g_Config.btGreenMsgBColor, 0, sMsg);
    c_Blue: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btBlueMsgFColor,
      g_Config.btBlueMsgBColor, 0, sMsg);
    c_fengs: SendMsg(Self, RM_SYSMESSAGE, 0, $FF, $FD, 0, sMsg);
  else
    begin

      //  SendMsg(Self,RM_SYSMESSAGE,0,g_Config.btRedMsgFColor,g_Config.btRedMsgBColor,0,sMsg);
      if MsgType = t_Cust then
      begin
        SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btCustMsgFColor,
          g_Config.btCustMsgBColor, 0, sMsg);
      end
      else
      begin
        SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btRedMsgFColor, g_Config.btRedMsgBColor,
          0, sMsg);
      end;
    end;
  end;
end;

procedure TBaseObject.MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus:
  TMonStatus);
var
  I                                                    : Integer;
  nMsgColor                                            : Integer;
  sMsg                                                 : string;
  MonSayMsg                                            : pTMonSayMsg;
  sAttackName                                          : string;
begin
  if m_SayMsgList = nil then
    exit;
  if (m_btRaceServer = RC_PLAYOBJECT) then
    exit;
  if (AttackBaseObject <> nil) then
  begin
    if (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT) and
      (AttackBaseObject.m_btRaceServer <> 209) then
    begin //   and (AttackBaseObject.m_Master = nil)
      exit;                                                 //宝宝也能说话
    end;
    if AttackBaseObject.m_Master <> nil then
      sAttackName := AttackBaseObject.m_Master.m_sCharName
    else
      sAttackName := AttackBaseObject.m_sCharName;
  end;
  for I := 0 to m_SayMsgList.Count - 1 do
  begin
    MonSayMsg := m_SayMsgList.Items[I];
    sMsg := AnsiReplaceText(MonSayMsg.sSayMsg, '%s', FilterShowName(m_sCharName));
    sMsg := AnsiReplaceText(sMsg, '%d', sAttackName);
    sMsg := AnsiReplaceText(sMsg, '%m', m_PEnvir.sMapDesc);
    if (MonSayMsg.State = MonStatus) and (Random(MonSayMsg.nRate) = 0) then
    begin
      if MonStatus = s_MonGen then
      begin
        UserEngine.SendBroadCastMsg(sMsg, t_Mon);
        break;
      end;
      if MonSayMsg.Color = c_White then
      begin
        ProcessSayMsg(sMsg);
      end
      else
      begin
        AttackBaseObject.SysMsg(sMsg, MonSayMsg.Color, t_Mon);
      end;
      break;
    end;
  end;
end;

procedure TBaseObject.SendGroupText(sMsg: string);          //004BB1CC
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
begin
  sMsg := g_Config.sGroupMsgPreFix + sMsg;
  if m_GroupOwner <> nil then
  begin
    for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
    begin
      PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      PlayObject.SendMsg(Self, RM_GROUPMESSAGE, 0, g_Config.btGroupMsgFColor,
        g_Config.btGroupMsgBColor, 0, sMsg);
    end;
  end;
end;

procedure TBaseObject.MakeGhost();                          //004BB300
var
  i                                                    : Integer;
begin
  m_boGhost := True;
  m_dwGhostTick := GetTickCount();
  for I := UserEngine.m_PetSellList.Count - 1 downto 0 do
  begin
    if TBaseObject(UserEngine.m_PetSellList[i]) = Self then
    begin
      UserEngine.m_PetSellList.Delete(i);
      Break;
    end;
  end;
  DisappearA();
end;

procedure TBaseObject.ApplyMeatQuality;                     //004BB32C
var
  I                                                    : Integer;
  StdItem                                              : pTStdItem;
  UserItem                                             : pTUseritem;
begin
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
    begin
      if StdItem.StdMode = 40 then
      begin
        UserItem.Dura := m_nMeatQuality;
      end;
    end;
  end;
end;

function TBaseObject.TakeBagItems(BaseObject: TBaseObject): Boolean; //004BB3B0
var
  UserItem                                             : pTUseritem;
  PlayObject                                           : TPlayObject;
begin
  Result := False;
  while (True) do
  begin
    if BaseObject.m_ItemList.Count <= 0 then
      break;
    UserItem := BaseObject.m_ItemList.Items[0];
    if not AddItemToBag(UserItem) then
      break;
    if Self is TPlayObject then
    begin
      PlayObject := TPlayObject(Self);
      PlayObject.SendAddItem(UserItem);
      Result := True;
    end;
    BaseObject.m_ItemList.Delete(0);
  end;
end;
{
procedure TBaseObject.ScatterBagItems(ItemOfCreat:TBaseObject); //004BB44C
var
   i, dropwide: integer;
   pu: PTUserItem;
   dellist: TStringList;
   boDropall: Boolean;
begin
   dellist := nil;
   if m_boAngryRing or m_boNoDropItem then exit; //不死戒指

   boDropall := TRUE;
   if m_btRaceServer = RC_PLAYOBJECT then begin
      dropwide := 2;
      if PKLevel < 2 then boDropall := FALSE; //荤恩篮 1/3犬伏肺 冻焙促.
      //弧盎捞绰 促 冻焙促.
   end else
      dropwide := 3;

   try
      for i:=m_ItemList.Count-1 downto 0 do begin
         if (Random(3) = 0) or boDropall then begin
            if DropItemDown (pTUserItem(m_ItemList[i]), dropwide, TRUE,ItemOfCreat,Self) then begin
               pu := PTUserItem(m_ItemList[i]);
               if m_btRaceServer = RC_PLAYOBJECT then begin
                  if dellist = nil then dellist := TStringList.Create;
                  dellist.AddObject(UserEngine.GetStdItemName (pu.wIndex), TObject(pu.MakeIndex));
               end;
               Dispose(PTUserItem(m_ItemList[i]));
               m_ItemList.Delete (i);
            end;
         end;
      end;
      if dellist <> nil then begin
         SendMsg (self, RM_SENDDELITEMLIST, 0, integer(dellist), 0, 0, '');
      end;
   except
      MainOutMessage ('[Exception] TBaseObject.ScatterBagItems');
   end;
end;
}

procedure TBaseObject.ScatterBagItems(ItemOfCreat: TBaseObject); //004BB44C
var
  I, II, DropWide                                      : Integer;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
  boCanNotDrop                                         : Boolean;
  MonDrop                                              : pTMonDrop;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::ScatterBagItems';
begin
  DropWide := _min(g_Config.nDropItemRage, 7);              //3
  try
    g_MonDropLimitLIst.Lock;
    m_ItemList.lock;
    try
      for I := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList.Items[I];
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        boCanNotDrop := False;
        if StdItem <> nil then
        begin
          for II := 0 to g_MonDropLimitLIst.Count - 1 do
          begin
            if CompareText(StdItem.Name, g_MonDropLimitLIst.Strings[II]) = 0 then
            begin
              MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[II]);
              if MonDrop.nDropCount < MonDrop.nCountLimit then
              begin
                Inc(MonDrop.nDropCount);
                g_MonDropLimitLIst.Objects[II] := TObject(MonDrop);
              end
              else
              begin
                Inc(MonDrop.nNoDropCount);
                boCanNotDrop := True;
              end;
              break;
            end;
          end;
        end;
        if boCanNotDrop then
          Continue;

        if DropItemDown(UserItem, DropWide, True, ItemOfCreat, Self) then
        begin
          // if m_btRaceServer = RC_PLAYOBJECT then  Tplayobject(self).SendDelItems(UserItem); //2006418

          Dispose(UserItem);
          m_ItemList.Delete(I);
        end;
      end;
    finally
      m_ItemList.unlock;
      g_MonDropLimitLIst.UnLock;

    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

procedure TBaseObject.ScatterGolds(GoldOfCreat: TBaseObject); //004BB63C
var
  I, nGold                                             : integer;
begin
  if m_nGold > 0 then
  begin
    if (g_Config.GoldAddinBag = 1) and (GoldOfCreat <> nil) then
    begin
      GoldOfCreat.m_nGold := GoldOfCreat.m_nGold + m_nGold;
      GoldOfCreat.GoldChanged;
      exit;
    end;
    I := 0;
    while (True) do
    begin
      //      for i:=0 to 18 do begin
      if m_nGold > g_Config.nMonOneDropGoldCount then
      begin
        nGold := g_Config.nMonOneDropGoldCount;
        m_nGold := m_nGold - g_Config.nMonOneDropGoldCount;
      end
      else
      begin
        nGold := m_nGold;
        m_nGold := 0;
      end;
      if nGold > 0 then
      begin
        if not DropGoldDown(nGold, TRUE, GoldOfCreat, Self) then
        begin
          m_nGold := m_nGold + nGold;
          break;
        end;
      end
      else
        break;
      Inc(I);
      if I >= 224 then
        break;
    end;
    GoldChanged;
  end;
end;

procedure TBaseObject.DropUseItems(BaseObject: TBaseObject); //004BB6C8
var
  nC, nRate                                            : Integer;
  StdItem                                              : pTStdItem;
  DropItemList                                         : TStringList;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::DropUseItems';
begin
  DropItemList := nil;
  try
    if m_boNoDropUseItem then
      exit;
    if m_btRaceServer = RC_YSBJECT then Exit;
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      nC := 0;
      while (True) do
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[nC].wIndex);
        if StdItem <> nil then
        begin
          if ((StdItem.Reserved and 1) <> 0) or (not (StdItem.Reserved in [11, 12])) and
            (not GetBoValue(@m_UseItems[nC], m_UseItems[nC].wIndex, 16)) then
          begin
            if DropItemList = nil then
              DropItemList := TStringList.Create;
            DropItemList.AddObject('', TObject(m_UseItems[nC].MakeIndex));
            //004BB885
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('16' + #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                //UserEngine.GetStdItemName(m_UseItems[nC].wIndex) + #9 +
                StdItem.Name + #9 +
                IntToStr(m_UseItems[nC].MakeIndex) + #9 +
                BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                '0');
            m_UseItems[nC].wIndex := 0;
          end;
        end;
        Inc(nC);
        if nC >= 9 then
          break;
      end;
    end;
    if PKLevel > 2 then
      nRate := 15
    else
      nRate := 30;
    nC := 0;
    while (True) do
    begin
      if Random(nRate) = 0 then
      begin
        if DropItemDown(@m_UseItems[nC], 2, True, BaseObject, Self) then
        begin
          StdItem := UserEngine.GetStdItem(m_UseItems[nC].wIndex);
          if StdItem <> nil then
          begin
            if StdItem.Reserved and 10 = 0 then
            begin
              if m_btRaceServer = RC_PLAYOBJECT then
              begin
                if DropItemList = nil then
                  DropItemList := TStringList.Create;
                DropItemList.AddObject(UserEngine.GetStdItemName(m_UseItems[nC].wIndex),
                  TObject(m_UseItems[nC].MakeIndex));
                //  Tplayobject(self).SendDelItems(@m_UseItems[nC]); //2006418
              end;
              m_UseItems[nC].wIndex := 0;
            end;                                            //004BB9A9
          end;
        end;                                                //004BB9A9
      end;
      Inc(nC);
      if nC >= 9 then
        break;
    end;
    if DropItemList <> nil then
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DropItemList), 0, 0, '');
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

function TBaseObject.getmainplayer(BaseObject: TBaseObject): TBaseObject;
var
  hum                                                  : Tplayobject;
begin
  result := BaseObject;
  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
    (TplayObject(BaseObject).sYsnameMaster <> '') then
  begin                                                     //如果是元神
    // hum:=nil;
    // hum:=UserEngine.GetPlayObjectEx(TPlayObject(BaseObject).sYsnameMaster);
    hum := TPlayObject(BaseObject).ysmasterplayer;
    if hum <> nil then
      result := hum;
  end;
  if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (BaseObject.m_Master <> nil) then
  begin                                                     //如果是宝宝
    if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) and
      (TplayObject(BaseObject.m_Master).sYsnameMaster <> '') then
    begin                                                   //宝宝主人是元神
      // hum:=nil;
      // hum:=UserEngine.GetPlayObjectEx(TplayObject(BaseObject.m_Master).sYsnameMaster);
      hum := TplayObject(BaseObject.m_Master).ysmasterplayer;
      if hum <> nil then
        result := hum;

    end;
    if (BaseObject.m_Master.m_btRaceServer = RC_PLAYOBJECT) and
      (TplayObject(BaseObject.m_Master).sYsnameMaster = '') then
    begin                                                   //宝宝主人是人物
      result := BaseObject.m_Master;

    end;

  end;

end;

procedure TBaseObject.Die;                                  //004BBA98
var
  boPK, guildwarkill                                   : Boolean;
  tStr, kstring                                        : string;
  tExp                                                 : LongWord;
  i                                                    : Integer;
  GroupHuman, hum, myplayer                            : TPlayObject;
  QuestNPC                                             : TMerchant;
  tCheck                                               : Boolean;
  AttackBaseObject, chufaObject                        : TBaseObject;
  Castle                                               : TUserCastle;
  StdItem, horseitem                                   : pTStdItem;
  hashorse                                             : boolean;
  nhashousepai, id                                     : integer;
  function DelToList(SMon: string): Boolean;
  var
    sList                                              : TStringList;
    sFileName                                          : string;
    i                                                  : Integer;
  begin
    sList := TStringList.Create;
    sFileName := g_Config.sEnvirDir + '\MonLifeSpan.TXT';
    if FileExists(sFileName) then
      sList.LoadFromFile(sFileName);
    for i := 0 to sList.Count - 1 do
    begin
      if Pos(SMon, sList[i]) > 0 then
      begin
        sList.Delete(i);
        sList.SaveToFile(sFileName);
        Break;
      end;
    end;

  end;
resourcestring
  sExceptionMsg1                                         =
    '[Exception] TBaseObject::Die 1';
  sExceptionMsg2                                         =
    '[Exception] TBaseObject::Die 2';
  sExceptionMsg3                                         =
    '[Exception] TBaseObject::Die 3';
begin
  //004BBABB
  if m_boSuperMan then
    exit;
  if m_boSupermanItem then
    exit;

  m_boDeath := True;
  m_dwDeathTick := GetTickCount();

  if (Pos('爱情', m_sCharName) > 0) and (m_wAppr = 241) and (m_btRaceServer = 115) then
  begin
    tStr := Format('%s %s %s %d %d ', [m_sOldName, m_sCharName, m_PEnvir.sMapName,
      m_nCurrX, m_nCurrY]);
    DelToList(tStr);
  end;

  //  SendRefMsg(RM_MAGADDABILTY,0,$108,0,0, '');//
  if m_boPetOnSell then
  begin
    for I := UserEngine.m_PetSellList.Count - 1 downto 0 do
    begin
      if TBaseObject(UserEngine.m_PetSellList[i]) = Self then
      begin
        UserEngine.m_PetSellList.Delete(i);
        Break;
      end;
    end;
  end;
  if (m_Master <> nil) and (m_LastHiter <> nil) then
  begin                                                     //如果是宠物死掉
    if m_LastHiter.m_Master <> nil then
      kstring := m_LastHiter.m_Master.m_sCharName
    else
      kstring := m_LastHiter.m_sCharName;

    if (m_Master.m_btRaceServer = RC_PLAYOBJECT) and (Tplayobject(m_Master).sYsnameMaster
      <> '') then
    begin                                                   //告诉元神宝宝ID
      id := integer(self);
      // Tplayobject(self).SendDefMessage(38416,integer(self),0,0,0,encodebuffer(@id,4));

      Tplayobject(m_Master).SendDefMessage(38416, integer(self), 0, 0, 1,
        encodebuffer(@id, 4));
    end;
    if m_btRaceServer = 17 then                             //天玉公主类型
      Tplayobject(m_Master).SysMsg('(' + m_sCharName + ')已经被' + kstring +
        '杀死了，失败！！！', c_fengs, t_Hint)                // c_Blue
    else
      if m_btRaceServer <> 211 then                         //如果替身不提示
        Tplayobject(m_Master).SysMsg('你的宠物(' + m_sCharName + ')被' + kstring +
          '杀死了', c_fengs, t_Hint);                         // c_Blue

  end;

  if m_bohorse and (m_Master <> nil) then
  begin                                                     //如果马死了.
    nhashousepai := Tplayobject(m_Master).CheckHorsepos;
    Tplayobject(m_master).SendDelItems(@m_master.m_UseItems[nhashousepai]);
    m_master.m_UseItems[nhashousepai].wIndex := 0;
  end;                                                      //如果死的是马，那么马牌没有了
  if ((m_sCharName = '丛林豹') or (m_sCharName = '狮魔兽') or (m_sCharName = '震天狮') or
    (FilterShowName(m_sCharName) = '踏云豹')) and (m_Master <> nil) and (m_LastHiter <> nil)
    then
  begin                                                     //如果豹子死了
    Tplayobject(m_Master).relivemon(-1);
    Tplayobject(m_Master).M_monitemmake := 0;
    TPlayObject(m_Master).m_PetBaseObject := nil;

  end;

  if m_Master <> nil then
  begin
    m_ExpHitter := nil;
    m_LastHiter := nil;
  end;
  m_nIncSpell := 0;
  m_nIncHealth := 0;
  m_nIncHealing := 0;
  //004BBB30
  try

    //怪物被打死
    if (m_btRaceServer <> RC_PLAYOBJECT) and (m_LastHiter <> nil) then
    begin
      if g_Config.boMonSayMsg then
        MonsterSayMsg(m_LastHiter, s_Die);
      if m_PEnvir.sMapFucx <> '' then                       //地图触发 2009-12-21
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then
          g_ManageNPC.GotoLable(TPlayObject(m_lastHiter), m_PEnvir.sMapFucx, false);
      if (m_ExpHitter <> nil) then
      begin
        ////////
                // MapQuest 触发
        chufaObject := getmainplayer(m_ExpHitter);          //获取这个杀怪者，脚本触发者
        if m_PEnvir.IsCheapStuff and (chufaObject <> nil) and (chufaObject.m_btRaceServer
          = RC_PLAYOBJECT) then
        begin
          if chufaObject.m_GroupOwner <> nil then
          begin
            for i := 0 to chufaObject.m_GroupOwner.m_GroupMembers.Count - 1 do
            begin
              GroupHuman :=
                TPlayObject(chufaObject.m_GroupOwner.m_GroupMembers.Objects[i]);
              if not GroupHuman.m_boDeath and (chufaObject.m_PEnvir = GroupHuman.m_PEnvir)
                and (abs(chufaObject.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and
                (abs(chufaObject.m_nCurrX - GroupHuman.m_nCurrX) <= 12) and (chufaObject =
                GroupHuman) then
              begin
                tCheck := False;
              end
              else
              begin                                         //004BBCB3
                tCheck := True;
              end;                                          //004BBCB7
              QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(GroupHuman, m_sCharName, '',
                tCheck));
              if (QuestNPC <> nil) and tCheck then
              begin //如果队友就是杀怪者，会执行两次脚本

                QuestNPC.Click(GroupHuman);
              end;                                          //<>nil
            end;                                            //for
          end;                                              //m_GroupOwner<>nil
          QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(chufaObject, m_sCharName, '',
            False));
          if (QuestNPC <> nil) and (chufaObject.m_btRaceServer = RC_PLAYOBJECT) then
          begin
            QuestNPC.Click(TPlayObject(chufaObject));
          end; //这里执行任务脚本，如果怪物死掉。
        end;                                                //if m_PEnvir.IsCheapStuff

        /////////
        if m_ExpHitter.m_btRaceServer = RC_PLAYOBJECT then
        begin
          tExp := m_ExpHitter.CalcGetExp(m_Abil.Level, m_dwFightExp);
          if not g_Config.boVentureServer then
          begin
            TPlayObject(m_ExpHitter).GainExp(tExp);
          end;                                              //004BBBBF
          //杀死怪物触发
          if (m_btRaceServer <> RC_PLAYOBJECT) and (m_ExpHitter <> nil) and
            ((m_ExpHitter.m_btRaceServer = RC_PLAYOBJECT) or (m_ExpHitter.m_Master <> nil))
            then
          begin
            TPlayObject(m_ExpHitter).m_sParam[0] := Inttostr(tExp);
            if g_FunctionNPC <> nil then
              g_FunctionNPC.GotoLable(TplayObject(m_ExpHitter), '@杀怪触发', False);
          end;
          /// 魔魂术
          if TPlayObject(m_ExpHitter).m_Magic76skill <> nil then
          begin
            if Random(15) < TPlayObject(m_ExpHitter).m_Magic76skill.btLevel * 2 + 4 then
            begin

              TPlayObject(m_ExpHitter).SysMsg('本着对魔魂术的领悟，你获得' +
                inttostr(m_Abil.Level) + '点魔法值 ', c_Red, t_Hint);
              // inc(TPlayObject(m_ExpHitter).m_abil.mP,m_Abil.Level);
              TPlayObject(m_ExpHitter).m_WAbil.mP :=
                _MIN(TPlayObject(m_ExpHitter).m_WAbil.MaxMP,
                TPlayObject(m_ExpHitter).m_WAbil.MP + m_WAbil.Level);
              TPlayObject(m_ExpHitter).HealthSpellChanged;
              if (TPlayObject(m_ExpHitter).m_Magic76skill.btLevel < 3) then
              begin                                         // 魔魂术
                if
                  TPlayObject(m_ExpHitter).m_Magic76skill.MagicInfo.TrainLevel[TPlayObject(m_ExpHitter).m_Magic76skill.btLevel] <= TPlayObject(m_ExpHitter).m_Abil.Level then
                begin
                  TPlayObject(m_ExpHitter).TrainSkill(TPlayObject(m_ExpHitter).m_Magic76skill, Random(3) + 1);
                  if not
                    TPlayObject(m_ExpHitter).CheckMagicLevelup(TPlayObject(m_ExpHitter).m_Magic76skill) then
                  begin
                    TPlayObject(m_ExpHitter).SendDelayMsg(TPlayObject(m_ExpHitter),
                      RM_MAGIC_LVEXP, 0,
                      TPlayObject(m_ExpHitter).m_Magic76skill.MagicInfo.wMagicId,
                      TPlayObject(m_ExpHitter).m_Magic76skill.btLevel,
                      TPlayObject(m_ExpHitter).m_Magic76skill.nTranPoint, '', 1000);
                  end;
                end;
              end;

            end;
          end;

          ///
          //是否执行任务脚本   如果杀死了怪物
          if m_PEnvir.m_nQfunction > 0 then
          begin
            myplayer := TPlayObject(m_ExpHitter);
            if TPlayObject(m_ExpHitter).sYsnameMaster <> '' then
            begin
              //  hum:=nil;
              //  hum:=UserEngine.GetPlayObjectEx(TPlayObject(m_ExpHitter).sYsnameMaster);
              hum := TPlayObject(m_ExpHitter).ysmasterplayer;
              if hum <> nil then
                myplayer := hum;
            end;
            g_ManageNPC.GotoLable(myplayer, '@mapfunc' + inttostr(m_PEnvir.m_nQfunction),
              False);
          end;

          if m_PEnvir.m_skillmonlabel <> '' then
          begin

            if TPlayObject(m_ExpHitter).sYsnameMaster <> '' then
            begin                                           //元神主人触发
              // hum:=nil;
             //  hum:=UserEngine.GetPlayObjectEx(TPlayObject(m_ExpHitter).sYsnameMaster);
              hum := TPlayObject(m_ExpHitter).ysmasterplayer;
              if hum <> nil then
              begin
                g_ManageNPC.GotoLable(hum, m_PEnvir.m_skillmonlabel, False);
              end;
            end
            else
              g_ManageNPC.GotoLable(TPlayObject(m_ExpHitter), m_PEnvir.m_skillmonlabel,
                False);
          end;

        end
        else
        begin
          ;                                                 //004BBD5B
          if m_ExpHitter.m_Master <> nil then
          begin
            if m_ExpHitter.m_btRaceServer <> RC_YSBJECT then //原神不升级
              m_ExpHitter.GainSlaveExp(m_Abil.Level);       //宝宝获得经验

            tExp := m_ExpHitter.m_Master.CalcGetExp(m_Abil.Level, m_dwFightExp);
            if not g_Config.boVentureServer then
            begin
              TPlayObject(m_ExpHitter.m_Master).GainExp(tExp);
              if (m_ExpHitter.m_Master.m_btRaceServer = RC_YSBJECT) and
                (m_ExpHitter.m_Master.m_Master <> nil) then
                TPlayObject(m_ExpHitter.m_Master.m_Master).GainExp(tExp);  //原神宝宝杀怪经验加自己身上
              //是否执行地图触发    //宝宝杀了怪物
              if m_PEnvir.m_nQfunction > 0 then
              begin
                myplayer := TPlayObject(m_ExpHitter.m_Master);
                if myplayer.sYsnameMaster <> '' then
                begin
                  //hum:=nil;
                  //hum:=UserEngine.GetPlayObjectEx(TPlayObject(m_ExpHitter.m_Master).sYsnameMaster);
                  hum := TPlayObject(m_ExpHitter.m_Master).ysmasterplayer;
                  if hum <> nil then
                    myplayer := hum;
                end;
                g_ManageNPC.GotoLable(myplayer, '@mapfunc' +
                  inttostr(m_PEnvir.m_nQfunction), False);
              end;

              if m_PEnvir.m_skillmonlabel <> '' then
              begin
                if TPlayObject(m_ExpHitter.m_Master).sYsnameMaster <> '' then
                begin
                  // g_ManageNPC.GotoLable(TPlayObject(m_ExpHitter.m_Master),m_PEnvir.m_skillmonlabel,False);
                      // hum:=nil;
                      // hum:=UserEngine.GetPlayObjectEx(TPlayObject(m_ExpHitter.m_Master).sYsnameMaster);
                  hum := TPlayObject(m_ExpHitter.m_Master).ysmasterplayer;
                  if hum <> nil then
                  begin
                    g_ManageNPC.GotoLable(hum, m_PEnvir.m_skillmonlabel, False);
                  end;
                end
                else
                  g_ManageNPC.GotoLable(TPlayObject(m_ExpHitter.m_Master),
                    m_PEnvir.m_skillmonlabel, False);

              end;
              if m_ExpHitter.m_Master.m_btRaceServer = RC_PLAYOBJECT then
                if g_FunctionNPC <> nil then
                  g_FunctionNPC.GotoLable(TplayObject(m_ExpHitter.m_Master), '@杀怪触发',
                  False);

              ////这里执行地图触发

            end;
          end;
        end;
      end
      else
      begin                                                 //004BBDD2
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then
        begin
          tExp := m_LastHiter.CalcGetExp(m_Abil.Level, m_dwFightExp);
          if not g_Config.boVentureServer then
          begin
            TPlayObject(m_LastHiter).GainExp(tExp);
          end;
          //杀死怪物触发
          if (m_btRaceServer <> RC_PLAYOBJECT) and (m_LastHiter <> nil) and
            ((m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or (m_LastHiter.m_Master <> nil))
            then
          begin
            TPlayObject(m_LastHiter).m_sParam[0] := Inttostr(tExp);
            if g_FunctionNPC <> nil then
              g_FunctionNPC.GotoLable(TplayObject(m_lastHiter), '@杀怪触发', False);
          end;

        end;
      end;
    end;
    if (g_Config.boMonSayMsg) and (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <>
      nil) then
    begin
      m_LastHiter.MonsterSayMsg(Self, s_KillHuman);
    end;

  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg1);
      MainOutMessage(E.Message);
      raise;
    end;

  end;
  try
    boPK := False;
    if (not g_Config.boVentureServer) and (not m_PEnvir.m_boFightZone) and (not
      m_PEnvir.m_boFight3Zone) then
    begin
      if (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) and (PKLevel < 2) then
      begin
        //            if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then
        if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or (m_LastHiter.m_btRaceServer =
          RC_NPC) then
          {修改日期2004/07/21，允许NPC杀死人物}

          boPK := True;
        if m_LastHiter.m_Master <> nil then
          if m_LastHiter.m_Master.m_btRaceServer = RC_PLAYOBJECT then
          begin
            m_LastHiter := m_LastHiter.m_Master;
            boPK := True;
          end;
      end;
    end;

    if boPK and (m_LastHiter <> nil) then
    begin
      guildwarkill := FALSE;
      if (m_MyGuild <> nil) and (m_LastHiter.m_MyGuild <> nil) then
      begin

        if GetGuildRelation(self, m_LastHiter) = 2 then
          guildwarkill := TRUE;
      end;
      Castle := g_CastleManager.InCastleWarArea(Self);
      if ((Castle <> nil) and Castle.m_boUnderWar) or (m_boInFreePKArea) then
        guildwarkill := TRUE;

      if not guildwarkill then
      begin
        if (g_Config.boKillHumanWinLevel or g_Config.boKillHumanWinExp or
          m_PEnvir.m_boPKWINLEVEL or m_PEnvir.m_boPKWINEXP) and (m_LastHiter.m_btRaceServer
          = RC_PLAYOBJECT) then
        begin
          TPlayObject(Self).PKDie(TPlayObject(m_LastHiter));
        end
        else
        begin
          if not m_LastHiter.IsGoodKilling(self) then
          begin
            m_LastHiter.IncPkPoint(g_Config.nKillHumanAddPKPoint {100});
            m_LastHiter.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
            SysMsg(format(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint);

            m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
            if PkLevel < 1 then
              if Random(5) = 0 then
                m_LastHiter.MakeWeaponUnlock;
          end
          else
            m_LastHiter.SysMsg(g_sYouProtectedByLawOfDefense {'[你受到正当规则保护。]'},
              c_Green, t_Hint);
        end;
        //检查攻击人是否用了着经验或等级装备
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then
        begin
          if m_LastHiter.m_dwPKDieLostExp > 0 then
          begin
            if m_Abil.Exp >= m_LastHiter.m_dwPKDieLostExp then
            begin
              Dec(m_Abil.Exp, m_LastHiter.m_dwPKDieLostExp);
            end
            else
              m_Abil.Exp := 0;
          end;
          if m_LastHiter.m_nPKDieLostLevel > 0 then
          begin
            if m_Abil.Level >= m_LastHiter.m_nPKDieLostLevel then
            begin
              Dec(m_Abil.Level, m_LastHiter.m_nPKDieLostLevel);
            end
            else
              m_Abil.Level := 0;
          end;
        end;

      end;

      //=================================================================
    end;
  except
    MainOutMessage(sExceptionMsg2);
  end;
  //   如果死的是人  马牌处理
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    hashorse := false;
    for i := m_SlaveList.Count - 1 downto 0 do
    begin
      if TBaseObject(m_SlaveList.Items[i]).m_bohorse then
      begin
        hashorse := true;
        break;
      end;
    end;
    if m_boOnHorse or hashorse then
    begin
      nhashousepai := Tplayobject(self).CheckHorsepos;
      //马牌消失
 //  m_UseItems[nhashousepai].Dura:=0;
      Tplayobject(self).SendDelItems(@m_UseItems[nhashousepai]);
      m_UseItems[nhashousepai].wIndex := 0;
    end;
    if g_FunctionNPC <> nil then
      g_FunctionNPC.GotoLable(TPlayObject(Self), '@死亡触发', False);
    if (PKLevel >= 2) then
    begin
      g_FunctionNPC.GotoLable(TPlayObject(Self), '@红名被杀', False);
      if (m_LastHiter <> nil) and (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then
        g_FunctionNPC.GotoLable(TPlayObject(m_LastHiter), '@杀死红名', False);
    end;
    g_FunctionNPC.GotoLable(TPlayObject(Self), '@被人谋杀', False);
    if (m_LastHiter <> nil) and (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then
      g_FunctionNPC.GotoLable(TPlayObject(m_LastHiter), '@谋杀他人', False);
  end;

  //
  try
    if (not m_PEnvir.m_boFightZone) and                     //004BC0C1
    (not m_PEnvir.m_boFight3Zone) and
      (not m_boAnimal) then
    begin
      AttackBaseObject := m_ExpHitter;
      //  AttackBaseObject:=m_LastHiter;
      if (m_ExpHitter <> nil) and (m_ExpHitter.m_Master <> nil) then
      begin
        AttackBaseObject := m_ExpHitter.m_Master;
      end;
      //  if  AttackBaseObject=nil then AttackBaseObject:=m_LastHiter;
      if (m_btRaceServer <> RC_PLAYOBJECT) and (m_btRaceServer <> RC_YSBJECT) then
      begin
        if m_btRaceServer <> RC_EVILOBJECT then             //心魔不调身上物品
          DropUseItems(AttackBaseObject);                   //怪物暴身上物品
        if (m_Master = nil) and (not m_boNoItem) then
          ScatterBagItems(AttackBaseObject);                //怪物背包
        if (m_btRaceServer >= RC_ANIMAL) and (m_Master = nil) and (not m_boNoItem) then
          ScatterGolds(AttackBaseObject);
      end
      else
      begin                                                 //004BC1B0
        if not m_boNoItem then
        begin {修改日期2004/07/21，增加此行，允许设置 m_boNoItem 后人物死亡不掉物品}
          if AttackBaseObject <> nil then
          begin
            if (g_Config.boKillByHumanDropUseItem and (AttackBaseObject.m_btRaceServer =
              RC_PLAYOBJECT)) or (g_Config.boKillByMonstDropUseItem and
              (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT)) then
              DropUseItems(nil);                            //身上物品
          end
          else
          begin
            DropUseItems(nil);
          end;
          if g_Config.boDieScatterBag then
            ScatterBagItems(nil);                           //背包物品
          if g_Config.boDieDropGold then
            ScatterGolds(nil);
        end;
        AddBodyLuck(-(50 - (50 - m_Abil.Level * 5)));
      end;                                                  //004BC211
    end;

    if m_PEnvir.m_boFight3Zone then
    begin
      Inc(m_nFightZoneDieCount);
      if m_MyGuild <> nil then
      begin
        TGuild(m_MyGuild).TeamFightWhoDead(m_sCharName);
      end;

      if (m_LastHiter <> nil) then
      begin
        if (m_LastHiter.m_MyGuild <> nil) and (m_MyGuild <> nil) then
        begin
          TGuild(m_LastHiter.m_MyGuild).TeamFightWhoWinPoint(m_LastHiter.m_sCharName,
            100); //matchpoint 刘啊, 俺牢己利 扁废
          tStr := TGuild(m_LastHiter.m_MyGuild).sGuildName + ':' +
            IntToStr(TGuild(m_LastHiter.m_MyGuild).nContestPoint) + '  ' +
            TGuild(m_MyGuild).sGuildName + ':' +
            IntToStr(TGuild(m_MyGuild).nContestPoint);
          UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
            g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '- ' + tStr);
        end;
      end;
    end;

    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      //Jacky 2004/09/05
      //人物死亡立即退组，以防止组队刷经验
      if m_GroupOwner <> nil then
        m_GroupOwner.DelMember(Self);

      if m_LastHiter <> nil then
      begin
        if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then
          tStr := m_LastHiter.m_sCharName
        else
          tStr := '#' + m_LastHiter.m_sCharName;
      end
      else
        tStr := '####';
      //004BC523
      AddGameDataLog('19' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        'FZ-' + BoolToIntStr(m_PEnvir.m_boFightZone) +
        '_F3-' + BoolToIntStr(m_PEnvir.m_boFight3Zone) + #9 +
        '0' + #9 +
        '1' + #9 +
        tStr);
    end;
    //减少地图上怪物计数
    if (m_Master = nil) and (not m_boDelFormMaped) then
    begin
      m_PEnvir.DelObjectCount(Self);
      m_boDelFormMaped := True;
    end;

    ////////  如果是被怪物杀死
    if (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) and
      (m_LastHiter.m_btRaceServer <> RC_PLAYOBJECT) then
    begin

      if m_PEnvir.m_skillbymonlabel <> '' then
      begin                                                 //地图有被怪物杀死触发
        g_ManageNPC.GotoLable(TPlayObject(self), m_PEnvir.m_skillbymonlabel, False);
      end;

    end;
    ////   如果是被人杀死
    if (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) and
      (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then
    begin
      if m_PEnvir.m_skillhumlabel <> '' then
      begin                                                 //地图有杀人触发
        g_ManageNPC.GotoLable(TPlayObject(m_LastHiter), m_PEnvir.m_skillhumlabel, False);
      end;

      if m_PEnvir.m_skillbyhumlabel <> '' then
      begin                                                 //地图有被人杀死触发
        g_ManageNPC.GotoLable(TPlayObject(self), m_PEnvir.m_skillbyhumlabel, False);
      end;
    end;
    if (m_LastHiter <> nil) and (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then
    begin
      TPlayObject(m_LastHiter).m_sLastKillMon := m_sCharName;

      TPlayObject(m_LastHiter).m_sLastKillDate := DateToStr(Now);
      TPlayObject(m_LastHiter).m_sKILLMONMAP := m_PEnvir.sMapDesc;
      m_sKILLERNAME := m_LastHiter.m_sCharName;
      if m_btRaceServer <> RC_PLAYOBJECT then
        TPlayObject(m_LastHiter).m_sKILLMONNAME := m_sCharName
      else
        TPlayObject(m_LastHiter).m_sKILLHUMNAME := m_sCharName
    end;
    ////
    SendRefMsg(RM_DEATH, m_btDirection, m_nCurrX, m_nCurrY, 1, '');
  except
    MainOutMessage(sExceptionMsg3);
  end;
end;

procedure TPlayObject.PKDie(PlayObject: TPlayObject);
var
  nWinLevel, nLostLevel, nWinExp, nLostExp             : Integer;
  boWinLEvel, boLostLevel, boWinExp, boLostExp         : Boolean;
  StdItem, horseitem                                   : pTStdItem;
  hashorse                                             : boolean;
  nhashousepai, i                                      : integer;
begin
  nWinLevel := g_Config.nKillHumanWinLevel;
  nLostLevel := g_Config.nKilledLostLevel;
  nWinExp := g_Config.nKillHumanWinExp;
  nLostExp := g_Config.nKillHumanLostExp;

  boWinLEvel := g_Config.boKillHumanWinLevel;
  boLostLevel := g_Config.boKilledLostLevel;
  boWinExp := g_Config.boKillHumanWinExp;
  boLostExp := g_Config.boKilledLostExp;

  if m_PEnvir.m_boPKWINLEVEL then
  begin
    boWinLEvel := True;
    nWinLevel := m_PEnvir.m_nPKWINLEVEL;
  end;
  if m_PEnvir.m_boPKLOSTLEVEL then
  begin
    boLostLevel := True;
    nLostLevel := m_PEnvir.m_nPKLOSTLEVEL;
  end;
  if m_PEnvir.m_boPKWINEXP then
  begin
    boWinExp := True;
    nWinExp := m_PEnvir.m_nPKWINEXP;
  end;
  if m_PEnvir.m_boPKLOSTEXP then
  begin
    boLostExp := True;
    nLostExp := m_PEnvir.m_nPKLOSTEXP;
  end;

  if PlayObject.m_Abil.Level - m_Abil.Level > g_Config.nHumanLevelDiffer then
  begin
    if not PlayObject.IsGoodKilling(self) then
    begin
      PlayObject.IncPkPoint(g_Config.nKillHumanAddPKPoint {100});
      PlayObject.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
      SysMsg(format(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red, t_Hint);  //你被杀害
      //马牌处理
      hashorse := false;
      for i := m_SlaveList.Count - 1 downto 0 do
      begin
        if TBaseObject(m_SlaveList.Items[i]).m_bohorse then
        begin
          hashorse := true;
          break;
        end;
      end;

      if m_boOnHorse or hashorse then
      begin
        nhashousepai := CheckHorsepos;
        SendDelItems(@m_UseItems[nhashousepai]);
        //  m_UseItems[nhashousepai].Dura:=0;
        m_UseItems[nhashousepai].wIndex := 0;               //马牌消失
      end;

      //
      PlayObject.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
      if PkLevel < 1 then
        if Random(5) = 0 then
          PlayObject.MakeWeaponUnlock;
    end
    else
    begin
      PlayObject.SysMsg(g_sYouProtectedByLawOfDefense {'[你受到正当规则保护。]'},
        c_Green, t_Hint);
    end;
    exit;
  end;
  if boWinLEvel then
  begin
    //Inc(PlayObject.m_Abil.Level,nWinLevel);
    if PlayObject.m_Abil.Level + nWinLevel <= MAXUPLEVEL then
    begin
      Inc(PlayObject.m_Abil.Level, nWinLevel);
    end
    else
    begin
      PlayObject.m_Abil.Level := MAXUPLEVEL;
    end;
    PlayObject.HasLevelUp(PlayObject.m_Abil.Level - nWinLevel);

    if boLostLevel then
    begin
      if PKLevel >= 2 then
      begin
        if m_Abil.Level >= nLostLevel * 2 then
          Dec(m_Abil.Level, nLostLevel * 2);
      end
      else
      begin
        if m_Abil.Level >= nLostLevel then
          Dec(m_Abil.Level, nLostLevel);
      end;
    end;

  end;

  if boWinExp then
  begin
    PlayObject.WinExp(nWinExp);
    if boLostExp then
    begin
      if m_Abil.Exp >= LongWord(nLostExp) then
      begin
        if m_Abil.Exp >= LongWord(nLostExp) then
        begin
          Dec(m_Abil.Exp, LongWord(nLostExp));
        end
        else
        begin
          m_Abil.Exp := 0;
        end;
      end
      else
      begin
        if m_Abil.Level >= 1 then
        begin
          Dec(m_Abil.Level);
          Inc(m_Abil.Exp, GetLevelExp(m_Abil.Level));
          if m_Abil.Exp >= LongWord(nLostExp) then
          begin
            Dec(m_Abil.Exp, LongWord(nLostExp));
          end
          else
          begin
            m_Abil.Exp := 0;
          end;
        end
        else
        begin
          m_Abil.Level := 0;
          m_Abil.Exp := 0;
        end;
        //HasLevelUp(m_Abil.Level + 1);
      end;
    end;
  end;
end;

procedure TBaseObject.ReAlive;                              //004BC710
begin
  m_boDeath := False;
  SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TBaseObject.SetLastHiter(BaseObject: TBaseObject); //004BC74C
begin
  m_LastHiter := BaseObject;
  m_LastHiterTick := GetTickCount();
  if m_ExpHitter = nil then
  begin
    m_ExpHitter := BaseObject;
    m_ExpHitterTick := GetTickCount();
  end
  else
  begin
    if m_ExpHitter = BaseObject then
      m_ExpHitterTick := GetTickCount();
  end;
end;

procedure TBaseObject.SetPKFlag(BaseObject: TBaseObject);   //004BC7BC
begin
  if (m_btRaceServer = RC_YSBJECT) and (m_Master <> nil) then
  begin
    if m_Master = BaseObject then
      exit;
  end;
  if (m_btRaceServer = RC_PLAYOBJECT) and (TplayObject(self).sYsnameMaster =
    BaseObject.m_sCharName) then
  begin
    // if m_Master= BaseObject then
    exit;
  end;                                                      //元神不会认为主人是敌人

  if (PKLevel < 2) and
    (BaseObject.PKLevel < 2) and
    (not m_PEnvir.m_boFightZone) and
    (not m_PEnvir.m_boFight3Zone) and
    (not m_boPKFlag) then
  begin
    if (not (InSafeZone)) and (not (BaseObject.InSafeZone)) and (not
      (BaseObject.m_boArrow)) then
    begin                                                   //安全区不变色。
      BaseObject.m_dwPKTick := GetTickCount();
      if not BaseObject.m_boPKFlag then
      begin
        BaseObject.m_boPKFlag := True;
        BaseObject.RefNameColor();
      end;
    end;
  end;
end;

function TBaseObject.IsGoodKilling(cert: TBaseObject): Boolean; //004BC8D8
begin
  Result := False;
  if cert.m_boPKFlag then
    Result := True;
end;

//004C880C 0FFFF6

function TBaseObject.IsProtectTarget(BaseObject: TBaseObject): boolean;
begin
  Result := True;
  if BaseObject = nil then
    exit;
  if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (Tplayobject(BaseObject).m_boArrow)
    then
  begin
    result := true;
    exit;
  end; //如果在夺宝中，这个人物不被保护。
  if (InSafeZone) or (BaseObject.InSafeZone) then
    Result := False;
  if not BaseObject.m_boInFreePKArea then
  begin
    //新人保护
    if g_Config.boPKLevelProtect then
    begin
      if (m_Abil.Level > g_Config.nPKProtectLevel) then
      begin                                                 //如果大于指定等级
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level <=
          g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then
        begin
          //被攻击的人物小指定等级没有红名，则不可以攻击。
          Result := False;
          exit;
        end;
      end;
      if (m_Abil.Level <= g_Config.nPKProtectLevel) then
      begin                                                 //如果小于指定等级
        if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level >
          g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then
        begin
          Result := False;
          exit;
        end;
      end;

    end;

    {
    //大于指定级别的红名人物不可以杀指定级别未红名的人物。
    if (PKLevel >= 2) and (m_Abil.Level > 10) then begin
      if (BaseObject.m_Abil.Level <= 10) and (BaseObject.PKLevel < 2) then begin
        Result:=False;
        exit;
      end;
    end;

    //小于指定级别的非红名人物不可以杀指定级别红名人物。
    if (m_Abil.Level <= 10) and (PKLevel < 2) then begin
      if (BaseObject.PKLevel >= 2) and (BaseObject.m_Abil.Level > 10) then begin
        Result:=False;
        exit;
      end;
    end;
    }
    //大于指定级别的红名人物不可以杀指定级别未红名的人物。
    if (PKLevel >= 2) and (m_Abil.Level > g_Config.nRedPKProtectLevel) then
    begin
      if (BaseObject.m_Abil.Level <= g_Config.nRedPKProtectLevel) and (BaseObject.PKLevel
        < 2) then
      begin
        Result := False;
        exit;
      end;
    end;

    //小于指定级别的非红名人物不可以杀指定级别红名人物。
    if (m_Abil.Level <= g_Config.nRedPKProtectLevel) and (PKLevel < 2) then
    begin
      if (BaseObject.PKLevel >= 2) and (BaseObject.m_Abil.Level >
        g_Config.nRedPKProtectLevel) then
      begin
        Result := False;
        exit;
      end;
    end;

    if (GetTickCount - m_dwMapMoveTick < 3000) or (GetTickCount -
      BaseObject.m_dwMapMoveTick < 3000) then
      Result := False;
  end;
end;

function TBaseObject.IsAttackTarget(BaseObject: TBaseObject): boolean; //004C89D0 0FFFF5
  function sub_4C88E4(): Boolean;
  begin
    Result := True;
  end;
var
  I                                                    : Integer;
  splayname                                            : string;
  hum                                                  : Tplayobject;
  target                                               : TBaseObject;
  myPlayer                                             : TBaseObject;
begin
  Result := False;
  if (BaseObject = nil) or (BaseObject = Self) then
    exit;
  //  if (m_btRaceServer=RC_YSBJECT) and
  if (BaseObject.m_btRaceServer = RC_NPC {10}) or (BaseObject.m_btRaceServer = RC_PEACENPC
    {15}) then
    exit;                                                   //NPC 不攻击
  { if (BaseObject.m_btRaceServer =RC_PLAYOBJECT) then
   //元神灵珠模式下不攻击
   Begin
       if TPlayObject(BaseObject).sYsnameMaster<>'' then
          if  TPlayObject(BaseObject).m_btLingzhuMode=1 then exit;
   end;
  }
  if m_btRaceServer >= RC_ANIMAL {50} then
  begin
    if m_Master <> nil then
    begin
      if (m_Master.m_LastHiter = BaseObject) or
        (m_Master.m_ExpHitter = BaseObject) or
        (m_Master.m_TargetCret = BaseObject) then
        Result := True;
      if BaseObject.m_TargetCret <> nil then
      begin
        if (BaseObject.m_TargetCret = m_Master) or
          (BaseObject.m_TargetCret.m_Master = m_Master) and
          (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then
          Result := True;
      end;                                                  //004C8AB3
      if (BaseObject.m_TargetCret = Self) and (BaseObject.m_btRaceServer >= RC_ANIMAL)
        then
        Result := True;
      //004C8AD1
      if BaseObject.m_Master <> nil then
      begin
        if (BaseObject.m_Master = m_Master.m_LastHiter) or (BaseObject.m_Master =
          m_Master.m_TargetCret) then
          Result := True;
      end;                                                  //004C8B15
      if BaseObject.m_Master = m_Master then
        Result := False;
      if BaseObject.m_boHolySeize then
        Result := False;
      if m_Master.m_boSlaveRelax then
        Result := False;
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
      begin
        //if (m_Master.InSafeZone) or (BaseObject.InSafeZone) then begin
        if BaseObject.InSafeZone then
          Result := False;                                  //004C8B6B
      end;
      BreakCrazyMode();
    end
    else
    begin                                                   //004C8B79
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
        Result := True;
      if (m_btRaceServer > RC_PEACENPC {15}) and (m_btRaceServer < RC_ANIMAL {50}) then
        Result := True;
      if BaseObject.m_Master <> nil then
        Result := True;
    end;                                                    //004C8BB5
    if m_boCrazyMode then
      Result := True;
  end
  else
  begin                                                     //004C8BCE
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      case m_btAttatckMode of                               //
        HAM_ALL {0}:
          begin
            if (BaseObject.m_btRaceServer < RC_NPC {10}) or (BaseObject.m_btRaceServer >
              RC_PEACENPC {15}) then
              Result := True;
            if g_Config.boNonPKServer then
              Result := sub_4C88E4();
          end;
        HAM_PEACE {1}:
          begin
            if BaseObject.m_btRaceServer >= RC_ANIMAL then
              Result := True;
          end;
        HAM_DEAR:
          begin
            if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (m_btRaceServer =
              RC_PLAYOBJECT) then
            begin
              myPlayer := self;
              if Tplayobject(self).sYsnameMaster <> '' then
              begin                                         //如果我是元神
                //  splayname:= Tplayobject(BaseObject).sYsnameMaster;
                  //hum:=nil;
                 // hum:=UserEngine.GetPlayObjectEx(Tplayobject(self).sYsnameMaster);
                hum := Tplayobject(self).ysmasterplayer;
                if hum <> nil then
                  myPlayer := hum;

              end;
              target := BaseObject;
              if Tplayobject(BaseObject).sYsnameMaster <> '' then
              begin
                //  splayname:= Tplayobject(BaseObject).sYsnameMaster;
                 // hum:=nil;
                 // hum:=UserEngine.GetPlayObjectEx(Tplayobject(BaseObject).sYsnameMaster);
                hum := Tplayobject(BaseObject).ysmasterplayer;
                if hum <> nil then
                  target := hum;

              end;
              if target <> TPlayObject(myPlayer).m_DearHuman then
                Result := True;

            end
            else
            begin
              if BaseObject <> TPlayObject(Self).m_DearHuman then
              begin
                Result := True;
              end;
            end;
          end;
        HAM_MASTER:
          begin
            if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
            begin
              myPlayer := self;
              target := BaseObject;
              if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (m_btRaceServer =
                RC_PLAYOBJECT) then
              begin

                if Tplayobject(self).sYsnameMaster <> '' then
                begin                                       //如果我是元神
                  //  splayname:= Tplayobject(BaseObject).sYsnameMaster;
                  //  hum:=nil;
                  //  hum:=UserEngine.GetPlayObjectEx(Tplayobject(self).sYsnameMaster);
                  hum := Tplayobject(self).ysmasterplayer;
                  if hum <> nil then
                    myPlayer := hum;

                end;

                if Tplayobject(BaseObject).sYsnameMaster <> '' then
                begin
                  //  splayname:= Tplayobject(BaseObject).sYsnameMaster;
                   // hum:=nil;
                   // hum:=UserEngine.GetPlayObjectEx(Tplayobject(BaseObject).sYsnameMaster);
                  hum := Tplayobject(BaseObject).ysmasterplayer;
                  if hum <> nil then
                    target := hum;

                end;
              end;

              Result := True;
              if TPlayObject(myPlayer).m_boMaster then
              begin
                for I := 0 to TPlayObject(myPlayer).m_MasterList.Count - 1 do
                begin
                  if TPlayObject(myPlayer).m_MasterList.Items[I] = target then
                  begin
                    Result := False;
                    break;
                  end;
                end;
              end;
              if TPlayObject(target).m_boMaster then
              begin
                for I := 0 to TPlayObject(target).m_MasterList.Count - 1 do
                begin
                  if TPlayObject(target).m_MasterList.Items[I] = myPlayer then
                  begin
                    Result := False;
                    break;
                  end;
                end;
              end;
            end
            else
              Result := True;
          end;
        HAM_GROUP {2}:
          begin
            if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer >
              RC_PEACENPC) then
              Result := True;
            if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
              if IsGroupMember(BaseObject) then
                Result := False;
            if g_Config.boNonPKServer then
              Result := sub_4C88E4();
          end;
        HAM_GUILD {3}:
          begin
            if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer >
              RC_PEACENPC) then
              Result := True;
            splayname := BaseObject.m_sCharName;
            target := BaseObject;
            if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (m_btRaceServer =
              RC_PLAYOBJECT) then
            begin
              if Tplayobject(self).sYsnameMaster <> '' then
              begin
                //  splayname:= Tplayobject(BaseObject).sYsnameMaster;
                //  hum:=nil;
                //  hum:=UserEngine.GetPlayObjectEx(Tplayobject(self).sYsnameMaster);
                hum := Tplayobject(self).ysmasterplayer;
                if hum <> nil then
                  m_MyGuild := hum.m_MyGuild;

              end;

              if (TplayObject(BaseObject).sYsnameMaster <> '') then
              begin
                splayname := Tplayobject(BaseObject).sYsnameMaster;
                //  hum:=nil;
                //  hum:=UserEngine.GetPlayObjectEx(Tplayobject(splayname).sYsnameMaster);
                hum := TplayObject(BaseObject).ysmasterplayer; //这里有个抱错
                if hum <> nil then
                  target := hum;
              end;
            end;
            if m_MyGuild <> nil then
            begin

              if TGuild(m_MyGuild).IsMember(splayname) then
                Result := False;
              if m_boGuildWarArea and (target.m_MyGuild <> nil) then
              begin
                if TGuild(m_MyGuild).IsAllyGuild(TGuild(target.m_MyGuild)) then
                  Result := False;
              end;
            end;                                            //<>nil
            if g_Config.boNonPKServer then
              Result := sub_4C88E4();
          end;
        HAM_PKATTACK {4}:
          begin
            if (BaseObject.m_btRaceServer < RC_NPC) or (BaseObject.m_btRaceServer >
              RC_PEACENPC) then
              Result := True;
            if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
              if PKLevel >= 2 then
              begin
                if BaseObject.PKLevel < 2 then
                  Result := True
                else
                  Result := False;
              end
              else
              begin
                if BaseObject.PKLevel >= 2 then
                  Result := True
                else
                  Result := False;
              end;
            if g_Config.boNonPKServer then
              Result := sub_4C88E4();
          end;
      end;
    end
    else
      Result := True;
  end;                                                      //004C8DF0
  if BaseObject.m_boAdminMode or BaseObject.m_boStoneMode or BaseObject.m_boAttackMode
    then
    Result := False;
  if (m_Master <> nil) and (m_Master.m_btRaceServer = RC_YSBJECT) and ((m_Master =
    BaseObject) or ((m_Master.m_Master <> nil) and (m_Master.m_Master = BaseObject))) then
  begin
    Result := false;
  end;
  if (BaseObject.m_Master <> nil) and (m_btRaceServer = RC_YSBJECT) and
    (BaseObject.m_Master = self) then
    Result := false;

  if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
    (Tplayobject(BaseObject).sYsnameMaster = m_sCharName) and (Tplayobject(self).sYsname =
    Tplayobject(BaseObject).m_sCharName) then                 //如果是我的元神不攻击
    Result := false;

  if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
    (Tplayobject(self).sYsnameMaster = BaseObject.m_sCharName) and
    (Tplayobject(BaseObject).sYsname = Tplayobject(self).m_sCharName) then  //如果我是元神,不攻击主人
    Result := false;

  if (BaseObject.m_Master <> nil) and (m_btRaceServer = RC_PLAYOBJECT) and
    (Tplayobject(self).sYsnameMaster <> '') and (Tplayobject(self).sYsnameMaster =
    BaseObject.m_Master.m_sCharName) then                     //如果我是元神不攻击主人的宝宝
    Result := false;

  if (m_Master <> nil) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
    (Tplayobject(BaseObject).sYsnameMaster <> '') and (Tplayobject(BaseObject).sYsnameMaster
    = m_Master.m_sCharName) then //如果我主人的宝宝不攻击 主人的元神
    Result := false;

end;

function TBaseObject.IsProperTarget(BaseObject: TBaseObject): Boolean; //004C8E30 0FFFF4
var
  ncheckCode                                           : Integer;
begin
  try
    ncheckCode := 0;
    Result := IsAttackTarget(BaseObject);                   //0FFFF5
    ncheckCode := 1;
    if Result then
    begin
      ncheckCode := 2;
      if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject <> nil) and
        (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
      begin
        Result := IsProtectTarget(BaseObject);              //0FFFF6
      end;
      ncheckCode := 3;
    end;
    ncheckCode := 4;
    if (BaseObject <> nil) and
      (m_btRaceServer = RC_PLAYOBJECT) and
      (BaseObject.m_Master <> nil) and
      (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then
    begin
      ncheckCode := 5;
      if BaseObject.m_Master = Self then
      begin
        if m_btAttatckMode <> HAM_ALL {0} then
          Result := False;
      end
      else
      begin
        ncheckCode := 6;
        Result := IsAttackTarget(BaseObject.m_Master);
        ncheckCode := 7;
        if InSafeZone or BaseObject.InSafeZone then
          Result := False;
      end;
    end;
  except
    MainOutMessage('IsProperTarget Error ncheckCode=' + Inttostr(ncheckCode));

  end;
  {  if (BaseObject <> nil) and  (m_Master <> nil) and (m_Master.m_btRaceServer = RC_YSBJECT) and (m_Master.m_Master=BaseObject) then begin
     Result:=false;
    end;
  }

end;

procedure TBaseObject.WeightChanged;                        //004C49BC
begin
  m_WAbil.Weight := RecalcBagWeight();
  SendUpdateMsg(Self, RM_WEIGHTCHANGED, 0, 0, 0, 0, '');
end;

function TBaseObject.InSafeZone: Boolean;                   //004BEE20
var
  I, nSafePoint, nSafeX, nSafeY                        : Integer;
  sMapName                                             : string;
  ncheckCode                                           : Integer;
begin
  if m_PEnvir = nil then
    exit;
  ncheckCode := 0;
  Result := m_PEnvir.m_boSAFE;
  ncheckCode := 1;
  if Result then
    exit;
  ncheckCode := 2;
  try
    if (m_PEnvir.sMapName <> g_Config.sRedHomeMap) or
      (abs(m_nCurrX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
      (abs(m_nCurrY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then
    begin
      ncheckCode := 3;
      Result := False;
    end
    else
    begin                                                   //004BEE98
      Result := True;
    end;
  except

    MainOutMessage('InSafeZone Checkcode=' + inttostr(ncheckCode));

  end;

  ncheckCode := 4;
  if Result then
    exit;
  ncheckCode := 5;
  try
    try
      g_StartPointList.Lock;
      for I := 0 to g_StartPointList.Count - 1 do
      begin
        ncheckCode := 6 + i * 2;
        sMapName := g_StartPointList.Strings[i];
        nSafePoint := Integer(g_StartPointList.Objects[i]);
        nSafeX := LoWord(nSafePoint);
        nSafeY := HiWord(nSafePoint);
        if (sMapName = m_PEnvir.sMapName) and
          (abs(m_nCurrX - nSafeX) <= g_Config.nSafeZoneSize) and
          (abs(m_nCurrY - nSafeY) <= g_Config.nSafeZoneSize) then
        begin
          Result := True;
          break;
        end;
      end;
    except
      MainOutMessage('InSafeZone Checkcode=' + inttostr(ncheckCode));

    end;
  finally
    g_StartPointList.UnLock;
  end;
end;

function TBaseObject.InSafeZone(Envir: TEnvirnoment; nX,
  nY: Integer): Boolean;
var
  I, nSafePoint, nSafeX, nSafeY                        : Integer;
  sMapName                                             : string;
begin
  Result := Envir.m_boSAFE;
  if Result then
    exit;
  if (Envir.sMapName <> g_Config.sRedHomeMap) or
    (abs(nX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
    (abs(nY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then
  begin
    Result := False;
  end
  else
  begin                                                     //004BEE98
    Result := True;
  end;
  if Result then
    exit;
  try
    g_StartPointList.Lock;
    for I := 0 to g_StartPointList.Count - 1 do
    begin
      sMapName := g_StartPointList.Strings[i];
      nSafePoint := Integer(g_StartPointList.Objects[i]);
      nSafeX := LoWord(nSafePoint);
      nSafeY := HiWord(nSafePoint);
      if (sMapName = Envir.sMapName) and
        (abs(nX - nSafeX) <= g_Config.nSafeZoneSize) and
        (abs(nY - nSafeY) <= g_Config.nSafeZoneSize) then
      begin
        Result := True;
        break;
      end;
    end;
  finally
    g_StartPointList.UnLock;
  end;
end;

//004BDBBC

procedure TBaseObject.OpenHolySeizeMode(dwInterval: LongWord);
begin
  m_boHolySeize := True;
  m_dwHolySeizeTick := GetTickCount();
  m_dwHolySeizeInterval := dwInterval;
  RefNameColor();
end;
//004BDBF8

procedure TBaseObject.BreakHolySeizeMode;
begin
  m_boHolySeize := False;
  RefNameColor();
end;

procedure TBaseObject.OpenCrazyMode(nTime: Integer);        //004BDC14
begin
  m_boCrazyMode := True;
  m_dwCrazyModeTick := GetTickCount();
  m_dwCrazyModeInterval := nTime * 1000;
  RefNameColor();
end;

procedure TBaseObject.BreakCrazyMode;                       //004BDC54
begin
  if m_boCrazyMode then
  begin
    m_boCrazyMode := False;
    RefNameColor();
  end;
end;

procedure TBaseObject.LeaveGroup;                           //004C3B70
resourcestring
  sExitGropMsg                                         = '%s 已经退出了本组....';
begin
  SendGroupText(format(sExitGropMsg, [m_sCharName]));
  m_GroupOwner := nil;
  SendMsg(Self, RM_GROUPCANCEL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.SendQiYuanTreeItem(sPath: string);
var
  TreeItem                                             : array[0..149] of TQiYuanTree;
  i, ii                                                : Integer;
  sSendMsg                                             : string;
  pStdItem                                             : PTStdItem;
  sList                                                : TStringList;
  sName                                                : string;
  count                                                : array[0..3] of Integer;
begin
  sList := TStringList.Create;
  count[0] := 0;
  FillChar(TreeItem, 150 * Sizeof(TQiyuanTree), 0);
  try
    for I := 1 to 3 do
    begin
      count[i] := 0;
      sName := g_Config.sEnvirDir + sPath + 'BlessItem' + Inttostr(i) + '.txt';
      if FileExists(sName) then
      begin
        sList.LoadFromFile(sName);
        for ii := 0 to sList.Count - 1 do
        begin
          sName := Trim(sList[ii]);
          pStdItem := UserEngine.GetStdItem(sName);
          if pStdItem <> nil then
          begin
            TreeItem[count[0]].wLooks := pStdItem^.Looks;
            TreeItem[count[0]].sItemName := sName;
            Inc(Count[0]);
            Inc(Count[i]);
          end;
        end;
      end;
    end;
  finally
    sList.Free;
  end;

  if count[0] > 0 then
  begin
    m_DefMsg := MakeDefaultMsg(627,
      Integer(Self), 12, 0, 0);
    SendSocket(@m_DefMsg, '');
    sSendMsg := EncodeBuffer(@TreeItem, Count[0] * Sizeof(TQiyuanTree));
    m_DefMsg := MakeDefaultMsg(627,
      Integer(Self), 780, MakeWord(Count[1], Count[2]), Count[3]);
    SendSocket(@m_DefMsg, sSendMsg);

  end;

end;

function TPlayObject.CancelGroup: Boolean;                  //004C397C
resourcestring
  sCanceGrop                                           = '你的小组被解散了...';
begin
  Result := True;
  if m_GroupMembers.Count <= 1 then
  begin
    SendGroupText(sCanceGrop);
    m_GroupMembers.Clear;
    m_GroupOwner := nil;
    Result := False;
  end;
end;

procedure TPlayObject.SendGroupMembers;                     //004DCBA4
var
  I                                                    : Integer;
  PlayObject                                           : TPlayObject;
  sSendMsg                                             : string;
begin
  sSendMsg := '';
  for I := 0 to m_GroupMembers.Count - 1 do
  begin
    PlayObject := TPlayObject(m_GroupMembers.Objects[i]);
    sSendMsg := sSendMsg + PlayObject.m_sCharName + '/';
  end;
  for I := 0 to m_GroupMembers.Count - 1 do
  begin
    PlayObject := TPlayObject(m_GroupMembers.Objects[i]);
    PlayObject.SendDefMessage(SM_GROUPMEMBERS, 0, 0, 0, 0, sSendMsg);
  end;
end;

function TPlayObject.GetItemUnitIndex: Integer;
var
  pUnit_Item                                           : pTUnit_Item;
  i, j                                                 : Integer;
  StdItem, StdItem1                                    : pTStdItem;
  bohas                                                : Boolean;
begin
  Result := -1;
  for I := 0 to g_Item_UnitList.Count - 1 do
  begin
    pUnit_Item := pTUnit_Item(g_Item_UnitList.Objects[i]);
    bohas := true;
    for j := 0 to 13 do
    begin
      if pUnit_Item.ItemName[j] = '' then Continue;
      if m_UseItems[j].wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[j].wIndex);
        if (j >= 5) and (j <= 8) then
          Continue;
        if StdItem.Name <> pUnit_Item.ItemName[j] then
        begin
          bohas := False;
          Break;
        end;
      end;
    end;
    if bohas then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[U_ARMRINGL].wIndex);
      StdItem1 := UserEngine.GetStdItem(m_UseItems[U_ARMRINGR].wIndex);
      if pUnit_Item.ItemName[U_ARMRINGL] <> '' then
      begin
        if pUnit_Item.boTwoARMRING then
        begin
          if (StdItem = nil) or (StdItem1 = nil) or (StdItem.Name <>
            pUnit_Item.ItemName[U_ARMRINGL]) or (StdItem.Name <>
            pUnit_Item.ItemName[U_ARMRINGL]) then
            BoHas := False;
        end
        else
          if ((StdItem = nil) and (StdItem1 = nil)) or (StdItem.Name <>
            pUnit_Item.ItemName[U_ARMRINGL]) and (StdItem.Name <>
            pUnit_Item.ItemName[U_ARMRINGL]) then
            BoHas := False;
      end;
      if pUnit_Item.ItemName[U_RINGL] <> '' then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_RINGL].wIndex);
        StdItem1 := UserEngine.GetStdItem(m_UseItems[U_RINGR].wIndex);
        if pUnit_Item.boTwoARMRING then
        begin
          if (StdItem = nil) or (StdItem1 = nil) or (StdItem.Name <>
            pUnit_Item.ItemName[U_RINGL]) or (StdItem.Name <> pUnit_Item.ItemName[U_RINGL])
            then
            BoHas := False;
        end
        else
          if ((StdItem = nil) and (StdItem1 = nil)) or (StdItem.Name <>
            pUnit_Item.ItemName[U_RINGL]) and (StdItem.Name <> pUnit_Item.ItemName[U_RINGL])
            then
            BoHas := False;
      end;
    end;
    if bohas then
    begin
      Result := i;
      Break;
    end;
  end;

end;

function TPlayObject.GetMagicInfo(nMagicID: Integer): pTUserMagic; //004CBC7C
var
  I                                                    : Integer;
  UserMagic                                            : pTUserMagic;
begin
  Result := nil;
  for I := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[i];
    if UserMagic = nil then Continue;
    if UserMagic.MagicInfo.wMagicId = nMagicID then
    begin
      Result := UserMagic;
      break;
    end;
  end;
end;

function TPlayObject.GetSpellPoint(UserMagic: pTUserMagic): Integer; //004C6910
begin
  Result := ROUND(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv + 1) *
    (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefSpell;
end;

function TPlayObject.useDoMotaebo(UserMagic: pTUserMagic; nTargetX, nTargetY: Integer;
  BaseObject: TBaseObject): boolean;
var
  nSpellPoint                                          : integer;
begin                                                       //突斩
  Result := false;
  if (GetTickCount - m_dwDoMotaeboTick) > 3 * 1000 then
  begin
    m_dwDoMotaeboTick := GetTickCount();
    m_btDirection := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrx,
      m_TargetCret.m_nCurry);
    nSpellPoint := GetSpellPoint(UserMagic);
    if m_WAbil.MP >= nSpellPoint then
    begin
      if (nSpellPoint > 0) and (m_btRaceServer <> RC_YSBJECT) then
      begin
        if m_WAbil.MP < nSpellPoint then
          exit;
        DamageSpell(nSpellPoint);
        HealthSpellChanged();
      end;
      if (nSpellPoint > 0) and (m_btRaceServer = RC_YSBJECT) and (m_Master <> nil) then
      begin
        if m_Master.m_WAbil.MP < nSpellPoint then
          exit;
        m_Master.DamageSpell(nSpellPoint);
        m_Master.HealthSpellChanged();
      end;

      if DoMotaebo(m_btDirection, UserMagic.btLevel, 2) then
      begin
        Result := true;
        if UserMagic.btLevel < 3 then
        begin
          if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] < m_Abil.Level then
          begin
            TrainSkill(UserMagic, Random(3) + 1);
            if not CheckMagicLevelup(UserMagic) then
            begin

              SendDelayMsg(Self,
                RM_MAGIC_LVEXP,
                0,
                UserMagic.MagicInfo.wMagicId,
                UserMagic.btLevel,
                UserMagic.nTranPoint,
                '', 1000);
            end;
          end;
        end;
      end;
    end;
  end;                                                      //004CC1B5

end;

function TPlayObject.DoMotaebo(nDir: Byte; nMagicLevel: Integer; ntype: integer): Boolean;  ////004C3130
  function CanMotaebo(BaseObject: TBaseObject): Boolean;    //0x004C30B0
  var
    nC                                                 : Integer;
  begin
    Result := False;
    //   if  (m_Abil.Level > BaseObject.m_Abil.Level)
    //   and (not BaseObject.m_boStickMode) then begin
    if ((m_Abil.Level > BaseObject.m_Abil.Level) or ((m_Abil.Level =
      BaseObject.m_Abil.Level) and (m_nfenghaolevel > BaseObject.m_nfenghaolevel)))
      and (not BaseObject.m_boStickMode) then
    begin
      nC := m_Abil.Level - BaseObject.m_Abil.Level;
      if Random(20) < ((nMagicLevel * 4) + 6 + nC) then
      begin
        if IsProperTarget(BaseObject) then
          Result := True;
      end;
    end;
  end;
var
  bo35                                                 : Boolean;
  I, n20, n24, n28                                     : Integer;
  PoseCreate                                           : TBaseObject;
  BaseObject_30                                        : TBaseObject;
  BaseObject_34                                        : TBaseObject;
  nX, nY                                               : integer;
  nercode                                              : integer;
begin
  try
    Result := False;
    bo35 := True;
    m_btDirection := nDir;
    BaseObject_34 := nil;
    n24 := nMagicLevel + 1;
    n28 := n24;
    PoseCreate := GetPoseCreate();
    nercode := 0;
    if PoseCreate <> nil then
    begin
      for I := 0 to _MAX(2, nMagicLevel + 1) do
      begin
        PoseCreate := GetPoseCreate();
        if PoseCreate <> nil then
        begin
          n28 := 0;
          if not CanMotaebo(PoseCreate) then
            break;
          if nMagicLevel >= 3 then
          begin
            if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY)
              then
            begin
              BaseObject_30 := m_PEnvir.GetMovingObject(nX, nY, True);
              if (BaseObject_30 <> nil) and CanMotaebo(BaseObject_30) then
                BaseObject_30.CharPushed(m_btDirection, 1); //004C3237
              nercode := 1;
            end;                                            //004C323C
          end; //004C323C if nMagicLevel >= 3 then begin
          BaseObject_34 := PoseCreate;
          if PoseCreate.CharPushed(m_btDirection, 1) <> 1 then
            break;
          GetFrontPosition(nX, nY);                         //sub_004B2790
          nercode := 2;
          if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0
            then
          begin
            m_nCurrX := nX;
            m_nCurrY := nY;
            SendRefMsg(RM_RUSH, nDir, m_nCurrX, m_nCurrY, ntype, ''); //0
            bo35 := False;
            Result := True;
          end;
          Dec(n24);
        end; //004C32D7  if PoseCreate <> nil  then begin
      end; //004C32DD for i:=0 to _MAX(2,nMagicLevel + 1) do begin
    end
    else
    begin //004C32E8 if PoseCreate <> nil  then begin
      bo35 := False;
      for i := 0 to _MAX(2, nMagicLevel + 1) do
      begin
        GetFrontPosition(nX, nY);                           //sub_004B2790
        nercode := 3;
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False) > 0 then
        begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          SendRefMsg(RM_RUSH, nDir, m_nCurrX, m_nCurrY, ntype, '');
          Dec(n28);
        end
        else
        begin
          if m_PEnvir.CanWalk(nX, nY, True) then
            n28 := 0
          else
          begin
            bo35 := True;
            break;
          end;
        end;
      end;                                                  //004C33AD
    end;                                                    //004C33B3
    if (BaseObject_34 <> nil) then
    begin                                                   //004C33B3
      if n24 < 0 then
        n24 := 0;
      n20 := Random((n24 + 1) * 10) + ((n24 + 1) * 10);
      n20 := BaseObject_34.GetHitStruckDamage(Self, n20);
      n20 := n20 + ntype * n20;
      if ntype = 2 then //   如果是突站。攻击为数据库设置的数据
        n20 := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) -
          LoWord(m_WAbil.DC)))) + m_nHittz;
      BaseObject_34.StruckDamage(n20);
      BaseObject_34.SendRefMsg(RM_STRUCK, n20, BaseObject_34.m_WAbil.HP,
        BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
      if ntype = 2 then
      begin
        if BaseObject_34.m_btRaceServer <> RC_PLAYOBJECT then
          BaseObject_34.m_dwWalkTick := BaseObject_34.m_dwWalkTick + 1000  //突站 怪物卡位 2秒
        else // TPlayObject(BaseObject_34).MakePosion(POISON_STONE,1,0);
          TPlayObject(BaseObject_34).m_dwtuzhanMoveTick := GetTickCount() +
            g_Config.RushMotaeboTime;                         //人物卡位
      end;
      if BaseObject_34.m_btRaceServer <> RC_PLAYOBJECT then
      begin
        BaseObject_34.SendMsg(BaseObject_34, RM_STRUCK, n20, BaseObject_34.m_WAbil.HP,
          BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
      end;
    end;                                                    //004C3464
    if bo35 then
    begin
      GetFrontPosition(nX, nY);                             //sub_004B2790
      SendRefMsg(RM_RUSHKUNG, m_btDirection, nX, nY, 0, '');
      SysMsg(sMateDoTooweak {冲撞力不够！！！}, c_Red, t_Hint);
    end;
    if n28 > 0 then
    begin
      if n24 < 0 then
        n24 := 0;
      n20 := Random(n24 * 10) + ((n24 + 1) * 3);
      n20 := GetHitStruckDamage(Self, n20);
      StruckDamage(n20);
      SendRefMsg(RM_STRUCK, n20, m_WAbil.HP, m_WAbil.MaxHP, 0, '');
    end;
  except
    MainOutMessage('[Exception] DoMotaebo:' + inttostr(nercode));
  end;

end;
//004C1268

procedure TBaseObject.TrainSkill(UserMagic: pTUserMagic;
  nTranPoint: Integer);
begin
  if m_boFastTrain then
    nTranPoint := nTranPoint * 3;
  Inc(UserMagic.nTranPoint, nTranPoint);
end;

function TBaseObject.CheckMagicLevelup(UserMagic: pTUserMagic): Boolean; //004C7054
var
  n10                                                  : Integer;
begin
  Result := False;
  if (UserMagic.btLevel < 4) and (UserMagic.MagicInfo.btTrainLv >= UserMagic.btLevel)
    then
    n10 := UserMagic.btLevel
  else
    n10 := 0;

  if (UserMagic.btLevel < 6) and (UserMagic.MagicInfo.btTrainLv >= UserMagic.btLevel) and
    (UserMagic.wMagIdx in [87, 88, 89, 90, 91]) then
    n10 := UserMagic.btLevel
  else
    n10 := 0;
  if n10 >= 4 then
    n10 := 3;
  if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) and
    (UserMagic.MagicInfo.MaxTrain[n10] <= UserMagic.nTranPoint) then
  begin

    if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) then
    begin
      Dec(UserMagic.nTranPoint, UserMagic.MagicInfo.MaxTrain[n10]);
      Inc(UserMagic.btLevel);
      SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, 0, UserMagic.MagicInfo.wMagicId,
        UserMagic.btLevel, UserMagic.nTranPoint, '', 800);
      sub_4C713C(UserMagic);
    end
    else
    begin
      UserMagic.nTranPoint := UserMagic.MagicInfo.MaxTrain[n10];
    end;
    Result := True;
  end;                                                      //004C7132
end;

function TPlayObject.DoSpell(UserMagic: pTUserMagic; nTargetX,
  nTargetY: Integer; BaseObject: TBaseObject): boolean;     //004C6968
var
  nSpellPoint                                          : integer;
begin
  Result := False;
  try
    if not MagicManager.IsWarrSkill(UserMagic.wMagIdx) then
    begin
      nSpellPoint := GetSpellPoint(UserMagic);

      if (nSpellPoint > 0) and (m_btRaceServer <> RC_YSBJECT) then
      begin
        if m_WAbil.MP < nSpellPoint then
          exit;
        DamageSpell(nSpellPoint);                           //减少蓝血
        HealthSpellChanged();
      end;
      if (nSpellPoint > 0) and (m_btRaceServer = RC_YSBJECT) and (m_Master <> nil) then
      begin
        if m_Master.m_WAbil.MP < nSpellPoint then
          exit;
        m_Master.DamageSpell(nSpellPoint);                  //减少蓝血
        m_Master.HealthSpellChanged();
      end;
      //  MainOutMessage('开始魔法2:');
      Result := MagicManager.DoSpell(Self, UserMagic, nTargetX, nTargetY, BaseObject);
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(format('[Exception] TPlayObject.DoSpell MagID:%d X:%d Y:%d',
        [UserMagic.wMagIdx, nTargetX, nTargetY]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

function TPlayObject.PileStones(nX, nY: Integer): Boolean;  //004CB64C
var
  Event                                                : TEvent;
  PileEvent                                            : TEvent;
  s1C                                                  : string;
begin
  Result := False;
  s1C := '';
  Event := TEvent(m_PEnvir.GetEvent(nX, nY));
  if (Event <> nil) and (Event.m_nEventType = ET_STONEMINE) then
  begin
    if TStoneMineEvent(Event).m_nMineCount > 0 then
    begin
      Dec(TStoneMineEvent(Event).m_nMineCount);
      if Random(g_Config.nMakeMineHitRate {4}) = 0 then
      begin
        PileEvent := TEvent(m_PEnvir.GetEvent(m_nCurrX, m_nCurrY));
        if PileEvent = nil then
        begin                                               //004CB71D
          PileEvent := TPileStones.Create(m_PEnvir, m_nCurrX, m_nCurrY, ET_PILESTONES, 5
            * 60 * 1000);
          g_EventManager.AddEvent(PileEvent);
        end
        else
        begin
          if PileEvent.m_nEventType = ET_PILESTONES then
            TPileStones(PileEvent).AddEventParam;
        end;
        if Random(g_Config.nMakeMineRate {12}) = 0 then
        begin
          MakeMine();
        end;
        s1C := '1';
        DoDamageWeapon(Random(15) + 5);
        Result := True;
      end;                                                  //004CB79C
    end
    else
    begin                                                   //004CB782
      if (GetTickCount - TStoneMineEvent(Event).m_dwAddStoneMineTick) > 10 * 60 * 1000
        then
        TStoneMineEvent(Event).AddStoneMine();
    end;
  end;                                                      //004CB79C
  SendRefMsg(RM_HEAVYHIT, m_btDirection, m_nCurrX, m_nCurrY, 0, s1C);
end;

//004C914C

procedure TBaseObject.SetTargetCreat(BaseObject: TBaseObject);
begin
  m_TargetCret := BaseObject;
  m_dwTargetFocusTick := GetTickCount();
end;

procedure TBaseObject.DelTargetCreat();                     //004C9178
begin
  m_TargetCret := nil;
end;

function TBaseObject._Attack(var wHitMode: Word; AttackTarget: TBaseObject): Boolean;  //004C1EF4
//攻击角色
  function DirectAttack(BaseObject: TBaseObject; nSecPwr: Integer): Boolean; //004C1B04
  begin
    Result := False;
    if (m_btRaceServer = RC_PLAYOBJECT) or
      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
      not (InSafeZone and BaseObject.InSafeZone) then
    begin
      if IsProperTarget(BaseObject) then
      begin
        if Random(BaseObject.m_btSpeedPoint) < m_btHitPoint then
        begin
          BaseObject.StruckDamage(nSecPwr);
          BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK),
            RM_10101,
            nSecPwr,
            BaseObject.m_WAbil.HP,
            BaseObject.m_WAbil.MaxHP,
            Integer(Self),
            '', 500);
          if BaseObject.m_btRaceServer <> RC_PLAYOBJECT then
          begin
            BaseObject.SendMsg(BaseObject,
              RM_STRUCK,
              nSecPwr,
              BaseObject.m_WAbil.HP,
              BaseObject.m_WAbil.MaxHP,
              Integer(Self),
              '');
          end;
          Result := True;
          //    BaseObject.SendRefMsg(RM_47,nSecPwr,$20000,0,integer(self),'');  // $20000   掉血显示

        end;
      end;
    end;

  end;
  //刺杀前面一个位置的攻击
  function SwordLongAttack(nSecPwr: Integer): Boolean;      //004C1C24
  var
    nX, nY                                             : Integer;
    BaseObject                                         : TBaseObject;
  begin
    Result := False;
    //Result:=g_boNotLimitSwordLong;
    nSecPwr := ROUND(nSecPwr * g_Config.nSwordLongPowerRate / 100);
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if BaseObject <> nil then
      begin
        if (nSecPwr > 0) and IsProperTarget(BaseObject) then
        begin
          Result := DirectAttack(BaseObject, nSecPwr);
          SetTargetCreat(BaseObject);
        end;
        Result := True;
      end;
    end;
  end;
  //半月攻击
  function SwordWideAttack(nSecPwr: Integer): Boolean;      //004C1CDC
  var
    nC, n10                                            : Integer;
    nX, nY                                             : Integer;
    BaseObject                                         : TBaseObject;
  begin
    Result := False;
    nC := 0;
    while (True) do
    begin
      n10 := (m_btDirection + g_Config.WideAttack[nC]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject) then
        begin
          Result := DirectAttack(BaseObject, nSecPwr);
          SetTargetCreat(BaseObject);
        end;
      end;
      Inc(nC);
      if nC >= 3 then
        break;
    end;
  end;

  function CrsWideAttack(nSecPwr: Integer): Boolean;
  var
    nC, n10                                            : Integer;
    nX, nY                                             : Integer;
    BaseObject                                         : TBaseObject;
  begin
    Result := False;
    nC := 0;
    while (True) do
    begin
      n10 := (m_btDirection + g_Config.CrsAttack[nC]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject) then
        begin
          Result := DirectAttack(BaseObject, nSecPwr);
          SetTargetCreat(BaseObject);
        end;
      end;
      Inc(nC);
      if nC >= 7 then
        break;
    end;
  end;

  function pjpdAttack(nSecPwr: Integer): Boolean;
  var
    nC, n10                                            : Integer;
    nX, nY                                             : Integer;
    BaseObject                                         : TBaseObject;
  begin
    Result := False;
    nC := 0;
    Result := DirectAttack(BaseObject, nSecPwr);

  end;

  procedure sub_4C1E5C(nSecPwr: Integer);                   //004C1E5C
  var
    btDir                                              : Byte;
    nX, nY                                             : Integer;
    BaseObject                                         : TBaseObject;
    procedure sub_4C1DC0();
    begin
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) then
        begin
          Result := DirectAttack(BaseObject, nSecPwr);
        end;
      end;
    end;
  begin
    Result := False;
    btDir := m_btDirection;
    m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nX, nY);
    sub_4C1DC0();
    btDir := sub_4B2F80(m_btDirection, 2);
    sub_4C1DC0();
    btDir := sub_4B2F80(m_btDirection, 6);
    sub_4C1DC0();
  end;
var
  nPower, nSecPwr, nWeaponDamage                       : Integer;
  bo21                                                 : Boolean;
  n20                                                  : Integer;
  nCheckCode                                           : Integer;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TBaseObject::_Attack Name:= %s Code:=%d';
begin
  Result := False;
  nCheckCode := 0;
  try
    bo21 := False;
    nWeaponDamage := 0;
    nPower := 0;
    nSecPwr := 0;
    if AttackTarget <> nil then
    begin
      if (AttackTarget.m_btRaceServer = 3) then exit;
      nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) -
        LoWord(m_WAbil.DC))));
      //MainOutMessage('wHitMode:'+IntToStr(wHitMode));//调试
      if (wHitMode in [3, 12, 13]) then
      begin
        m_boPowerHit := False;
        Inc(nPower, m_nHitPlus);
        bo21 := True;
      end;
      if wHitMode = 61352 then
      begin                                                 //强化攻杀
        m_boFireHitSkill := False;
        nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10)); // m_nHitDouble;
        bo21 := True;
      end;
      if wHitMode = 49456 then
      begin                                                 //强化攻杀
        m_boFireHitSkill := False;
        nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10)); // m_nHitDouble;
        bo21 := True;
      end;
      if (wHitMode in [7, 16]) and m_boFireHitSkill then
      begin                                                 //烈火剑法
        m_boFireHitSkill := False;
        m_dwLatestFireHitTick := GetTickCount();            //Jacky 禁止双烈火
        m_nHitDouble := ROUND(m_MagicFireSwordSkill.MagicInfo.wPower /
          (m_MagicFireSwordSkill.MagicInfo.btTrainLv + 1) * (m_MagicFireSwordSkill.btLevel
          + 1)) + (m_MagicFireSwordSkill.MagicInfo.wPower +
          Random(m_MagicFireSwordSkill.MagicInfo.wMaxPower -
          m_MagicFireSwordSkill.MagicInfo.wPower));
        nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10)); // m_nHitDouble;
        bo21 := True;
      end;
      if (whitmode = 10) and (m_Magic59Skill <> nil) then
      begin
        m_nHitpj := ROUND(m_Magic59Skill.MagicInfo.wPower /
          (m_Magic59Skill.MagicInfo.btTrainLv + 1) * (m_Magic59Skill.btLevel + 1)) +
          (m_Magic59Skill.MagicInfo.wPower + Random(m_Magic59Skill.MagicInfo.wMaxPower -
          m_Magic59Skill.MagicInfo.wPower));
        nPower := nPower + m_nHitpj;
        bo21 := True;
      end;

      if (whitmode = 11) and (m_Magic60Skill <> nil) then
      begin
        m_nHitpd := ROUND(m_Magic60Skill.MagicInfo.wPower /
          (m_Magic60Skill.MagicInfo.btTrainLv + 1) * (m_Magic60Skill.btLevel + 1)) +
          (m_Magic60Skill.MagicInfo.wPower + Random(m_Magic60Skill.MagicInfo.wMaxPower -
          m_Magic60Skill.MagicInfo.wPower));
        nPower := nPower + m_nHitpd;
        bo21 := True;
      end;
    end
    else
    begin
      nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC) -
        LoWord(m_WAbil.DC))));
      if (wHitMode = 3) and m_boPowerHit then
      begin                                                 //功杀
        m_boPowerHit := False;
        Inc(nPower, m_nHitPlus);
        bo21 := True;
      end;
      //Jacky 防止砍空刀刀烈火
      if (wHitMode = 7) and m_boFireHitSkill then
      begin
        m_boFireHitSkill := False;
        m_dwLatestFireHitTick := GetTickCount();            //Jacky 禁止双烈火
      end;

      //
    end;
    nCheckCode := 1;
    if (wHitMode = 4) then
    begin                                                   //004C205A 刺杀
      nSecPwr := 0;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        nCheckCode := 11;
        if m_MagicErgumSkill <> nil then
        begin
          nCheckCode := 12;
          nSecPwr := ROUND(nPower / (m_MagicErgumSkill.MagicInfo.btTrainLv + 2) *
            (m_MagicErgumSkill.btLevel + 2));
          nCheckCode := 13;
        end;
      end
      else
        nSecPwr := nSecPwr;
      if nSecPwr > 0 then
      begin
        nCheckCode := 110;
        if not SwordLongAttack(nSecPwr) and g_Config.boLimitSwordLong then
          wHitMode := 0;
        nCheckCode := 111;
      end;
    end;
    nCheckCode := 2;
    if (wHitMode = 5) then
    begin                                                   //半月
      nSecPwr := 0;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if m_MagicBanwolSkill <> nil then
        begin
          nSecPwr := ROUND(nPower / (m_MagicBanwolSkill.MagicInfo.btTrainLv + 10) *
            (m_MagicBanwolSkill.btLevel + 2));
        end;
      end
      else
        nSecPwr := nSecPwr;
      if nSecPwr > 0 then
        SwordWideAttack(nSecPwr);
    end;

    if (wHitMode = 15) then
    begin                                                   //抱月
      nSecPwr := 0;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if m_Magic43Skill <> nil then
        begin
          nSecPwr := ROUND(nPower / (m_Magic43Skill.MagicInfo.btTrainLv + 10) *
            (m_Magic43Skill.btLevel + 2));
        end;
      end
      else
        nSecPwr := nSecPwr;
      if nSecPwr > 0 then
        CrsWideAttack(nSecPwr);
    end;

    nCheckCode := 3;
    if (wHitMode = 6) then
    begin
      nSecPwr := 0;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
      end
      else
        nSecPwr := nSecPwr;
      if nSecPwr > 0 then
        sub_4C1E5C(nSecPwr);
    end;
    if (wHitMode = 8) then
    begin
      nSecPwr := 0;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if m_MagicCrsSkill <> nil then
        begin
          nSecPwr := ROUND(nPower / (m_MagicCrsSkill.MagicInfo.btTrainLv + 10) *
            (m_MagicCrsSkill.btLevel + 2));
        end;
      end
      else
        nSecPwr := nSecPwr;
      if nSecPwr > 0 then
        CrsWideAttack(nSecPwr);
    end;

    {
     if (wHitMode = 10) then begin        //破击 破盾
      nSecPwr:=0;
      if m_btRaceServer = RC_PLAYOBJECT then begin
        if m_MagicCrsSkill <> nil then begin
          nSecPwr:=ROUND(nPower / (m_MagicCrsSkill.MagicInfo.btTrainLv + 10) * (m_MagicCrsSkill.btLevel + 2));
        end;
      end else nSecPwr:=nSecPwr;
      if nSecPwr > 0 then pjpdAttack(nSecPwr);
    end;
  }
    if AttackTarget = nil then
    begin
      exit;
    end;                                                    //004C218D
    nCheckCode := 4;
    if IsProperTarget {0FFF4}(AttackTarget) then
    begin
      nCheckCode := 41;
      if (Random(AttackTarget.m_btSpeedPoint) >= round(m_btHitPoint * 1.5)) then
      begin                                                 //增加命中概率
        nCheckCode := 42;
        nPower := 0;
      end;
      nCheckCode := 43;
    end
    else
      nPower := 0;
    nCheckCode := 5;
    if nPower > 0 then
    begin
      nPower := AttackTarget.GetHitStruckDamage(Self, nPower);
      nWeaponDamage := (Random(5) + 2) - m_AddAbil.btWeaponStrong;
    end;
    nCheckCode := 600;

    //  if wHitMode in[10,11] then begin
    //   nPower:=nPower*4;
    //  end;

    if nPower > 0 then
    begin                                                   //004C21FC
      nCheckCode := 601;
      AttackTarget.StruckDamage(nPower);

      // m_DefMsg:=MakeDefaultMsg(SM_41,Integer(ProcessMsg.BaseObject),ProcessMsg.nParam1,ProcessMsg.nParam2,ProcessMsg.wParam);

      nCheckCode := 602;
      AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nPower,
        AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self), '', 200);
      nCheckCode := 603;
      //攻击者被打中               破击剑法   破盾斩

      if (wHitMode in [10, 11]) then
      begin                                                 //AttackTarget
        // AttackTarget.SendRefMsg(RM_47,1536,m_btDirection,0,integer(self),'');
      //  AttackTarget.StruckDamage(17);  // 393216    458752

        if (wHitMode = 10) and (m_Magic59Skill <> nil) then
        begin
          //   AttackTarget.StruckDamage(nPower);
          //   AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK),RM_10101,nPower,AttackTarget.m_WAbil.HP,AttackTarget.m_WAbil.MaxHP,Integer(Self),'',200);

          if AttackTarget.m_boAbilMagzqDefence then
          begin
            if random(10) <= m_Magic59Skill.btLevel * 3 then
              AttackTarget.m_wStatusTimeArr[STATE_14] := 1;
          end;
          if random(10) <= m_Magic59Skill.btLevel * 3 then
            AttackTarget.m_wStatusTimeArr[STATE_DEFENCEUP] := 1;
          if random(10) <= m_Magic59Skill.btLevel * 3 then
            AttackTarget.m_wStatusTimeArr[STATE_MAGDEFENCEUP] := 1;
          //如果有护身 击破

          AttackTarget.SendRefMsg(RM_47, nPower, 393216, 0, integer(self), '');  // $60000  $30000 风火轮
        end;

        if (wHitMode = 11) and (m_Magic60Skill <> nil) then
        begin
          //    AttackTarget.StruckDamage(nPower);
          //    AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK),RM_10101,nPower,AttackTarget.m_WAbil.HP,AttackTarget.m_WAbil.MaxHP,Integer(Self),'',200);

          if AttackTarget.m_boAbilMagPowerDefence then
          begin
            if random(10) < m_Magic60Skill.btLevel * 3 then
              AttackTarget.m_wStatusArrValue[6] := 1;
          end;
          //如果有金刚 击破
          if AttackTarget.m_boAbilMagBubbleDefence then
          begin
            if random(10) < m_Magic60Skill.btLevel * 3 then
              AttackTarget.m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] := 1;
            ;
          end;
          //如果魔法盾
          if AttackTarget.m_boAbilMagfyDefence then
          begin
            if random(10) <= m_Magic60Skill.btLevel * 3 then
              AttackTarget.m_dwStatusArrTimeOutTick[7] := GetTickCount();
          end;
          //如果风影 击破

          AttackTarget.SendRefMsg(RM_47, nPower, $70000, 0, integer(self), '');  // $70000   458752
        end;
      end;
      //风火轮
      if AttackTarget.m_wStatusTimeArr[STATE_15] <> 0 then
      begin

        nPower := AttackTarget.m_wStatusTimeArr[STATE_15] div 2;
        AttackTarget.m_wStatusTimeArr[STATE_15] := 0;
        AttackTarget.m_dwStatusArrTick[STATE_15] := GetTickCount();

        self.StruckDamage(nPower);
        self.SendRefMsg(RM_47, nPower, $30000, 0, integer(AttackTarget), '');
        AttackTarget.StatusChanged();
      end;

      //  AttackTarget.SendRefMsg(RM_47,nPower,$20000,0,integer(self),'');  // $20000   掉血显示

      if (not AttackTarget.m_boUnParalysis and m_boParalysis and
        (Random(AttackTarget.m_btAntiPoison + g_Config.nAttackPosionRate {5}) = 0)) or
        (m_boSupperParalysis) then
      begin
        nCheckCode := 604;
        AttackTarget.MakePosion(POISON_STONE, g_Config.nAttackPosionTime {5}, 0);
      end;
      nCheckCode := 605;
      //虹魔，吸血

      if m_nHongMoSuite > 0 then
      begin
        m_db3B0 := nPower / 1.E2 * m_nHongMoSuite;
        if m_db3B0 >= 2.0 then
        begin
          n20 := TRUNC(m_db3B0);
          m_db3B0 := n20;
          DamageHealth(-n20, 1);
        end;
      end;
      nCheckCode := 606;
      if (m_MagicOneSwordSkill <> nil) and
        (m_btRaceServer = RC_PLAYOBJECT) and
        (m_MagicOneSwordSkill.btLevel < 3) and (m_MagicOneSwordSkill.MagicInfo <> nil)
          and
        (m_MagicOneSwordSkill.MagicInfo.TrainLevel[m_MagicOneSwordSkill.btLevel] <=
          m_Abil.Level) then
      begin
        nCheckCode := 607;
        TPlayObject(Self).TrainSkill(m_MagicOneSwordSkill, Random(3) + 1);
        nCheckCode := 608;
        if not TPlayObject(Self).CheckMagicLevelup(m_MagicOneSwordSkill) then
        begin
          nCheckCode := 609;
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicOneSwordSkill.MagicInfo.wMagicId,
            m_MagicOneSwordSkill.btLevel, m_MagicOneSwordSkill.nTranPoint, '', 3000);
        end;
        nCheckCode := 610;
      end;
      if m_wPowerRate[7] > 0 then
      begin
        if AttackTarget <> nil then
        begin
          n20 := Random(100);
          if n20 < g_Config.nSkill91Rate then
            if ((AttackTarget.m_btRaceServer = RC_PLAYOBJECT) and
              (g_Config.boSkill91HumLevel) and ((m_Abil.Level - AttackTarget.m_Abil.Level)
              > g_Config.nSkill91HumLevel)) or ((AttackTarget.m_btRaceServer <>
              RC_PLAYOBJECT) and (AttackTarget.m_Abil.Level < g_Config.nSkill91MonLevel))
              then
            begin
              AttackTarget.SendRefMsg(RM_510, 0, 1, 0, 70, '');
              nPower := (nPower * g_config.nSkill91Power) div 100 + nPower;
            end;
        end;
      end;
      nCheckCode := 6061;
      if bo21 and (m_MagicPowerHitSkill <> nil) and
        (m_btRaceServer = RC_PLAYOBJECT) and (m_MagicPowerHitSkill.wMagIdx <> 88) and
        (m_MagicPowerHitSkill.btLevel < 3) and (m_MagicPowerHitSkill.MagicInfo <> nil)
          and
        (m_MagicPowerHitSkill.MagicInfo.TrainLevel[m_MagicPowerHitSkill.btLevel] <=
          m_Abil.Level) then
      begin                                                 //这里
        nCheckCode := 611;
        TPlayObject(Self).TrainSkill(m_MagicPowerHitSkill, Random(3) + 1);
        nCheckCode := 612;
        if not TPlayObject(Self).CheckMagicLevelup(m_MagicPowerHitSkill) then
        begin
          nCheckCode := 613;
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicPowerHitSkill.MagicInfo.wMagicId,
            m_MagicPowerHitSkill.btLevel, m_MagicPowerHitSkill.nTranPoint, '', 3000);
        end;
        nCheckCode := 614;
      end;
      if bo21 and (m_MagicPowerHitSkill <> nil) and
        (m_btRaceServer = RC_PLAYOBJECT) and (m_MagicPowerHitSkill.wMagIdx = 88) and
        (m_MagicPowerHitSkill.btLevel < 5) and (m_MagicPowerHitSkill.MagicInfo <> nil)
          and
        (m_MagicPowerHitSkill.MagicInfo.TrainLevel[m_MagicPowerHitSkill.btLevel] <=
          m_Abil.Level) then
      begin                                                 //这里
        nCheckCode := 611;
        TPlayObject(Self).TrainSkill(m_MagicPowerHitSkill, Random(3) + 1);
        nCheckCode := 612;
        if not TPlayObject(Self).CheckMagicLevelup(m_MagicPowerHitSkill) then
        begin
          nCheckCode := 613;
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicPowerHitSkill.MagicInfo.wMagicId,
            m_MagicPowerHitSkill.btLevel, m_MagicPowerHitSkill.nTranPoint, '', 3000);
        end;
        nCheckCode := 614;
      end;
      nCheckCode := 6;
      if (wHitMode = 4) and (m_MagicErgumSkill <> nil) and
        (m_btRaceServer = RC_PLAYOBJECT) and
        (m_MagicErgumSkill.btLevel < 3) and
        (m_MagicErgumSkill.MagicInfo.TrainLevel[m_MagicErgumSkill.btLevel] <=
          m_Abil.Level) then
      begin
        nCheckCode := 61;
        TPlayObject(Self).TrainSkill(m_MagicErgumSkill, 1);
        nCheckCode := 62;
        if not TPlayObject(Self).CheckMagicLevelup(m_MagicErgumSkill) then
        begin
          nCheckCode := 63;
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicErgumSkill.MagicInfo.wMagicId,
            m_MagicErgumSkill.btLevel, m_MagicErgumSkill.nTranPoint, '', 3000);
        end;
      end;
      nCheckCode := 7;
      if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) and
        (m_btRaceServer = RC_PLAYOBJECT) and
        (m_MagicBanwolSkill.btLevel < 3) and
        (m_MagicBanwolSkill.MagicInfo.TrainLevel[m_MagicBanwolSkill.btLevel] <=
          m_Abil.Level) then
      begin

        TPlayObject(Self).TrainSkill(m_MagicBanwolSkill, 1);
        if not TPlayObject(Self).CheckMagicLevelup(m_MagicBanwolSkill) then
        begin
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicBanwolSkill.MagicInfo.wMagicId,
            m_MagicBanwolSkill.btLevel, m_MagicBanwolSkill.nTranPoint, '', 3000);
        end;
      end;

      if (wHitMode = 15) and (m_Magic43Skill <> nil) and
        (m_btRaceServer = RC_PLAYOBJECT) and
        (m_Magic43Skill.btLevel < 3) and
        (m_Magic43Skill.MagicInfo.TrainLevel[m_Magic43Skill.btLevel] <= m_Abil.Level)
          then
      begin

        TPlayObject(Self).TrainSkill(m_Magic43Skill, 1);
        if not TPlayObject(Self).CheckMagicLevelup(m_Magic43Skill) then
        begin
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_Magic43Skill.MagicInfo.wMagicId,
            m_Magic43Skill.btLevel, m_Magic43Skill.nTranPoint, '', 3000);
        end;
      end;
      nCheckCode := 8;
      if (wHitMode in [7, 16]) and (m_MagicFireSwordSkill <> nil) and
        (m_btRaceServer = RC_PLAYOBJECT) and
        (m_MagicFireSwordSkill.btLevel < 3) and
        (m_MagicFireSwordSkill.MagicInfo.TrainLevel[m_MagicFireSwordSkill.btLevel] <=
          m_Abil.Level) then
      begin

        TPlayObject(Self).TrainSkill(m_MagicFireSwordSkill, 1);
        if not TPlayObject(Self).CheckMagicLevelup(m_MagicFireSwordSkill) then
        begin
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_MagicFireSwordSkill.MagicInfo.wMagicId,
            m_MagicFireSwordSkill.btLevel, m_MagicFireSwordSkill.nTranPoint, '', 3000);
        end;
      end;

      if (wHitMode = 10) and (m_Magic59Skill <> nil) and m_bo59kill and // 破击
      (m_btRaceServer = RC_PLAYOBJECT) and
        (m_Magic59Skill.btLevel < 3) and
        (m_Magic59Skill.MagicInfo.TrainLevel[m_Magic59Skill.btLevel] <= m_Abil.Level)
          then
      begin

        TPlayObject(Self).TrainSkill(m_Magic59Skill, 1);
        if not TPlayObject(Self).CheckMagicLevelup(m_Magic59Skill) then
        begin
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_Magic59Skill.MagicInfo.wMagicId,
            m_Magic59Skill.btLevel, m_Magic59Skill.nTranPoint, '', 3000);
        end;
      end;

      if (wHitMode = 11) and (m_Magic60Skill <> nil) and m_bo60kill and // 破盾
      (m_btRaceServer = RC_PLAYOBJECT) and
        (m_Magic60Skill.btLevel < 3) and
        (m_Magic60Skill.MagicInfo.TrainLevel[m_Magic60Skill.btLevel] <= m_Abil.Level)
          then
      begin

        TPlayObject(Self).TrainSkill(m_Magic60Skill, 1);
        if not TPlayObject(Self).CheckMagicLevelup(m_Magic60Skill) then
        begin
          SendDelayMsg(Self, RM_MAGIC_LVEXP, 0, m_Magic60Skill.MagicInfo.wMagicId,
            m_Magic60Skill.btLevel, m_Magic60Skill.nTranPoint, '', 3000);
        end;
      end;

      Result := True;
    end;                                                    //004C270C
    nCheckCode := 9;
    if (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then
      DoDamageWeapon(nWeaponDamage);
    if AttackTarget.m_btRaceServer <> RC_PLAYOBJECT then
      AttackTarget.SendMsg(AttackTarget, RM_STRUCK, nPower, AttackTarget.m_WAbil.HP,
        AttackTarget.m_WAbil.MaxHP, Integer(Self), '');
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg, [m_sCharName, nCheckCode]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

procedure TBaseObject.SendAttackMsg(wIdent: Word; btDir: Byte; nX, nY, w3: Integer);  //004C2E0C
begin
  SendRefMsg(wIdent, btDir, nX, nY, w3, '');
end;

function TBaseObject.GetHitStruckDamage(Target: TBaseObject; nDamage: integer): Integer;  //004BDD20
var
  n14                                                  : Integer;
  lvdamge, jgdamage, nDam                              : integer;

begin
  n14 := LoWord(m_WAbil.AC) + Random(SmallInt(HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC)) +
    1);
  nDamage := _MAX(0, nDamage - n14);
  if (m_btLifeAttrib = LA_UNDEAD) and (Target <> nil) then
  begin
    Inc(nDamage, Target.m_AddAbil.bt1DF);
  end;
  if (nDamage > 0) and m_boAbilMagBubbleDefence then
  begin
    nDamage := ROUND((nDamage / 1.0E2) * (m_btMagBubbleDefenceLevel + 2) *
      g_Config.nMagBubbleDefenceRate);
    DamageBubbleDefence(nDamage);
  end;

  if (nDamage > 0) and m_boAbilMagfyDefence then
  begin                                                     //风隐伤害
    //  nDamage:=ROUND((nDamage / 1.0e2) * ( m_btMagfyDefenceLevel + 2) * 8.0);
    //  DamageBubbleDefence(nDamage);
    //  if m_dwStatusArrTimeOutTick[7] > GetTickCount  then begin
    //  if m_dwStatusArrTimeOutTick[7] > 3 then
    //    Dec(m_dwStatusArrTimeOutTick[7],10*1000)
     // if  m_dwStatusArrTimeOutTick[7]< 0 :=1;
    //  end;
  end;

  if (nDamage > 0) and m_boAbilMagPowerDefence then
  begin // (m_wStatusArrValue[6]>0)   金刚护体
    //    nDamage:=ROUND((nDamage / 1.0e2) * (m_btMagPowerDefencelevel + 2) * 10.0);
    nDam := (100 div (m_btMagPowerDefencelevel * g_Config.nMagPowerDefenceRate + 6));
    jgdamage := _min(nDamage, nDam);
    // jgdamage:=_min(nDamage,(100 div (m_btMagPowerDefencelevel*2+1))+1);
    if m_wStatusArrValue[6] > jgdamage then
    begin

      Dec(m_wStatusArrValue[6], jgdamage)
    end
    else
      m_wStatusArrValue[6] := 1;
    SendRefMsg(RM_29, 0, m_wStatusArrValue[6], 100, 154, '');
  end;

  if (nDamage > 0) and m_boAbilMagzqDefence then
  begin // (m_wStatusArrValue[6]>0)   护身真气
    //  nDamage:=ROUND((nDamage / 1.0e2) * (m_btMagzqDefencelevel + 2) * 12.0);
    if m_wStatusTimeArr[STATE_14] > nDamage then
    begin
      nDam := (100 div (m_btMagzqDefencelevel * 4 + 4)) + 1;
      jgdamage := _min(nDamage, nDam);
      Dec(m_wStatusTimeArr[STATE_14], jgdamage);
    end
    else
      m_wStatusTimeArr[STATE_14] := 1;
    SendRefMsg(RM_29, 0, m_wStatusTimeArr[STATE_14], 100, 154, '');
  end;

  if (nDamage > 0) and (m_wStatusArrValue[8] = 200) and (Target.m_btRaceServer <>
    RC_PLAYOBJECT) then
  begin
    if random(10) < 3 then
    begin
      nDamage := 1;
      SendRefMsg(RM_FUSHEN, 0, hiword(integer(Target)), loword(integer(Target)), 4, '');
      SysMsg('神御成功', c_Red, t_Hint);
    end;
  end;

  if (nDamage > 0) and (Target <> nil) and (Target.m_wStatusArrValue[8] = 197) and
    (Target.m_btRaceServer = RC_PLAYOBJECT) then
  begin
    if (random(10) < 3) and (m_btRaceServer <> RC_PLAYOBJECT) and (m_Abil.Level <
      Target.m_Abil.Level) then
    begin
      nDamage := _Max(m_WAbil.HP div 2, nDamage);           //nDamage*2;
      Target.SendRefMsg(RM_FUSHEN, 0, hiword(integer(self)), loword(integer(self)), 2,
        '');
      Target.SysMsg('重击成功', c_Red, t_Hint);
    end;
  end;

  if (nDamage > 0) and (Target <> nil) and (Target.m_wStatusArrValue[8] = 198) and
    (Target.m_btRaceServer = RC_PLAYOBJECT) then
  begin
    if (random(10) < 3) and (m_btRaceServer <> RC_PLAYOBJECT) and (m_Abil.Level <
      Target.m_Abil.Level) then
    begin
      nDamage := 9999;
      Target.SendRefMsg(RM_FUSHEN, 0, hiword(integer(self)), loword(integer(self)), 1,
        '');
      Target.SysMsg('秒杀成功', c_Red, t_Hint);
    end;
  end;

  Result := nDamage;
end;

function TBaseObject.GetMagStruckDamage(BaseObject: TBaseObject; nDamage: Integer):
  Integer;                                                    //004BDDEC
var
  n14, n20                                             : Integer;
  nDam                                                 : integer;
  jgdamage                                             : integer;
begin
  n14 := LoWord(m_WAbil.MAC) + Random(SmallInt(HiWord(m_WAbil.MAC) - LoWord(m_WAbil.MAC))
    + 1);
  nDamage := _MAX(0, nDamage - n14);
  if (m_btLifeAttrib = LA_UNDEAD) and (BaseObject <> nil) then
  begin
    Inc(nDamage, m_AddAbil.bt1DF);
  end;
  if (nDamage > 0) and m_boAbilMagBubbleDefence then
  begin
    nDamage := ROUND((nDamage / 1.0E2) * (m_btMagBubbleDefenceLevel + 2) *
      g_Config.nMagBubbleDefenceRate);
    DamageBubbleDefence(nDamage);
  end;

  if (nDamage > 0) and m_boAbilMagfyDefence then
  begin                                                     //风隐伤害
    //   nDamage:=ROUND((nDamage / 1.0e2) * ( m_btMagfyDefenceLevel + 2) * 8.0);
     //  DamageBubbleDefence(nDamage);
     //  if m_dwStatusArrTimeOutTick[7] > GetTickCount  then begin
     //  if m_dwStatusArrTimeOutTick[7] > 3 then
     //    Dec(m_dwStatusArrTimeOutTick[7],10*1000)
      // if  m_dwStatusArrTimeOutTick[7]< 0 :=1;
     //  end;
  end;

  //  nDam:=Random(10) + 5;
  if m_wStatusTimeArr[POISON_DAOCAO2] > 0 then
  begin                                                     //魔法防御减少
    //  nDam:=ROUND(nDam * (g_Config.nPosionDamagarmor / 10){1.2});
    nDamage := ROUND(nDamage * (g_Config.nPosionDamagarmor / 10) {1.2}); //伤害值增加
  end;

  if (nDamage > 0) and m_boAbilMagPowerDefence then
  begin                                                     // (m_wStatusArrValue[6]>0)
    //  nDamage:=ROUND((nDamage / 1.0e2) * (m_btMagPowerDefencelevel + 2) * 10);
    nDam := (100 div (m_btMagPowerDefencelevel * g_Config.nMagPowerDefenceRate + 6));
    jgdamage := _min(nDamage, nDam);
    if m_wStatusArrValue[6] > jgdamage then
    begin

      Dec(m_wStatusArrValue[6], jgdamage);
    end
    else
      m_wStatusArrValue[6] := 1;
    SendRefMsg(RM_29, 0, m_wStatusArrValue[6], 100, 154, '');
  end;

  if (nDamage > 0) and m_boAbilMagzqDefence then
  begin // (m_wStatusArrValue[6]>0)   护身真气
    //  nDamage:=ROUND((nDamage / 1.0e2) * (m_btMagzqDefencelevel + 2) * 12.0);
    if m_wStatusTimeArr[STATE_14] > nDamage then
    begin
      nDam := (100 div (m_btMagzqDefencelevel * 4 + 4)) + 1;
      jgdamage := _min(nDamage, nDam);
      Dec(m_wStatusTimeArr[STATE_14], jgdamage);
    end
    else
      m_wStatusTimeArr[STATE_14] := 1;
    SendRefMsg(RM_29, 0, m_wStatusTimeArr[STATE_14], 100, 154, '');
  end;
  if (nDamage > 0) and (m_wStatusArrValue[8] = 200) and (BaseObject.m_btRaceServer <>
    RC_PLAYOBJECT) then
  begin
    if random(10) < 3 then
    begin
      nDamage := 1;
      SendRefMsg(RM_FUSHEN, 0, hiword(integer(BaseObject)), loword(integer(BaseObject)),
        4, '');
      SysMsg('神御成功', c_Red, t_Hint);
    end;
  end;

  if BaseObject.m_wPowerRate[7] > 0 then
  begin
    if BaseObject <> nil then
    begin
      n20 := Random(100);
      if n20 < g_Config.nSkill91Rate then
        if ((m_btRaceServer = RC_PLAYOBJECT) and (g_Config.boSkill91HumLevel) and
          ((BaseObject.m_Abil.Level - m_Abil.Level) > g_Config.nSkill91HumLevel)) or
          ((m_btRaceServer <> RC_PLAYOBJECT) and (m_Abil.Level < g_Config.nSkill91MonLevel))
          then
        begin
          SendRefMsg(RM_510, 0, 1, 0, 70, '');
          nDamage := (nDamage * g_config.nSkill91Power) div 100 + nDamage;
        end;
    end;
  end;
  if (nDamage > 0) and (BaseObject <> nil) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT)
    and (BaseObject.m_wStatusArrValue[8] = 197) then
  begin
    if (random(10) < 2) and (m_btRaceServer <> RC_PLAYOBJECT) and (m_Abil.Level <
      BaseObject.m_Abil.Level) then
    begin
      nDamage := _Max(m_WAbil.HP div 2, nDamage);
      BaseObject.SendRefMsg(RM_FUSHEN, 0, hiword(integer(self)), loword(integer(self)), 2,
        '');
      BaseObject.SysMsg('重击成功', c_Red, t_Hint);
    end;
  end;

  if (nDamage > 0) and (BaseObject <> nil) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT)
    and (BaseObject.m_wStatusArrValue[8] = 198) then
  begin
    if (random(10) < 2) and (m_btRaceServer <> RC_PLAYOBJECT) and (m_Abil.Level <
      BaseObject.m_Abil.Level) then
    begin
      nDamage := 9999;
      BaseObject.SendRefMsg(RM_FUSHEN, 0, hiword(integer(self)), loword(integer(self)), 1,
        '');
      BaseObject.SysMsg('秒杀成功', c_Red, t_Hint);
    end;
  end;

  Result := nDamage;
end;

//004BDEB8

procedure TBaseObject.StruckDamage(nDamage: integer);
var
  I                                                    : Integer;
  nDam                                                 : Integer;
  nDura, nOldDura                                      : integer;
  PlayObject                                           : TPlayObject;
  StdItem                                              : pTStdItem;
  bo19                                                 : Boolean;
begin
  if nDamage <= 0 then
    exit;
  if m_boSuperMan then
    exit;                                                   //1.5 更新
  nDam := Random(10) + 5;
  if m_wStatusTimeArr[POISON_DAMAGEARMOR {1 0x62}] > 0 then
  begin
    nDam := ROUND(nDam * (g_Config.nPosionDamagarmor / 10) {1.2});
    nDamage := ROUND(nDamage * (g_Config.nPosionDamagarmor / 10) {1.2});
  end;
  bo19 := False;
  if m_UseItems[U_DRESS].wIndex > 0 then
  begin
    nDura := m_UseItems[U_DRESS].Dura;
    nOldDura := ROUND(nDura / 1000);
    Dec(nDura, nDam);
    if nDura <= 0 then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelItems(@m_UseItems[U_DRESS]);
        StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
        //004BE088
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('3' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            //UserEngine.GetStdItemName(m_UseItems[U_DRESS].wIndex) + #9 +
            StdItem.Name + #9 +
            IntToStr(m_UseItems[U_DRESS].MakeIndex) + #9 +
            BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
            '0');
        m_UseItems[U_DRESS].wIndex := 0;
        FeatureChanged();
      end;
      m_UseItems[U_DRESS].wIndex := 0;
      m_UseItems[U_DRESS].Dura := 0;
      bo19 := True;
    end
    else
    begin
      m_UseItems[U_DRESS].Dura := nDura;
    end;
    if nOldDura <> ROUND(nDura / 1000) then
    begin
      SendMsg(Self, RM_DURACHANGE, U_DRESS, nDura, m_UseItems[U_DRESS].DuraMax, 0, '');
    end;
  end;
  for I := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    if (m_UseItems[i].wIndex > 0) and (Random(8) = 0) and (i <> 11) then
    begin                                                   //宝石位置不掉持久
      nDura := m_UseItems[i].Dura;
      nOldDura := ROUND(nDura / 1000);
      Dec(nDura, nDam);
      if nDura <= 0 then
      begin
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          PlayObject := TPlayObject(Self);
          PlayObject.SendDelItems(@m_UseItems[i]);
          StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
          //004BE2B8
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('3' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              //UserEngine.GetStdItemName(m_UseItems[i].wIndex) + #9 +
              StdItem.Name + #9 +
              IntToStr(m_UseItems[i].MakeIndex) + #9 +
              BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
              '0');
          m_UseItems[i].wIndex := 0;
          FeatureChanged();
        end;
        m_UseItems[i].wIndex := 0;
        m_UseItems[i].Dura := 0;
        bo19 := True;
      end
      else
      begin
        m_UseItems[i].Dura := nDura;
      end;
      if nOldDura <> ROUND(nDura / 1000) then
      begin
        SendMsg(Self, RM_DURACHANGE, i, nDura, m_UseItems[i].DuraMax, 0, '');
      end;
    end;
  end;
  if bo19 then
    RecalcAbilitys();
  DamageHealth(nDamage, 1);
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    PlayObject := TPlayObject(Self);
    PlayObject.DecEvilMagic(nDam * 2);
  end;
end;

function TBaseObject.GeTBaseObjectInfo(): string;           //004CF87C
begin
  Result := m_sCharName + ' ' +
    '地图:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ') ' +
    '座标:' + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY) + ' ' +
    '等级:' + IntToStr(m_Abil.Level) + ' ' +
    '经验:' + IntToStr(m_Abil.Exp) + ' ' +
    '生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) + ' ' +
    '魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) + ' ' +
    '攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' + IntToStr(HiWord(m_WAbil.DC)) + ' '
      +
    '魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' + IntToStr(HiWord(m_WAbil.MC)) + ' '
      +
    '道术: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' + IntToStr(HiWord(m_WAbil.SC)) + ' ' +
    '防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' + IntToStr(HiWord(m_WAbil.AC)) + ' '
      +
    '魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' + IntToStr(HiWord(m_WAbil.MAC)) + ' '
      +
    '准确:' + IntToStr(m_btHitPoint) + ' ' +
    '敏捷:' + IntToStr(m_btSpeedPoint);
end;

function TBaseObject.GetBackPosition(var nX, nY: Integer): Boolean; //004B2900
var
  Envir                                                : TEnvirnoment;
begin
  Envir := m_PEnvir;
  nX := m_nCurrX;
  nY := m_nCurrY;
  case m_btDirection of
    DR_UP:
      if nY < (Envir.m_nHeight - 1) then
        Inc(nY);
    DR_DOWN:
      if nY > 0 then
        Dec(nY);
    DR_LEFT:
      if nX < (Envir.m_nWidth - 1) then
        Inc(nX);
    DR_RIGHT:
      if nX > 0 then
        Dec(nX);
    DR_UPLEFT:
      begin
        if (nX < (Envir.m_nWidth - 1)) and (nY < (Envir.m_nHeight - 1)) then
        begin
          Inc(nX);
          Inc(nY);
        end;
      end;
    DR_UPRIGHT:
      begin
        if (nX < (Envir.m_nWidth - 1)) and (nY > 0) then
        begin
          Dec(nX);
          Inc(nY);
        end
      end;
    DR_DOWNLEFT:
      begin
        if (nX > 0) and (nY < (Envir.m_nHeight - 1)) then
        begin
          Inc(nX);
          Dec(nY);
        end;
      end;
    DR_DOWNRIGHT:
      begin
        if (nX > 0) and (nY > 0) then
        begin
          Dec(nX);
          Dec(nY);
        end;
      end;
  end;
  Result := True;
end;

procedure TAnimalObject.HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower,
  nMagPower: integer; boFlag: Boolean);                     //004C2E40
var
  I                                                    : Integer;
  nDamage                                              : Integer;
  BaseObjectList                                       : TList;
  BaseObject                                           : TBaseObject;
begin
  m_btDirection := GetNextDirection(m_nCurrx, m_nCurrY, TargeTBaseObject.m_nCurrX,
    TargeTBaseObject.m_nCurrY);
  BaseObjectList := TList.Create;
  m_PEnvir.GeTBaseObjects(TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY, False,
    BaseObjectList);
  for I := 0 to BaseObjectList.Count - 1 do
  begin
    BaseObject := TBaseObject(BaseObjectList.Items[I]);
    if BaseObject = nil then
      continue;
    if IsProperTarget(BaseObject) then
    begin
      nDamage := 0;
      Inc(nDamage, BaseObject.GetHitStruckDamage(Self, nHitPower));
      Inc(nDamage, BaseObject.GetMagStruckDamage(Self, nMagPower));
      if nDamage > 0 then
      begin
        BaseObject.StruckDamage(nDamage);
        BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nDamage,
          BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '', 200);
      end;
    end;
  end;
  BaseObjectList.Free;
  SendRefMsg(RM_HIT, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
end;

procedure TAnimalObject.tiexueHitAttackTarget(TargeTBaseObject: TBaseObject; nHitPower,
  nMagPower: integer; boFlag: Boolean; ntype: integer);     //004C2E40
var
  I                                                    : Integer;
  nDamage                                              : Integer;
  BaseObjectList                                       : TList;
  BaseObject                                           : TBaseObject;
begin
  m_btDirection := GetNextDirection(m_nCurrx, m_nCurrY, TargeTBaseObject.m_nCurrX,
    TargeTBaseObject.m_nCurrY);
  BaseObjectList := TList.Create;
  m_PEnvir.GeTBaseObjects(TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY, False,
    BaseObjectList);
  for I := 0 to BaseObjectList.Count - 1 do
  begin
    BaseObject := TBaseObject(BaseObjectList.Items[I]);
    if BaseObject = nil then
      continue;
    if IsProperTarget(BaseObject) then
    begin
      nDamage := 0;
      Inc(nDamage, BaseObject.GetHitStruckDamage(Self, nHitPower));
      Inc(nDamage, BaseObject.GetMagStruckDamage(Self, nMagPower));
      if nDamage > 0 then
      begin

        BaseObject.StruckDamage(nDamage);
        BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nDamage,
          BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '', 200);
        if random(5) < 1 then
          BaseObject.CharPushed(GetNextDirection(m_nCurrx, m_nCurrY, BaseObject.m_nCurrX,
            BaseObject.m_nCurrY), random(1) + 1);

      end;
    end;
  end;
  BaseObjectList.Free;
  SendRefMsg(RM_HIT, makeword(m_btDirection, ntype), m_nCurrX, m_nCurrY, 0, '');

end;

procedure TAnimalObject.tiexueHitwideTarget(TargeTBaseObject: TBaseObject; nHitPower,
  nMagPower: integer; boFlag: Boolean; ntype: integer);     //004C2E40
var
  I, nc, n10                                           : Integer;
  nDamage                                              : Integer;
  nx, ny                                               : integer;
  BaseObject                                           : TBaseObject;
begin
  nC := 0;
  while (True) do
  begin
    n10 := (m_btDirection + g_Config.WideAttack[nC]) mod 8;
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if (BaseObject <> nil) and IsProperTarget(BaseObject) then
      begin
        nDamage := 0;
        Inc(nDamage, BaseObject.GetHitStruckDamage(Self, nHitPower));
        Inc(nDamage, BaseObject.GetMagStruckDamage(Self, nMagPower));
        if nDamage > 0 then
        begin

          BaseObject.StruckDamage(nDamage);
          BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nDamage,
            BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '', 200);
          if random(5) < 1 then
            BaseObject.CharPushed(GetNextDirection(m_nCurrx, m_nCurrY,
              BaseObject.m_nCurrX, BaseObject.m_nCurrY), random(1) + 1);

        end;
      end;
    end;
    Inc(nC);
    if nC >= 3 then
      break;
  end;
  SendRefMsg(RM_HIT, makeword(m_btDirection, ntype), m_nCurrX, m_nCurrY, 0, '');
end;

procedure TAnimalObject.tiexueHitALLTarget(TargeTBaseObject: TBaseObject; nHitPower,
  nMagPower: integer; boFlag: Boolean; ntype: integer);     //004C2E40
var
  I, n8, nC                                            : Integer;
  nDamage                                              : Integer;

  BaseObject                                           : TBaseObject;
begin
  for I := 0 to m_VisibleActors.Count - 1 do
  begin
    BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[I]).BaseObject);
    if BaseObject.m_boDeath then
      Continue;
    if IsProperTarget(BaseObject) then
    begin
      if (abs(m_nCurrX - BaseObject.m_nCurrX) <= m_nViewRange) and (abs(m_nCurrY -
        BaseObject.m_nCurrY) <= m_nViewRange) then
      begin
        nDamage := 0;
        Inc(nDamage, BaseObject.GetHitStruckDamage(Self, nHitPower));
        Inc(nDamage, BaseObject.GetMagStruckDamage(Self, nMagPower));
        if nDamage > 0 then
        begin

          BaseObject.StruckDamage(nDamage);
          BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nDamage,
            BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '', 200);
          if random(5) < 1 then
          begin
            BaseObject.GetBackPosition(n8, nC);
            n8 := n8 + random(5) + 2;
            nC := nC + random(5) + 2;
            if BaseObject.m_PEnvir.CanWalk(n8, nc, False) then
            begin
              BaseObject.SpaceMove(m_PEnvir.sMapName, n8, nC, 0);
              exit;
            end;
          end;

          if random(5) < 1 then
            BaseObject.CharPushed(GetNextDirection(m_nCurrx, m_nCurrY,
              BaseObject.m_nCurrX, BaseObject.m_nCurrY), random(1) + 1);

        end;
      end;
    end;
  end;                                                      // for
  SendRefMsg(RM_HIT, makeword(m_btDirection, ntype), m_nCurrX, m_nCurrY, 0, '');

end;

procedure TAnimalObject.DelTargetCreat;
begin
  inherited;
  m_nTargetX := -1;
  m_nTargetY := -1;
end;

procedure TAnimalObject.SearchTarget;                       //004C94B4
var
  BaseObject, BaseObject18                             : TBaseObject;
  i, nC, n10                                           : integer;
begin
  BaseObject18 := nil;
  n10 := 999;
  for i := 0 to m_VisibleActors.Count - 1 do
  begin
    BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[i]).BaseObject);
    if not BaseObject.m_boDeath then
    begin
      if IsProperTarget(BaseObject) and
        (not BaseObject.m_boHideMode or m_boCoolEye) then
      begin
        nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
        if nC < n10 then
        begin
          n10 := nC;
          BaseObject18 := BaseObject;
        end;
        if (BaseObject.m_boTishen) and (BaseObject.m_nxiyingmon <=
          (BaseObject.m_btSlaveMakeLevel + 1)) then
        begin
          inc(BaseObject.m_nxiyingmon);
          BaseObject18 := BaseObject;
          break;
        end;
      end;
    end;
  end;
  if BaseObject18 <> nil then
    SetTargetCreat {FFF2}(BaseObject18);
end;

procedure TAnimalObject.sub_4C959C;                         //004C959C
var
  I, nC, n10                                           : integer;
  Creat, BaseObject                                    : TBaseObject;
begin
  Creat := nil;
  n10 := 999;
  for I := 0 to m_VisibleActors.Count - 1 do
  begin
    BaseObject := TBaseObject(pTVisibleBaseObject(m_VisibleActors.Items[I]).BaseObject);
    if BaseObject.m_boDeath then
      Continue;
    if IsProperTarget(BaseObject) then
    begin
      nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY - BaseObject.m_nCurrY);
      if nC < n10 then
      begin
        n10 := nC;
        Creat := BaseObject;
      end;
    end;
  end;                                                      // for
  if Creat <> nil then
    SetTargetCreat(Creat);
end;

procedure TAnimalObject.SetTargetXY(nX, nY: Integer);       //004C9668
begin
  m_nTargetX := nX;
  m_nTargetY := nY;
end;

procedure TAnimalObject.Wondering;                          //004C9810
begin
  if (Random(20) = 0) then
    if (Random(4) = 1) then
      TurnTo(Random(8))
    else
      WalkTo(m_btDirection, False);
end;

procedure TAnimalObject.Wondering1;                         //004C9810
begin
  if (Random(2) = 0) then
    if (Random(4) = 1) then
      TurnTo(Random(8))
    else
      WalkTo(m_btDirection, False);
end;

function TBaseObject.MakePosion(nType, nTime, nPoint: Integer): Boolean; //004C35A8
var
  nOldCharStatus                                       : Integer;
begin
  Result := False;
  if nType < MAX_STATUS_ATTRIBUTE then
  begin
    nOldCharStatus := m_nCharStatus;
    if m_wStatusTimeArr[nType] > 0 then
    begin
      if m_wStatusTimeArr[nType] < nTime then
      begin
        m_wStatusTimeArr[nType] := nTime;
      end;
    end
    else
    begin                                                   //004C35FF
      m_wStatusTimeArr[nType] := nTime;
    end;
    m_dwStatusArrTick[nType] := GetTickCount();
    m_nCharStatus := GetCharStatus();
    m_btGreenPoisoningPoint := nPoint;
    if nOldCharStatus <> m_nCharStatus then
      StatusChanged();
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      if ntype in [POISON_DAOCAO1, POISON_DAOCAO1] then
        SysMsg(format('受到诅咒！！！%d秒 %d点', [nTime, nPoint]), c_Red, t_Hint)
      else
        SysMsg(format('中毒了！！！%d秒 %d点', [nTime, nPoint]), c_Red, t_Hint);

      //   SysMsg(sYouPoisoned{中毒了！！！},c_Red,t_Hint);

    end;
    Result := True;
  end;                                                      //004C366C

end;

function TBaseObject.sub_4DD704: Boolean;                   //004DD704
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
begin
  Result := False;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for I := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_Msglist.Items[i];
      if SendMessage.wIdent = RM_10401 then
      begin
        Result := True;
        break;
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

procedure TPlayObject.SendSaveItemList(nBaseObject: Integer); //004DC120
var
  i, II                                                : Integer;
  Item                                                 : pTStdItem;
  sSendMsg                                             : string;
  ClientItem                                           : TClientItem;

  StdItem                                              : TStdItem;
  UserItem                                             : PTUserItem;
  sUserItemName                                        : string;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint, tint2                                          : integer;
  BODY                                                 : array[0..10000] of char;
  ItemLIst                                             : TList;
begin
  fillchar(body, sizeof(body), 0);
  ii := 0;

  begin
    sSendMsg := '';
    ItemLIst := m_StorageItemList;

    if boPneumastorage then
      if Ysplayer = nil then
        Exit
      else
        ItemList := Ysplayer.m_StorageItemList;

    i := 0;
    for I := ItemList.Count - 1 downto 0 do
    begin
      if i > ItemList.count - 1 then
        break;
      UserItem := ItemList.Items[i];

      Item := UserEngine.GetStdItem(UserItem.wIndex);
      if Item <> nil then
      begin
        StdItem := Item^;
        ItemUnit.GetItemAddValue(UserItem, StdItem);
        //Move(StdItem,ClientItem.S,SizeOf(TStdItem));
        ClientItem.S := StdItem;

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex,
            UserItem.wIndex);

        if sUserItemName <> '' then
          ClientItem.S.Name := sUserItemName;
        ClientItem.DarkProperty := Useritem.DarkProp; // ItemUnit.GetItemDarkProperty(m_UseItems[i].MakeIndex, m_UseItems[i].wIndex);
        ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
        if (ClientItem.S.StdMode = 49) and (ClientItem.S.Shape in [18, 22]) then
        begin

          copymemory(@tint, @UserItem.btValue[0], 4);
          if tint <> 0 then
          begin
            MyTime := EncodeTime(8, 00, 00, 0);
            mydate := encodedate(1970, 01, 01);
            date1 := mydate + mytime;
            mydate := date();
            mytime := time();
            date2 := mydate + mytime;
            tint2 := round((date2 - date1) * 86400);
            tint := round((tint2 - tint) / 86400);
            if ClientItem.S.DuraMax - tint > 0 then
            begin
              ClientItem.S.DuraMax := ClientItem.S.DuraMax - tint;
            end
            else
            begin

              Dispose(UserItem);

              m_StorageItemList.Delete(I);
              if g_FunctionNPC <> nil then
              begin
                g_FunctionNPC.GotoLable(Self, '@ItemTimeOver' +
                  IntToStr(UserEngine.GetItemAnicount(UserItem.wIndex)), False);
              end;

              SysMsg('你的物品' + ClientItem.S.Name + '使用期限已过，自动从仓库中消失了',
                c_Red, t_Hint);

              Continue;

            end;

          end;

        end;

        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.MakeIndex := UserItem.MakeIndex;
        copymemory(@body[SizeOf(TClientItem) * ii], @ClientItem, SizeOf(TClientItem));
        inc(ii);

      end;

    end;                                                    //for
    if ii >= 1 then
      sSendMsg := EncodeBuffer(@body, SizeOf(TClientItem) * ii);
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0, ItemList.Count);
    SendSocket(@m_DefMsg, sSendMsg);
  end;
end;

procedure TPlayObject.SendChangeGuildName;                  //004DE5A4
begin
  if m_MyGuild <> nil then
  begin
    SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, TGuild(m_MyGuild).sGuildName + '/' +
      m_sGuildRankName);
  end
  else
  begin
    SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
  end;
end;

procedure TPlayObject.SendDelItemList(ItemList: TStringList); //004D0DAC
var
  I                                                    : Integer;
  s10                                                  : string;
begin
  s10 := '';
  for I := 0 to ItemList.Count - 1 do
  begin
    s10 := s10 + ItemList.Strings[i] + '/' + IntToStr(Integer(ItemList.Objects[i])) +
      '/';
  end;
  m_DefMsg := MakeDefaultMsg(SM_DELITEMS, 0, 0, 0, ItemList.Count);
  SendSocket(@m_DefMsg, EncodeString(s10));
end;

procedure TPlayObject.SendDelItems(UserItem: pTUserItem);   //004D0BDC
var
  StdItem                                              : pTStdItem;
  StdItem80                                            : TStdItem;
  ClientItem                                           : TClientItem;

  sUserItemName                                        : string;
begin

  begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
    begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(@UserItem, StdItem80);
      Move(StdItem80, ClientItem.S, SizeOf(TStdItem));

      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.S.Name := sUserItemName;
      ClientItem.DarkProperty := Useritem.DarkProp; //= ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);
      ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      if StdItem.StdMode = 50 then
      begin
        ClientItem.S.Name := ClientItem.S.Name + ' #' + IntToStr(UserItem.Dura);
      end;
      m_DefMsg := MakeDefaultMsg(SM_DELITEM, Integer(Self), 0, 0, 1);
      SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
    end;
  end;
end;

procedure TPlayObject.SendUpdateItem(UserItem: pTUserItem); //004D0A10
var
  StdItem                                              : pTStdItem;
  StdItem80                                            : TStdItem;
  ClientItem                                           : TClientItem;

  sUserItemName                                        : string;
begin

  begin
    StdItem := UserEngine.GetStdItem(UserItem.wIndex);
    if StdItem <> nil then
    begin
      StdItem80 := StdItem^;
      ItemUnit.GetItemAddValue(UserItem, StdItem80);

      ClientItem.S := StdItem80;

      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName <> '' then
        ClientItem.S.Name := sUserItemName;
      ClientItem.DarkProperty := Useritem.DarkProp; //ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);

      ////
      ClientItem.MakeIndex := UserItem.MakeIndex;
      ClientItem.Dura := UserItem.Dura;
      ClientItem.DuraMax := UserItem.DuraMax;
      if StdItem.StdMode = 50 then
      begin
        ClientItem.S.Name := ClientItem.S.Name + ' #' + IntToStr(UserItem.Dura);
      end;

      ClientItem.S.Price := 0;
      if (ClientItem.S.StdMode = 0) and (ClientItem.s.Shape = 200) then
        ClientItem.s.AC := 0;
      m_DefMsg := MakeDefaultMsg(SM_UPDATEITEM, Integer(Self), 0, 0, 1);
      SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
      if Useritem.AttachMagic.aaa.PetAddProperty.nMakeIndex > 0 then
      begin
        m_DefMsg := MakeDefaultMsg(34983, Integer(Self), 24, 0, 1);
        SendSocket(@m_DefMsg, EncodeBuffer(@Useritem.AttachMagic.aaa.PetAddProperty,
          SizeOf(TPetAddProperty)));
      end;
    end;
  end;
end;

function TPlayObject.CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem): Boolean;  //004C5084
var
  Castle                                               : TUserCastle;
begin
  Result := False;
  if (StdItem.StdMode = 10) and (m_btGender <> 0) then
  begin
    SysMsg(sWearNotOfWoMan, c_Red, t_Hint);
    exit;
  end;
  if (StdItem.StdMode = 11) and (m_btGender <> 1) then
  begin
    SysMsg(sWearNotOfMan, c_Red, t_Hint);
    exit;
  end;
  if (nWhere = 1) or (nWhere = 2) then
  begin
    if StdItem.Weight > m_WAbil.MaxHandWeight then
    begin
      SysMsg(sHandWeightNot, c_Red, t_Hint);
      exit;
    end;
  end
  else
  begin
    if (StdItem.Weight + GetUserItemWeitht(nWhere)) > m_WAbil.MaxWearWeight then
    begin
      SysMsg(sWearWeightNot, c_Red, t_Hint);
      exit;
    end;
  end;
  Castle := g_CastleManager.IsCastleMember(Self);
  case StdItem.Need of                                      //
    0:
      begin
        if m_Abil.Level >= StdItem.NeedLevel then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sLevelNot, c_Red, t_Hint);
        end;
      end;
    1:
      begin
        if HiWord(m_WAbil.DC) >= StdItem.NeedLevel then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sDCNot, c_Red, t_Hint);
        end;
      end;
    10:
      begin
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (m_Abil.Level >=
          HiWord(StdItem.NeedLevel)) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sJobOrLevelNot, c_Red, t_Hint);
        end;
      end;
    11:
      begin
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.DC) >=
          HiWord(StdItem.NeedLevel)) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sJobOrDCNot, c_Red, t_Hint);
        end;
      end;
    12:
      begin
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.MC) >=
          HiWord(StdItem.NeedLevel)) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sJobOrMCNot, c_Red, t_Hint);
        end;
      end;
    13:
      begin
        if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.SC) >=
          HiWord(StdItem.NeedLevel)) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sJobOrSCNot, c_Red, t_Hint);
        end;
      end;
    2:
      begin
        if HiWord(m_WAbil.MC) >= StdItem.NeedLevel then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sMCNot, c_Red, t_Hint);
        end;
      end;
    3:
      begin
        if HiWord(m_WAbil.SC) >= StdItem.NeedLevel then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sSCNot, c_Red, t_Hint);
        end;
      end;
    4:
      begin
        if m_btReLevel >= StdItem.NeedLevel then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    40:
      begin
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then
        begin
          if m_Abil.Level >= HiWord(StdItem.NeedLevel) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sLevelNot, c_Red, t_Hint);
          end;
        end
        else
        begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    41:
      begin
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then
        begin
          if HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sDCNot, c_Red, t_Hint);
          end;
        end
        else
        begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    42:
      begin
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then
        begin
          if HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sMCNot, c_Red, t_Hint);
          end;
        end
        else
        begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    43:
      begin
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then
        begin
          if HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sSCNot, c_Red, t_Hint);
          end;
        end
        else
        begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    44:
      begin
        if m_btReLevel >= LoWord(StdItem.NeedLevel) then
        begin
          if m_btCreditPoint >= HiWord(StdItem.NeedLevel) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sCreditPointNot, c_Red, t_Hint);
          end;
        end
        else
        begin
          SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
        end;
      end;
    5:
      begin
        if m_btCreditPoint >= StdItem.NeedLevel then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sCreditPointNot, c_Red, t_Hint);
        end;
      end;
    6:
      begin
        if (m_MyGuild <> nil) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sGuildNot, c_Red, t_Hint);
        end;
      end;
    60:
      begin
        if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sGuildMasterNot, c_Red, t_Hint);
        end;
      end;
    7:
      begin
        //      if (m_MyGuild <> nil) and (UserCastle.m_MasterGuild = m_MyGuild) then begin
        if (m_MyGuild <> nil) and (Castle <> nil) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sSabukHumanNot, c_Red, t_Hint);
        end;
      end;
    70:
      begin
        //      if (m_MyGuild <> nil) and (UserCastle.m_MasterGuild = m_MyGuild) and (m_nGuildRankNo = 1) then begin
        if (m_MyGuild <> nil) and (Castle <> nil) and (m_nGuildRankNo = 1) then
        begin
          if m_Abil.Level >= StdItem.NeedLevel then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sLevelNot, c_Red, t_Hint);
          end;
        end
        else
        begin
          SysMsg(g_sSabukMasterManNot, c_Red, t_Hint);
        end;
      end;
    8:
      begin
        if m_nMemberType <> 0 then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sMemberNot, c_Red, t_Hint);
        end;
      end;
    81:
      begin
        if (m_nMemberType = LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >=
          HiWord(StdItem.NeedLevel)) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
        end;
      end;
    82:
      begin
        if (m_nMemberType >= LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >=
          HiWord(StdItem.NeedLevel)) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
        end;
      end;
  end;
  //if not Result then SysMsg(g_sCanottWearIt,c_Red,t_Hint);

end;

function TBaseObject.sub_4C5370(nX, nY: Integer; nRange: Integer; var nDX, nDY: Integer):
  Boolean;                                                    //004C5370
var
  I                                                    : Integer;
  II                                                   : Integer;
  III                                                  : Integer;
begin
  Result := False;
  if m_PEnvir.GetMovingObject(nX, nY, True) = nil then
  begin
    Result := True;
    nDX := nX;
    nDY := nY;
  end;
  if not Result then
  begin
    for I := 1 to nRange do
    begin
      for II := -I to I do
      begin
        for III := -I to I do
        begin
          nDX := nX + III;
          nDY := nY + II;
          if m_PEnvir.GetMovingObject(nDX, nDY, True) = nil then
          begin
            Result := True;
            break;
          end;
        end;
        if Result then
          break;
      end;
      if Result then
        break;
    end;
  end;
  if not Result then
  begin
    nDX := nX;
    nDY := nY;
  end;
end;

function TPlayObject.GetUserItemWeitht(nWhere: Integer): Integer; //004BF764
var
  I                                                    : Integer;
  n14                                                  : Integer;
  StdItem                                              : pTStdItem;
begin
  n14 := 0;
  for I := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    if (nWhere = -1) or (not (i = nWhere) and not (i = 1) and not (i = 2)) then
    begin
      StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
      if StdItem <> nil then
        Inc(n14, StdItem.Weight);
    end;
  end;
  Result := n14;
end;

function TPlayObject.EatItems(StdItem: pTStdItem): Boolean; //004C6238
var
  bo06                                                 : Boolean;
  nOldStatus                                           : Integer;
begin
  Result := False;
  if m_PEnvir.m_boNODRUG then
  begin
    SysMsg(sCanotUseDrugOnThisMap, c_Red, t_Hint);
    exit;
  end;
  case StdItem.StdMode of
    0:
      begin                                                 //004C62BA
        case StdItem.Shape of
          1, 201:
            begin
              IncHealthSpell(StdItem.AC, StdItem.MAC);
              Result := True;
            end;
          200:
            begin
              if StdItem.Looks = 793 then
              begin
                m_boAddhpmode := true;
                m_dwAddhpmodetick := GetTickCount + StdItem.AC * 60 * 1000;
                SendDefMessage(510, integer(self), 1, 1, 1, '');
              end;
              if StdItem.Looks = 794 then
              begin
                m_boAddmpmode := true;
                m_dwAddmpmodetick := GetTickCount + StdItem.MAC * 60 * 1000;
                SendDefMessage(510, integer(self), 1, 1, 2, '');
              end;
            end;
          2:
            begin
              m_boUserUnLockDurg := True;
              Result := True;
            end;
        else
          begin

            if (StdItem.AC > 0) then
            begin
              Inc(m_nIncHealth, StdItem.AC);
            end;
            if (StdItem.MAC > 0) then
            begin
              Inc(m_nIncSpell, StdItem.MAC);
            end;
            Result := True;
          end;
        end;
      end;
    1:
      begin
        nOldStatus := GetMyStatus();
        Inc(m_nHungerStatus, StdItem.DuraMax div 10);
        m_nHungerStatus := _MIN(5000, m_nHungerStatus);
        if nOldStatus <> GetMyStatus() then
          RefMyStatus();
        Result := True;
      end;
    2: Result := True;
    3:
      begin                                                 //可以增加人物属性的物品
        if StdItem.Shape = 15 then
        begin                                               //回城石
          if GetTickCount - m_dwusehuichengTick > 10000 then
          begin
            m_dwusehuichengTick := GetTickCount();
            BaseObjectMove(inttostr(StdItem.DC - 48), IntToStr(StdItem.AC),
              IntToStr(StdItem.MAC));
          end
          else
            SysMsg('回城石10秒只能使用一次', c_red, t_Hint);
          // Result:=True;
        end;

        if StdItem.Shape = 12 then
        begin
          bo06 := False;
          if LoByte(StdItem.DC) > 0 then
          begin
            m_wStatusArrValue[0 {0x218}] := LoByte(StdItem.DC);
            m_dwStatusArrTimeOutTick[0 {0x220}] := GetTickCount + HiByte(StdItem.MAC) *
              1000;
            SysMsg('攻击力增加' + IntToStr(HiByte(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoByte(StdItem.MC) > 0 then
          begin
            m_wStatusArrValue[1 {0x219}] := LoByte(StdItem.MC);
            m_dwStatusArrTimeOutTick[1 {0x224}] := GetTickCount + HiByte(StdItem.MAC) *
              1000;
            SysMsg('魔法力增加' + IntToStr(HiByte(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if LoByte(StdItem.SC) > 0 then
          begin
            m_wStatusArrValue[2 {0x21A}] := LoByte(StdItem.SC);
            m_dwStatusArrTimeOutTick[2 {0x228}] := GetTickCount + HiByte(StdItem.MAC) *
              1000;
            SysMsg('道术增加' + IntToStr(HiByte(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if HiByte(StdItem.AC) > 0 then
          begin
            m_wStatusArrValue[3] := HiByte(StdItem.AC);
            m_dwStatusArrTimeOutTick[3] := GetTickCount + HiByte(StdItem.MAC) * 1000;
            SysMsg('攻击速度增加' + IntToStr(HiByte(StdItem.MAC)) + '秒', c_Green,
              t_Hint);
            bo06 := True;
          end;

          if LoByte(StdItem.AC) > 0 then
          begin
            m_wStatusArrValue[4 {0x21C}] := LoByte(StdItem.AC);
            m_dwStatusArrTimeOutTick[4 {0x230}] := GetTickCount + HiByte(StdItem.MAC) *
              1000;
            SysMsg('生命值增加' + IntToStr(HiByte(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if (StdItem.MAC) > 0 then
          begin
            m_wStatusArrValue[5 {0x21D}] := StdItem.MAC;
            m_dwStatusArrTimeOutTick[5 {0x234}] := GetTickCount + HiByte(StdItem.MAC) *
              1000;
            SysMsg('魔法值增加' + IntToStr(HiByte(StdItem.MAC)) + '秒', c_Green, t_Hint);
            bo06 := True;
          end;
          if bo06 then
          begin
            RecalcAbilitys();
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            Result := True;
          end;
        end
        else
        begin
          Result := EatUseItems(StdItem.Shape);
        end;
      end;
  end;
end;

function TPlayObject.ReadBook(StdItem: pTStdItem): Boolean; //004C67DC
var
  Magic                                                : pTMagic;
  UserMagic                                            : pTUserMagic;
  PlayObject                                           : TPlayObject;
  magicname, st, mt                                    : string;
begin
  Result := False;
  magicname := StdItem.Name;
  if sYsnameMaster <> '' then
  begin
    if copy(magicname, 1, 4) = '元神' then
    begin
      magicname := copy(magicname, 5, length(magicname) - 4);
    end;
  end;
  Magic := UserEngine.FindMagic(magicname);
  if Magic <> nil then
  begin
    if not IsTrainingSkill(Magic.wMagicId) then
    begin
      if (Magic.btJob = 99) or (Magic.btJob = m_btJob) then
      begin
        if sYsnameMaster = '' then
        begin
          if g_Config.PlayerSkillTree and (not IsTrainingpreSkill(magicname)) then
          begin
            exit;
          end;
          if g_Config.PlayerSkillTree and IsTraininglimitSkill(magicname) then
          begin
            exit;
          end;
        end
        else
        begin
          if g_Config.YSSkillTree and (not IsTrainingpreSkill(magicname)) then
          begin
            exit;
          end;
          if g_Config.YSSkillTree and IsTraininglimitSkill(magicname) then
          begin
            exit;
          end;
        end;

        if m_Abil.Level >= Magic.TrainLevel[0] then
        begin
          New(UserMagic);
          UserMagic.MagicInfo := Magic;
          UserMagic.wMagIdx := Magic.wMagicId;
          UserMagic.btKey := 0;
          UserMagic.btLevel := 0;
          UserMagic.nTranPoint := 0;
          m_MagicList.Add(UserMagic);
          RecalcAbilitys();
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            PlayObject := TPlayObject(Self);
            PlayObject.SendAddMagic(UserMagic);
          end;
          Result := True;
        end;
      end;
    end;
  end;
end;

function TBaseObject.IsTrainingSkill(nIndex: Integer): Boolean; //004C6780
var
  I                                                    : Integer;
  UserMagic                                            : pTUserMagic;
begin
  Result := False;
  for I := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[i];
    if (UserMagic <> nil) and (UserMagic.wMagIdx = nIndex) then
    begin
      Result := True;
      break;
    end;
  end;
end;

function TBaseObject.IsTraininglimitSkill(magicname: string): Boolean; //004C6780
var
  I                                                    : Integer;
  UserMagic                                            : pTUserMagic;
  Magic                                                : pTMagic;
  prenIndex, prenIndex1, prenIndex2                    : Integer;
  // hasfoundlimit:boolean;
begin
  Result := false;
  //  hasfoundlimit:=false;
  prenIndex := 0;
  prenIndex1 := 0;
  prenIndex2 := 0;
  Magic := UserEngine.FindMagic(magicname);
  if Magic = nil then
    exit;
  case magic.wMagicID of
    7:
      begin
        prenIndex := 41;
        prenIndex1 := 40;
      end;
    40:
      begin
        prenIndex := 7;
        prenIndex1 := 41;
      end;
    41:
      begin
        prenIndex := 7;
        prenIndex1 := 40;
      end;

    43: prenIndex := 25;
    25: prenIndex := 43;

    26: prenIndex := 44;
    44: prenIndex := 26;
    ///////武士

    6: prenIndex := 45;
    45: prenIndex := 6;
    17: prenIndex := 46;
    46: prenIndex := 17;
    16: prenIndex := 48;
    48: prenIndex := 16;
    ////////道士

    11: prenIndex := 49;
    49: prenIndex := 11;
    5: prenIndex := 50;
    50: prenIndex := 5;

    10: prenIndex := 51;
    51: prenIndex := 10;
    53: prenIndex := 33;
    33: prenIndex := 53;
    ///法师

  end;
  if prenIndex = 0 then
  begin
    Result := false;
    exit;
  end;
  for I := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[i];
    if (UserMagic <> nil) and (UserMagic.wMagIdx in [prenIndex, prenIndex1]) then
    begin
      if UserMagic.wMagIdx = prenIndex then
        prenIndex2 := prenIndex
      else
        prenIndex2 := prenIndex1;
      result := True;
      break;
    end;
  end;
  if result then
  begin
    Magic := UserEngine.FindMagic(prenIndex2);
    if Magic <> nil then
      SysMsg('你已经学习' + Magic.sMagicName + ',不能学习该技能', c_Red, t_Hint)

  end
end;

function TBaseObject.IsTrainingPreSkill(magicname: string): Boolean; //004C6780
var
  I                                                    : Integer;
  UserMagic                                            : pTUserMagic;
  Magic                                                : pTMagic;
  prenIndex, prenIndex1, prenIndex2                    : Integer;
begin
  Result := false;
  prenIndex := 0;
  prenIndex1 := 0;
  prenIndex2 := 0;
  Magic := UserEngine.FindMagic(magicname);
  if Magic = nil then
    exit;
  case magic.wMagicID of
    7, 40, 41: prenIndex := 3;
    42:
      begin
        prenIndex := 7;
        prenIndex1 := 40;
        prenIndex2 := 41;
      end;
    12: prenIndex := 42;
    43, 25: prenIndex := 12;
    27:
      begin
        prenIndex := 25;
        prenIndex1 := 43;
      end;
    26, 44: prenIndex := 27;
    ///////武士
    4: prenIndex := 2;
    6, 45: prenIndex := 4;
    13:
      begin
        prenIndex := 6;
        prenIndex1 := 45;
      end;
    17, 46: prenIndex := 13;
    18: prenIndex := 17;
    47: prenIndex := 46;
    19:
      begin
        prenIndex := 18;
        prenIndex1 := 47;
      end;
    14: prenIndex := 19;
    15: prenIndex := 14;
    37: prenIndex := 15;
    16, 48: prenIndex := 37;
    29:
      begin
        prenIndex := 16;
        prenIndex1 := 48;
      end;
    30: prenIndex := 29;
    ////////道士
    8: prenIndex := 1;
    20: prenIndex := 8;
    9: prenIndex := 20;
    11, 49: prenIndex := 9;
    21:
      begin
        prenIndex := 11;
        prenIndex1 := 49;
      end;
    5, 50: prenIndex := 21;
    23:
      begin
        prenIndex := 5;
        prenIndex1 := 50;
      end;
    22: prenIndex := 23;
    10, 51: prenIndex := 22;
    52: prenIndex := 51;
    24: prenIndex := 10;
    31:
      begin
        prenIndex := 52;
        prenIndex1 := 24;
      end;
    32: prenIndex := 31;
    53, 33: prenIndex := 32;
    54:
      begin
        prenIndex := 53;
        prenIndex1 := 33;
      end;
    ///法师

  end;
  if prenIndex = 0 then
  begin
    Result := true;
    exit;
  end;
  for I := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[i];
    if (UserMagic <> nil) and (UserMagic.wMagIdx in [prenIndex, prenIndex1, prenIndex2])
      then
    begin
      Result := True;
      break;
    end;
  end;
  if not Result then
  begin
    Magic := UserEngine.FindMagic(prenIndex);
    if Magic <> nil then
      SysMsg('若想获得该技能，必须先学习' + Magic.sMagicName, c_Red, t_Hint);
  end;
end;

procedure TPlayObject.SendAddMagic(UserMagic: pTUserMagic); //004D12F4
var
  ClientMagic                                          : TClientMagic;
begin
  ClientMagic.Key := Char(UserMagic.btKey);
  ClientMagic.Level := UserMagic.btLevel;
  ClientMagic.CurTrain := UserMagic.nTranPoint;
  ClientMagic.Def := UserMagic.MagicInfo^;
  m_DefMsg := MakeDefaultMsg(SM_ADDMAGIC, 0, 0, 0, 1);
  SendSocket(@m_DefMsg, EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)));
end;

procedure TPlayObject.SendDelMagic(UserMagic: pTUserMagic);
begin
  m_DefMsg := MakeDefaultMsg(SM_DELMAGIC, UserMagic.wMagIdx, 0, 0, 1);
  SendSocket(@m_DefMsg, '');
end;

function TPlayObject.EatUseItems(nShape: integer): Boolean; //004BD1BC
var
  Castle                                               : TUserCastle;
begin
  Result := False;
  if m_boArrow then
  begin //如果在夺宝期间 //卷轴只能使用随机
    if nshape in [1, 3, 5] then
    begin
      SysMsg('现在不能使用', c_red, t_Hint);
      exit;
    end;
    if nshape = 2 then
    begin
      if GetTickCount - m_nArrowEattick < m_nArrowtime then
      begin
        SysMsg('您刚刚使用过，请稍候再用', c_red, t_Hint);
        exit;
      end
      else
      begin                                                 //可以使用
        m_nArrowEattick := GetTickCount();
      end;
    end;                                                    //=2
  end;                                                      //m_boArrow

  case nShape of                                            //
    1:
      begin
        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        BaseObjectMove(m_sHomeMap, '', '');
        Result := True;
      end;
    2:
      begin
        if not m_PEnvir.m_boNORANDOMMOVE then
        begin
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          BaseObjectMove(m_sMapName, '', '');
          Result := True;
        end;
      end;
    3:
      begin
        SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        if PKLevel < 2 then
        begin
          BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY));
        end
        else
        begin
          BaseObjectMove(g_Config.sRedHomeMap, IntToStr(g_Config.nRedHomeX),
            IntToStr(g_Config.nRedHomeY));
        end;
        Result := True;
      end;
    4:
      begin
        if WeaptonMakeLuck() then
          Result := True;
      end;
    5:
      begin
        if m_MyGuild <> nil then
        begin
          if not m_boInFreePKArea then
          begin
            Castle := g_CastleManager.IsCastleMember(Self);
            {
            if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
              BaseObjectMove(UserCastle.m_sHomeMap,IntToStr(UserCastle.GetHomeX),IntToStr(UserCastle.GetHomeY));
            }
            if (Castle <> nil) and Castle.IsMasterGuild(TGuild(m_MyGuild)) then
            begin
              BaseObjectMove(Castle.m_sHomeMap, IntToStr(Castle.GetHomeX),
                IntToStr(Castle.GetHomeY));
            end
            else
            begin
              SysMsg('无效', c_Red, t_Hint);
            end;
            Result := True;
          end
          else
          begin                                             //004BD3F7
            SysMsg('此处无法使用', c_Red, t_Hint);
          end;
        end;
      end;
    9:
      begin
        if RepairWeapon() then
          Result := True;
      end;
    10:
      begin
        if SuperRepairWeapon() then
          Result := True;
      end;
    11:
      begin
        if WinLottery() then
          Result := True;
      end;
  end;
end;

procedure TPlayObject.MoveToHome;
begin
  SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
  BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY));
end;

procedure TPlayObject.BaseObjectMove(sMap, sX, sY: string); //004BD0C4
var
  Envir                                                : TEnvirnoment;
  nX, nY                                               : Integer;
begin
  Envir := m_PEnvir;

  if sMap = '' then
    sMap := m_sMapName;
  if (sX <> '') and (sY <> '') then
  begin
    nX := Str_ToInt(sX, 0);
    nY := Str_ToInt(sY, 0);
    SpaceMove(sMap, nX, nY, 0);
  end
  else
  begin
    MapRandomMove(sMap, 3); //这里修改让随机卷不受夺宝限制   //0
  end;
  if (Envir <> m_PEnvir) and (m_btRaceServer = RC_PLAYOBJECT) then
  begin
    m_boTimeRecall := False;
  end;

end;
//使用祝福油

function TPlayObject.WeaptonMakeLuck: Boolean;              //004BD4A0
var
  StdItem                                              : pTStdItem;
  nRand                                                : Integer;
  boMakeLuck                                           : Boolean;
begin
  Result := False;
  if m_UseItems[U_WEAPON].wIndex <= 0 then
    exit;
  nRand := 0;
  StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
  if StdItem <> nil then
  begin
    nRand := abs((HiByte(StdItem.DC) - LoByte(StdItem.DC))) div 5;
  end;
  if Random(g_Config.nWeaponMakeUnLuckRate {20}) = 1 then
  begin
    MakeWeaponUnlock();
  end
  else
  begin                                                     //004BD527
    boMakeLuck := False;
    if m_UseItems[U_WEAPON].btValue[4] > 0 then
    begin
      Dec(m_UseItems[U_WEAPON].btValue[4]);
      SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
      boMakeLuck := True;
    end
    else
      if m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint1 {1} then
      begin
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
        boMakeLuck := True;
      end
      else
        if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint2 {3}) and
          (Random(nRand + g_Config.nWeaponMakeLuckPoint2Rate {6}) = 1) then
        begin
          Inc(m_UseItems[U_WEAPON].btValue[3]);
          SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
          boMakeLuck := True;
        end
        else
          if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint3 {7}) and
            (Random(nRand * g_Config.nWeaponMakeLuckPoint3Rate {10 + 30}) = 1) then
          begin
            Inc(m_UseItems[U_WEAPON].btValue[3]);
            SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green, t_Hint);
            boMakeLuck := True;
          end;
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      RecalcAbilitys();
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      SendUpdateItem(@m_UseItems[U_WEAPON]);
    end;
    if not boMakeLuck then
      SysMsg(g_sWeaptonNotMakeLuck {'无效'}, c_Green, t_Hint);
  end;
  Result := True;
end;

function TPlayObject.RepairWeapon: Boolean;                 //004BD69C
var
  nDura                                                : Integer;
  UserItem                                             : pTUserItem;
begin
  Result := False;
  UserItem := @m_UseItems[U_WEAPON];
  if (UserItem.wIndex <= 0) or (UserItem.DuraMax <= UserItem.Dura) then
    exit;
  Dec(UserItem.DuraMax, (UserItem.DuraMax - UserItem.Dura) div g_Config.nRepairItemDecDura
    {30});
  nDura := _MIN(5000, UserItem.DuraMax - UserItem.Dura);
  if nDura > 0 then
  begin
    Inc(UserItem.Dura, nDura);
    SendMsg(Self, RM_DURACHANGE, 1, UserItem.Dura, UserItem.DuraMax, 0, '');
    SysMsg(g_sWeaponRepairSuccess {'武器修复成功...'}, c_Green, t_Hint);
    Result := True;
  end;
end;

function TPlayObject.SuperRepairWeapon: Boolean;            //004BD768
begin
  Result := False;
  if m_UseItems[U_WEAPON].wIndex <= 0 then
    exit;
  m_UseItems[U_WEAPON].Dura := m_UseItems[U_WEAPON].DuraMax;
  SendMsg(Self, RM_DURACHANGE, 1, m_UseItems[U_WEAPON].Dura,
    m_UseItems[U_WEAPON].DuraMax, 0, '');
  SysMsg(g_sWeaponRepairSuccess {'武器修复成功...'}, c_Green, t_Hint);
  Result := True;
end;

function TPlayObject.WinLottery: Boolean;                   //004BD7F8
var
  nGold, nWinLevel, nRate                              : Integer;
begin
  nGold := 0;
  nWinLevel := 0;
  {
  case Random(30000) of
    0..4999: begin //004BD866
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=500;
       nWinLevel:=6;
       Inc(nWinLotteryLevel6);
     end;
    end;
    14000..15999: begin //004BD895
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=1000;
       nWinLevel:=5;
       Inc(nWinLotteryLevel5);
     end;
    end;
    16000..16149: begin //004BD8C4
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=10000;
       nWinLevel:=4;
       Inc(nWinLotteryLevel4);
     end;
    end;
    16150..16169: begin //004BD8F0
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=100000;
       nWinLevel:=3;
       Inc(nWinLotteryLevel3);
     end;
    end;
    16170..16179: begin //004BD918
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=200000;
       nWinLevel:=2;
       Inc(nWinLotteryLevel2);
     end;
    end;
    16180 + 1820: begin //004BD940
     if nWinLotteryCount < nNoWinLotteryCount then begin
       nGold:=1000000;
       nWinLevel:=1;
       Inc(nWinLotteryLevel1);
     end;
    end;
  end;
  }
  nRate := Random(g_Config.nWinLotteryRate);
  if nRate in [g_Config.nWinLottery6Min..g_Config.nWinLottery6Max] then
  begin
    if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
    begin
      nGold := g_Config.nWinLottery6Gold;
      nWinLevel := 6;
      Inc(g_Config.nWinLotteryLevel6);
    end;
  end
  else
    if nRate in [g_Config.nWinLottery5Min..g_Config.nWinLottery5Max] then
    begin
      if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
      begin
        nGold := g_Config.nWinLottery5Gold;
        nWinLevel := 5;
        Inc(g_Config.nWinLotteryLevel5);
      end;
    end
    else
      if nRate in [g_Config.nWinLottery4Min..g_Config.nWinLottery4Max] then
      begin
        if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
        begin
          nGold := g_Config.nWinLottery4Gold;
          nWinLevel := 4;
          Inc(g_Config.nWinLotteryLevel4);
        end;
      end
      else
        if nRate in [g_Config.nWinLottery3Min..g_Config.nWinLottery3Max] then
        begin
          if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
          begin
            nGold := g_Config.nWinLottery3Gold;
            nWinLevel := 3;
            Inc(g_Config.nWinLotteryLevel3);
          end;
        end
        else
          if nRate in [g_Config.nWinLottery2Min..g_Config.nWinLottery2Max] then
          begin
            if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
            begin
              nGold := g_Config.nWinLottery2Gold;
              nWinLevel := 2;
              Inc(g_Config.nWinLotteryLevel2);
            end;
          end
          else
            if nRate in [g_Config.nWinLottery1Min + g_Config.nWinLottery1Max] then
            begin
              if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
              begin
                nGold := g_Config.nWinLottery1Gold;
                nWinLevel := 1;
                Inc(g_Config.nWinLotteryLevel1);
              end;
            end;
  if nGold > 0 then
  begin
    case nWinLevel of                                       //
      1: SysMsg(g_sWinLottery1Msg {'祝贺您，中了一等奖。'}, c_Green, t_Hint);
      2: SysMsg(g_sWinLottery2Msg {'祝贺您，中了二等奖。'}, c_Green, t_Hint);
      3: SysMsg(g_sWinLottery3Msg {'祝贺您，中了三等奖。'}, c_Green, t_Hint);
      4: SysMsg(g_sWinLottery4Msg {'祝贺您，中了四等奖。'}, c_Green, t_Hint);
      5: SysMsg(g_sWinLottery5Msg {'祝贺您，中了五等奖。'}, c_Green, t_Hint);
      6: SysMsg(g_sWinLottery6Msg {'祝贺您，中了六等奖。'}, c_Green, t_Hint);
    end;
    if IncGold(nGold) then
    begin
      GoldChanged();
    end
    else
    begin
      DropGoldDown(nGold, True, nil, nil);
    end;

  end
  else
  begin
    Inc(g_Config.nNoWinLotteryCount, 500);
    SysMsg(g_sNotWinLotteryMsg {'等下次机会吧！！！'}, c_Red, t_Hint);
  end;
  Result := True;
end;

procedure TBaseObject.DamageBubbleDefence(nInt: Integer);   //004C6ED0
begin
  if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] > 0 then
  begin
    if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] > 3 then
      Dec(m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}], 3)
    else
      m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] := 1;
  end;
end;

function TBaseObject.IsGuildMaster: Boolean;                //004BF4A0
begin
  Result := False;
  if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then
    Result := True;
end;

procedure TPlayObject.ChangeServerMakeSlave(SalveInfo: pTSlaveInfo); //004DF84C
var
  nSlavecount                                          : Integer;
  BaseObject                                           : TBaseObject;
begin
  if m_btJob = 2 then
  begin
    nSlavecount := 1;
  end
  else
  begin
    nSlavecount := 5;
  end;
  BaseObject := MakeSlave(SalveInfo.sSalveName, 3, SalveInfo.btSalveLevel, nSlavecount,
    SalveInfo.dwRoyaltySec);
  if BaseObject <> nil then
  begin
    BaseObject.n294 := SalveInfo.nKillCount;
    BaseObject.m_btSlaveExpLevel := SalveInfo.btSlaveExpLevel;
    BaseObject.m_WAbil.HP := SalveInfo.nHP;
    BaseObject.m_WAbil.MP := SalveInfo.nMP;
    if (1500 - SalveInfo.btSalveLevel * 200) < BaseObject.m_nWalkSpeed then
    begin
      BaseObject.m_nWalkSpeed := 1500 - SalveInfo.btSalveLevel * 200;
    end;
    if Integer(2000 - SalveInfo.btSalveLevel * 200) < BaseObject.m_nNextHitTime then
    begin
      BaseObject.m_nWalkSpeed := 2000 - SalveInfo.btSalveLevel * 200;
    end;
    RecalcAbilitys();
  end;
end;

procedure TPlayObject.SendDelDealItem(UserItem: pTUserItem); //004DD5D0
var
  StdItem                                              : pTStdItem;
  ClientItem                                           : TClientItem;

  sUserItemName                                        : string;
begin

  SendDefMessage(SM_DEALDELITEM_OK, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then
  begin

    begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        ClientItem.S := StdItem^;

        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex,
            UserItem.wIndex);
        if sUserItemName <> '' then
          ClientItem.S.Name := sUserItemName;
        ClientItem.DarkProperty := Useritem.DarkProp; // ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);
        ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
      end;
      m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEDELITEM, Integer(Self), 0, 0, 1);
      TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem,
        SizeOf(TClientItem)));
    end;
    m_DealCreat.m_DealLastTick := GetTickCount();
    m_DealLastTick := GetTickCount();
  end;
end;

procedure TPlayObject.ClearItemEvil;

var
  UserItem                                             : PTUserItem;
begin
  UserItem := GetItems(m_nYuJingPingIndex);
  if UserItem <> nil then
    FillChar(Useritem.DarkProp, SizeOf(TDarkProperty), 0);

end;

function TPlayObject.CheckMagic(sMagicName, sType: string; nLevel: Integer): Boolean;
var
  i                                                    : Integer;
  UserMagic                                            : pTUserMagic;
begin
  Result := False;
  for I := 0 to m_MagicList.Count - 1 do
  begin
    UserMagic := m_MagicList.Items[I];
    if CompareText(UserMagic.MagicInfo.sMagicName, sMagicName) = 0 then
    begin
      if (sType = '=') and (UserMagic.btLevel = nLevel) then
        Result := True;
      if (sType = '>') and (UserMagic.btLevel > nLevel) then
        Result := True;
      if (sType = '<') and (UserMagic.btLevel < nLevel) then
        Result := True;
      break;
    end;
  end;
end;

procedure TPlayObject.OPENMAGICBOX(nType: Integer; sParam, sLabel: string);
var
  sSendMsg                                             : string;
  sItemName, sSelect                                   : string;
  nIdx                                                 : Integer;
  StdItem                                              : PTStdItem;
begin
  nIdx := 0;
  FillChar(m_BoxItem, SizeOf(TBoxItem) * 11, 0);
  while (sParam <> '') do
  begin
    sParam := GetValidStr3(sParam, sItemName, ['|']);
    sSelect := GetValidStr3(sItemName, sItemName, ['/']);
    StdItem := UserEngine.GetStdItem(sItemName);
    m_BoxItemSelected[nIdx] := sSelect <> '';
    m_BoxItem[nIdx].SName := sItemName;
    m_BoxItem[nIdx].wLooks := 0;
    if StdItem <> nil then m_BoxItem[nIdx].wLooks := stditem.Looks;
    Inc(nIdx);
    if nIdx > 10 then Break;

  end;
  Inc(m_OpenBoxIndex);
  m_OpenBoxIndex := m_OpenBoxIndex mod 9;
  m_sBoxLable := sLabel;
  sSendMsg := EncodeBuffer(@m_boxItem, SizeOf(TBoxItem) * 11);
  //    m_DefMsg := MakeDefaultMsg(627,Integer(Self), 1, 8, nType);
  m_DefMsg := MakeDefaultMsg(627, Integer(Self), 261, 11, nType);
  SendSocket(@m_DefMsg, sSendMsg);
  m_sParam[0] := IntToStr(m_OpenBoxIndex);
end;

procedure TPlayObject.SetBlessPower(nPower: Integer);
begin
  m_DefMsg := MakeDefaultMsg(627, Integer(Self), 268, nPower, 0);
  SendSocket(@m_DefMsg, '');
end;

procedure TPlayObject.ClientOpenMagicBox(nStep: Integer; nItemMake1, nItemMake2:
  Integer);
var
  m_Looks                                              : array[0..7] of TBoxItemInfo;
  i                                                    : Integer;
  sSendMsg                                             : string;
  UserItem                                             : pTUserItem;
begin
  case nStep of
    264:
      begin
        FillChar(m_looks, SizeOf(TBoxiTemInfo) * 8, 0);
        {      for I := 0 to 10 do
              begin
                 if m_BoxItemSelected[i] then
                 Begin
                    m_Looks[0].wLooks:=m_boxitem[i].wLooks;
                    strpcopy(m_Looks[0].sName,m_BoxItem[i].SName);
                 End;
             end;
         }
        m_Looks[0].wLooks := m_boxitem[m_OpenBoxIndex].wLooks;
        strpcopy(m_Looks[0].sName, m_BoxItem[m_OpenBoxIndex].SName);

        sSendMsg := EncodeBuffer(@m_Looks, SizeOf(TBoxiTemInfo) * 8);
        m_DefMsg := MakeDefaultMsg(627, Integer(Self), 262, 4, 0);
        SendSocket(@m_DefMsg, sSendMsg);
        //if g_FunctionNPC<>nil then
           //g_FunctionNPC.GotoLable(Self,m_sBoxLable,false);
      end;
    266:
      begin
        if g_FunctionNPC <> nil then
          g_FunctionNPC.GotoLable(Self, m_sBoxLable, false);
        {
    for I := 0 to 7 do
     begin
        if m_BoxItemSelected[i] then
        begin
            New(UserItem);
            UserEngine.CopyToUserItemFromName(m_boxitem[i].SName, UserItem);
            if AddItemToBag(UserItem) then
            begin
               SendAddItem(UserItem);
               SysMsg('你得到了'+m_boxitem[i].SName,c_Green,t_Hint);
            end
            else
            begin
              DisPose(UserItem);
            end;

        end;
     end;        }

      end;
    265:                                                    //再开一个宝箱
      begin
        UserItem := CheckItems(m_sEatName);
        if UserItem <> nil then
        begin
          ClientUseItems(Useritem.MakeIndex, 0, m_sEatName);
        end;
      end;
    268:                                                    //祈愿树放入物品
      begin

        m_sParam[0] := '0';
        m_sParam[1] := IntToStr(nItemMake1);
        m_sParam[2] := IntToStr(nItemMake2);

        if m_NPC1 <> nil then
        begin
          TMerchant(m_NPC1).GotoLable(Self, '@StartBless', false);

        end;

        //         m_DefMsg := MakeDefaultMsg(627,Integer(Self), 268, 1, 0);
        //      SendSocket(@m_DefMsg, sSendMsg);
      end;
    524:                                                    //开始祈愿
      begin
        m_sParam[0] := '1';
        m_sParam[1] := IntToStr(nItemMake1);
        m_sParam[2] := IntToStr(nItemMake2);
        if m_NPC1 <> nil then
        begin
          TMerchant(m_NPC1).GotoLable(Self, '@StartBless', false);

        end;
      end;

  end;
end;

procedure TPlayObject.SETMagicBox(sParam: string);
var
  i                                                    : Integer;
  sIdx                                                 : string;
begin
  FillChar(m_BoxItemSelected, 11, #0);
  sParam := GetValidStr3(sParam, sidx, ['/']);
  for I := 0 to 10 do
  begin
    if sIdx = '' then Break;
    if sIdx = '1' then
      m_BoxItemSelected[i] := True;
    sParam := GetValidStr3(sParam, sidx, ['/']);

  end;
end;

procedure TPlayObject.ClientMessageA(npcidx, nIdx: Integer);
var
  Npc                                                  : TNormNpc;
begin

  Npc := UserEngine.FindMerchant(TObject(npcidx));
  if Npc = nil then
    Npc := UserEngine.FindNPC(TObject(npcidx));
  if Npc = nil then
    exit;
  Npc.GotoLable(self, m_sMessageLabeOK + Inttostr(nIdx), False)
end;

procedure TPlayObject.messageA(nIdend: Integer; sText, sLabelOk, sLabelCancel: string);
begin
  sText := AnsiReplaceStr(sText, '\', #13#10);
  SendDefMessage(193, nIdend, 0, 0, 1, sText);
  m_sMessageLabeOK := sLabelOk;
  m_sMessageLableCancel := sLabelCancel;

end;

procedure TPlayObject.CLientAddZhenmoValue(nMakeIndex, nMakeIndex1: Integer);
var

  userItem                                             : PTUserItem;
  userItem1                                            : PTUserItem;
  Baseobject                                           : TBaseObject;
  stditem                                              : pTStdItem;
  i, uindex                                            : Integer;

begin
  userItem := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    userItem := m_ItemList[i];
    if userItem.MakeIndex = nMakeIndex then
    begin
      uindex := i;
      Break;
    end;
    userItem := nil;
  end;
  if userItem = nil then
  begin
    SysMsg('非法的装备', c_Red, t_Hint);
    Exit;
  end;
  userItem1 := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    userItem1 := m_ItemList[i];
    if userItem1.MakeIndex = nMakeIndex1 then
      Break;
    userItem1 := nil;
  end;
  if userItem1 = nil then
  begin
    SysMsg('非法的装备', c_Red, t_Hint);
    Exit;
  end;
  stditem := UserEngine.GetStdItem(UserItem.wIndex);
  if Stditem = nil then exit;
  m_sParam[5] := stditem.Name;
  if (Stditem.StdMode <> 3) or (stditem.Shape <> 27) then
  begin
    SysMsg('不能给该物品附魔!', c_Red, t_Hint);
    Exit;
  end;
  //  pAttachMagicRCD:=ItemUnit.GetItemAttachMagic(nMakeIndex1);
  if userItem1.AttachMagic.MakeIndex = 0 then
  begin
    SysMsg('该装备上没有心魔了', c_Red, t_Hint);
    Exit;
  end;
  userItem1.AttachMagic.ZMValue := userItem1.AttachMagic.ZMValue + Stditem.AC * 1000;
  // DarkProperty:=ItemUnit.GetItemDarkProperty(useritem1.MakeIndex,useritem1.wIndex);
  userItem1.DarkProp.DMagic := userItem1.DarkProp.DMagic + Stditem.AC *
    g_config.nAddDarkofZMZ + g_config.nAddDarkofValue +
    random(g_Config.nAddDarkofRandValue);
  SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
  m_ItemList.Delete(uindex);
  stditem := UserEngine.GetStdItem(UserItem1.wIndex);
  if g_FunctionNPC <> nil then
  begin
    m_sParam[0] := Useritem1.AttachMagic.MercenaryName;
    m_sParam[2] := IntToStr(Useritem1.MakeIndex);
    m_sParam[3] := IntToStr(nMakeIndex1);
    m_sParam[4] := stditem.Name;
    g_FunctionNPC.GotoLable(Self, '@增加镇魔值', False);

  end;
  SendDelItems(userItem);
  Dispose(userItem);
  SendUpdateItem(userItem1);
  m_DefMsg := MakeDefaultMsg(207, Integer(Self), 40, 0, 1);
  SendSocket(@m_DefMsg, EncodeBuffer(@userItem1.AttachMagic.aaa,
    SizeOf(TAttachMagicRCD1)));
  SysMsg(StdItem.name + '的镇魔值和黑暗魔力都获得了提升!', c_Red, t_Hint);
end;

procedure TPlayObject.SendYuanYingInfo();
var
  sSendMSg                                             : string;
  buf                                                  : array[0..11] of Byte;
  i                                                    : Integer;
  wYs, w                                               : Word;
begin
  w := 0;
  //CopyMemory(@buf,@btAdditionalAbil[3],12);
  if btAdditionalAbil[2] > 0 then
  begin
    sSendMSg := EncodeBuffer(@btAdditionalAbil[3], 12);
    w := 3;
  end
  else
    sSendMSg := '';
  wYs := 0;
  if btHasYS2 = 1 then
  begin
    wYs := MakeWord(wyslevel_1, nysjob_1);
  end;
  if btHasYS2 = 2 then
  begin
    wYs := MakeWord(wyslevel, nysjob);
  end;
  if sYsname <> '' then
    SendDefMessage(3040, Integer(self), MakeWord(4, btAdditionalAbil[2]), 10, wys,
      sSendMSg, True)
  else
    SendDefMessage(3040, Integer(self), MakeWord(w, btAdditionalAbil[2]), 10, wys,
      sSendMSg, True)

end;

function TPlayObject.GetADDITIONALABIL(nPos: Integer): byte;
begin
  Result := 0;
  case nPos of
    0..7: result := btAdditionalAbil[nPos];
    8: Result := (btAdditionalAbil[8]and$F0) shr 4;
    9: Result := (btAdditionalAbil[8]and$0F);
    10: Result := (btAdditionalAbil[13]and$F0) shr 4;
    11: Result := (btAdditionalAbil[13]and$0F);
    12: Result := (btAdditionalAbil[14]and$F0) shr 4;
    13: Result := (btAdditionalAbil[14]and$0F);
    14: Result := (btAdditionalAbil[9]and$F0) shr 4;
    15: Result := (btAdditionalAbil[9]and$0F);
    16: Result := (btAdditionalAbil[10]and$F0) shr 4;
    17: Result := (btAdditionalAbil[10]and$0F);
    18: Result := (btAdditionalAbil[11]);
    19: Result := (btAdditionalAbil[12]and$F0) shr 4;
    20: Result := (btAdditionalAbil[12]and$0F);

  end;
end;

procedure TPlayObject.SendLXBHInfo(btSendItem: Byte = 0);
var
  LXBHInfo                                             : TLXBHInfo;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint, tint2                                          : integer;
  body                                                 : array[0..10000] of char;
  magicBody                                            : array[0..10000] of Char;
  PetAddProperty                                       : array[0..66] of TPetAddProperty;
  nPetCount                                            : iNTEGER;
  Item                                                 : pTStdItem;
  StdItem                                              : TStdItem;
  sSendMsg                                             : string;
  ClientItem                                           : TClientItem;
  sUserItemName                                        : string;
  i, ii, jjj                                           : Integer;
begin
  case btSendItem of
    0:                                                      //开启灵犀宝盒
      begin
        FillChar(LXBHInfo, SizeOf(TLxbhInfo), #0);
        LXBHInfo.sName := '灵犀宝盒';
        LXBHInfo.nTime1 := $50D1AD2A;                       //Now+114;
        LXBHInfo.nTime2 := nLXBHTIme;                       //Now+114;
        LXBHInfo.btItemCOunt := btLXBHItemCount;
        LXBHInfo.HeziCOunt := btLXBHCount;
        LXBHInfo.HZCount := btLXBHCount;
        SendDefMessage(854, 0, 0, 0, 0, EncodeBuffer(@LXBHInfo, SizeOf(TLXBHInfo)),
          True);

      end;
    1:
      begin

        for I := 0 to 19 do
        begin
          if LXBHITEM[i].MakeIndex > 0 then
          begin
            Item := UserEngine.GetStdItem(LXBHITEM[i].wIndex);
            if Item <> nil then
            begin
              StdItem := Item^;
              ItemUnit.GetItemAddValue(@LXBHITEM[i], StdItem);
              ClientItem.S := StdItem;
              // ItemUnit.GetItemAddValue(UserItem, ClientItem.S);
             //取自定义物品名称
              sUserItemName := '';
              if LXBHITEM[i].btValue[13] = 1 then
                sUserItemName := ItemUnit.GetCustomItemName(LXBHITEM[i].MakeIndex,
                  LXBHITEM[i].wIndex);
              if sUserItemName <> '' then
                ClientItem.S.Name := sUserItemName;
              ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
              //获取黑暗属性
              ClientItem.DarkProperty := LXBHITEM[i].DarkProp;  //ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);
              if ClientItem.S.StdMode <> 37 then
                ClientItem.DarkProperty.B3 := $E3;
              ///////////////
              if (ClientItem.S.StdMode = 49) and (ClientItem.S.Shape in [18, 22]) then
              begin

                copymemory(@tint, @LXBHITEM[i].btValue[0], 4);
                if tint <> 0 then
                begin
                  MyTime := EncodeTime(8, 00, 00, 0);
                  mydate := encodedate(1970, 01, 01);
                  date1 := mydate + mytime;
                  mydate := date();
                  mytime := time();
                  date2 := mydate + mytime;
                  tint2 := round((date2 - date1) * 86400);
                  tint := round((tint2 - tint) / 86400);
                  if ClientItem.S.DuraMax - tint > 0 then
                  begin
                    ClientItem.S.DuraMax := ClientItem.S.DuraMax - tint;
                  end
                  else
                  begin
                    if g_FunctionNPC <> nil then
                    begin
                      g_FunctionNPC.GotoLable(Self, '@ItemTimeOver' +
                        IntToStr(UserEngine.GetItemAnicount(LXBHITEM[i].wIndex)), False);
                    end;
                    //物品到期触发
                    LXBHITEM[i].MakeIndex := 0;
                    SysMsg('你的物品' + ClientItem.S.Name +
                      '使用期限已过，自动从包裹中消失了', c_Red, t_Hint);
                    Continue;
                  end;
                end;
              end;
              ClientItem.Dura := LXBHITEM[i].Dura;
              ClientItem.DuraMax := LXBHITEM[i].DuraMax;
              ClientItem.MakeIndex := LXBHITEM[i].MakeIndex;
              if StdItem.StdMode = 50 then
              begin
                ClientItem.S.Name := ClientItem.S.Name + ' #' +
                  IntToStr(LXBHITEM[i].Dura);
              end;
              if LXBHITEM[i].AttachMagic.MakeIndex = LXBHITEM[i].MakeIndex then
              begin
                CopyMemory(@Magicbody[SizeOf(TAttachMagicRCD1) * jjj],
                  @LXBHITEM[i].AttachMagic.aaa, SizeOf(TAttachMagicRCD1));
                Inc(jjj);

              end;
              if (ClientItem.S.StdMode = 49) and (ClientItem.S.Shape = 51) then
              begin
                if LXBHITEM[i].AttachMagic.aaa.PetAddProperty.nMakeIndex =
                  LXBHITEM[i].MakeIndex then
                begin
                  PetAddProperty[nPetCount] :=
                    LXBHITEM[i].AttachMagic.aaa.PetAddProperty;
                  ClientItem.DarkProperty.btid := 1;
                  //  ClientItem.DarkProperty.DMagic:=$8100;
                  ClientItem.s.AniCount := 0;
                  ClientItem.S.Reserved := 0;
                  ClientItem.DuraMax := 17;
                  // PetAddProperty[nPetCount].btvalue3:=$10;
                  Inc(nPetCount);
                end;
              end;
              copymemory(@body[SizeOf(TClientItem) * ii], @ClientItem,
                SizeOf(TClientItem));
              inc(ii);
            end;
          end;                                              //while
        end;
        if ii >= 1 then
          sSendMsg := EncodeBuffer(@body, SizeOf(TClientItem) * ii);

        if sSendMsg <> '' then
        begin
          m_DefMsg := MakeDefaultMsg(854, 0, MakeWord(1, ii), 0, 0);
          SendSocket(@m_DefMsg, sSendMsg);

        end;
        if jjj >= 1 then
        begin
          sSendMsg := EncodeBuffer(@Magicbody, SizeOf(TAttachMagicRCD1) * jjj);
          m_DefMsg := MakeDefaultMsg(207, //str_toint( myMuldecodeString(keystring.SM_BAGITEMS,Str_ToInt(arrip[7],0))                        //
            Integer(Self), 40, 0, jjj);
          SendSocket(@m_DefMsg, sSendMsg);
        end;
        //五行属性
        if nPetCount > 0 then
        begin

          m_DefMsg := MakeDefaultMsg(34983, Integer(Self), 24, 0, nPetCount);
          SendSocket(@m_DefMsg, EncodeBuffer(@PetAddProperty, SizeOf(TPetAddProperty) *
            nPetCOunt));

        end;

      end;
  end;
end;

procedure TPlayObject.ClientAddLXBH(nParam, nRecog, nSeries: Integer);
var
  LXBHInfo                                             : TLXBHInfo;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint, tint2                                          : integer;
  userItem                                             : PTUserItem;
  i, ii                                                : Integer;
  stditem                                              : pTStdItem;
begin
  case nParam of
    1:                                                      //开启灵犀宝盒
      begin
        FillChar(LXBHInfo, SizeOf(TLxbhInfo), #0);
        MyTime := EncodeTime(8, 00, 00, 0);
        mydate := encodedate(1970, 01, 01);
        date1 := mydate + mytime;
        mydate := date() + 7;
        mytime := time();
        date2 := mydate + mytime;
        nLXBHTime := round((date2 - date1) * 86400);
        btLXBHCount := 10;
        btLXBHItemCount := 0;
        SendLXBHInfo();
      end;
    4:                                                      //注入灵灵力
      begin
        if nSeries < btLXBHCount then
        begin
          SysMsg(' 你的宝盒有<' + Inttostr(btLXBHCount) + '>个格子，每次注入最少需要<' +
            Inttostr(btLXBHCount) + '点灵力>！', c_Red, t_Hint);
          Exit;
        end;
        if m_YSPoint < nSeries then
        begin
          SysMsg('你的灵力值不足10点，无法扩充宝盒格子！', c_Red, t_Hint);
          Exit;
        end;
        Dec(m_YSPoint, nSeries);
        Inc(nLXBHTime, 7 * 86400);
        SendLXBHInfo();
        SysMsg('你的灵力注入成功，灵力值减少<' + Inttostr(btLXBHCount) +
          '>点，宝盒使用时间增加<7天>！', c_Red, t_Hint);

      end;
    7:                                                      //扩充格子
      begin
        if m_YSPoint < 10 then
        begin
          SysMsg('你的灵力值不足10点，无法扩充宝盒格子！', c_Red, t_Hint);
          Exit;
        end;
        if btLXBHCount > 19 then
        begin
          SysMsg('你的灵犀宝盒已经达到最大格子数量不能再扩充了！', c_Red, t_Hint);
          Exit;
        end;
        Dec(m_YsPoint, 10);
        Inc(btLxBhCOunt, 2);
        SendLXBHInfo();
        SysMsg('你的灵犀宝盒格子扩充成功，你当前拥有<' + Inttostr(btLXBHCount) +
          '>个宝盒格子！', c_Red, t_Hint);

      end;
    6:                                                      //包裹物品放到盒子里
      begin
        for I := 0 to m_ItemList.Count - 1 do
        begin
          UserItem := nil;
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nRecog) then
          begin
            if UserEngine.GetStdItemName(UserItem.wIndex) = m_sArrowitem then
            begin
              SysMsg('夺宝宝盒不能放在灵犀宝盒里', c_Red, t_Hint);
              Exit;
            end;
            stditem := UserEngine.GetStdItem(UserItem.wIndex);
            if stditem.Reserved = 11 then
            begin                                           //stditem.StdMode =49
              SysMsg('此物品禁止交易,不能放在灵犀宝盒里', c_red, t_Hint);
              Exit;
            end;
            if GetBoValue(UserItem, UserItem.wIndex, 0) then
            begin
              SysMsg('此物品禁止交易,不能放在灵犀宝盒里', c_red, t_Hint);
              Exit;
            end;
            for ii := 0 to 19 do
            begin
              if LXBHITEM[ii].MakeIndex = 0 then
              begin
                LXBHITEM[ii] := UserItem^;
                Inc(btLXBHItemCount);
                SendLXBHInfo(1);
                SendDefMessage(854, nRecog, btLXBHItemCount, 0, 0, '');
                Dispose(userItem);
                m_ItemList.Delete(i);
                Exit;
              end;
            end;

          end;
        end;

      end;
    5:                                                      //盒子物品到包裹
      begin
        for I := 0 to 19 do
        begin
          if LXBHITEM[i].MakeIndex = nRecog then
          begin
            if IsEnoughBag then
            begin
              New(UserItem);
              UserItem^ := LXBHITEM[i];
              LXBHITEM[i].MakeIndex := 0;
              Dec(btlxbhItemCount);
              m_ItemList.Add(UserItem);
              SendDefMessage(854, nRecog, 2, 0, 0, '');
              SendAddItem(userItem);

            end;
            Break;
          end;

        end;

      end;
  end;
end;

procedure TPlayObject.CLientAddEvil(nMakeIndex, nMakeIndex1: Integer);
var

  userItem                                             : PTUserItem;
  userItem1                                            : PTUserItem;
  Baseobject                                           : TBaseObject;
  stditem                                              : pTStdItem;
  i                                                    : Integer;
begin
  userItem := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    userItem := m_ItemList[i];
    if userItem.MakeIndex = nMakeIndex then
      Break;
    userItem := nil;
  end;
  if userItem = nil then
  begin
    SysMsg('非法的玉净瓶', c_Red, t_Hint);
    Exit;
  end;
  userItem1 := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    userItem1 := m_ItemList[i];
    if userItem1.MakeIndex = nMakeIndex1 then
      Break;
    userItem1 := nil;
  end;
  if userItem1 = nil then
  begin
    SysMsg('非法的装备', c_Red, t_Hint);
    Exit;
  end;
  stditem := UserEngine.GetStdItem(UserItem1.wIndex);
  if Stditem = nil then exit;
  if not StdItem^.StdMode in [5, 6, 10, 11, 15, 19, 21, 22, 23, 24, 25, 26, 29, 30, 33,
    34, 51, 58, 59, 64, 81, 82] then
  begin
    SysMsg('不能给该物品附魔!', c_Red, t_Hint);
    Exit;
  end;
  //  pAttachMagicRCD:=ItemUnit.GetItemAttachMagic(nMakeIndex);
  if userItem.MakeIndex = 0 then
  begin
    SysMsg('该玉净瓶没有封印过心魔了', c_Red, t_Hint);
    Exit;
  end;
  m_nYuJingPingIndex := nMakeIndex;
  m_sParam[1] := IntToStr(nMakeIndex);
  m_nFuMoItemIndex := nMakeIndex1;
  m_sParam[2] := IntToStr(nMakeIndex1);
  m_sParam[4] := Stditem^.Name;
  stditem := UserEngine.GetStdItem(UserItem.wIndex);
  if stditem = nil then Exit;
  m_sParam[3] := Stditem^.Name;
  m_sParam[0] := userItem.AttachMagic.MercenaryName;
  if g_FunctionNPC <> nil then
    g_FunctionNPC.GotoLable(Self, '@装备附魔', false);

end;

procedure TPlayObject.ClientAddMagicToItem();
var

  userItem                                             : PTUserItem;
  userItem1                                            : PTUserItem;
  Baseobject                                           : TBaseObject;
  stditem, stditem1                                    : pTStdItem;
  i                                                    : Integer;
begin
  userItem := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    userItem := m_ItemList[i];
    if userItem.MakeIndex = m_nYuJingPingIndex then
      Break;
    userItem := nil;
  end;
  if userItem = nil then
  begin
    SysMsg('非法的玉净瓶', c_Red, t_Hint);
    Exit;
  end;
  userItem1 := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    userItem1 := m_ItemList[i];
    if userItem1.MakeIndex = m_nFuMoItemIndex then
      Break;
    userItem1 := nil;
  end;
  if userItem1 = nil then
  begin
    SysMsg('非法的装备', c_Red, t_Hint);
    Exit;
  end;
  stditem := UserEngine.GetStdItem(UserItem1.wIndex);
  stditem1 := UserEngine.GetStdItem(Useritem.wIndex);
  if Stditem = nil then exit;
  if Stditem1 = nil then exit;
  if not StdItem^.StdMode in [5, 6, 10, 11, 15, 19, 21, 22, 23, 24, 25, 26, 29, 30, 33,
    34, 51, 58, 59, 64, 81, 82] then
  begin
    SysMsg('不能给该物品附魔!', c_Red, t_Hint);
    Exit;
  end;
  // pAttachMagicRCD:=ItemUnit.GetItemAttachMagic(m_nYuJingPingIndex);
  if userItem.AttachMagic.MakeIndex = 0 then
  begin
    SysMsg('该玉净瓶没有封印过心魔了', c_Red, t_Hint);
    Exit;
  end;
  userItem1.AttachMagic := UserItem.AttachMagic;
  userItem1.AttachMagic.MakeIndex := m_nFuMoItemIndex;
  FillChar(userItem.AttachMagic, SizeOf(TAttachMagicRCD), 0);

  SendUpdateItem(userItem);
  m_DefMsg := MakeDefaultMsg(207, Integer(Self), Loword(m_nYuJingPingIndex),
    HiWord(m_nYuJingPingIndex), 0);
  SendSocket(@m_DefMsg, '');

  SendSocket(@m_DefMsg, EncodeBuffer(@userItem1.AttachMagic.aaa,
    SizeOf(TAttachMagicRCD1)));
  m_sParam[0] := Useritem.AttachMagic.MercenaryName;
  m_sParam[1] := IntToStr(Useritem.MakeIndex);
  m_sParam[2] := Stditem1.Name;
  m_sParam[3] := Stditem.Name;
  SendUpdateItem(userItem1);
  m_DefMsg := MakeDefaultMsg(207, Integer(Self), 40, 0, 1);

  SendSocket(@m_DefMsg, EncodeBuffer(@userItem1.AttachMagic.aaa,
    SizeOf(TAttachMagicRCD1)));

  if stditem <> nil then
    SysMsg(format('心魔的魔力精髓，已经附注到你的%s，你的%s获得了强大的威力！',
      [stditem.Name, stditem.Name]), c_Red, t_Hint);

end;

procedure TPlayObject.ClientYuanYing(nMakeIndex: Integer);
begin
  m_sParam[0] := IntToStr(nMakeIndex);
  if g_ManageNPC <> nil then
    g_ManageNPC.GotoLable(Self, '@炼化元婴', false);
  SendYuanYingInfo;
end;

procedure TPlayObject.CallLHFMMon(nMakeIndex, x, y: Integer);
var
  UserItem                                             : PTUserItem;
  sMon                                                 : string;
  Mon                                                  : TBaseObject;
begin
  m_sParam[0] := IntToStr(nMakeIndex);
  m_sParam[1] := IntToStr(x);
  m_sParam[2] := IntToStr(y);

  if g_ManageNPC <> nil then
    g_ManageNPC.GotoLable(self, '@释放封元印', False);
  Exit;

  UserItem := GetItems(nMakeIndex);
  sMon := '';
  if UserItem <> nil then
  begin
    case UserItem.btValue[1] of
      1: sMon := '猛魔枪卒11';
      2: sMon := '猛魔刀斧手11';
      3: sMon := '地火兽投矛手11';
      4: sMon := '鬼火方卒11';
      5: sMon := '地火兽弓箭手11';
      6: sMon := '猛魔统领11';
      7: sMon := '地火兽骑将11';
      8: sMon := '炎魔11';
      9: sMon := '幽影武士11';
      10: sMon := '铁血魔王11';
    end;
    Mon := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, x, y, sMon);
    if Mon <> nil then
    begin
      Mon.m_Master := Self;
      Mon.m_dwMasterRoyaltyTick := GetTickCount + 240 * 60 * 60 * 1000;
    end;

  end;
end;

procedure TPlayObject.ClientAddMagic(nMakeIndex: Integer);
var

  userItem                                             : PTUserItem;
  Baseobject                                           : TBaseObject;
  i                                                    : Integer;
  nvalue1, nvalue2                                     : Integer;
begin
  userItem := nil;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    userItem := m_ItemList[i];
    if userItem.MakeIndex = nMakeIndex then
      Break;
    userItem := nil;
  end;
  if userItem = nil then
  begin
    SysMsg('非法的玉净瓶', c_Red, t_Hint);
    Exit;
  end;

  if userItem.AttachMagic.MakeIndex > 0 then
  begin
    SysMsg('该玉净瓶已经封印过心魔了', c_Red, t_Hint);
    Exit;
  end;

  Baseobject := m_PEnvir.GetMovingObjectNotself(self, m_nCurrX, m_nCurrY, True);
  if (Baseobject = nil) then
  begin
    SysMsg('没有发现心魔', c_Red, t_Hint);
    Exit;
  end;
  if (Baseobject.m_btRaceImg <> 255) then
  begin
    SysMsg('没有发现心魔', c_Red, t_Hint);
    Exit;
  end;

  FillChar(userItem.AttachMagic, 40, 0);
  userItem.AttachMagic.MakeIndex := nMakeIndex;
  strpcopy(userItem.AttachMagic.MercenaryName, Baseobject.m_sCharName);
  //  Move(Baseobject.m_sCharName[1],pAttachMagicRCD.MercenaryName[0],Length(Baseobject.m_sCharName));
  userItem.AttachMagic.MercenaryJob := Baseobject.m_btJob;
  userItem.AttachMagic.ZMValue := (Random(3) + 6) * 1000;
  userItem.AttachMagic.MercenaryState := TMonsteys(Baseobject).m_btRealm;
  case Baseobject.m_btJob of
    0:
      begin
        Randomize;
        nvalue1 := 0;
        nValue2 := 0;
        if Random(100) <= g_Config.nEvilDcRate1[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue1 := Random(g_Config.nEvilDc1[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if Random(100) <= g_Config.nEvilDcRate2[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue2 := Random(g_Config.nEvilDc2[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if nvalue2 > nvalue1 then
          nvalue2 := nvalue1;
        userItem.AttachMagic.DC := MakeWord(nvalue2, nvalue1);
        if Random(100) <= g_Config.nEvilDcRate1[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue1 := Random(g_Config.nEvilDc1[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if Random(100) <= g_Config.nEvilDcRate1[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue2 := Random(g_Config.nEvilDc2[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if nvalue2 > nvalue1 then
          nvalue2 := nvalue1;

        userItem.AttachMagic.AC := MakeWord(nvalue2, nvalue1);
      end;
    1:
      begin
        Randomize;
        nvalue1 := 0;
        nValue2 := 0;
        if Random(100) <= g_Config.nEvilMcRate1[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue1 := Random(g_Config.nEvilMc1[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if Random(100) <= g_Config.nEvilMcRate2[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue2 := Random(g_Config.nEvilMc2[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if nvalue2 > nvalue1 then
          nvalue2 := nvalue1;
        userItem.AttachMagic.Mc := MakeWord(nvalue2, nvalue1);
        if Random(100) <= g_Config.nEvilMcRate1[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue1 := Random(g_Config.nEvilMc1[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if Random(100) <= g_Config.nEvilMcRate2[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue2 := Random(g_Config.nEvilMc2[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if nvalue2 > nvalue1 then
          nvalue2 := nvalue1;

        userItem.AttachMagic.MAC := MakeWord(nvalue2, nvalue1);
      end;
    2:
      begin
        Randomize;
        nvalue1 := 0;
        nValue2 := 0;
        if Random(100) <= g_Config.nEvilScRate1[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue1 := Random(g_Config.nEvilSc1[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if Random(100) <= g_Config.nEvilScRate2[userItem.AttachMagic.MercenaryState mod 5]
          then
        begin
          nvalue2 := Random(g_Config.nEvilSc2[userItem.AttachMagic.MercenaryState mod 5])
            + 1;
        end;
        if nvalue2 > nvalue1 then
          nvalue2 := nvalue1;
        userItem.AttachMagic.Sc := MakeWord(nvalue2, nvalue1);
      end;
  end;

  userItem.AttachMagic.bFlag := 1;

  Dec(userItem^.Dura);

  SendUpdateItem(userItem);
  m_DefMsg := MakeDefaultMsg(207, Integer(Self), 40, 0, 1);

  SendSocket(@m_DefMsg, EncodeBuffer(@userItem.AttachMagic.aaa,
    SizeOf(TAttachMagicRCD1)));
  SendRefMsg(RM_510, 0, 1, 0, 61, '');
  Baseobject.DisappearA;
  SysMsg('玉净瓶魔力四射，俘获心魔成功！', c_Red, t_Hint);

end;

procedure TPlayObject.SendAddDealItem(UserItem: pTUserItem); //004DD464
var
  StdItem                                              : pTStdItem;
  StdItem80                                            : TStdItem;
  ClientItem                                           : TClientItem;

  sUserItemName                                        : string;

begin
  SendDefMessage(SM_DEALADDITEM_OK, 0, 0, 0, 0, '');
  if m_DealCreat <> nil then
  begin

    begin
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        StdItem80 := StdItem^;
        //取自定义物品名称
        sUserItemName := '';
        if UserItem.btValue[13] = 1 then
          sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex,
            UserItem.wIndex);
        if sUserItemName <> '' then
          StdItem80.Name := sUserItemName;
        ClientItem.DarkProperty := UserItem.DarkProp; // ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);
        ItemUnit.GetItemAddValue(UserItem, StdItem80);
        ClientItem.S := StdItem80;
        ClientItem.MakeIndex := UserItem.MakeIndex;
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
        m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEADDITEM, Integer(Self), 0, 0, 1);
        TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem,
          SizeOf(TClientItem)));
        m_DealCreat.m_DealLastTick := GetTickCount();
        m_DealLastTick := GetTickCount();
      end;
    end;
  end;
end;

procedure TPlayObject.OpenDealDlg(BaseObject: TBaseObject); //004DD300
begin
  m_boDealing := True;
  m_DealCreat := BaseObject;
  GetBackDealItems();
  SendDefMessage(SM_DEALMENU, 0, 0, 0, 0, m_DealCreat.m_sCharName);
  m_DealLastTick := GetTickCount();
end;

procedure TPlayObject.JoinGroup(PlayObject: TPlayObject);   //004C3AE4
begin
  m_GroupOwner := PlayObject;
  //SendGroupText(m_sCharName + ' 已加入小组.');
  SendGroupText(format(g_sJoinGroup, [m_sCharName]));
end;

function TBaseObject.MagCanHitTarget(nX, nY: Integer;
  TargeTBaseObject: TBaseObject): Boolean;                  //004C6B1C
var
  n14, n18, n1C, n20                                   : Integer;
begin
  Result := False;
  if TargeTBaseObject = nil then
    exit;
  n20 := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
  n14 := 0;
  while (n14 < 13) do
  begin
    n18 := GetNextDirection(nX, nY, TargeTBaseObject.m_nCurrX,
      TargeTBaseObject.m_nCurrY);
    if m_PEnvir.GetNextPosition(nX, nY, n18, 1, nX, nY) and m_PEnvir.sub_4B5FC8(nX, nY)
      then
    begin
      if (nX = TargeTBaseObject.m_nCurrX) and (nY = TargeTBaseObject.m_nCurrY) then
      begin
        Result := True;
        break;
      end
      else
      begin
        n1C := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY - TargeTBaseObject.m_nCurrY);
        if n1C > n20 then
        begin
          Result := True;
          break;
        end;
        n1C := n20;
      end;
    end
    else
    begin
      break;
    end;
    Inc(n14);
  end;
end;

function TBaseObject.IsProperFriend(BaseObject1: TBaseObject): boolean; //004C909C

  function IsFriend(cret: TBaseObject): Boolean;            //004C8F08
  var
    I                                                  : Integer;
    selfplay, cretplay                                 : TbaseObject;
  begin
    Result := False;                                        ///getmainplayer(BaseObject1)
    if cret.m_btRaceServer = RC_PLAYOBJECT then
    begin                                                   //如果对象是人物
      selfplay := getmainplayer(Self);
      cretplay := getmainplayer(Cret);
      case m_btAttatckMode of

        HAM_ALL: Result := True;
        HAM_PEACE: Result := True;
        HAM_DEAR:
          begin

            if (selfplay = cretplay) or (cretplay = TPlayObject(selfplay).m_DearHuman)
              then
            begin
              Result := True;
            end;
          end;
        HAM_MASTER:
          begin
            if (selfplay = cretplay) then
            begin
              Result := True;
            end
            else
              if TPlayObject(selfplay).m_boMaster then
              begin
                for I := 0 to TPlayObject(selfplay).m_MasterList.Count - 1 do
                begin
                  if TPlayObject(selfplay).m_MasterList.Items[I] = cretplay then
                  begin
                    Result := True;
                    break;
                  end;
                end;
              end
              else
                if TPlayObject(cretplay).m_boMaster then
                begin
                  for I := 0 to TPlayObject(cretplay).m_MasterList.Count - 1 do
                  begin
                    if TPlayObject(cretplay).m_MasterList.Items[I] = selfplay then
                    begin
                      Result := True;
                      break;
                    end;
                  end;
                end;
          end;
        HAM_GROUP:
          begin
            if selfplay = cretplay then
              Result := True;
            if IsGroupMember(cretplay) then
              Result := True;
          end;
        HAM_GUILD:
          begin
            if cretplay = selfplay then
              Result := True;
            if m_MyGuild <> nil then
            begin
              if TGuild(m_MyGuild).IsMember(cretplay.m_sCharName) then
                Result := True;
              if m_boGuildWarArea and (cretplay.m_MyGuild <> nil) then
              begin
                if TGuild(m_MyGuild).IsAllyGuild(TGuild(cretplay.m_MyGuild)) then
                  Result := True;
              end;
            end;
          end;
        HAM_PKATTACK:
          begin
            if cretplay = selfplay then
              Result := True;
            if PKLevel >= 2 then
            begin
              if cretplay.PKLevel < 2 then
                Result := True;
            end
            else
            begin
              if cretplay.PKLevel >= 2 then
                Result := True;
            end;
          end;
      end;
    end;
  end;
var
  BaseObject                                           : TBaseObject;

begin                                                       //004C909C
  Result := False;
  BaseObject := BaseObject1;                                //getmainplayer(BaseObject1) ;
  if m_btRaceServer = RC_YSBJECT then
  begin
    if (BaseObject = self) or (BaseObject = m_Master) then
    begin
      result := true;
      exit
    end;
  end;

  if BaseObject = nil then
    exit;
  if (m_btRaceServer >= RC_ANIMAL) then
  begin
    if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
      Result := True;
    if BaseObject.m_Master <> nil then
      Result := False;
    exit;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    Result := IsFriend(BaseObject1);
    if BaseObject.m_btRaceServer < RC_ANIMAL then
      exit;
    if BaseObject.m_Master = self then
    begin
      Result := True;
      exit;
    end;
    if BaseObject.m_Master <> nil then
    begin
      Result := IsFriend(BaseObject.m_Master);
      exit;
    end;
  end
  else
    Result := True;                                         //004C913E
end;

function TBaseObject.MagMakeDefenceArea(nX, nY, nRange, nSec: Integer;
  btState: Byte): Integer;                                  //004C6F04
var
  III                                                  : Integer;
  I, II                                                : Integer;
  nStartX, nStartY, nEndX, nEndY                       : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  BaseObject                                           : TBaseObject;
begin
  Result := 0;
  nStartX := nX - nRange;
  nEndX := nX + nRange;
  nStartY := nY - nRange;
  nEndY := nY + nRange;
  for I := nStartX to nEndX do
  begin
    for II := nStartY to nEndY do
    begin
      if m_PEnvir.GetMapCellInfo(i, ii, MapCellInfo) and (MapCellInfo.ObjList <> nil)
        then
      begin
        for III := 0 to MapCellInfo.ObjList.Count - 1 do
        begin
          OSObject := MapCellInfo.ObjList.Items[III];
          if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then
          begin
            BaseObject := TBaseObject(OSObject.CellObj);
            if (BaseObject <> nil) and (not BaseObject.m_boGhost) then
            begin
              if IsProperFriend(BaseObject) then
              begin
                if btState = 0 then
                begin
                  BaseObject.DefenceUp(nSec);
                end
                else
                begin
                  BaseObject.MagDefenceUp(nSec);
                end;
                Inc(Result);
              end
            end;
          end;
        end;
      end;
    end;
  end;
end;

function TBaseObject.DefenceUp(nSec: Integer): Boolean;     //004C6C28
begin
  Result := False;
  if m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] > 0 then
  begin                                                     //004C6C5C
    if m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] < nSec then
    begin
      m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] := nSec;
      Result := True;
    end;
  end
  else
  begin
    m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_DEFENCEUP {0x20C}] := GetTickCount;
  SysMsg(format(g_sDefenceUpTime, [nSec]), c_Green, t_Hint);
  //SysMsg('防御力增加' + IntToStr(nSec) + '秒',c_Green,t_Hint);
  RecalcAbilitys();

  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
end;

function TBaseObject.MagDefenceUp(nSec: Integer): Boolean;  //004C6D38
begin
  Result := False;
  if m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] > 0 then
  begin                                                     //004C6D6C
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] < nSec then
    begin
      m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] := nSec;
      Result := True;
    end;
  end
  else
  begin
    m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] := nSec;
    Result := True;
  end;
  m_dwStatusArrTick[STATE_MAGDEFENCEUP {0x210}] := GetTickCount;
  SysMsg(format(g_sMagDefenceUpTime, [nSec]), c_Green, t_Hint);
  //  SysMsg('抗魔法力增加' + IntToStr(nSec) + '秒',c_Green,t_Hint);
  RecalcAbilitys();

  SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
end;
//魔法盾

function TBaseObject.MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean; //004C6E4C
var
  nOldStatus, Statepos                                 : Integer;
begin
  Result := False;
  Statepos := STATE_BUBBLEDEFENCEUP;
  if m_wStatusTimeArr[Statepos {0x76}] <> 0 then
    exit;                                                   //004C6E79
  nOldStatus := m_nCharStatus;
  m_wStatusTimeArr[Statepos {0x76}] := nSec;
  m_dwStatusArrTick[Statepos {0x214}] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  if nOldStatus <> m_nCharStatus then
  begin
    StatusChanged();
  end;
  m_boAbilMagBubbleDefence := True;
  m_btMagBubbleDefenceLevel := nLevel;
  Result := True;
end;

function TBaseObject.Magfenghuo(nLevel, nSec: Integer): Boolean; //004C6E4C
var
  nOldStatus, Statepos                                 : Integer;
begin
  Result := False;
  Statepos := STATE_15;
  if m_wStatusTimeArr[Statepos {0x76}] <> 0 then
    exit;                                                   //004C6E79
  nOldStatus := m_nCharStatus;
  m_wStatusTimeArr[Statepos {0x76}] := nSec;
  m_dwStatusArrTick[Statepos {0x214}] := GetTickCount();
  m_nCharStatus := GetCharStatus();
  //  if nOldStatus <> m_nCharStatus then begin
  StatusChanged();
  //   end;
  //  m_boAbilMagBubbleDefence:=True;
  //  m_btMagBubbleDefenceLevel:=nLevel;
  Result := True;
end;

procedure TPlayObject.MakeMine;                             //004CB3AC
  function RandomDrua(): Integer;
  begin
    Result := Random(g_Config.nStoneGeneralDuraRate {13000}) + g_Config.nStoneMinDura
      {3000};
    if Random(g_Config.nStoneAddDuraRate {20}) = 0 then
    begin
      Result := Result + Random(g_Config.nStoneAddDuraMax {10000});
    end;
  end;
var
  UserItem                                             : pTUserItem;
  nRandom                                              : Integer;
begin
  if m_ItemList.Count >= m_bMaxBagitem then
    exit;                                                   //  MAXBAGITEM

  nRandom := Random(g_Config.nStoneTypeRate {120});
  if nRandom in [g_Config.nGoldStoneMin {1}..g_Config.nGoldStoneMax {2}] then
  begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sGoldStone, UserItem) then
    begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end
    else
      Dispose(UserItem);
    exit;
  end;
  if nRandom in [g_Config.nSilverStoneMin {3}..g_Config.nSilverStoneMax {20}] then
  begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sSilverStone, UserItem) then
    begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end
    else
      Dispose(UserItem);
    exit;
  end;
  if nRandom in [g_Config.nSteelStoneMin {21}..g_Config.nSteelStoneMax {45}] then
  begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sSteelStone, UserItem) then
    begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end
    else
      Dispose(UserItem);
    exit;
  end;
  if nRandom in [g_Config.nBlackStoneMin {46}..g_Config.nBlackStoneMax {56}] then
  begin
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sBlackStone, UserItem) then
    begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
    end
    else
      Dispose(UserItem);
    exit;
  end;
  New(UserItem);
  if UserEngine.CopyToUserItemFromName(g_Config.sCopperStone, UserItem) then
  begin
    UserItem.Dura := RandomDrua();
    m_ItemList.Add(UserItem);
    WeightChanged();
    SendAddItem(UserItem);
  end
  else
    Dispose(UserItem);

  {
  case Random(120) of    //
    1..2: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sGoldStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
    3..20: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sSilverStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
    21..45: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sSteelStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
    46..56: begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sBlackStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
    else begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sCopperStone,UserItem) then begin
        UserItem.Dura:=RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
      end else Dispose(UserItem);
    end;
  end;
  }
end;

function TPlayObject.GetPetLevel(ItemMake: Integer): TMonPetInfo;
var
  UserItem                                             : pTUserItem;
  pStdItem                                             : pTStdItem;
  function GetTime: Integer;
  var
    MyTime, mydate, date1, date2                       : TDateTime;
    tint, wInt                                         : integer;
  begin
    MyTime := EncodeTime(8, 00, 00, 0);
    mydate := encodedate(1970, 01, 01);
    date1 := mydate + mytime;
    mydate := date();
    mytime := time();
    date2 := mydate + mytime;
    tint := round((date2 - date1) * 86400); //一天的秒数      //开始使用时间
    copymemory(@wint, @UserItem.btValue[0], 4);
    Result := (tint - wint) div 3600;
  end;
begin

  FillChar(Result, SizeOf(TMonPetInfo), 0);
  UserItem := GetItems(ItemMake);
  if UserItem = nil then exit;

  pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if pStdItem = nil then exit;
  Result.montype := UserItem.btvalue[9] + pStdItem.AniCount * 8;
  Result.MonLevel := UserItem.btvalue[4];
  Result.MonColor := Useritem.btValue[8];
  Result.FendTime := IntToStr(GetTime);
  Result.exp := MakeWord(Useritem.btValue[6], Useritem.btValue[7]);
  Result.Level := makeword(UserItem.btvalue[4], UserItem.btvalue[9] + pStdItem.AniCount *
    8);
  Result.ZSD := UserItem.btvalue[9];
end;

procedure TPlayObject.UPDATEMONSTONE;
var
  UserItem                                             : pTUserItem;
begin
  if m_PetBaseObject <> nil then
  begin
    SendDefMessage(SM_510, Integer(m_PetBaseObject), 1, 0, 46, '');
    SendPetInfo(M_MonItemMake, 1);
    UserItem := GetItems(M_monitemmake);
    if UserItem <> nil then
      SendUpdateItem(UserItem);
  end;
end;

procedure TPlayObject.UPGRADEPetLevel(nlevel: integer);
var
  i                                                    : integer;
  UserItem                                             : pTUserItem;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint                                                 : integer; //M_monitemmake
  StdItem, StdItem2                                    : pTStdItem;
begin
  UserItem := GetItems(M_monitemmake);
  if UserItem = nil then exit;
  if m_PetBaseObject = nil then Exit;                       //没有释放豹子
  if not nlevel in [0..2] then exit;                        //转生等级不对
  Useritem.btvalue[4] := nlevel;

  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem = nil then exit;
  M_monstoragelevel := makeword(UserItem.btvalue[4], UserItem.btvalue[9] +
    StdItem.AniCount * 8);
  M_monsterZSD := UserItem.btValue[9];
  if UserItem.btValue[8] >= 0 then
    m_PetBaseObject.m_wAppr := UserEngine.GetMonAppr(getpetName(M_MonItemMake));

  // M_MonPetColor:=UserItem.btValue[8];
  m_PetBaseObject.FeatureChanged;
  m_PetBaseObject.m_sCharName := GetPetName(M_MonItemMake);
  SendDefMessage(SM_510, Integer(m_PetBaseObject), 1, 0, 46, '');
  SendPetInfo(M_monitemmake, 1);
  SendUpdateItem(UserItem);
end;

procedure TPlayObject.UPGRADEPetExp(nlevel: integer; sMethod: char);
var
  wint                                                 : Word;
  UserItem                                             : pTUserItem;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint                                                 : integer; //M_monitemmake
  StdItem, StdItem2                                    : pTStdItem;
begin
  UserItem := GetItems(M_monitemmake);
  if UserItem = nil then exit;
  if m_PetBaseObject = nil then Exit;                       //没有释放豹子
  //if not nlevel in[0..2] then exit;//转生等级不对
  wint := MakeWord(Useritem.btvalue[6], Useritem.btvalue[7]);
  case sMethod of
    '=': wint := nLevel;
    '+': wint := nLevel + wint;
    '-': wint := wint - nlevel;
  end;
  Useritem.btvalue[6] := lobyte(wint);
  Useritem.btvalue[7] := hibyte(wint);
  UserItem.btvalue[4] := wint div g_Config.ClbLevelUpTrains;
  M_monsterExp := wint;
  M_monstoragelevel := makeword(UserItem.btvalue[4], UserItem.btvalue[9] +
    StdItem.AniCount * 8);
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem = nil then exit;
  M_monstoragelevel := makeword(UserItem.btvalue[4], UserItem.btvalue[9] +
    StdItem.AniCount * 8);

  // M_MonPetColor:=UserItem.btValue[8];
  m_PetBaseObject.FeatureChanged;
  m_PetBaseObject.m_sCharName := GetPetName(M_MonItemMake);
  SendDefMessage(SM_510, Integer(m_PetBaseObject), 1, 0, 46, '');
  SendPetInfo(Useritem.MakeIndex, 1);
  SendUpdateItem(UserItem);
end;

procedure TPlayObject.UPGRADEPetZS(nlevel: integer);
var
  i                                                    : integer;
  UserItem                                             : pTUserItem;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint                                                 : integer; //M_monitemmake
  StdItem, StdItem2                                    : pTStdItem;
begin
  UserItem := GetItems(M_monitemmake);
  if UserItem = nil then exit;
  if m_PetBaseObject = nil then Exit;                       //没有释放豹子
  if not nlevel in [0..2] then exit;                        //转生等级不对
  Useritem.btvalue[9] := nlevel;
  UserItem.btValue[4] := 0;
  UserItem.btValue[7] := 0;
  UserItem.btValue[6] := 0;
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem = nil then exit;
  M_monstoragelevel := makeword(UserItem.btvalue[4], UserItem.btvalue[9] +
    StdItem.AniCount * 8);
  M_monsterZSD := UserItem.btValue[9];
  if UserItem.btValue[8] >= 0 then
    m_PetBaseObject.m_wAppr := UserEngine.GetMonAppr(getpetName(M_MonItemMake));

  // M_MonPetColor:=UserItem.btValue[8];
  m_PetBaseObject.FeatureChanged;
  m_PetBaseObject.m_sCharName := GetPetName(M_MonItemMake);
  SendDefMessage(SM_510, Integer(m_PetBaseObject), 1, 0, 46, '');
  SendPetInfo(Useritem.MakeIndex, 1);
  SendUpdateItem(UserItem);
end;

procedure TPlayObject.UPGRADEPet(ntype: integer);
var
  i                                                    : integer;
  UserItem                                             : pTUserItem;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint                                                 : integer; //M_monitemmake
  StdItem, StdItem2                                    : pTStdItem;
begin
  UserItem := GetItems(M_monitemmake);
  if UserItem = nil then exit;
  if m_PetBaseObject = nil then Exit;                       //没有释放豹子
  if ntype = 0 then
  begin
    Inc(UserItem.btValue[9]);
    UserItem.btValue[6] := 0;
    UserItem.btValue[7] := 0;
    UserItem.btValue[4] := 0;
  end
  else
  begin

    UserItem.btValue[8] := ntype - 1;
  end;
  if UserItem.btValue[8] > 2 then
    UserItem.btValue[8] := 2;
  if Useritem.btvalue[9] = 0 then
  begin
    UserItem.btValue[4] := 0;
    UserItem.btValue[7] := 0;
    UserItem.btValue[6] := 0;
  end;
  // UserItem.btValue[7]:=1 ;

  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  if StdItem = nil then exit;
  M_monstoragelevel := makeword(UserItem.btvalue[4], UserItem.btvalue[9] +
    StdItem.AniCount * 8);
  // M_MonPetColor:=UserItem.btValue[8];
  if UserItem.btValue[8] >= 0 then
  begin
    m_PetBaseObject.m_wAppr := UserEngine.GetMonAppr(getpetName(M_MonItemMake));
    m_PetBaseObject.m_btRaceImg := UserEngine.GetMonrACEiMG(getpetName(M_MonItemMake));
  end;

  SendDefMessage(SM_510, Integer(m_PetBaseObject), 1, 0, 84, '');

  m_PetBaseObject.m_sCharName := GetPetName(M_MonItemMake);
  m_PetBaseObject.m_btGender := GetpetLevel(M_MonItemMake).montype and $3;
  SendPetInfo(Useritem.MakeIndex, 1);
  SendUpdateItem(UserItem);
  m_PetBaseObject.RefShowName;
  m_PetBaseObject.FeatureChanged;
  m_PetBaseObject.SendRefMsg(RM_SPACEMOVE_SHOW, m_PetBaseObject.m_btDirection,
    m_PetBaseObject.m_nCurrX, m_PetBaseObject.m_nCurrY, 0, '');
end;

function TPlayObject.GetPetName(ItemIndex: Integer): string;
var
  MonLevel, monType                                    : Integer;
  UserItem                                             : PTUserItem;
  StdItem                                              : pTStdItem;
begin
  Result := '';
  UserItem := GetItems(ItemIndex);
  if UserItem = nil then exit;
  //  M_monstoragelevel:=makeword(UserItem.btvalue[4], UserItem.btvalue[7]+StdItem.AniCount*8);
  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
  monlevel := UserItem.btvalue[4];
  montype := UserItem.btvalue[9] + StdItem.AniCount * 8;

  case montype of
    0: Result := '丛林豹';
    1:
      begin
        Result := '踏云豹';

        case UserItem.btvalue[8] of
          0: Result := '踏云豹1';                           //黄色
          1: Result := '踏云豹2';                           //黑
          2: Result := '踏云豹3';                           //白

        end;
      end;
    2:
      begin

        Result := '迅天雷豹' + Inttostr(UserItem.btvalue[8] + 1);
      end;
    8:
      begin
        Result := '天狮兽';
      end;
    9:
      begin
        if (UserItem.btvalue[8] < 0) or (UserItem.btvalue[8] > 2) then
          UserItem.btvalue[8] := 0;
        Result := '震天狮' + Inttostr(UserItem.btvalue[8] + 1);
      end;
    10:
      begin
        if (UserItem.btvalue[8] < 0) or (UserItem.btvalue[8] > 2) then
          UserItem.btvalue[8] := 0;
        case UserItem.btvalue[8] of
          0: Result := '战天狂狮3';                         //黄色
          1: Result := '战天狂狮2';                         //黑
          2: Result := '战天狂狮1';                         //白

        end;
        //Result := '战天狂狮'+Inttostr(UserItem.btvalue[8]+1);
      end;
    16: Result := '麒麟兽';
    17:
      begin
        Result := '圣麒麟1';
        if (UserItem.btvalue[8] < 0) or (UserItem.btvalue[8] > 2) then
          UserItem.btvalue[8] := 0;
        case UserItem.btvalue[8] of
          0: Result := '圣麒麟';                            //黄色
          1: Result := '圣麒麟2';                           // 红
          2: Result := '圣麒麟1';                           //白

        end;
      end;
    18:
      begin
        Result := '玄天麒麟';
        if (UserItem.btvalue[8] < 0) or (UserItem.btvalue[8] > 2) then
          UserItem.btvalue[8] := 0;
        case UserItem.btvalue[8] of
          0: Result := '玄天麒麟';                          //黄色
          1: Result := '玄天麒麟2';                         //红
          2: Result := '玄天麒麟2';                         //白

        end;
      end;
    24: Result := '赤翎凤';
    25:
      begin
        Result := '傲天凤1';
        if UserItem.btValue[8] > 0 then Result := '傲天凤2';
      end;
    26:
      begin
        Result := '炽天凤凰1';
        if UserItem.btValue[8] > 0 then Result := '炽天凤凰2';
      end;
  else
    Result := '丛林豹';
  end;

end;

procedure TPlayObject.relivemon(ntype: integer);
var
  i                                                    : integer;
  UserItem                                             : pTUserItem;
  MyTime, mydate, date1, date2                         : TDateTime;
  tint                                                 : integer; //M_monitemmake
begin
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if ntype < 0 then                                       //死亡
      if (UserItem <> nil) and (UserItem.MakeIndex = M_monitemmake) then
      begin
        tint := 1000;                                       //
        copymemory(@UserItem.btValue[0], @tint, 4);
        SendUpdateItem(UserItem);
        break;
        exit;
      end;
    //复活
    if (UserItem <> nil) and (UserItem.MakeIndex = m_bocheckboxitem) then
    begin
      MyTime := EncodeTime(8, 00, 00, 0);
      mydate := encodedate(1970, 01, 01);
      date1 := mydate + mytime;
      mydate := date();
      mytime := time();
      date2 := mydate + mytime;
      tint := round((date2 - date1) * 86400); //一天的秒数      //开始使用时间

      copymemory(@UserItem.btValue[0], @tint, 4);
      if ntype = 2 then
      begin
        UserItem.btValue[9] := 1;                           //豹子升级
        UserItem.btValue[7] := 0;                           //经验值
        UserItem.btValue[6] := 0;
        UserItem.btValue[4] := 0;                           //等级
      end;
      SendUpdateItem(UserItem);
      // PlayObject.SysMsg('您的丛林豹已经精神饱满，充满了活力。',c_Red,t_Hint) ;
      break;
    end;
  end;
end;

procedure TPlayObject.MakeGoBackeMap(nMapName, x, y: word);
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;

begin
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = m_bocheckboxitem then
    begin
      Useritem.btValue[4] := nMapName + $30;
      Useritem.btValue[0] := Lobyte(x);
      Useritem.btValue[1] := HiByte(x);
      Useritem.btValue[2] := Lobyte(y);
      Useritem.btValue[3] := HiByte(y);
      SendUpdateItem(UserItem);
    end;
  end;
end;

function TPlayObject.CheckItemboxr(sItemName: string; param: string): boolean;
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  s1C                                                  : string;
  tint, tint2                                          : integer;
  MyTime, mydate, date1, date2                         : TDateTime;
begin
  result := false;
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[i];
    if UserItem.MakeIndex = m_bocheckboxitem then
    begin
      s1C := UserEngine.GetStdItemName(UserItem.wIndex);
      if (CompareText(s1C, sItemName) = 0) then
      begin
        result := true;

        if (sitemname = '豹魔石') or (sitemname = '狮魔石') then
        begin
          if (param = '升级') then
          begin //如果是升级的检查就不检查豹子是否死亡
            if (UserItem.btValue[4] = 7) then
              result := true
            else
              result := false;
            exit;
          end;
          copymemory(@tint, @UserItem.btValue[0], 4);
          MyTime := EncodeTime(8, 00, 00, 0);
          mydate := encodedate(1970, 01, 01);
          date1 := mydate + mytime;
          mydate := date();
          mytime := time();
          date2 := mydate + mytime;
          tint2 := round((date2 - date1) * 86400);
          tint := round((tint2 - tint) / 86400);
          if tint < 4 then
            result := false;

        end;

      end;
      break;
    end;
  end;
end;

function TPlayObject.QuestCheckItem(sItemName: string; var nCount,
  nParam: Integer; var nDura: Integer): pTUserItem;         //004C4B78
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  s1C                                                  : string;
begin
  Result := nil;
  nParam := 0;
  nDura := 0;
  nCount := 0;
  try
    for I := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      s1C := UserEngine.GetStdItemName(UserItem.wIndex, false);
      if CompareText(s1C, sItemName) = 0 then
      begin
        if UserItem.Dura > nDura then
        begin
          nDura := UserItem.Dura;
          Result := UserItem;
        end;
        Inc(nParam, UserItem.Dura);
        if Result = nil then
          Result := UserItem;
        Inc(nCount);
      end;                                                  //004C4C97
    end;
  except
    MainOutMessage('CheckItem Error!');
  end;
end;

function TBaseObject.sub_4C4CD4(sItemName: string;
  var nCount: Integer): pTUserItem;                         //004C4CD4
var
  I                                                    : Integer;
  sName                                                : string;
begin
  Result := nil;
  nCount := 0;
  for I := Low(THumanUseItems) to High(THumanUseItems) do
  begin
    sName := UserEngine.GetStdItemName(m_UseItems[i].wIndex);
    if CompareText(sName, sItemName) = 0 then
    begin
      Result := @m_UseItems[i];
      Inc(nCount);
    end;
  end;
end;

function TPlayObject.QuestTakeCheckItem(CheckItem: pTUserItem): Boolean; //004C4F6C
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
begin
  Result := False;
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if UserItem = CheckItem then
    begin
      SendDelItems(UserItem);
      Dispose(UserItem);
      m_ItemList.Delete(I);
      Result := True;
      break;
    end;
  end;
  for I := Low(m_UseItems) to High(m_UseItems) do
  begin
    if @m_UseItems[I] = CheckItem then
    begin
      SendDelItems(@m_UseItems[I]);
      m_UseItems[I].wIndex := 0;
      Result := True;
      break;
    end;
  end;
end;

function TPlayObject.GetItemCount(sItemName: string): Integer;
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
begin
  Result := 0;
  m_ItemList.lock;

  try
    for I := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0 then
      begin
        Inc(Result, UserItem.Dura);
      end;
    end;
  finally
    m_ItemList.unlock;
  end;
end;

procedure TPlayObject.TakeItem(sItemName: string; nItemCount: Integer); //0049C998
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
begin
  if CompareText(sItemName, sSTRING_GOLDNAME) = 0 then
  begin
    DecGold(nItemCount);
    GoldChanged();
    //0049CADB
    if g_boGameLogGold then
      AddGameDataLog('10' + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nItemCount) + #9 +
        '1' + #9 +
        m_sCharName);
    exit;
  end;
  m_ItemList.lock;
  try
    for I := m_ItemList.Count - 1 downto 0 do
    begin
      if nItemCount <= 0 then
        break;
      UserItem := m_ItemList.Items[i];
      if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0 then
      begin
        //0049CC24
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('10' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sItemName + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            '1' + #9 +
            m_sCharName);
        SendDelItems(UserItem);
        //UserEngine.GetStdItemName(UserItem.wIndex);
        Dispose(UserItem);
        m_ItemList.Delete(I);
        Dec(nItemCount);
      end;
    end;
  finally
    m_ItemList.unlock;
  end;

end;

procedure TPlayObject.ClientQueryRepairCost(nParam1, nInt: Integer;
  sMsg: string);                                            //004DBCCC
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  UserItemA                                            : pTUserItem;
  Merchant                                             : TMerchant;
  sUserItemName                                        : string;
begin
  UserItemA := nil;
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if (UserItem.MakeIndex = nInt) then
    begin
      //取自定义物品名称
      sUserItemName := '';
      if UserItem.btValue[13] = 1 then
        sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
      if sUserItemName = '' then
        sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

      if (CompareText(sUserItemName, sMsg) = 0) then
      begin
        UserItemA := UserItem;
        break;
      end;
    end;
  end;
  if UserItemA = nil then
    exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
    ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientQueryRepairCost(Self, UserItemA);

end;

procedure TPlayObject.ClientGemStone(RedCount, BlueCount, GreenCount, ItemCount: Integer;
  sMsg: string);
var
  Buf                                                  : array[4..18] of Integer;
  i                                                    : Integer;
begin
  m_sParam[0] := IntToStr(RedCount);
  m_sParam[1] := IntToStr(BlueCount);
  m_sParam[2] := IntToStr(GreenCount);
  Fillchar(Buf, 60, 0);
  DecodeBuffer(sMsg, @Buf, 4 * Itemcount);
  for I := 4 to 18 do
    m_sParam[i] := IntToStr(BUF[i]);
  if m_NPC1 <> nil then
    TMerchant(m_NPC1).GotoLable(Self, '@@gemsmelt', false);
end;

procedure TPlayObject.ClientRepairItem(nParam1, nInt: Integer;
  sMsg: string);                                            //004DBFC0
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  Merchant                                             : TMerchant;
  sUserItemName                                        : string;
begin
  UserItem := nil;
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    //取自定义物品名称
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

    if (UserItem.MakeIndex = nInt) and
      (CompareText(sUserItemName, sMsg) = 0) then
    begin
      break;
    end;
  end;                                                      // for
  if UserItem = nil then
    exit;
  Merchant := UserEngine.FindMerchant(TObject(nParam1));
  if (Merchant <> nil) and
    ((Merchant.m_PEnvir = m_PEnvir) and
    (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
    (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
    Merchant.ClientRepairItem(Self, UserItem);
end;

procedure TPlayObject.ClientStorageItem(NPC: TObject;
  nItemIdx: Integer; sMsg: string);                         //004DC2B8
var
  Merchant                                             : TMerchant;
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  bo19                                                 : Boolean;
  StdItem                                              : pTStdItem;
  sUserItemName                                        : string;
begin
  bo19 := False;                                            //免费版本功能限制
  UserItem := nil;
  if boPneumastorage then
    if Ysplayer = nil then Exit;
  if Pos(' ', sMsg) >= 0 then //折分物品名称(信件物品的名称后面加了使用次数)
    GetValidStr3(sMsg, sMsg, [' ']);

  if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then
  begin
    SysMsg(g_sTryModeCanotUseStorage, c_Red, t_Hint); //'试玩模式不可以使用仓库功能！！！'
    exit;
  end;
  if m_boArrow then
  begin
    SysMsg('现在不能使用', c_Green, t_Hint);
    exit;
  end;

  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    //取自定义物品名称
{      sUserItemName:='';
  if UserItem.btValue[13] = 1 then
      sUserItemName:=ItemUnit.GetCustomItemName(UserItem.MakeIndex,UserItem.wIndex);
    if sUserItemName = '' then    }
    sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

    if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg) = 0) then
    begin
      if GetBoValue(UserItem, UserItem.wIndex, 4) then
      begin
        // SysMsg('该物品禁止存入',c_Green,t_Hint);
        break;
      end;

      Merchant := UserEngine.FindMerchant(NPC);
      if (Merchant <> nil) and
        (Merchant.m_boStorage) and                          //检查NPC是否允许存物品
      (((Merchant.m_PEnvir = m_PEnvir) and
        (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
        (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then
      begin
        if m_StorageItemList.Count < 39 then
        begin
          if boPneumastorage then
          begin
            if Ysplayer <> nil then
            begin
              if Ysplayer.m_StorageItemList.Count < 39 then
                Ysplayer.m_StorageItemList.Add(UserItem)
              else
              begin
                SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
                Exit;
              end;
            end;
          end
          else
            m_StorageItemList.Add(UserItem);
          m_ItemList.Delete(I);
          WeightChanged();
          SendDefMessage(SM_STORAGE_OK, 0, 0, 0, 0, '');
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          //004DC55E
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('1' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '1' + #9 +
              '0');
        end
        else
        begin
          SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
        end;
        bo19 := True;
      end;
      break;
    end;
  end;
  if not bo19 then
    //  SendDefMessage(SM_STORAGE_FAIL,0,0,0,0,''); //
    SendDefMessage(38288, 1, 255, 0, 0, '该物品不允许保存');
  // 接受数据dwflag=1 wcmd=38288 w1=255 w2=0 w3=0 data=[传承珠不允许保存]

end;

procedure TPlayObject.ClientTakeBackStorageItem(NPC: TObject;
  nItemIdx: Integer; sMsg: string);                         //004DC664
var
  Merchant                                             : TMerchant;
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  bo19                                                 : Boolean;
  StdItem                                              : pTStdItem;
  sUserItemName                                        : string;
  ItemLIst                                             : TList;
begin
  bo19 := False;                                            //免费版本功能限制
  UserItem := nil;
  ItemLIst := nil;
  Merchant := UserEngine.FindMerchant(NPC);
  if Merchant = nil then
    exit;
  ItemLIst := m_StorageItemList;

  if boPneumastorage then
    if Ysplayer = nil then
      Exit
    else
      ItemList := Ysplayer.m_StorageItemList;
  if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then
  begin
    SysMsg(g_sTryModeCanotUseStorage, c_Red, t_Hint); // '试玩模式不可以使用仓库功能！！！'
    exit;
  end;
  if not m_boCanGetBackItem then
  begin
    SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg + '\\'
      + '仓库开锁命令: @' + g_GameCommand.UNLOCKSTORAGE.sCmd + '\'
      + '仓库加锁命令: @' + g_GameCommand.LOCK.sCmd + '\'
      + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + #13#10
      + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);

    exit;
  end;

  if ItemLIst = nil then exit;

  for I := 0 to ItemList.Count - 1 do
  begin
    UserItem := ItemList.Items[I];

    //取自定义物品名称
    sUserItemName := '';
    if UserItem.btValue[13] = 1 then
      sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
    if sUserItemName = '' then
      sUserItemName := UserEngine.GetStdItemName(UserItem.wIndex);

    if (UserItem.MakeIndex = nItemIdx) and
      (CompareText(sUserItemName, sMsg) = 0) then
    begin

      if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))) then
      begin
        if (Merchant <> nil) and
          (Merchant.m_boGetback) and                        //检查NPC是否允许取物品
        (((Merchant.m_PEnvir = m_PEnvir) and
          (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
          (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC)) then
        begin

          if AddItemToBag(UserItem) then
          begin
            SendAddItem(UserItem);
            ItemList.Delete(I);
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('0' + #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '1' + #9 +
                '0');
          end
          else
          begin
            SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
          end;

          bo19 := True;
        end;
      end
      else
      begin
        SysMsg(g_sCanotGetItems, c_Red, t_Hint); //   '无法携带更多的东西！！！'
      end;
      break;
    end;
  end;
  if not bo19 then
    SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, '');
end;

procedure TPlayObject.Clientgetslave();
var
  i, j                                                 : integer;
  myslavearray                                         : array[0..10] of tmyslave;
  s1C                                                  : string;
  mon                                                  : TBaseObject;
begin
  j := 0;
  fillchar(myslavearray, sizeof(myslavearray), #0);
  for i := 0 to m_SlaveList.Count - 1 do
  begin
    if i > 10 then
      break;
    if (not TBaseObject(m_SlaveList.Items[i]).m_boTishen) and (not
      TBaseObject(m_SlaveList.Items[i]).m_bohorse) and
      (TBaseObject(m_SlaveList.Items[i]).m_sCharName <> '丛林豹') then
    begin
      mon := TBaseObject(m_SlaveList.Items[i]);
      myslavearray[i].btlevel := TBaseObject(m_SlaveList.Items[i]).m_btSlaveExpLevel;
      //TBaseObject(m_SlaveList.Items[i]).m_WAbil.Level;
      StrPCopy(myslavearray[i].charname, TBaseObject(m_SlaveList.Items[i]).m_sCharName);

      myslavearray[j].hp := mon.m_WAbil.HP;
      myslavearray[j].maxhp := mon.m_WAbil.MaxHP;
      myslavearray[j].ac := MakeWord(_MIN(High(Byte), LoWord(mon.m_WAbil.AC)),
        _MIN(High(Byte), HiWord(mon.m_WAbil.AC)));
      myslavearray[j].dc := MakeWord(_MIN(High(Byte), LoWord(mon.m_WAbil.DC)),
        _MIN(High(Byte), HiWord(mon.m_WAbil.DC)));
      myslavearray[j].mac := MakeWord(_MIN(High(Byte), LoWord(mon.m_WAbil.MAC)),
        _MIN(High(Byte), HiWord(mon.m_WAbil.MAC)));

      myslavearray[j].char2f := $2F;
      inc(j);
    end;
  end;

  m_DefMsg := MakeDefaultMsg(26712, 0, 0, 0, 0);
  s1C := EncodeBuffer(@myslavearray, j * sizeof(tmyslave)); // SizeOf(TonSellItemdata)

  //       s1C:=EncodeBuffer(@mySELLITEMFLAG,SizeOf(TmySELLITEMFLAG));
  SendSocket(@m_DefMsg, s1C);                               //发给自己。

  //  SendDefMessage(26712,tint,0,0,0,'');
end;

procedure TPlayObject.Clientgettime();
var
  tint                                                 : integer;
  MyTime, mydate, date1, date2                         : TDateTime;
begin

  MyTime := EncodeTime(8, 00, 00, 0);
  mydate := encodedate(1970, 01, 01);
  date1 := mydate + mytime;
  mydate := date();
  mytime := time();
  date2 := mydate + mytime;
  tint := round((date2 - date1) * 86400);
  SendDefMessage(38400, tint, 0, 0, 0, '');
end;
//幻化

procedure TPlayObject.ClientPetHuanhua(MainPetId, PetID, ItemID: Integer; nStep:
  Integer);
var
  MainItem, UserItem, Item                             : PTUserItem;
  function PetInfo(nPos: Integer): string;
  begin
    case npos of
      0: Result := '积累经验';
      1: Result := '幻化次数';
      2: Result := '资质';
      3: Result := '生命';
      4: Result := '魔法值';
      5: Result := '中毒躲避';
      6: Result := '魔御下限';
      7: Result := '魔御上限';
      8: Result := '魔法命中';
      9: Result := '躲避';
      10: Result := '防御下限';
      11: Result := '防御上限';
      12: Result := '魔法躲避';
      13: Result := '中毒命中';
      14: Result := '顿悟';
      15: Result := '五行属性';
      16: Result := '五行属性';
      17: Result := '灵兽经验';
      18: Result := '保留';
      19: Result := '魔法攻击下限';
      20: Result := '魔法攻击上限';
      21: Result := '道术攻击下限';
      22: Result := '道术攻击上限';
      23: Result := '攻击下限';
      24: Result := '攻击上限';
      25: Result := '命中';
      26: Result := '幸运';
      27: Result := '骑战速度';
    end;

  end;
  function GetString: string;
  var
    Str1, str2                                         : string;
    i                                                  : Integer;
    v1, v2                                             : Integer;
  begin
    for I := 0 to 29 do
    begin
      m_PetAddValue[i] := 0;
      m_PetAddRate[i] := 0;
      if i in [0, 1, 15, 16, 17, 18] then Continue;
      v1 := GetPetAddInfo(MainItem, i);
      V2 := GetPetAddInfo(UserItem, i);
      if v2 > 0 then
      begin
        m_PetAddRate[i] := m_nPetRate;
        if Item <> nil then m_PetAddRate[i] := m_nPetRate + 10;
        if v1 = 0 then
        begin
          m_PetAddValue[i] := 1;

          Str1 := Str1 + format('%d点的%s,', [1, PetInfo(i)]);
        end
        else
        begin
          m_PetAddValue[i] := Max(1, Round(v1 * v2 / (v1 + v2)));

          Str2 := Str2 + format('%d点的%s,', [m_PetAddValue[i], PetInfo(i)]);
        end;

      end;
    end;

    if Item = nil then
    begin
      Result := '您的主灵兽可以';
      if Str1 <> '' then
        Result := Result + '有' + Inttostr(m_nPetRate) + '％的概率继承到' + str1 + ',';
      if Str2 <> '' then
        Result := Result + '有' + Inttostr(m_nPetRate) + '％的概率继承到' + str2;

    end
    else
    begin
      Result := '您的主灵兽可以';
      if Str1 <> '' then
        Result := Result + '有' + Inttostr(m_nPetRate + 10) + '％的概率继承到' + str1 +
          ',';
      if Str2 <> '' then
        Result := Result + '有' + Inttostr(m_nPetRate + 10) + '％的概率继承到' + str2;
    end;
  end;
  function SetString: string;
  var
    Str1, str2                                         : string;
    i                                                  : Integer;
    v1, v2                                             : Integer;
  begin
    Str2 := '';
    for I := 0 to 29 do
    begin

      if i in [0, 1, 15, 16, 17, 18] then Continue;
      if m_PetAddValue[i] > 0 then
      begin
        Randomize;
        v1 := Random(100);
        if v1 < m_PetAddRate[i] then
        begin
          SetPetAddInfo(MainItem, i, m_PetAddValue[i] + GetPetAddInfo(MainItem, i));
          Str2 := Str2 + format('%d点的%s,', [m_PetAddValue[i], PetInfo(i)]);
        end;

      end;
    end;
    if str2 <> '' then
      Result := '在封元印和灵力的双重力量下，你的主灵兽继承了副灵兽' + Str2
    else
      Result := '在封元印和灵力的双重力量下，你的主灵兽没有继承到副灵兽的任何属性'; Result
        := '在封元印和灵力的双重力量下，你的主灵兽继承了副灵兽' + Str2
  end;

begin
  //主灵兽
  MainItem := GetItems(MainPetId);
  m_nmainPetId := MainPetId;
  if MainItem = nil then exit;
  Useritem := GetItems(Petid);
  if UserItem = nil then exit;
  Item := GetItems(Itemid);
  m_sParam[0] := IntToStr(nStep);
  m_sParam[1] := IntToStr(MainItem.MakeIndex);
  m_sParam[2] := IntToStr(Useritem.MakeIndex);
  if Item <> nil then
    m_sParam[3] := IntToStr(Item.MakeIndex)
  else
    m_sParam[3] := '';

  case nStep of
    0:
      begin
        g_FunctionNPC.GotoLable(tplayobject(Self), '@灵兽幻化', False);
        // SendDefMessage(3052,Integer(self),0,10,20,GetString,False);

      end;
    1:
      begin
        //   SendDefMessage(3052,Integer(self),0,10,20,SetString,False);
        g_FunctionNPC.GotoLable(tplayobject(Self), '@灵兽幻化', False);
        {      DelItem(UserItem);
              if Item<>nil then
                DelItem(Item);
              SendUpdateItem(MainItem);
              }
      end;
  end;

end;

procedure TPlayObject.ClientYsGoldChange(sMsg: string);
var                                                         // sTemp:string;
  YsBagItem                                            : TYsBagItem;
  hum                                                  : Tplayobject;
begin
  //  hum:=nil;
  //  hum:= UserEngine.GetPlayObjectEx(sYsname); //我的元神
  hum := self.Ysplayer;
  if hum = nil then
    exit;

  decodebuffer(sMsg, @YsBagItem, sizeof(TYsBagItem) - 1);

  if integer(hum) <> YsBagItem.YsId then
    exit;

  if YsBagItem.Flag = 1 then
  begin                                                     //人物到元神   self=人物
    DecGold(YsBagItem.ItemMake);
    GoldChanged();

    hum.IncGold(YsBagItem.ItemMake);
    hum.GoldChanged();

  end;                                                      // flag=1
  if YsBagItem.Flag = 0 then
  begin                                                     //元神到人物   self=人物
    hum.DecGold(YsBagItem.ItemMake);
    hum.GoldChanged();

    IncGold(YsBagItem.ItemMake);
    GoldChanged();

  end;                                                      // flag=0

end;

procedure TPlayObject.ClientYsBagItem(sMsg: string);
var
  sTemp, sUserItemName                                 : string;
  YsBagItem                                            : TYsBagItem;
  i                                                    : integer;
  UserItem                                             : pTUserItem;
  StdItem                                              : pTStdItem;
  boFound, boTrans, bolimit                            : boolean;
  hum                                                  : Tplayobject;
begin
  //   hum:=nil;
   //  hum:= UserEngine.GetPlayObjectEx(sYsname); //我的元神
  hum := self.Ysplayer;
  if hum = nil then
    exit;
  if hum.m_boDeath or hum.m_boGhost then
    exit;                                                   //防止复制
  if m_boDeath or m_boGhost then
    exit;
  decodebuffer(sMsg, @YsBagItem, sizeof(TYsBagItem) - 1);
  boFound := false;
  boTrans := false;
  bolimit := false;

  if integer(hum) <> YsBagItem.YsId then
    exit;

  if YsBagItem.Flag = 1 then
  begin                                                     //人物到元神   self=人物
    for i := m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := m_ItemList.Items[i];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);

      if UserItem.MakeIndex = YsBagItem.ItemMake then
      begin
        if ((stditem.Reserved = 11) or (stditem.Shape = 151)) or (M_monitemmake =
          UserItem.MakeIndex) or (GetBoValue(UserItem, UserItem.wIndex, 4)) then
          bolimit := true;
        if GetBoValue(UserItem, UserItem.wIndex, 13) then
          bolimit := True;
        if (not bolimit) and (hum.AddItemToBag(UserItem)) then
        begin
          m_ItemList.Delete(i);
          boTrans := true;
        end;

        boFound := true;
        break;
      end;
    end;
    if boFound and (UserItem <> nil) then
    begin
      m_DefMsg := MakeDefaultMsg(38408, integer(self), 0, 0, 0);
      if boTrans then
        YsBagItem.send := 1
      else
        YsBagItem.send := 0;
      SendSocket(@m_DefMsg, encodebuffer(@YsBagItem, sizeof(YsBagItem)));
      if (not boTrans) and (not bolimit) then
        SysMsg('元神背包已经满了', c_Red, t_Hint);
      if bolimit then                                       //
        SysMsg('该物品不能放到元神背包', c_Red, t_Hint);
      if boTrans then
        hum.SendAddItem(UserItem);

    end;
  end;                                                      // flag=1
  if YsBagItem.Flag = 0 then
  begin                                                     //元神到人物   self=人物

    for i := hum.m_ItemList.Count - 1 downto 0 do
    begin
      UserItem := hum.m_ItemList.Items[i];
      if UserItem.MakeIndex = YsBagItem.ItemMake then
      begin
        if AddItemToBag(UserItem) then
        begin
          hum.m_ItemList.Delete(i);
          boTrans := true;
        end;
        boFound := true;
        break;
      end;
    end;
    if boFound and (UserItem <> nil) then
    begin

      if boTrans then
        YsBagItem.send := 1
      else
      begin
        YsBagItem.flag := 0;
        YsBagItem.send := 0;
      end;
      m_DefMsg := MakeDefaultMsg(38408, integer(self), 0, 0, 0);
      if YsBagItem.send = 0 then
        SysMsg('人物背包已经满了', c_Red, t_Hint);
      SendSocket(@m_DefMsg, encodebuffer(@YsBagItem, sizeof(YsBagItem)));
      //
      if boTrans then
        SendAddItem(UserItem);

    end;
  end;                                                      // flag=0

end;

procedure TPlayObject.ClientSendBagPos(count: integer; sMsg: string);
var
  Storagefile                                          : TIniFile;
  //   sItemPos:string;
   //  ParrItemPos:array of Tbagitempos;
begin
  //   EnterCriticalSection(ProcessStorageSection);
  try
    // sItemPos:='';
    //   sTemp:='';
    Storagefile := Tinifile.create(g_Config.sEnvirDir + 'Storage\' + m_sCharName);
    //  setlength(ParrItemPos,count);
    //  decodebuffer(sMsg,@ParrItemPos[0]);
    //  for I:=0 to count-1 do begin
    //  sItemPos:=sItemPos+ inttostr(ParrItemPos[i].itemmake)
    //  end;

    Storagefile.writeinteger('BagItemPos', 'count', count);
    Storagefile.writeString('BagItemPos', 'Pos', sMsg);

    //  ParrItemPos.free;
    Storagefile.Free;

  finally
    //  LeaveCriticalSection(ProcessStorageSection);
  end;
end;

procedure TPlayObject.ClientDelTask(TaskId: Integer);
var
  Storagefile, TaskContext                             : TIniFile;
  i, Taskstep, MaxTaskCount, Achievement, TotalTaskCount, TaskCount: integer;
begin
  //
  SendDefMessage(38294, TaskId, 0, 0, 2, '');

  Storagefile := Tinifile.create(g_Config.sEnvirDir + 'Storage\' + m_sCharName);
  if Storagefile = nil then
    exit;
  //  TotalTaskCount:=Storagefile.readinteger('Task','TotalTaskCount',0);
   // TaskCount:=Storagefile.readinteger('Task','TaskCount',0);
  //  if TaskCount>1 then Dec( TaskCount,1 );
   // Storagefile.Writeinteger('Task','TaskCount',TaskCount);
//  SendDefMessage(38294,0,0,0,0,format('<TaskInfo MaxTaskCount=%d Achievement=%d TotalTaskCount=%d/>',[MaxTaskCount,Achievement,TotalTaskCount]));
  Storagefile.Writestring('Task' + inttostr(TaskId), 'Title', '');
  Storagefile.Writeinteger('Task' + inttostr(TaskId), 'TaskStep', 0);

  Storagefile.Free;
  //   SendDefMessage(38294,0,0,0,0,'<TaskInfo MaxTaskCount=10 Achievement=0 TotalTaskCount=40/>')
  // 接受数据dwflag=31 wcmd=38294 w1=0 w2=0 w3=2 data=[]

end;

procedure TPlayObject.sendTaskInfo();
var
  Storagefile, TaskContext                             : TIniFile;
  TaskName                                             : string;
  i, Taskstep, MaxTaskCount, Achievement, TotalTaskCount, TaskCount: integer;
  Tasktitle, stepDESC                                  : string;
begin

  try

    Storagefile := Tinifile.create(g_Config.sEnvirDir + 'Storage\' + m_sCharName);
    if Storagefile = nil then
      exit;
    MaxTaskCount := Storagefile.readinteger('Task', 'MaxTaskCount', 10);
    Achievement := Storagefile.readinteger('Task', 'Achievement', 0);
    TotalTaskCount := Storagefile.readinteger('Task', 'TotalTaskCount', 0);
    nTaskCount := TotalTaskCount;
    nENDTASKCOUNT := Achievement;
    TaskCount := Storagefile.readinteger('Task', 'TaskCount', 0);
    SendDefMessage(38294, 0, 0, 0, 0,
      format('<TaskInfo MaxTaskCount=%d Achievement=%d TotalTaskCount=%d/>', [MaxTaskCount,
      Achievement, TotalTaskCount]));
    //    if  TaskCount>0 then begin
    for I := 1 to 10 do
    begin                                                   //  TaskCount

      TaskName := Storagefile.readstring('Task' + inttostr(i), 'Title', '');
      Taskstep := Storagefile.readinteger('Task' + inttostr(i), 'TaskStep', 0);
      if TaskName = '' then
        continue;
      TaskContext := Tinifile.create(g_Config.sEnvirDir + 'Task\' + TaskName + '.txt');
      if TaskContext <> nil then
      begin
        Tasktitle := TaskContext.ReadString('setup', 'title', '');
        stepDESC := TaskContext.ReadString('setup', 'stepDESC' + inttostr(Taskstep), '');
        if Tasktitle <> '' then
          SendDefMessage(38294, i, 0, 0, 1, format('<Task title=%s> %s </Task>',
            [Tasktitle, stepDESC]));
        TaskContext.Free;
      end;
    end;
    // end;
  finally
    Storagefile.Free;
  end;
end;

procedure TPlayObject.SendBagPos();
var
  Storagefile                                          : TIniFile;
  //  sItemPos:string;
  ParrItemPos                                          : array of Tbagitempos;
  count, i, j                                          : integer;
  sMsg                                                 : string;
  UserItem                                             : pTUserItem;
  tarrItemPos                                          : array of Tbagitempos;
  foundj                                               : boolean;
begin
  //   EnterCriticalSection(ProcessStorageSection);
  try

    sMsg := '';
    Storagefile := Tinifile.create(g_Config.sEnvirDir + 'Storage\' + m_sCharName);
    if Storagefile = nil then
      exit;
    count := Storagefile.readinteger('BagItemPos', 'count', 0);
    sMsg := Storagefile.readString('BagItemPos', 'Pos', '');
    setlength(ParrItemPos, count);
    decodebuffer(sMsg, @ParrItemPos[0], count * sizeof(Tbagitempos));
    setlength(tarrItemPos, m_ItemList.Count);

    for I := 0 to m_ItemList.Count - 1 do
    begin

      UserItem := m_ItemList.Items[I];
      foundj := false;
      for j := 0 to count - 1 do
      begin
        if UserItem.MakeIndex = ParrItemPos[j].itemmake then
        begin
          tarrItemPos[i] := ParrItemPos[j];

          foundj := true;
          break;
        end
      end;                                                  //for j
      if not foundj then
      begin
        tarrItemPos[i].itemmake := UserItem.MakeIndex;
        tarrItemPos[i].pos := 0;
      end;
    end;
    m_DefMsg := MakeDefaultMsg(70, 0, 0, 0, m_ItemList.Count); // count
    //  and (m_ItemList.Count=Count)

    if m_ItemList.Count <> 0 then
      SendSocket(@m_DefMsg, encodebuffer(@tarrItemPos[0], m_ItemList.Count *
        sizeof(Tbagitempos)));

    //   SendDefMessage(70,0,0,0,count,sMsg);
    setlength(ParrItemPos, 0);
    setlength(tarrItemPos, 0);
    Pointer(tarrItemPos) := nil;
    Pointer(ParrItemPos) := nil;
    Storagefile.Free;

  finally
    //  LeaveCriticalSection(ProcessStorageSection);
  end;
end;

procedure TPlayObject.Clientmonpickup(nx, ny: Integer);
var
  //mon:tbaseobject;
   //  i:integer;
  VisibleMapItem                                       : pTVisibleMapItem;
begin
  if m_bohasMONSTORAGE then
  begin
    {  for i:=m_SlaveList.Count -1 downto 0 do begin
         mon:=TBaseObject(m_SlaveList.Items[i]);
           if  mon.m_sCharName='丛林豹' then begin
             break;
           end;
      end; //for
    }//  if  i< m_SlaveList.Count then begin
    if m_bocanaddpickupitem then
    begin
      New(VisibleMapItem);
      VisibleMapItem.nX := nX;
      VisibleMapItem.nY := nY;
      m_mobpicupItems.Add(VisibleMapItem);
      //      MainOutMessage(format('加入检物品列表(%d/%d)',[nx,ny]));
    end;
    //   end;

  end;

end;

procedure TPlayObject.ClientStorageItemTomon(nItemIdx: Integer); //004DC2B8
var
  Merchant                                             : TMerchant;
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  bo19                                                 : Boolean;
  pStdItem                                             : pTStdItem;
  StdItem                                              : TStdItem;
  sUserItemName                                        : string;

  ClientItem                                           : TClientItem;
begin
  bo19 := False;
  UserItem := nil;

  begin
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      if UserItem.MakeIndex = nItemIdx then
      begin
        if m_monStoragelist.Count < m_monStoragesize then
        begin

          pStdItem := UserEngine.GetStdItem(UserItem.wIndex);
          StdItem := pStdItem^;
          if (stditem.StdMode = 49) and (stditem.Shape = 51) or (stditem.Shape = 151) or
            GetBoValue(UserItem, UserItem.wIndex, 14) then
          begin
            SendDefMessage(38404, nItemIdx, 0, 0, 0, '');
            SysMsg('不能放入该物品', c_Red, t_Hint);
            exit;
          end;

          ItemUnit.GetItemAddValue(UserItem, StdItem);
          ClientItem.S := StdItem;
          sUserItemName := '';
          if UserItem.btValue[13] = 1 then
            sUserItemName := ItemUnit.GetCustomItemName(UserItem.MakeIndex,
              UserItem.wIndex);
          if sUserItemName <> '' then
            ClientItem.S.Name := sUserItemName;
          ClientItem.DarkProperty := UserItem.DarkProp; //ItemUnit.GetItemDarkProperty(UserItem.MakeIndex, UserItem.wIndex);
          ClientItem.S.Name := FilterItemName(ClientItem.S.Name);
          ClientItem.MakeIndex := UserItem.MakeIndex;
          ClientItem.Dura := UserItem.Dura;
          ClientItem.DuraMax := UserItem.DuraMax;

          m_monStoragelist.Add(UserItem);
          m_ItemList.Delete(I);
          SendDefMessage(38404, nItemIdx, 0, 0, 1, '');
          m_DefMsg := MakeDefaultMsg(38403, integer(self), 0, 0, 1);
          SendSocket(@m_DefMsg, EncodeBuffer(@ClientItem, SizeOf(TClientItem)));
          WeightChanged();
          bo19 := true;

        end
        else
        begin
          SendDefMessage(38404, nItemIdx, 0, 0, 0, '');     //宠物背包满了，放物品失败
        end; //  m_monStoragelist.Count < m_monStoragesize

        break;
      end; //    UserItem.MakeIndex = nItemIdx

    end;                                                    //FOR

  end;

  //  if not bo19 then SendDefMessage(SM_STORAGE_FAIL,0,0,0,0,'');

end;

procedure TPlayObject.ClientTakeStorageItemFrommon(nItemIdx: Integer); //004DC664
var
  Merchant                                             : TMerchant;
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
  bo19                                                 : Boolean;
  StdItem                                              : pTStdItem;
  sUserItemName                                        : string;
begin
  bo19 := False;                                            //免费版本功能限制
  UserItem := nil;

  for I := 0 to m_monStoragelist.Count - 1 do
  begin
    UserItem := m_monStoragelist.Items[I];
    if UserItem.MakeIndex = nItemIdx then
    begin
      if AddItemToBag(UserItem) then
      begin
        SendDefMessage(38405, nItemIdx, 0, 0, 1, '');
        SendAddItem(UserItem);
        WeightChanged();
        m_monStoragelist.Delete(I);
        SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');

      end
      else
      begin
        // SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG,0,0,0,0,'');
        SendDefMessage(38405, nItemIdx, 0, 0, 0, '');
        SysMsg(g_sCanotGetItems, c_Red, t_Hint); //   '无法携带更多的东西！！！'
      end;

      bo19 := True;
      break;
    end;

  end;                                                      //for

  // if not bo19 then SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL,0,0,0,0,'');

end;

function TBaseObject.GetItemByName(sItemName: string; boDel: Boolean = false):
  pTUserItem;
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;

begin
  Result := nil;
  sItemName := FilterItemName(sItemName);
  for I := 0 to m_Itemlist.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0 then
    begin
      if boDel then
      begin
        TPlayObject(Self).SendDelItems(UserItem);
        Dispose(UserItem);
      end
      else
        Result := UserItem;

      break;
    end;
  end;                                                      // for
end;

function TBaseObject.GetItems(nMakeIndex: Integer): pTUserItem;
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
begin
  Result := nil;
  for I := 0 to m_Itemlist.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if UserItem^.MakeIndex = nMakeIndex then
    begin
      Result := UserItem;
      break;
    end;
  end;                                                      // for
end;

function TBaseObject.GetItemsCount(sItemName: string): Integer; //004C4AB0
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
begin
  Result := 0;
  for I := 0 to m_Itemlist.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0 then
    begin
      Inc(Result);
    end;
  end;                                                      // for
end;

function TBaseObject.CheckItems(sItemName: string): pTUserItem; //004C4AB0
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
begin
  Result := nil;
  for I := 0 to m_Itemlist.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0 then
    begin
      Result := UserItem;
      break;
    end;
  end;                                                      // for
end;

function TBaseObject.CheckItemsByIndex(nIndex: Integer): pTUserItem; //004C4AB0
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
begin
  Result := nil;
  for I := 0 to m_Itemlist.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if UserItem.MakeIndex = nIndex then
    begin
      Result := UserItem;
      break;
    end;
  end;                                                      // for
end;

procedure TPlayObject.MakeSaveRcd(var HumanRcd: THumDataInfo); //004B3580
var
  I                                                    : Integer;
  HumData                                              : pTHumData;
  HumItems                                             : pTHumItems;

  BagItems                                             : pTBagItems;
  HumMagic                                             : pTHumMagic;
  UserMagic                                            : pTUserMagic;
  StorageItems                                         : pTStorageItems;
  monStorageItems                                      : pTmonStorageItems;
begin
  HumData := @HumanRcd.Data;
  HumData.sChrName := m_sCharName;
  HumData.sCurMap := m_sMapName;
  HumData.wCurX := m_nCurrX;
  HumData.wCurY := m_nCurrY;
  HumData.btDir := m_btDirection;
  HumData.btHair := m_btHair;
  HumData.btSex := m_btGender;
  HumData.btJob := m_btJob;
  HumData.nGold := m_nGold;
  if (sYsnameMaster <> '') then
    HumData.nGold := m_nGold;
  if (sYsnameMaster <> '') and (btHasYS2 = 2) then
  begin
    HumData.Pneuma_2.Abil := m_Abil;
    {HumData.Abil_1.Level := m_Abil.Level;
    HumData.Abil_1.HP := m_Abil.HP;
    HumData.Abil_1.MP := m_Abil.MP;
    HumData.Abil_1.MaxHP := m_Abil.MaxHP;
    HumData.Abil_1.MaxMP := m_Abil.MaxMP;
    HumData.Abil_1.Exp := m_Abil.Exp;
    HumData.Abil_1.MaxExp := m_Abil.MaxExp;
    HumData.Abil_1.Weight := m_Abil.Weight;
    HumData.Abil_1.MaxWeight := m_Abil.MaxWeight;
    HumData.Abil_1.WearWeight := m_Abil.WearWeight;
    HumData.Abil_1.MaxWearWeight := m_Abil.MaxWearWeight;
    HumData.Abil_1.HandWeight := m_Abil.HandWeight;
    HumData.Abil_1.MaxHandWeight := m_Abil.MaxHandWeight;
    HumData.Abil_1.HP := m_WAbil.HP;
    HumData.Abil_1.MP := m_WAbil.MP;

    HUmData.Abil := Abil_1;
    }
    Humdata.Magic := Magic_1;
    HumData.btSex := btsex_1;
    HumData.btJob := btJob_1;
    HumData.Pneuma_2.btsex_1 := m_btGender;
    HumData.Pneuma_2.btJob_1 := m_btJob;
    HumData.btSex := btsex_1;
    HumData.btJob := btJob_1;

    HumMagic := @HumanRcd.Data.Pneuma_2.Magic;
    for I := 0 to m_MagicList.Count - 1 do
    begin
      if I >= MAXMAGIC then
        break;
      UserMagic := m_MagicList.Items[I];
      HumMagic[I].wMagIdx := UserMagic.wMagIdx;
      HumMagic[I].btLevel := UserMagic.btLevel;
      HumMagic[I].btKey := UserMagic.btKey;
      HumMagic[I].nTranPoint := UserMagic.nTranPoint;
    end;
  end
  else
  begin
    HumData.Abil.Level := m_Abil.Level;
    HumData.Abil.HP := m_Abil.HP;
    HumData.Abil.MP := m_Abil.MP;
    HumData.Abil.MaxHP := m_Abil.MaxHP;
    HumData.Abil.MaxMP := m_Abil.MaxMP;
    HumData.Abil.Exp := m_Abil.Exp;
    HumData.Abil.MaxExp := m_Abil.MaxExp;
    HumData.Abil.Weight := m_Abil.Weight;
    HumData.Abil.MaxWeight := m_Abil.MaxWeight;
    HumData.Abil.WearWeight := m_Abil.WearWeight;
    HumData.Abil.MaxWearWeight := m_Abil.MaxWearWeight;
    HumData.Abil.HandWeight := m_Abil.HandWeight;
    HumData.Abil.MaxHandWeight := m_Abil.MaxHandWeight;
    HumData.Abil.HP := m_WAbil.HP;
    HumData.Abil.MP := m_WAbil.MP;
    HumMagic := @HumanRcd.Data.Magic;
    for I := 0 to m_MagicList.Count - 1 do
    begin
      if I >= MAXMAGIC then
        break;
      UserMagic := m_MagicList.Items[I];
      HumMagic[I].wMagIdx := UserMagic.wMagIdx;
      HumMagic[I].btLevel := UserMagic.btLevel;
      HumMagic[I].btKey := UserMagic.btKey;
      HumMagic[I].nTranPoint := UserMagic.nTranPoint;
    end;
    HUmData.Pneuma_2.Abil := Abil_1;
    Humdata.Pneuma_2.Magic := Magic_1;
    if Abil_1.Level = 0 then
    begin
      if ysmasterplayer <> nil then
      begin
        HumData.Pneuma_2.btSex_1 := ysmasterplayer.nyssex_1;
        HumData.Pneuma_2.btJob_1 := ysmasterplayer.nysjob_1;
      end
    end
    else
    begin
      HumData.Pneuma_2.btSex_1 := btsex_1;
      HumData.Pneuma_2.btJob_1 := btJob_1;
    end;
  end;

  HumData.m_bMaxBagitem := m_bMaxBagitem;
  HumData.m_sSytleName := m_sSytleName;                     //个性化签名

  HumData.wStatusTimeArr := m_wStatusTimeArr;               //hint 人物状态保存。
  HumData.sHomeMap := m_sHomeMap;
  HumData.wHomeX := m_nHomeX;
  HumData.wHomeY := m_nHomeY;
  HumData.wPKPoint := m_nPkPoint;
  HumData.BonusAbil := m_BonusAbil;                         // 08/09
  HumData.nBonusPoint := m_nBonusPoint;                     // 08/09
  HumData.sStoragePwd := m_sStoragePwd;
  HumData.btCreditPoint := m_btCreditPoint;
  HumData.btReLevel := m_btReLevel;

  HumData.sMasterName := m_sMasterName;
  if sYsnameMaster <> '' then
  begin
    HumData.sYsname := sYsnameMaster;
    HumData.btYS := nyssex + 1; ;
    HumData.boYS := True;
  end
  else
  begin
    HumData.sYsname := sYsname;
    HumData.btys := nyssex + 1;
    HumData.boYS := False;
  end;
  //  HumData.sYsnameMaster := sYsnameMaster;
  HumData.nyssex := nyssex;
  HumData.nysjob := nysjob;
  HumData.wyslevel := wyslevel_1;
  HumData.nyssex_1 := nyssex_1;
  HumData.nysjob_1 := nysjob_1;
  HumData.wyslevel_1 := wyslevel_1;
  HumData.btHasYS2 := btHasYS2;
  HumData.sDieMap := sDieMap;
  HumData.wDieX := wDieX;
  HumData.wDieY := wDieY;
  HumData.boMaster := m_boMaster;
  HumData.sDearName := m_sDearName;

  HumData.nGameGold := m_nGameGold;
  HumData.nGamePoint := m_nGamePoint;
  HumData.m_nJpPoint := m_nJpPoint;
  HumData.wGEMCOUNT[0] := wGEMCOUNT[0];
  HumData.wGEMCOUNT[1] := wGEMCOUNT[1];
  HumData.wGEMCOUNT[2] := wGEMCOUNT[2];
  HumData.wATTACHEPOINT := wATTACHEPOINT;
  HumData.m_YSPoint := m_YSPoint;
  Humdata.m_nGameCode := m_nGameCode;
  HumData.M_YSfenghao := M_YSfenghao;
  if m_boAllowGroup then
    HumData.btAllowGroup := 1
  else
    HumData.btAllowGroup := 0;

  HumData.btAttatckMode := m_btAttatckMode;
  HumData.btIncHealth := m_nIncHealth;
  HumData.btIncSpell := m_nIncSpell;
  HumData.btIncHealing := m_nIncHealing;
  HumData.btFightZoneDieCount := m_nFightZoneDieCount;
  HumData.sAccount := m_sUserID;

  HumData.boLockLogon := m_boLockLogon;
  HumData.wContribution := m_wContribution;

  HumData.nHungerStatus := m_nHungerStatus;
  HumData.boAllowGuildReCall := m_boAllowGuildReCall;
  HumData.wGroupRcallTime := m_wGroupRcallTime;
  HumData.dBodyLuck := m_dBodyLuck;
  HumData.boAllowGroupReCall := m_boAllowGroupReCall;
  HumData.QuestUnitOpen := m_QuestUnitOpen;
  HumData.QuestUnit := m_QuestUnit;
  HumData.QuestFlag := m_QuestFlag;

  HumItems := @HumanRcd.Data.HumItems;
  HumItems[U_DRESS] := m_UseItems[U_DRESS];
  HumItems[U_WEAPON] := m_UseItems[U_WEAPON];
  HumItems[U_RIGHTHAND] := m_UseItems[U_RIGHTHAND];

  HumItems[U_HELMET] := m_UseItems[U_NECKLACE];
  HumItems[U_NECKLACE] := m_UseItems[U_HELMET];

  HumItems[U_ARMRINGL] := m_UseItems[U_ARMRINGL];
  HumItems[U_ARMRINGR] := m_UseItems[U_ARMRINGR];
  HumItems[U_RINGL] := m_UseItems[U_RINGL];
  HumItems[U_RINGR] := m_UseItems[U_RINGR];

  HumItems[U_BUJUK] := m_UseItems[U_BUJUK];
  HumItems[U_BELT] := m_UseItems[U_BELT];
  HumItems[U_BOOTS] := m_UseItems[U_BOOTS];
  HumItems[U_CHARM] := m_UseItems[U_CHARM];
  HumData.Hum_ShieldItem := m_UseItems[U_shield];
  HumData.Hum_HunZhuItem := m_UseItems[14];
  HumanRcd.data.btLXBHCount := btLXBHCount;
  HumanRcd.data.nLXBHTIme := nLXBHTime;
  for I := 0 to 14 do
    Humanrcd.data.btAdditionalAbil[i] := btAdditionalAbil[i];
  HumanRcd.data.btLXBHItemCount := btLXBHItemCount;
  {  if sYsnameMaster='' then
    Begin
       for I := 0 to 19 do
           HumanRcd.data.LXBHITEM[i] := LXBHITEM[i];
    End;
   } if not (m_bMaxBagitem in [46, 66]) then
    m_bMaxBagitem := 46;
  HumData.m_bMaxBagitem := m_bMaxBagitem;

  BagItems := @HumanRcd.Data.BagItems;
  for I := 0 to m_ItemList.Count - 1 do
  begin
    if I >= m_bMaxBagitem then
      break;                                                //  MAXBAGITEM
    BagItems[I] := pTUserItem(m_ItemList.Items[I])^;
  end;

  monStorageItems := @HumanRcd.Data.monStorageItems;
  for i := 0 to m_monStoragelist.Count - 1 do
  begin
    if i > High(TmonStorageItems) then
      break;
    monStorageItems[i] := pTUserItem(m_monStoragelist.Items[I])^;
  end;

  StorageItems := @HumanRcd.Data.StorageItems;
  for I := 0 to m_StorageItemList.Count - 1 do
  begin
    if I > High(TStorageItems) then
      break;                                                //>= 修复最后一个不保存的问题
    StorageItems[I] := pTUserItem(m_StorageItemList.Items[I])^;
  end;

end;

function TBaseObject.sub_4C3538: Integer;                   //004C3538
var
  nC, n10                                              : Integer;
begin
  Result := 0;
  nC := -1;
  while (nC <> 2) do
  begin
    n10 := -1;
    while (n10 <> 2) do
    begin
      if not m_PEnvir.CanWalk(m_nCurrX + nC, m_nCurrY + n10, False) then
      begin
        if (nC <> 0) or (n10 <> 0) then
          Inc(Result);
      end;
      Inc(n10);
    end;
    Inc(nC);
  end;
end;

procedure TPlayObject.RefRankInfo(nRankNo: Integer; sRankName: string); //004CAE3C
begin
  m_nGuildRankNo := nRankNo;
  m_sGuildRankName := sRankName;
  SendMsg(Self, RM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
end;

function TBaseObject.DelBagItem(nIndex: Integer): Boolean;  //004C4F10
begin
  Result := False;
  if (nIndex < 0) or (nIndex >= m_ItemList.Count) then
    exit;
  Dispose(pTUserItem(m_ItemList.Items[nIndex]));
  m_ItemList.Delete(nIndex);
  Result := True;
end;

function TBaseObject.DelBagItem(nItemIndex: Integer;        //004C4DFC
  sItemName: string; bosendDel: Boolean = false): Boolean;
var
  I                                                    : Integer;
  UserItem                                             : pTUserItem;
begin
  Result := False;
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if (UserItem.MakeIndex = nItemIndex) and
      (CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0) then
    begin
      if bosendDel then
        TPlayObject(Self).SendDelItems(UserItem);

      Dispose(UserItem);
      m_ItemList.Delete(I);
      Result := True;
      break;
    end;
  end;
  if Result then
    WeightChanged();

end;

procedure TPlayObject.GetOldAbil(var OAbility: TOAbility);
begin
  {
  FillChar(OAbility, SizeOf(TOAbility), #0);
  OAbility.Level:=m_WAbil.Level;
  OAbility.AC:=MakeWord(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC));
  OAbility.MAC:=MakeWord(LoWord(m_WAbil.MAC),HiWord(m_WAbil.MAC));
  OAbility.DC:=MakeWord(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC));
  OAbility.MC:=MakeWord(LoWord(m_WAbil.MC),HiWord(m_WAbil.MC));
  OAbility.SC:=MakeWord(LoWord(m_WAbil.SC),HiWord(m_WAbil.SC));
  OAbility.HP:=m_WAbil.HP;
  OAbility.MP:=m_WAbil.MP;
  OAbility.MaxHP:=m_WAbil.MaxHP;
  OAbility.MaxMP:=m_WAbil.MaxMP;
  OAbility.Exp:=m_WAbil.Exp;
  OAbility.MaxExp:=m_WAbil.MaxExp;
  OAbility.Weight:=m_WAbil.Weight;
  OAbility.MaxWeight:=m_WAbil.MaxWeight;
  OAbility.WearWeight:=m_WAbil.WearWeight;
  OAbility.MaxWearWeight:=_MAX(High(Byte),m_WAbil.MaxWearWeight);
  OAbility.HandWeight:=m_WAbil.HandWeight;
  OAbility.MaxHandWeight:=_MAX(High(Byte),m_WAbil.MaxHandWeight);
  }
  FillChar(OAbility, SizeOf(TOAbility), #0);
  OAbility.Level := m_WAbil.Level;
  OAbility.AC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.AC)), _MIN(High(Byte),
    HiWord(m_WAbil.AC)));
  OAbility.MAC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MAC)), _MIN(High(Byte),
    HiWord(m_WAbil.MAC)));
  OAbility.DC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.DC)), _MIN(High(Byte),
    HiWord(m_WAbil.DC)));
  OAbility.MC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MC)), _MIN(High(Byte),
    HiWord(m_WAbil.MC)));
  OAbility.SC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.SC)), _MIN(High(Byte),
    HiWord(m_WAbil.SC)));
  OAbility.HP := m_WAbil.HP;
  OAbility.MP := m_WAbil.MP;
  OAbility.MaxHP := m_WAbil.MaxHP;
  OAbility.MaxMP := m_WAbil.MaxMP;
  OAbility.dw1AC := m_nPkPoint;                             //m_WAbil.dw1AC;    pK值
  OAbility.Exp := m_WAbil.Exp;
  OAbility.MaxExp := m_WAbil.MaxExp;
  OAbility.Weight := m_WAbil.Weight;
  OAbility.MaxWeight := m_WAbil.MaxWeight;
  OAbility.WearWeight := _MIN(High(Byte), m_WAbil.WearWeight);
  OAbility.MaxWearWeight := _MIN(High(Byte), m_WAbil.MaxWearWeight);
  OAbility.HandWeight := _MIN(High(Byte), m_WAbil.HandWeight);
  OAbility.MaxHandWeight := _MIN(High(Byte), m_WAbil.MaxHandWeight);
end;

function TPlayObject.GetHitMsgCount: Integer;
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_HIT) or
        (SendMessage.wIdent = CM_HEAVYHIT) or
        (SendMessage.wIdent = CM_BIGHIT) or
        (SendMessage.wIdent = CM_POWERHIT) or
        (SendMessage.wIdent = CM_LONGHIT) or
        (SendMessage.wIdent = CM_WIDEHIT) or
        (SendMessage.wIdent = CM_FIREHIT) or
        (SendMessage.wIdent = CM_3026HIT)
        then
      begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetSpellMsgCount: Integer;
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_SPELL) then
      begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetRunMsgCount: Integer;
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_RUN) then
      begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetWalkMsgCount: Integer;
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_WALK) then
      begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetTurnMsgCount: Integer;
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
begin
  Result := 0;
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    for I := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_TURN) then
      begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.GetSiteDownMsgCount: Integer;
var
  I                                                    : Integer;
  SendMessage                                          : pTSendMessage;
begin
  Result := 0;
  EnterCriticalSection(ProcessMsgCriticalSection);
  try
    for I := 0 to m_MsgList.Count - 1 do
    begin
      SendMessage := m_Msglist.Items[i];
      if (SendMessage.wIdent = CM_SITDOWN) then
      begin
        Inc(Result);
      end;
    end;
  finally
    LeaveCriticalSection(ProcessMsgCriticalSection);
  end;
end;

function TPlayObject.CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord): Boolean;
var
  dwCheckTime                                          : LongWord;
  dwCurrTick                                           : LongWord;
  dwActionIntervalTime                                 : LongWord;
begin
  Result := False;
  dwDelayTime := 0;
  //检查人物弯腰停留时间
  if not g_Config.boDisableStruck then
  begin
    dwCheckTime := GetTickCount - m_dwStruckTick;
    if g_Config.dwStruckTime > dwCheckTime then
    begin
      dwDelayTime := g_Config.dwStruckTime - dwCheckTime;
      m_btOldDir := m_btDirection;
      exit;
    end;
  end;

  if m_boTestSpeedMode then
  begin
    SysMsg('间隔: ' + IntToStr(dwCheckTime) + ':' + IntToStr(wIdent), c_Blue, t_Notice);
  end;

  if m_wOldIdent = wIdent then
  begin //当二次操作一样时，则将 boFirst 设置为 真 ，退出由调用函数本身检查二个相同操作之间的间隔时间

    Result := True;
    exit;
  end;
  if not g_Config.boControlActionInterval then
  begin
    Result := True;
    exit;
  end;

  dwActionIntervalTime := m_dwActionIntervalTime;
  case wIdent of
    CM_LONGHIT:
      begin
        //跑位刺杀
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_RUN) and (m_btOldDir <>
          m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
      end;
    CM_HIT:
      begin
        //走位攻击
        if g_Config.boControlWalkHit and (m_wOldIdent = CM_WALK) and (m_btOldDir <>
          m_btDirection) then
        begin
          dwActionIntervalTime := m_dwWalkHitIntervalTime;
        end;
        //跑位攻击
        if g_Config.boControlRunHit and (m_wOldIdent = CM_RUN) and (m_btOldDir <>
          m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunHitIntervalTime;
        end;
      end;
    CM_RUN:
      begin
        //跑位刺杀
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_LONGHIT) and (m_btOldDir <>
          m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
        //跑位攻击
        if g_Config.boControlRunHit and (m_wOldIdent = CM_HIT) and (m_btOldDir <>
          m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunHitIntervalTime;
        end;
        //跑位魔法
        if g_Config.boControlRunMagic and (m_wOldIdent = CM_SPELL) and (m_btOldDir <>
          m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunMagicIntervalTime;
        end;
      end;
    CM_WALK:
      begin
        //走位攻击
        if g_Config.boControlWalkHit and (m_wOldIdent = CM_HIT) and (m_btOldDir <>
          m_btDirection) then
        begin
          dwActionIntervalTime := m_dwWalkHitIntervalTime;
        end;
        //跑位刺杀
        if g_Config.boControlRunLongHit and (m_wOldIdent = CM_LONGHIT) and (m_btOldDir <>
          m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunLongHitIntervalTime;
        end;
      end;
    CM_SPELL:
      begin
        //跑位魔法      if g_Config.boControlRunMagic and (m_wOldIdent = CM_RUN) and (m_btOldDir <> m_btDirection) then
        begin
          dwActionIntervalTime := m_dwRunMagicIntervalTime;
        end;
      end;
  end;

  //将几个攻击操作合并成一个攻击操作代码
  if (wIdent = CM_HIT) or
    (wIdent = CM_HEAVYHIT) or
    (wIdent = CM_BIGHIT) or
    (wIdent = CM_POWERHIT) or
    //     (wIdent = CM_LONGHIT) or
  (wIdent = CM_WIDEHIT) or
    (wIdent = CM_FIREHIT) or
    (wIdent = CM_3026HIT)

  then
  begin

    wIdent := CM_HIT;
  end;

  if dwCheckTime >= dwActionIntervalTime then
  begin
    m_dwActionTick := GetTickCount();
    Result := True;
  end
  else
  begin
    dwDelayTime := dwActionIntervalTime - dwCheckTime;
  end;
  m_wOldIdent := wIdent;
  m_btOldDir := m_btDirection;

end;

procedure TPlayObject.SetScriptLabel(sLabel: string);
begin
  m_CanJmpScriptLableList.Clear;
  m_CanJmpScriptLableList.Add(sLabel);
end;
//取得当前脚本可以跳转的标签

procedure TPlayObject.GetScriptLabel(sMsg: string);
var
  sText                                                : string;
  sData                                                : string;
  sCmdStr, sLabel                                      : string;
begin
  m_CanJmpScriptLableList.Clear;
  while (True) do
  begin
    if sMsg = '' then
      break;
    sMsg := GetValidStr3(sMsg, sText, ['\']);
    if sText <> '' then
    begin
      sData := '';
      while (Pos('<', sText) > 0) and (Pos('>', sText) > 0) and (sText <> '') do
      begin
        if sText[1] <> '<' then
        begin
          sText := '<' + GetValidStr3(sText, sData, ['<']);
        end;
        sText := ArrestStringEx(sText, '<', '>', sCmdStr);
        sLabel := GetValidStr3(sCmdStr, sCmdStr, ['/']);
        if sLabel <> '' then
          m_CanJmpScriptLableList.Add(sLabel);
      end;
    end;
  end;
end;

procedure TPlayObject.GetScriptLabelleft(sMsg: string);
var
  sText                                                : string;
  sData                                                : string;
  sCmdStr, sLabel                                      : string;
begin
  m_CanJmpScriptLableListleft.Clear;
  while (True) do
  begin
    if sMsg = '' then
      break;
    sMsg := GetValidStr3(sMsg, sText, ['\']);
    if sText <> '' then
    begin
      sData := '';
      while (Pos('<', sText) > 0) and (Pos('>', sText) > 0) and (sText <> '') do
      begin
        if sText[1] <> '<' then
        begin
          sText := '<' + GetValidStr3(sText, sData, ['<']);
        end;
        sText := ArrestStringEx(sText, '<', '>', sCmdStr);
        sLabel := GetValidStr3(sCmdStr, sCmdStr, ['/']);
        if sLabel <> '' then
          m_CanJmpScriptLableListleft.Add(sLabel);
      end;
    end;
  end;
end;

function TPlayObject.LableIsCanJmp(sLabel: string; m_bocallboard: boolean): Boolean;
var
  I                                                    : Integer;
begin
  Result := False;
  if CompareText(sLabel, '@main') = 0 then
  begin
    Result := True;
    exit;
  end;
  for I := 0 to m_CanJmpScriptLableList.Count - 1 do
  begin
    if CompareText(sLabel, m_CanJmpScriptLableList.Strings[I]) = 0 then
    begin
      Result := True;
      break;
    end;
  end;
  if m_bocallboard then
  begin
    for I := 0 to m_CanJmpScriptLableListleft.Count - 1 do
    begin
      if CompareText(sLabel, m_CanJmpScriptLableListleft.Strings[I]) = 0 then
      begin
        Result := True;
        break;
      end;
    end;

  end;

  if CompareText(sLabel, m_sPlayDiceLabel) = 0 then
  begin
    m_sPlayDiceLabel := '';
    Result := True;
    exit;
  end;
end;

procedure TPlayObject.RecalcAbilitys;
begin
  inherited;
  RecalcAdjusBonus();
end;

procedure TPlayObject.SearchViewRange;
var
  I                                                    : Integer;
  nStartX                                              : Integer;
  nEndX                                                : Integer;
  nStartY                                              : Integer;
  nEndY                                                : Integer;
  n18                                                  : Integer;
  n1C                                                  : Integer;
  nIdx                                                 : Integer;
  n24                                                  : Integer;
  MapCellInfo                                          : pTMapCellinfo;
  OSObject                                             : pTOSObject;
  BaseObject                                           : TBaseObject;
  MapItem                                              : pTMapItem;
  MapEvent                                             : TEvent;
  VisibleBaseObject                                    : pTVisibleBaseObject;
  VisibleMapItem                                       : pTVisibleMapItem;
  nCheckCode                                           : Integer;
resourcestring
  sExceptionMsg1                                         =
    '[Exception] TPlayObject::SearchViewRange Code:%d';
  sExceptionMsg2                                         =
    '[Exception] TPlayObject::SearchViewRange 1-%d %s %s %d %d %d';

begin
  n24 := 0;
  try
    nCheckCode := 2;
    for I := 0 to m_VisibleItems.Count - 1 do
    begin
      pTVisibleMapItem(m_VisibleItems.Items[I]).nVisibleFlag := 0;
    end;
    nCheckCode := 3;
    for I := 0 to m_VisibleEvents.Count - 1 do
    begin
      TEvent(m_VisibleEvents.Items[i]).nVisibleFlag := 0;
    end;
    nCheckCode := 4;
    for I := 0 to m_VisibleActors.Count - 1 do
    begin
      pTVisibleBaseObject(m_VisibleActors.Items[i]).nVisibleFlag := 0;
    end;
    nCheckCode := 5;
  except
    MainOutMessage(format(sExceptionMsg1, [nCheckCode]));
    KickException();
  end;
  nCheckCode := 6;

  nStartX := m_nCurrX - m_nViewRange;
  nEndX := m_nCurrX + m_nViewRange;
  nStartY := m_nCurrY - m_nViewRange;
  nEndY := m_nCurrY + m_nViewRange;
  try
    nCheckCode := 7;
    for n18 := nStartX to nEndX do
    begin
      nCheckCode := 8;
      for n1C := nStartY to nEndY do
      begin
        nCheckCode := 9;
        if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo) and (MapCellInfo.ObjList <> nil)
          then
        begin
          nCheckCode := 10;
          n24 := 1;
          nIdx := 0;
          while (True) do
          begin
            nCheckCode := 11;
            if MapCellInfo.ObjList.Count <= nIdx then
              break;                                        //004B9858
            OSObject := MapCellInfo.ObjList.Items[nIdx];
            nCheckCode := 12;
            //////////  2006，8，3 处理抱错
            if OSObject = nil then
            begin
              MapCellInfo.ObjList.Delete(nIdx);
              if MapCellInfo.ObjList.Count > 0 then
                Continue;
              MapCellInfo.ObjList.Free;
              MapCellInfo.ObjList := nil;
              break;
            end;
            ///////////

            if OSObject <> nil then
            begin
              nCheckCode := 13;
              if OSObject.btType = OS_MOVINGOBJECT then
              begin
                nCheckCode := 14;
                if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then
                begin
                  Dispose(OSObject);
                  MapCellInfo.ObjList.Delete(nIdx);
                  if MapCellInfo.ObjList.Count > 0 then
                    Continue;
                  MapCellInfo.ObjList.Free;
                  MapCellInfo.ObjList := nil;
                  break;
                end;                                        //004B9907
                nCheckCode := 15;
                BaseObject := TBaseObject(OSObject.CellObj);
                if BaseObject <> nil then
                begin
                  nCheckCode := 16;
                  if BaseObject.m_sCharName = 'uyiuy' then
                    i := 0;
                  if not BaseObject.m_boGhost and not BaseObject.m_boFixedHideMode and not
                    BaseObject.m_boObMode then
                  begin
                    nCheckCode := 17;
                    if (m_btRaceServer < RC_ANIMAL) or
                      (m_Master <> nil) or
                      m_boCrazyMode or
                      m_boWantRefMsg or
                      ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX -
                        m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) or
                      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
                    begin
                      nCheckCode := 18;
                      UpdateVisibleGay(BaseObject);
                      nCheckCode := 19;
                    end;                                    //004B99E2
                  end;                                      //004B99E2
                end; //004B99E2 if BaseObject <> nil then begin
              end; //004B99E2 if OSObject.btType = OS_MOVINGOBJECT then begin
              nCheckCode := 20;
              if m_btRaceServer = RC_PLAYOBJECT then
              begin
                if OSObject.btType = OS_ITEMOBJECT then
                begin
                  nCheckCode := 21;
                  if (GetTickCount - OSObject.dwAddTime) >
                    g_Config.dwClearDropOnFloorItemTime {60 * 60 * 1000} then
                  begin
                    nCheckCode := 211;
                    Dispose(pTMapItem(OSObject.CellObj)); //Jacky 10/22  防止占用内存不释放现象
                    nCheckCode := 212;
                    Dispose(OSObject);
                    nCheckCode := 213;
                    MapCellInfo.ObjList.Delete(nIdx);
                    nCheckCode := 214;
                    if MapCellInfo.ObjList.Count > 0 then
                      Continue;
                    MapCellInfo.ObjList.Free;
                    MapCellInfo.ObjList := nil;
                    break;
                  end;                                      //004B9A8E
                  MapItem := pTMapItem(OSObject.CellObj);
                  nCheckCode := 28;
                  UpdateVisibleItem(n18, n1C, MapItem);
                  if (MapItem.OfBaseObject <> nil) or (MapItem.DropBaseObject <> nil)
                    then
                  begin
                    nCheckCode := 29;
                    if (GetTickCount - MapItem.dwCanPickUpTick) >
                      g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then
                    begin
                      nCheckCode := 30;
                      MapItem.OfBaseObject := nil;
                      MapItem.DropBaseObject := nil;
                    end
                    else
                    begin                                   //004B9AF6
                      nCheckCode := 31;
                      if TBaseObject(MapItem.OfBaseObject) <> nil then
                      begin
                        nCheckCode := 32;
                        if TBaseObject(MapItem.OfBaseObject).m_boGhost then
                          MapItem.OfBaseObject := nil;
                      end;
                      nCheckCode := 33;
                      if TBaseObject(MapItem.DropBaseObject) <> nil then
                      begin
                        nCheckCode := 34;
                        if TBaseObject(MapItem.DropBaseObject).m_boGhost then
                          MapItem.DropBaseObject := nil;
                      end;
                      nCheckCode := 35;
                    end;                                    //004B9B38
                  end;
                end; //004B9B38 if OSObject.btType = OS_ITEMOBJECT then begin
                nCheckCode := 36;
                if OSObject.btType = OS_EVENTOBJECT then
                begin
                  nCheckCode := 37;
                  MapEvent := TEvent(OSObject.CellObj);
                  if MapEvent.m_boVisible then
                  begin
                    nCheckCode := 38;
                    UpdateVisibleEvent(n18, n1C, MapEvent);
                  end;
                  nCheckCode := 39;
                end;
              end
            end; //004B9B81 if OSObject <> nil then begin
            Inc(nIdx);
          end;                                              //while (True) do begin
        end;
      end; //for n1C:= n10 to n14  do begin
    end;                                                    //for n18:= n8 to nC do begin
  except
    on e: Exception do
    begin

      MainOutMessage(format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX,
        m_nCurrY, nCheckCode]));
      {
      MainOutMessage(m_sCharName + ',' +
                     m_sMapName + ',' +
                     IntToStr(m_nCurrX) + ',' +
                     IntToStr(m_nCurrY) + ',' +
                     ' SearchViewRange 1-' +
                     IntToStr(n24));
      }
      MainOutMessage(E.Message);
      raise;
      KickException();
    end;

  end;
  nCheckCode := 40;
  n24 := 2;
  try
    n18 := 0;
    while (True) do
    begin
      if m_VisibleActors.Count <= n18 then
        break;
      nCheckCode := 41;
      VisibleBaseObject := m_VisibleActors.Items[n18];
      nCheckCode := 42;
      if VisibleBaseObject.nVisibleFlag = 0 then
      begin
        nCheckCode := 43;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          nCheckCode := 44;
          BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
          {
          if not BaseObject.m_boFixedHideMode then
            SendMsg(BaseObject,RM_DISAPPEAR,0,0,0,0,'');
          }
          nCheckCode := 45;
          if not BaseObject.m_boFixedHideMode and (not BaseObject.m_boGhost) then
          begin //01/21 修改防止人物退出时发送重复的消息占用带宽，人物进入隐身模式时人物不消失问题
            nCheckCode := 46;
            SendMsg(BaseObject, RM_DISAPPEAR, 0, 0, 0, 0, '');
          end;
          nCheckCode := 47;
        end;
        m_VisibleActors.Delete(n18);
        nCheckCode := 48;
        Dispose(VisibleBaseObject);
        nCheckCode := 49;
        Continue;
      end;
      nCheckCode := 50;
      if (m_btRaceServer = RC_PLAYOBJECT) and (VisibleBaseObject.nVisibleFlag = 2) then
      begin
        nCheckCode := 51;
        BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
        nCheckCode := 52;
        if BaseObject <> Self then
        begin
          nCheckCode := 53;
          if BaseObject.m_boDeath then
          begin
            nCheckCode := 54;
            if BaseObject.m_boSkeleton then
            begin
              nCheckCode := 55;
              SendMsg(BaseObject, RM_SKELETON, BaseObject.m_btDirection,
                BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
              nCheckCode := 56;
            end
            else
            begin                                           //004B9DA8
              nCheckCode := 57;
              SendMsg(BaseObject, RM_DEATH, BaseObject.m_btDirection,
                BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
              nCheckCode := 58;
            end;
          end
          else
          begin                                             //004B9DD3
            nCheckCode := 59;
            SendMsg(BaseObject, RM_TURN, BaseObject.m_btDirection, BaseObject.m_nCurrX,
              BaseObject.m_nCurrY, 0, BaseObject.GetShowName);
            nCheckCode := 60;
          end;
        end;                                                //004B9E09
      end;
      Inc(n18);
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg2, [n24, m_sCharName, m_sMapName, m_nCurrX,
        m_nCurrY, nCheckCode]));
      {MainOutMessage(m_sCharName + ',' +
                     m_sMapName + ',' +
                     IntToStr(m_nCurrX) + ',' +
                     IntToStr(m_nCurrY) + ',' +
                     ' SearchViewRange 2');}
      MainOutMessage(E.Message);
      raise;
      KickException();
    end;

  end;
  try
    //    if (m_btRaceServer = RC_PLAYOBJECT) then begin
    I := 0;
    while (True) do
    begin
      if m_VisibleItems.Count <= I then
        break;
      VisibleMapItem := m_VisibleItems.Items[I];
      if VisibleMapItem = nil then
      begin
        m_VisibleItems.Delete(I);
        Continue;
      end;
      if VisibleMapItem.nVisibleFlag = 0 then
      begin
        SendMsg(Self, RM_ITEMHIDE, 0, Integer(VisibleMapItem.MapItem), VisibleMapItem.nX,
          VisibleMapItem.nY, '');
        m_VisibleItems.Delete(I);
        Dispose(VisibleMapItem);
        Continue;
      end;                                                  //004B9F6C
      if VisibleMapItem.nVisibleFlag = 2 then
      begin
        SendMsg(Self, RM_ITEMSHOW, VisibleMapItem.wLooks,
          Integer(VisibleMapItem.MapItem), VisibleMapItem.nX, VisibleMapItem.nY,
          VisibleMapItem.sName);
      end;
      Inc(I);
    end;
    I := 0;
    while (True) do
    begin
      if m_VisibleEvents.Count <= I then
        break;

      MapEvent := m_VisibleEvents.Items[I];
      if MapEvent = nil then
      begin
        m_VisibleEvents.Delete(I);
        Continue;
      end;
      if MapEvent.nVisibleFlag = 0 then
      begin
        SendMsg(Self, RM_HIDEEVENT, 0, Integer(MapEvent), MapEvent.m_nX, MapEvent.m_nY,
          '');
        m_VisibleEvents.Delete(I);
        Continue;
      end;                                                  //004BA053
      if MapEvent.nVisibleFlag = 2 then
      begin
        if MapEvent.m_nEventType >= 0 then                  //暗影雷电 =-1
          if MapEvent is TSafeZoneLight then                //如果是安全区光环
            SendMsg(Self, RM_SHOWEVENT, g_Config.nUseSafeZoneLightType,
              Integer(MapEvent), MakeLong(MapEvent.m_nX, MapEvent.m_nEventParam),
              MapEvent.m_nY, '')
          else
            SendMsg(Self, RM_SHOWEVENT, MapEvent.m_nEventType, Integer(MapEvent),
              MakeLong(MapEvent.m_nX, MapEvent.m_nEventParam), MapEvent.m_nY, '');
      end;
      Inc(I);
    end;
    //    end;
  except
    MainOutMessage(m_sCharName + ',' +
      m_sMapName + ',' +
      IntToStr(m_nCurrX) + ',' +
      IntToStr(m_nCurrY) + ',' +
      ' SearchViewRange 3');

    KickException();
  end;
end;

{
function TPlayObject.GetShowName: String;
var
  sShowName:String;
  sGuildName:String;
  sDearName:String;
  sMasterName:String;
begin
try
  //sShowName:=m_sCharName;
  if m_MyGuild <> nil then begin
    if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
      sGuildName:='(' + UserCastle.sName + ')' + TGuild(m_MyGuild).sGuildName + '[' + m_sGuildRankName + ']';
    end else begin
      if g_boShowGuildName or (UserCastle.boUnderWar and (m_boInFreePKArea or UserCastle.IsCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY))) then begin
        sGuildName:= TGuild(m_MyGuild).sGuildName + '[' + m_sGuildRankName + ']';
      end;
    end;
  end;
  if m_sMasterName <> '' then begin
    if m_boMaster then begin
      sMasterName:= m_sMasterName + '的师傅';
    end else begin
      sMasterName:= m_sMasterName + '的徒弟';
    end;
  end;
  if m_sDearName <> '' then begin
    if m_btGender = 0 then begin
      sDearName:= m_sDearName + '的老公';
    end else begin
      sDearName:= m_sDearName + '的老婆';
    end;
  end;
  sShowName:=sGuildName;
  sShowName:= sShowName + '\' + m_sCharName;
  if sDearName <> '' then begin
    sShowName:= sShowName + '\' + sDearName;
  end;
  if sMasterName <> '' then begin
    sShowName:= sShowName + '\' + sMasterName;
  end;

  Result:=sShowName;
except
  on e: Exception do begin
    MainOutMessage('[Exception] TPlayObject.GetShowName');
    MainOutMessage(E.Message);
  end;
end;
end;
}

function TPlayObject.GetShowName: string;
var
  sShowName                                            : string;
  sCharName                                            : string;
  sGuildName                                           : string;
  sDearName                                            : string;
  sMasterName                                          : string;
  Castle                                               : TUserCastle;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::GetShowName';
begin
  try
    //sShowName:=m_sCharName;
    if (m_btRaceServer = RC_YSBJECT) and (m_Master <> nil) then
    begin
      result := m_sCharName + '(' + m_Master.m_sCharName + ')';
      exit;
    end;
    if (m_btRaceServer = RC_YSBJECT) then
    begin
      result := FilterShowName(m_sCharName);
      exit;
    end;
    if sYsnameMaster <> '' then
    begin                                                   //表示元神
      result := m_sCharName + '\(' + sYsnameMaster + '的元神)';
      exit;
    end;

    sCharName := '';
    sGuildName := '';
    sDearName := '';
    sMasterName := '';
    if m_MyGuild <> nil then
    begin
      Castle := g_CastleManager.IsCastleMember(Self);
      if Castle <> nil then
      begin
        sGuildName := AnsiReplaceText(g_sCastleGuildName, '%castlename',
          AnsiReplaceText(Castle.m_sName, '/', ''));
        sGuildName := AnsiReplaceText(sGuildName, '%guildname',
          AnsiReplaceText(TGuild(m_MyGuild).sGuildName, '/', ''));
        sGuildName := AnsiReplaceText(sGuildName, '%rankname',
          AnsiReplaceText(m_sGuildRankName, '/', ''));
      end
      else
      begin
        Castle := g_CastleManager.InCastleWarArea(Self);
        //01/25 多城堡
        //if g_Config.boShowGuildName or (UserCastle.m_boUnderWar and (m_boInFreePKArea or UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY))) then begin
        if g_Config.boShowGuildName or (((Castle <> nil) and Castle.m_boUnderWar) or
          m_boInFreePKArea) then
        begin
          sGuildName := AnsiReplaceText(g_sNoCastleGuildName, '%guildname',
            TGuild(m_MyGuild).sGuildName);
          sGuildName := AnsiReplaceText(sGuildName, '%rankname', m_sGuildRankName);
        end;
      end;
    end;

    if not g_Config.boShowRankLevelName then
    begin
      if m_btReLevel > 0 then
      begin
        case m_btJob of
          0: sCharName := AnsiReplaceText(g_sWarrReNewName, '%chrname', m_sCharName);
          1: sCharName := AnsiReplaceText(g_sWizardReNewName, '%chrname', m_sCharName);
          2: sCharName := AnsiReplaceText(g_sTaosReNewName, '%chrname', m_sCharName);
        end;
      end
      else
      begin
        sCharName := m_sCharName;
      end;
    end
    else
    begin
      sCharName := format(m_sRankLevelName, [m_sCharName]);
    end;

    //  sCharName:=m_sCharName; //hint
    if m_sMasterName <> '' then
    begin
      if m_boMaster then
      begin
        //sMasterName:= m_sMasterName + '的师傅';
        sMasterName := format(g_sMasterName, [m_sMasterName]);
      end
      else
      begin
        //sMasterName:= m_sMasterName + '的徒弟';
        sMasterName := format(g_sNoMasterName, [m_sMasterName]);
      end;
    end;
    if m_sDearName <> '' then
    begin
      if m_btGender = 0 then
      begin
        //sDearName:= m_sDearName + '的老公';
        sDearName := format(g_sManDearName, [m_sDearName]);
      end
      else
      begin
        sDearName := format(g_sWoManDearName, [m_sDearName]); // + '的老婆';
      end;
    end;

    sShowName := AnsiReplaceText(g_sHumanShowName, '%chrname', sCharName);
    sShowName := AnsiReplaceText(sShowName, '%guildname', sGuildName);
    sShowName := AnsiReplaceText(sShowName, '%dearname', sDearName);
    sShowName := AnsiReplaceText(sShowName, '%mastername', sMasterName);
    Result := sShowName;
  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg);
      MainOutMessage(E.Message);
      raise;
    end;

  end;
end;

function TPlayObject.CheckItemsNeed(StdItem: pTStdItem): Boolean;
var
  Castle                                               : TUserCastle;
begin
  Result := True;
  Castle := g_CastleManager.IsCastleMember(Self);
  case StdItem.Need of
    6:
      begin
        if (m_MyGuild = nil) then
        begin
          Result := False;
        end;
      end;
    60:
      begin
        if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then
        begin
          Result := False;
        end;
      end;
    7:
      begin
        //if (m_MyGuild = nil) or (UserCastle.m_MasterGuild <> m_MyGuild) then begin
        if Castle = nil then
        begin
          Result := False;
        end;
      end;
    70:
      begin
        //if (m_MyGuild = nil) or (UserCastle.m_MasterGuild <> m_MyGuild) or (m_nGuildRankNo <> 1) then begin
        if (Castle = nil) or (m_nGuildRankNo <> 1) then
        begin
          Result := False;
        end;
      end;
    8:
      begin
        if m_nMemberType = 0 then
          Result := False;
      end;
    81:
      begin
        if (m_nMemberType <> LoWord(StdItem.NeedLevel)) or (m_nMemberLevel <
          HiWord(StdItem.NeedLevel)) then
          Result := False;
      end;
    82:
      begin
        if (m_nMemberType < LoWord(StdItem.NeedLevel)) or (m_nMemberLevel <
          HiWord(StdItem.NeedLevel)) then
          Result := False;
      end;
  end;

end;

procedure TPlayObject.CheckMarry;
var
  boIsfound                                            : Boolean;
  sUnMarryFileName                                     : string;
  LoadList                                             : TStringList;
  I                                                    : Integer;
  sSayMsg                                              : string;
begin
  boIsfound := False;
  sUnMarryFileName := g_Config.sEnvirDir + 'UnMarry.txt';
  if FileExists(sUnMarryFileName) then
  begin
    LoadList := TStringList.Create;
    LoadList.LoadFromFile(sUnMarryFileName);
    for I := 0 to LoadList.Count - 1 do
    begin
      if CompareText(LoadList.Strings[i], m_sCharName) = 0 then
      begin
        LoadList.Delete(i);
        boIsfound := True;
        break;
      end;
    end;
    LoadList.SaveToFile(sUnMarryFileName);
    LoadList.Free;
  end;
  if boIsfound then
  begin
    if m_btGender = 0 then
    begin
      sSayMsg := AnsiReplaceText(g_sfUnMarryManLoginMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sDearName);
    end
    else
    begin
      sSayMsg := AnsiReplaceText(g_sfUnMarryWoManLoginMsg, '%d', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
    end;
    SysMsg(sSayMsg, c_Red, t_Hint);
    m_sDearName := '';
    RefShowName;
  end;
  SendDefMessage(449, 0, 3, 0, 0, m_sDearName);
  m_DearHuman := UserEngine.GeTPlayObject(m_sDearName);
  if m_DearHuman <> nil then
  begin
    m_DearHuman.m_DearHuman := Self;
    SendDefMessage(453, 1, 3, 0, 0, m_sDearName);
    m_DearHuman.SendDefMessage(453, 1, 3, 0, 0, m_sCharName);
    if m_btGender = 0 then
    begin
      sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineSelfMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_DearHuman.m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_DearHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_DearHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineDearMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);

    end
    else
    begin
      sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineSelfMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_DearHuman.m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_DearHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_DearHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineDearMsg, '%d', m_sDearName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
    end;
  end
  else
  begin
    if m_btGender = 0 then
    begin
      SysMsg(g_sManLoginDearNotOnlineMsg, c_Red, t_Hint);
    end
    else
    begin
      SysMsg(g_sWoManLoginDearNotOnlineMsg, c_Red, t_Hint);
    end;
  end;

end;

function TPlayObject.Checkhuancai(): Boolean;
var
  StdItem                                              : pTStdItem;
  res                                                  : integer;
  toukui                                               : boolean;
  xianglian                                            : boolean;
  shouzuo                                              : boolean;
  jiezhi                                               : boolean;
begin
  Result := False;
  //res:=0;
  toukui := false;
  xianglian := false;
  shouzuo := false;
  jiezhi := false;

  if m_UseItems[U_NECKLACE].wIndex > 0 then
  begin                                                     //    = '项链'
    StdItem := UserEngine.GetStdItem(m_UseItems[U_NECKLACE].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 614) or (stditem.Shape = 191) then
        xianglian := true;
    end;
  end;
  res := 0;
  if m_UseItems[U_ARMRINGL].wIndex > 0 then
  begin //      U_ARMRINGLNAME    = '左手镯';
    StdItem := UserEngine.GetStdItem(m_UseItems[U_ARMRINGL].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 615) or (stditem.Shape = 191) then
        inc(res);
    end;
  end;

  if m_UseItems[U_ARMRINGR].wIndex > 0 then
  begin //         U_ARMRINGRNAME    = '右手镯';
    StdItem := UserEngine.GetStdItem(m_UseItems[U_ARMRINGR].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 615) or (stditem.Shape = 191) then
        inc(res);
    end;
  end;
  if res > 0 then
    shouzuo := true;

  res := 0;
  if m_UseItems[U_RINGL].wIndex > 0 then
  begin //        U_RINGLNAME       = '左戒指';
    StdItem := UserEngine.GetStdItem(m_UseItems[U_RINGL].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 616) or (stditem.Shape = 191) then
        inc(res);
    end;
  end;
  if m_UseItems[U_RINGR].wIndex > 0 then
  begin //      U_RINGRNAME       = '右戒指';
    StdItem := UserEngine.GetStdItem(m_UseItems[U_RINGR].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 616) or (stditem.Shape = 191) then
        inc(res);
    end;
  end;
  if res > 0 then
    jiezhi := true;

  if xianglian and shouzuo and jiezhi then
    result := true;

end;                                                        //

function TPlayObject.Checkhuanying(): Boolean;
var
  StdItem                                              : pTStdItem;
  res                                                  : integer;
  toukui                                               : boolean;
  xianglian                                            : boolean;
  shouzuo                                              : boolean;
  jiezhi                                               : boolean;
begin
  Result := False;
  //res:=0;
  toukui := false;
  xianglian := false;
  shouzuo := false;
  jiezhi := false;

  if m_UseItems[U_HELMET].wIndex > 0 then
  begin                                                     //头盔
    StdItem := UserEngine.GetStdItem(m_UseItems[U_HELMET].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 860) or (StdItem.looks = 617) or (stditem.Shape = 192) then
        toukui := true;
    end;
  end;

  if m_UseItems[U_NECKLACE].wIndex > 0 then
  begin                                                     //    = '项链'
    StdItem := UserEngine.GetStdItem(m_UseItems[U_NECKLACE].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 861) or (StdItem.looks = 618) or (stditem.Shape = 192) then
        xianglian := true;
    end;
  end;
  res := 0;
  if m_UseItems[U_ARMRINGL].wIndex > 0 then
  begin //      U_ARMRINGLNAME    = '左手镯';
    StdItem := UserEngine.GetStdItem(m_UseItems[U_ARMRINGL].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 862) or (StdItem.looks = 619) or (stditem.Shape = 192) then
        inc(res);
    end;
  end;

  if m_UseItems[U_ARMRINGR].wIndex > 0 then
  begin //         U_ARMRINGRNAME    = '右手镯';
    StdItem := UserEngine.GetStdItem(m_UseItems[U_ARMRINGR].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 862) or (stditem.Shape = 192) then
        inc(res);
    end;
  end;
  if res > 0 then
    shouzuo := true;

  res := 0;
  if m_UseItems[U_RINGL].wIndex > 0 then
  begin //        U_RINGLNAME       = '左戒指';
    StdItem := UserEngine.GetStdItem(m_UseItems[U_RINGL].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 863) or (StdItem.looks = 620) or (stditem.Shape = 192) then
        inc(res);
    end;
  end;
  if m_UseItems[U_RINGR].wIndex > 0 then
  begin //      U_RINGRNAME       = '右戒指';
    StdItem := UserEngine.GetStdItem(m_UseItems[U_RINGR].wIndex);
    if (stdItem <> nil) then
    begin
      if (StdItem.looks = 863) or (StdItem.looks = 620) or (stditem.Shape = 192) then
        inc(res);
    end;
  end;
  if res > 0 then
    jiezhi := true;

  if toukui and xianglian and shouzuo and jiezhi then
    result := true;

end;                                                        //

procedure TplayObject.CheckHorse;
var
  StdItem                                              : pTStdItem;
  horsename                                            : string;
  mobhorse                                             : Tbaseobject;
  i                                                    : integer;
  hashorse                                             : boolean;
  Horsepos                                             : integer;

begin
  if (ysmasterplayer <> nil) and m_boBaoZiAttacked then
  begin
    SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');

    SendDefMessage(205, 1, 0, 0, 0, '');
    ysmasterplayer.Sendpetinfo(ysmasterplayer.M_monYSOnHorseitemmake, 8);
    ysmasterplayer.Sendpetinfo(ysmasterplayer.M_monYSOnHorseitemmake, 100);
    SendRefMsg(RM_TAKEHORSE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
    SendUpdateMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '');
  end;
  Horsepos := CheckHorsepos;
  if Horsepos > 0 then
  begin

    hashorse := false;
    StdItem := UserEngine.GetStdItem(m_UseItems[Horsepos].wIndex);
    if StdItem <> nil then
    begin
      if m_PEnvir.m_boCANHORSE then
      begin
        //TBaseObject.MakeSlave(sMonName:String;nMakeLevel,nExpLevel,nMaxMob:Integer;dwRoyaltySec:LongWord)
        ArrestStringEx(stditem.Name, '(', ')', horsename);
        for i := m_SlaveList.Count - 1 downto 0 do
        begin
          if TBaseObject(m_SlaveList.Items[i]).m_sCharName = horsename then
          begin
            hashorse := true;
            break;
          end;
        end;                                                //for
        if (not hashorse) and (not m_boOnHorse) then
          mobhorse := MakeSlave(horsename, 0, 0, 10, 10 * 24 * 60 * 60); // stditem.Name
        if mobhorse <> nil then
          mobhorse.m_bohorse := true;
        //解决不能骑普通马的bug
        SendDefMessage(34977, stditem.Shape + 110, 612, 1, 0, '');
      end;                                                  //这里是可以骑马

      if not m_PEnvir.m_boCANHORSE then
      begin
        //  TBaseObject.MakeSlave(sMonName:String;nMakeLevel,nExpLevel,nMaxMob:Integer;dwRoyaltySec:LongWord)
        ArrestStringEx(stditem.Name, '(', ')', horsename);
        //   mobhorse:= MakeSlave(horsename,0,0,10,10 * 24 * 60 * 60);   // stditem.Name

        for i := m_SlaveList.Count - 1 downto 0 do
        begin
          if TBaseObject(m_SlaveList.Items[i]).m_sCharName = horsename then
          begin
            TBaseObject(m_SlaveList.Items[i]).MakeGhost;
            m_SlaveList.Delete(i);
            //  SysMsg('这里不能骑马',c_Red,t_Hint);
            break;
          end;                                              //if
        end;                                                //for
        SysMsg('这里不能骑马', c_Red, t_Hint);
        m_boOnHorse := false;

        FeatureChanged;
      end; //    not m_PEnvir.m_boCANHORSE

      //  if (not (m_PEnvir.m_boCANHORSE))and m_boOnHorse  then  begin    //如果在马上不能骑马
       //      m_boOnHorse:=false;

       //      FeatureChanged;
       // end;
       // m_boOnHorse:=false;
    end;                                                    //  <>nil

  end;                                                      //有马牌

end;

procedure TPlayObject.CheckFriend;
var
  //  boIsfound:Boolean;
  FriendFileName                                       : string;
  //  LoadList:TStringList;
  OnlineFriend                                         : Tstringlist;
  Friendstring, Onlinestring                           : string;
  I                                                    : Integer;
  sSayMsg                                              : string;
  FriendHuman                                          : TPlayObject;
begin
  // boIsfound:=False;
  FriendFileName := g_Config.sFriendsDir + m_sCharName + '.txt';
  if FileExists(FriendFileName) then
  begin
    //    LoadList:=TStringList.Create;
    m_FrientList.LoadFromFile(FriendFileName);
    OnlineFriend := TStringList.Create;

    for I := 0 to m_FrientList.Count - 1 do
    begin
      Friendstring := Friendstring + m_FrientList.Strings[i] + '/';
      FriendHuman := UserEngine.GeTPlayObject(m_FrientList.Strings[i]);
      if FriendHuman <> nil then
      begin                                                 //好友在线
        //  FriendHuman.SysMsg('你的好友'+m_sCharName+'已经上线了',c_Red,t_Hint);
        FriendHuman.SendDefMessage(453, 1, 0, 0, 0, m_sCharName);  //发送这个消息，客户端自动会提示
        Onlinestring := Onlinestring + m_FrientList.Strings[i] + '/';
        OnlineFriend.Add(m_FrientList.Strings[i]);
      end;
    end;                                                    //for
    //   LoadList.SaveToFile(sUnMarryFileName);
    //  LoadList.Free;
    SendDefMessage(449, 0, 0, 0, 0, Friendstring);          //好友列表
    //  SendDefMessage(449,0,2, 0, 0,m_sSytleName);    //师徒列表
    //  SendDefMessage(449,0,3, 0, 0,m_sSytleName);   //夫妻列表
    if OnlineFriend.Count > 0 then
    begin
      //在线好友
      for I := 0 to OnlineFriend.Count - 1 do
      begin
        SendDefMessage(453, 1, 0, 0, 0, OnlineFriend.strings[i]);
        //  SysMsg('你的好友'+OnlineFriend.strings[i]+'已经上线了',c_Red,t_Hint);
      end;
    end;
    OnlineFriend.free;

  end;
end;

function TplayObject.CheckHorsepos(): integer;
var
  nhashousepai                                         : integer;
  horseitem                                            : pTStdItem;
begin
  nhashousepai := -1;
  if m_UseItems[U_RIGHTHAND].wIndex > 0 then
  begin
    horseitem := UserEngine.GetStdItem(m_UseItems[U_RIGHTHAND].wIndex);
    if horseitem <> nil then
      if horseitem.StdMode in [33] then
        nhashousepai := U_RIGHTHAND;
  end;

  if m_UseItems[U_BUJUK].wIndex > 0 then
  begin
    horseitem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
    if horseitem <> nil then
      if horseitem.StdMode in [33] then
        nhashousepai := U_BUJUK;
  end;

  result := nhashousepai;
end;

procedure TPlayObject.CheckMaster;
var
  boIsfound                                            : Boolean;
  sSayMsg                                              : string;
  I                                                    : Integer;
  Human                                                : TPlayObject;
begin
  //处理强行脱离师徒关系
  boIsfound := False;
  g_UnForceMasterList.Lock;
  try
    for I := 0 to g_UnForceMasterList.Count - 1 do
    begin
      if CompareText(g_UnForceMasterList.Strings[i], m_sCharName) = 0 then
      begin
        g_UnForceMasterList.Delete(i);
        SaveUnForceMasterList();
        boIsfound := True;
        break;
      end;
    end;
  finally
    g_UnForceMasterList.UnLock;
  end;

  if boIsfound then
  begin
    if m_boMaster then
    begin
      sSayMsg := AnsiReplaceText(g_sfUnMasterLoginMsg, '%d', m_sMasterName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
    end
    else
    begin
      sSayMsg := AnsiReplaceText(g_sfUnMasterListLoginMsg, '%d', m_sMasterName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
    end;
    SysMsg(sSayMsg, c_Red, t_Hint);
    m_sMasterName := '';
    RefShowName;
  end;

  if (m_sMasterName <> '') and not m_boMaster then
  begin                                                     //我是徒弟
    if m_Abil.Level >= g_Config.nMasterOKLevel then
    begin                                                   //可以出师了
      Human := UserEngine.GeTPlayObject(m_sMasterName);     //human 是师傅
      if (Human <> nil) and (not Human.m_boDeath) and (not Human.m_boGhost) then
      begin
        sSayMsg := AnsiReplaceText(g_sYourMasterListUnMasterOKMsg, '%d', m_sCharName);
        Human.SysMsg(sSayMsg, c_Red, t_Hint);               //告诉师傅我已经出师了
        SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);      //告诉徒弟   已经出师了
        if g_Config.nMasterRunScript then
        begin
          g_ManageNPC.GotoLable(TPlayObject(self), '@STTDCF', False);
        end;
        //如果大徒弟则将师父上的名字去掉
        if m_sCharName = Human.m_sMasterName then
        begin
          Human.m_sMasterName := '';
          Human.RefShowName;
        end;
        for I := 0 to Human.m_MasterList.Count - 1 do
        begin                                               //师傅的徒弟列表
          if Human.m_MasterList.Items[I] = Self then
          begin //把自己从师傅的徒弟列表中删除。
            Human.m_MasterList.Delete(I);
            break;
          end;
        end;

        m_sMasterName := '';
        RefShowName;
        if Human.m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Byte) then
        begin
          Inc(Human.m_btCreditPoint, g_Config.nMasterOKCreditPoint);
        end;
        Inc(Human.m_nBonusPoint, g_Config.nMasterOKBonusPoint);
        // Human.SendMsg(Human,RM_ADJUST_BONUS,0,0,0,0,'');      //修改声望值
        Human.SendMsg(Human, RM_SUBABILITY, 0, 0, 0, 0, '');
        if g_Config.nMasterRunScript then
        begin
          g_ManageNPC.GotoLable(Human, '@STSFCF', False);
        end;
      end
      else
      begin
        //如果师父不在线则保存到记录表中
        if g_Config.nMasterRunScript then
        begin
          g_ManageNPC.GotoLable(TPlayObject(self), '@STTDCF', False);
        end;
        g_UnMasterList.Lock;
        try
          boIsfound := False;
          for I := 0 to g_UnMasterList.Count - 1 do
          begin
            if CompareText(g_UnMasterList.Strings[i], m_sCharName) = 0 then
            begin
              boIsfound := True;
              break;
            end;
          end;
          if not boIsfound then
          begin
            g_UnMasterList.Add(m_sMasterName);
          end;
        finally
          g_UnMasterList.UnLock;
        end;
        if not boIsfound then
        begin
          SaveUnMasterList();
        end;
        SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);
        m_sMasterName := '';
        RefShowName;
      end;
    end;
  end;

  //处理出师记录
  boIsfound := False;
  g_UnMasterList.Lock;
  try
    for I := 0 to g_UnMasterList.Count - 1 do
    begin
      if CompareText(g_UnMasterList.Strings[i], m_sCharName) = 0 then
      begin
        g_UnMasterList.Delete(i);
        SaveUnMasterList();
        boIsfound := True;
        break;
      end;
    end;
  finally
    g_UnMasterList.UnLock;
  end;

  if boIsfound and m_boMaster then
  begin                                                     //如果我是师傅
    SysMsg(g_sUnMasterLoginMsg, c_Red, t_Hint);

    m_sMasterName := '';
    RefShowName;

    if m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Byte) then
    begin
      Inc(m_btCreditPoint, g_Config.nMasterOKCreditPoint);
    end;
    Inc(m_nBonusPoint, g_Config.nMasterOKBonusPoint);
    //    SendMsg(Self,RM_ADJUST_BONUS,0,0,0,0,'');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');           //修改声望值
    if g_Config.nMasterRunScript then
    begin
      g_ManageNPC.GotoLable(Tplayobject(Self), '@STSFCF', False);
    end;
  end;

  if m_sMasterName = '' then
    exit;
  SendDefMessage(449, 0, 2, 0, 0, m_sMasterName);           //列表中加入师傅或者徒弟的名字
  if m_boMaster then
  begin                                                     //
    //师父上线通知
    m_MasterHuman := UserEngine.GeTPlayObject(m_sMasterName); //
    if m_MasterHuman <> nil then
    begin                                                   //如果有徒弟在线
      m_MasterHuman.m_MasterHuman := Self;                  //  徒弟的师傅是我
      m_MasterList.Add(m_MasterHuman);                      //我的徒弟列表里加一个

      sSayMsg := AnsiReplaceText(g_sMasterOnlineSelfMsg, '%d', m_sMasterName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_MasterHuman.m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_MasterHuman.m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_MasterHuman.m_nCurrY));
      SysMsg(sSayMsg, c_Blue, t_Hint);

      sSayMsg := AnsiReplaceText(g_sMasterOnlineMasterListMsg, '%d', m_sMasterName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
      sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
      sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
      m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);        //告诉徒弟 师傅上线了
      //这里发送师傅上线通知
      m_MasterHuman.SendDefMessage(453, 1, 2, 0, 0, m_sCharName);  //453 徒弟列表中添加师傅上线

      SendDefMessage(453, 1, 2, 0, 0, m_sMasterName); // 自己列表中添加 徒弟上线   //徒弟列表
    end
    else
    begin
      SysMsg(g_sMasterNotOnlineMsg, c_Red, t_Hint);

    end;
  end
  else
  begin
    //徒弟上线通知
  //  SendDefMessage(449,0,2, 0, 0,m_sMasterName);

    if m_sMasterName <> '' then
    begin                                                   //师傅名
      m_MasterHuman := UserEngine.GeTPlayObject(m_sMasterName);
      if m_MasterHuman <> nil then
      begin                                                 //师傅在线

        if m_MasterHuman.m_sMasterName = m_sCharName then
        begin
          m_MasterHuman.m_MasterHuman := Self;
        end;

        m_MasterHuman.m_MasterList.Add(Self);               //师傅的徒弟列表加我
        // m_MasterHuman.SendDefMessage(453,0,2, 0, 0,m_sCharName);
        sSayMsg := AnsiReplaceText(g_sMasterListOnlineSelfMsg, '%d', m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_MasterHuman.m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_MasterHuman.m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_MasterHuman.m_nCurrY));
        SysMsg(sSayMsg, c_Blue, t_Hint);                    //告诉徒弟

        SendDefMessage(453, 1, 2, 0, 0, m_sMasterName);     //告诉徒弟师傅上线了
        sSayMsg := AnsiReplaceText(g_sMasterListOnlineMasterMsg, '%d', m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);      //告诉师傅
        m_MasterHuman.SendDefMessage(453, 1, 2, 0, 0, m_sCharName);

      end
      else
      begin
        SysMsg(g_sMasterListNotOnlineMsg, c_Red, t_Hint);
        //发送师傅列表

      end;
    end;
  end;
end;

procedure TPlayObject.MakeGhost;
var
  I                                                    : Integer;
  sSayMsg                                              : string;
  Human, hum                                           : TPlayObject;
  pu                                                   : pTUserItem;
  Ecode                                                : Integer;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::MakeGhost Code=%d';
begin
  try
    if (g_HighLevelHuman = Self) then
      g_HighLevelHuman := nil;
    if (g_HighPKPointHuman = Self) then
      g_HighPKPointHuman := nil;
    if (g_HighDCHuman = Self) then
      g_HighDCHuman := nil;
    if (g_HighMCHuman = Self) then
      g_HighMCHuman := nil;
    if (g_HighSCHuman = Self) then
      g_HighSCHuman := nil;
    if (g_HighOnlineHuman = Self) then
      g_HighOnlineHuman := nil;
    //人物下线后通知配偶 好友，并把对方的相关记录清空
    Ecode := 0;

    if m_FrientList.Count > 0 then
    begin
      m_FrientList.lock;
      try
        for I := m_FrientList.Count - 1 downto 0 do
        begin
          Human := UserEngine.GeTPlayObject(m_FrientList.Strings[i]);
          if Human <> nil then
          begin                                             //好友在线
            //  FriendHuman.SysMsg('你的好友'+m_sCharName+'已经下线了',c_Red,t_Hint);
            Human.SendDefMessage(453, 0, 0, 0, 0, m_sCharName);  //发送这个消息，客户端自动会提示
          end;
        end;                                                //for
      finally
        m_FrientList.unlock;
      end;
    end;                                                    //if
    ////////////
    Ecode := 1;
    if self.sYsnameMaster <> '' then
    begin //如果是元神 那么人物的元神 =NIL
      hum := nil;
      hum := UserEngine.GetPlayObjectEx(sYsnameMaster);
      if hum <> nil then
        hum.Ysplayer := nil;
      SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
    end;
    Ecode := 2;
    ///////////
      //人物下线，如果是夺宝中，把宝箱留下
    if m_boArrow and (m_sArrowitem <> '') then
    begin                                                   //  如果有任务抢夺宝贝
      m_boArrow := false;
      m_wStatusTimeArr[STATE_12] := 0;
      m_dwStatusArrTick[STATE_12] := GetTickCount();

      m_ItemList.lock;
      try
        for i := m_ItemList.Count - 1 downto 0 do
        begin
          pu := m_ItemList.Items[i];
          if UserEngine.GetStdItemName(pu.wIndex) = m_sArrowitem then
          begin
            if DropItemDown(pTUserItem(m_ItemList[i]), 2, True, nil, Self) then
            begin
              Dispose(PTUserItem(m_ItemList[i]));
              m_ItemList.Delete(i);
              break;
            end;                                            //if dropitemdown
          end;                                              //if
        end;                                                //for
      finally
        m_ItemList.unlock;
      end;
    end;                                                    //if
    Ecode := 3;
    ////

    if m_sofflinegoto <> '' then
    begin                                                   //人物下线触发
      if g_ManageNPC <> nil then
      begin
        g_ManageNPC.GotoLable(TPlayObject(self), m_sofflinegoto, False);
      end;
    end;
    if m_boSoftClose then
    begin
      if g_FunctionNPC <> nil then
      begin
        g_FunctionNPC.GotoLable(TPlayObject(self), '@下线触发', False);
      end;

    end;

    Ecode := 4;
    if m_DearHuman <> nil then
    begin
      if m_btGender = 0 then
      begin
        sSayMsg := AnsiReplaceText(g_sManLongOutDearOnlineMsg, '%d', m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);

      end
      else
      begin
        sSayMsg := AnsiReplaceText(g_sWoManLongOutDearOnlineMsg, '%d', m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);
      end;
      m_DearHuman.SendDefMessage(453, 0, 3, 0, 0, m_sCharName);
      m_DearHuman.m_DearHuman := nil;
      m_DearHuman := nil;
    end;
    Ecode := 5;
    if (m_MasterHuman <> nil) or (m_MasterList.Count > 0) then
    begin
      if m_boMaster then
      begin
        for I := 0 to m_MasterList.Count - 1 do
        begin
          Human := TPlayObject(m_MasterList.Items[I]);
          sSayMsg := AnsiReplaceText(g_sMasterLongOutMasterListOnlineMsg, '%s',
            m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          Human.SysMsg(sSayMsg, c_Red, t_Hint);
          Human.SendDefMessage(453, 0, 2, 0, 0, m_sCharName); //通知徒弟师傅已经下线
          Human.m_MasterHuman := nil;
        end;
      end
      else
      begin
        if m_MasterHuman = nil then
          exit;
        sSayMsg := AnsiReplaceText(g_sMasterListLongOutMasterOnlineMsg, '%d',
          m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_MasterHuman.SysMsg(sSayMsg, c_Red, t_Hint);
        m_MasterHuman.SendDefMessage(453, 0, 2, 0, 0, m_sCharName);
        //如果为大徒弟则将对方的记录清空
        if m_MasterHuman.m_sMasterName = m_sCharName then
        begin
          m_MasterHuman.m_MasterHuman := nil;
        end;
        Ecode := 6;
        for I := 0 to m_MasterHuman.m_MasterList.Count - 1 do
        begin
          if m_MasterHuman.m_MasterList.Items[I] = Self then
          begin
            m_MasterHuman.m_MasterList.Delete(I);
            break;
          end;
        end;
      end;
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg, [Ecode]));
      MainOutMessage(E.Message);
      raise;
    end;

  end;
  inherited;
end;

function TPlayObject.IsFriend(sCharName: string): Boolean;

var
  FriendName                                           : string;
  I                                                    : Integer;
  FriendHuman                                          : TPlayObject;
begin
  Result := False;

  for I := 0 to m_FrientList.Count - 1 do
  begin
    if CompareText(m_FrientList.Strings[i], sCharName) = 0 then
    begin
      Result := True;
      break;
    end;
  end;                                                      //删除自己好友列表中的好友

end;

function TPlayObject.GetMyInfo: string;
var
  sMyInfo                                              : string;
begin
  sMyInfo := g_sMyInfo;
  sMyInfo := AnsiReplaceText(sMyInfo, '%name', m_sCharName);
  sMyInfo := AnsiReplaceText(sMyInfo, '%map', m_PEnvir.sMapDesc);
  sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
  sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
  sMyInfo := AnsiReplaceText(sMyInfo, '%level', IntToStr(m_Abil.Level));
  sMyInfo := AnsiReplaceText(sMyInfo, '%gold', IntToStr(m_nGold));
  sMyInfo := AnsiReplaceText(sMyInfo, '%pk', IntToStr(m_nPkPoint));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minhp', IntToStr(m_WAbil.HP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxhp', IntToStr(m_WAbil.MaxHP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minmp', IntToStr(m_WAbil.MP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxmp', IntToStr(m_WAbil.MaxMP));
  sMyInfo := AnsiReplaceText(sMyInfo, '%mindc', IntToStr(LoWord(m_WAbil.DC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxdc', IntToStr(HiWord(m_WAbil.DC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minmc', IntToStr(LoWord(m_WAbil.MC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxmc', IntToStr(HiWord(m_WAbil.MC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%minsc', IntToStr(LoWord(m_WAbil.SC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%maxsc', IntToStr(HiWord(m_WAbil.SC)));
  sMyInfo := AnsiReplaceText(sMyInfo, '%logontime', DateTimeToStr(m_dLogonTime));
  sMyInfo := AnsiReplaceText(sMyInfo, '%logonlong', IntToStr((GetTickCount -
    m_dwLogonTick) div 60000));
  Result := sMyInfo;
end;

function TPlayObject.CheckItemBindUse(UserItem: pTUserItem): Boolean;
var
  I                                                    : Integer;
  ItemBind                                             : pTItemBind;
begin
  Result := True;
  g_ItemBindAccount.Lock;
  try
    for I := 0 to g_ItemBindAccount.Count - 1 do
    begin
      ItemBind := g_ItemBindAccount.Items[I];
      if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
        (ItemBind.nItemIdx = UserItem.wIndex) then
      begin
        Result := False;
        if (CompareText(ItemBind.sBindName, m_sUserID) = 0) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sItemIsNotThisAccount, c_Red, t_Hint);
        end;
        exit;
      end;
    end;
  finally
    g_ItemBindAccount.UnLock;
  end;

  g_ItemBindIPaddr.Lock;
  try
    for I := 0 to g_ItemBindIPaddr.Count - 1 do
    begin
      ItemBind := g_ItemBindIPaddr.Items[I];
      if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
        (ItemBind.nItemIdx = UserItem.wIndex) then
      begin
        Result := False;
        if (CompareText(ItemBind.sBindName, m_sIPaddr) = 0) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sItemIsNotThisIPaddr, c_Red, t_Hint);
        end;
        exit;
      end;
    end;
  finally
    g_ItemBindIPaddr.UnLock;
  end;
  g_ItemBindCharName.Lock;
  try
    for I := 0 to g_ItemBindCharName.Count - 1 do
    begin
      ItemBind := g_ItemBindCharName.Items[I];
      if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
        (ItemBind.nItemIdx = UserItem.wIndex) then
      begin
        Result := False;
        if (CompareText(ItemBind.sBindName, m_sCharName) = 0) then
        begin
          Result := True;
        end
        else
        begin
          SysMsg(g_sItemIsNotThisCharName, c_Red, t_Hint);
        end;
        exit;
      end;
    end;
  finally
    g_ItemBindCharName.UnLock;
  end;
end;

procedure TPlayObject.ClientMapMove(nParam, nParam2: Integer);
var
  i                                                    : Integer;
  Useritem                                             : pTUserItem;

begin
  for I := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := nil;
    UserItem := m_ItemList.Items[I];
    if (UserItem <> nil) and (UserItem.MakeIndex = nParam) then
    begin
      if Useritem.Dura > 0 then
      begin
        m_bocheckboxitem := UserItem.MakeIndex;
        case nParam2 of
          0:                                                //落霞岛
            MakeGoBackeMap(1, 247, 240);                    // Spacemove('1',247,240,0);
          256:                                              //中州
            MakeGoBackeMap(0, 470, 224);                    // Spacemove('0',451,250,0);
          512:                                              //土城
            MakeGoBackeMap(2, 241, 437);
          768:                                              //禁地
            MakeGoBackeMap(4, 350, 173);
          $400:                                             //西域
            MakeGoBackeMap(5, 470, 110);
          $500:                                             //死水
            MakeGoBackeMap(7, 69, 56);

        end;
        m_bocheckboxitem := 0;
        // Dec(Useritem.Dura);
        SendUpdateItem(UserItem);
      end;
      if UserItem.Dura = 0 then
      begin
        SendUpdateItem(UserItem);
        if UserItem.Dura <= 0 then
        begin
          SendDelItems(UserItem);
          Dispose(UserItem);
          m_ItemList.Delete(I);
          WeightChanged();
        end;
      end;
      break;

    end;
  end;

end;

procedure TPlayObject.ProcessClientPassword(ProcessMsg: pTProcessMessage);
var
  nLen                                                 : Integer;
  sData                                                : string;
begin
  //  SysMsg(ProcessMsg.sMsg,c_Red,t_Hint);
  if ProcessMsg.wParam = 0 then
  begin
    ProcessUserLineMsg('@' + g_GameCommand.UNLOCK.sCmd);
    exit;
  end;

  sData := ProcessMsg.sMsg;
  nLen := length(sData);
  if m_boSetStoragePwd then
  begin
    m_boSetStoragePwd := False;
    if (nLen > 3) and (nLen < 8) then
    begin
      m_sTempPwd := sData;
      m_boReConfigPwd := True;
      SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint);         {'请重复输入一次仓库密码：'}
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
    end
    else
    begin
      SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint); {'输入的密码长度不正确！！！，密码长度必须在 4 - 7 的范围内，请重新设置密码。'}
    end;
    exit;
  end;
  if m_boReConfigPwd then
  begin
    m_boReConfigPwd := False;
    if CompareStr(m_sTempPwd, sData) = 0 then
    begin
      m_sStoragePwd := sData;
      m_boPasswordLocked := True;
      m_sTempPwd := '';
      SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint); {'密码设置成功！！，仓库已经自动上锁，请记好您的仓库密码，在取仓库时需要使用此密码开锁。'}
    end
    else
    begin
      m_sTempPwd := '';
      SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
    end;
    exit;
  end;
  if m_boUnLockPwd or m_boUnLockStoragePwd then
  begin
    if CompareStr(m_sStoragePwd, sData) = 0 then
    begin
      m_boPasswordLocked := False;
      if m_boUnLockPwd then
      begin
        if g_Config.boLockDealAction then
          m_boCanDeal := True;
        if g_Config.boLockDropAction then
          m_boCanDrop := True;
        if g_Config.boLockWalkAction then
          m_boCanWalk := True;
        if g_Config.boLockRunAction then
          m_boCanRun := True;
        if g_Config.boLockHitAction then
          m_boCanHit := True;
        if g_Config.boLockSpellAction then
          m_boCanSpell := True;
        if g_Config.boLockSendMsgAction then
          m_boCanSendMsg := True;
        if g_Config.boLockUserItemAction then
          m_boCanUseItem := True;
        if g_Config.boLockInObModeAction then
        begin
          m_boObMode := False;
          m_boAdminMode := False;
        end;
        m_boLockLogoned := True;
        SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
      end;
      if m_boUnLockStoragePwd then
      begin
        if g_Config.boLockGetBackItemAction then
          m_boCanGetBackItem := True;
        SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
      end;

    end
    else
    begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
      if m_btPwdFailCount > 3 then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
      end;
    end;
    m_boUnLockPwd := False;
    m_boUnLockStoragePwd := False;
    exit;
  end;

  if m_boCheckOldPwd then
  begin
    m_boCheckOldPwd := False;
    if m_sStoragePwd = sData then
    begin
      SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
      m_boSetStoragePwd := True;
    end
    else
    begin
      Inc(m_btPwdFailCount);
      SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
      if m_btPwdFailCount > 3 then
      begin
        SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        m_boPasswordLocked := True;
      end;
    end;
    exit;
  end;
end;

procedure TPlayObject.ScatterBagItems(ItemOfCreat: TBaseObject);
var
  I, DropWide                                          : Integer;
  pu                                                   : pTUserItem;
  DelList                                              : TStringList;
  boDropall                                            : Boolean;
  StdItem                                              : pTStdItem;
  //    UserItem:pTUserItem;
resourcestring
  sExceptionMsg                                          =
    '[Exception] TPlayObject::ScatterBagItems';
begin
  if m_btRaceServer = RC_YSBJECT then
  begin
    inherited;
    Exit;

  end;
  DelList := nil;
  if m_boAngryRing or m_boNoDropItem then
    exit;                                                   //不死戒指

  boDropall := False;
  DropWide := 2;
  if g_Config.boDieRedScatterBagAll and (PKLevel >= 2) then
  begin
    boDropall := True;
  end;

  //非红名掉1/3 //红名全掉

  try
    if m_boArrow and (m_sArrowitem <> '') then
    begin                                                   //  如果有任务抢夺宝贝

      for i := m_ItemList.Count - 1 downto 0 do
      begin
        pu := m_ItemList.Items[i];
        if UserEngine.GetStdItemName(pu.wIndex) = m_sArrowitem then
        begin
          if DropItemDown(pTUserItem(m_ItemList[i]), DropWide, True, ItemOfCreat, Self)
            then
          begin
            if DelList = nil then
              DelList := TStringList.Create;
            DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex),
              TObject(pu.MakeIndex));
            Dispose(PTUserItem(m_ItemList[i]));
            m_ItemList.Delete(i);
            break;
          end;                                              //if dropitemdown
        end;                                                //if
      end;                                                  //for
      m_boArrow := false;
      m_sArrowitem := '';
    end;                                                    //if

    for i := m_ItemList.Count - 1 downto 0 do
    begin
      pu := pTUserItem(m_ItemList[i]);
      StdItem := UserEngine.GetStdItem(pu.wIndex);
      if StdItem = nil then Continue;
      if boDropall or (Random(g_Config.nDieScatterBagRate {3}) = 0) or ((StdItem.Reserved
        and 2) <> 0) then
      begin

        if DropItemDown(pTUserItem(m_ItemList[i]), DropWide, True, ItemOfCreat, Self)
          then
        begin
          pu := pTUserItem(m_ItemList[i]);
          if GetBoValue(pu, pu.wIndex, 15) then Continue;   //死亡包裹禁止爆出
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            if DelList = nil then
              DelList := TStringList.Create;
            DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex),
              TObject(pu.MakeIndex));
            //  SendDelItems(pu); //2006418
          end;

          Dispose(PTUserItem(m_ItemList[i]));
          m_ItemList.Delete(i);
        end;
      end;
    end;                                                    //for

    if DelList <> nil then
    begin
      SendMsg(self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
    end;
  except
    MainOutMessage(sExceptionMsg);
  end;
end;

procedure TPlayObject.RecallHumanMap(sHumName, sMapName: string);
var
  PlayObject                                           : TPlayObject;
  nX, nY, n18, n1C                                     : Integer;
begin
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    PlayObject.MapRandomMove(sMapName, 3);
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.RecallHuman(sHumName: string);
var
  PlayObject                                           : TPlayObject;
  nX, nY, n18, n1C                                     : Integer;
begin
  PlayObject := UserEngine.GeTPlayObject(sHumName);
  if PlayObject <> nil then
  begin
    if GetFrontPosition(nX, nY) then
    begin
      if sub_4C5370(nX, nY, 3, n18, n1C) and (not (PlayObject.m_boOnSellItem)) then
      begin                                                 //
        PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
        PlayObject.SpaceMove(m_sMapName, n18, n1C, 0);
      end;
    end
    else
    begin
      SysMsg('召唤失败！！！', c_Red, t_Hint);
    end;
  end
  else
  begin
    SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
  end;
end;

procedure TPlayObject.ReQuestGuildWar(sGuildName: string);
var
  Guild                                                : TGuild;
  WarGuild                                             : pTWarGuild;
  boReQuestOK                                          : Boolean;
begin
  if not IsGuildMaster then
  begin
    SysMsg('只有行会掌门人才能申请！！！', c_Red, t_Hint);
    exit;
  end;
  if nServerIndex <> 0 then
  begin
    SysMsg('这个命令不能在本服务器上使用！！！', c_Red, t_Hint);
    exit;
  end;
  Guild := g_GuildManager.FindGuild(sGuildName);
  if Guild = nil then
  begin
    SysMsg('行会不存在！！！', c_Red, t_Hint);
    exit;
  end;
  boReQuestOK := False;
  WarGuild := TGuild(m_MyGuild).AddWarGuild(Guild);
  if WarGuild <> nil then
  begin
    if Guild.AddWarGuild(TGuild(m_MyGuild)) = nil then
    begin
      WarGuild.dwWarTick := 0;
    end
    else
    begin
      boReQuestOK := True;
    end;
  end;
  if boReQuestOK then
  begin
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex, TGuild(m_MyGuild).sGuildName);
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);
  end;

end;

function TPlayObject.CheckDenyLogon(): Boolean;
begin
  Result := False;
  if GetDenyIPaddrList(m_sIPaddr) then
  begin
    SysMsg(g_sYourIPaddrDenyLogon, c_Red, t_Hint);
    Result := True;
  end
  else
    if GetDenyAccountList(m_sUserID) then
    begin
      SysMsg(g_sYourAccountDenyLogon, c_Red, t_Hint);
      Result := True;
    end
    else
      if GetDenyChrNameList(m_sCharName) then
      begin
        SysMsg(g_sYourCharNameDenyLogon, c_Red, t_Hint);
        Result := True;
      end;
  if Result then
    m_boEmergencyClose := True;
end;

procedure TPlayObject.ProcessUserCmd(sParam1, sParam2, sParam3, sParam4,
  sParam5, sParam6, sParam7: string);
var
  MD5                                                  : TMD5;
  sCmd                                                 : string;
  sUserMsg                                             : string;
  nUserCount                                           : Integer;
  procedure ShowUserMsg(sMsg: string);
  begin
{$IF DEBUG = 0}
    asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
    end;
{$IFEND}
    SysMsg(sMsg, c_Green, t_Hint);
{$IF DEBUG = 0}
    asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
    end;
{$IFEND}
  end;
begin
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
  end;
{$IFEND}
  MD5 := TMD5.Create;
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
  end;
{$IFEND}
  if (sParam1 = '') or (sParam1[1] <> '~') then
  begin
{$IF DEBUG = 0}
    asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
    end;
{$IFEND}
    exit;
{$IF DEBUG = 0}
    asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
    end;
{$IFEND}
  end;
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0E8h
    db 0EBh
    db 005h
    @@Start:
  end;
{$IFEND}
  sCmd := MD5.EncryptString(sParam2);                       //
{$IF DEBUG = 0}
  asm
    jz @@Start
    jnz @@Start
    db 0E8h
    @@Start:
  end;
{$IFEND}
  MD5.Free;

end;

end.

